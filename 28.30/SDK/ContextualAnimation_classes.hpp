#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ContextualAnimation

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "ContextualAnimation_structs.hpp"


namespace SDK
{

// Class ContextualAnimation.AnimNotifyState_EarlyOutContextualAnimWindow
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_EarlyOutContextualAnimWindow final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_EarlyOutContextualAnimWindow">();
	}
	static class UAnimNotifyState_EarlyOutContextualAnimWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_EarlyOutContextualAnimWindow>();
	}
};
static_assert(alignof(UAnimNotifyState_EarlyOutContextualAnimWindow) == 0x000008, "Wrong alignment on UAnimNotifyState_EarlyOutContextualAnimWindow");
static_assert(sizeof(UAnimNotifyState_EarlyOutContextualAnimWindow) == 0x000030, "Wrong size on UAnimNotifyState_EarlyOutContextualAnimWindow");

// Class ContextualAnimation.AnimNotifyState_IKWindow
// 0x0070 (0x00A0 - 0x0030)
class UAnimNotifyState_IKWindow final : public UAnimNotifyState
{
public:
	class FName                                   GoalName;                                          // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            BlendIn;                                           // 0x0038(0x0030)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            BlendOut;                                          // 0x0068(0x0030)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0098(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_IKWindow">();
	}
	static class UAnimNotifyState_IKWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_IKWindow>();
	}
};
static_assert(alignof(UAnimNotifyState_IKWindow) == 0x000008, "Wrong alignment on UAnimNotifyState_IKWindow");
static_assert(sizeof(UAnimNotifyState_IKWindow) == 0x0000A0, "Wrong size on UAnimNotifyState_IKWindow");
static_assert(offsetof(UAnimNotifyState_IKWindow, GoalName) == 0x000030, "Member 'UAnimNotifyState_IKWindow::GoalName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_IKWindow, BlendIn) == 0x000038, "Member 'UAnimNotifyState_IKWindow::BlendIn' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_IKWindow, BlendOut) == 0x000068, "Member 'UAnimNotifyState_IKWindow::BlendOut' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_IKWindow, bEnable) == 0x000098, "Member 'UAnimNotifyState_IKWindow::bEnable' has a wrong offset!");

// Class ContextualAnimation.ContextualAnimActorInterface
// 0x0000 (0x0028 - 0x0028)
class IContextualAnimActorInterface final : public IInterface
{
public:
	class USkeletalMeshComponent* GetMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimActorInterface">();
	}
	static class IContextualAnimActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContextualAnimActorInterface>();
	}
};
static_assert(alignof(IContextualAnimActorInterface) == 0x000008, "Wrong alignment on IContextualAnimActorInterface");
static_assert(sizeof(IContextualAnimActorInterface) == 0x000028, "Wrong size on IContextualAnimActorInterface");

// Class ContextualAnimation.ContextualAnimSceneActorComponent
// 0x01B0 (0x06B0 - 0x0500)
class UContextualAnimSceneActorComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UContextualAnimSceneActorComponent* SceneActorComponent)> OnJoinedSceneDelegate;                             // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneActorComponent* SceneActorComponent)> OnLeftSceneDelegate;                               // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneActorComponent* SceneActorComponent, class FName NotifyName)> OnPlayMontageNotifyBeginDelegate;                  // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UContextualAnimSceneAsset*              SceneAsset;                                        // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebug;                                      // 0x0540(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FContextualAnimRepBindingsData         RepBindings;                                       // 0x0548(0x0050)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FContextualAnimRepLateJoinData         RepLateJoinData;                                   // 0x0598(0x0038)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FContextualAnimRepTransitionData       RepTransitionData;                                 // 0x05D0(0x0028)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FContextualAnimRepTransitionData       RepTransitionSingleActorData;                      // 0x05F8(0x0028)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FContextualAnimSceneBindings           Bindings;                                          // 0x0620(0x0028)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FContextualAnimIKTarget>        IKTargets;                                         // 0x0648(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x58];                                     // 0x0658(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EarlyOutContextualAnimScene();
	bool LateJoinContextualAnimScene(class AActor* Actor, class FName Role);
	void OnJoinedScene(const struct FContextualAnimSceneBindings& InBindings);
	void OnLeftScene();
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnPlayMontageNotifyBegin(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnRep_Bindings();
	void OnRep_LateJoinData();
	void OnRep_RepTransitionSingleActor();
	void OnRep_TransitionData();
	void OnTickPose(class USkinnedMeshComponent* SkinnedMeshComponent, float DeltaTime, bool bNeedsValidRootMotion);
	void ServerEarlyOutContextualAnimScene();
	void ServerStartContextualAnimScene(const struct FContextualAnimSceneBindings& InBindings);
	bool StartContextualAnimScene(const struct FContextualAnimSceneBindings& InBindings);
	bool TransitionContextualAnimScene(class FName SectionName);
	bool TransitionSingleActor(int32 SectionIdx, int32 AnimSetIdx);

	const struct FContextualAnimIKTarget GetIKTargetByGoalName(class FName GoalName) const;
	const TArray<struct FContextualAnimIKTarget> GetIKTargets() const;
	bool IsInActiveScene() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSceneActorComponent">();
	}
	static class UContextualAnimSceneActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSceneActorComponent>();
	}
};
static_assert(alignof(UContextualAnimSceneActorComponent) == 0x000010, "Wrong alignment on UContextualAnimSceneActorComponent");
static_assert(sizeof(UContextualAnimSceneActorComponent) == 0x0006B0, "Wrong size on UContextualAnimSceneActorComponent");
static_assert(offsetof(UContextualAnimSceneActorComponent, OnJoinedSceneDelegate) == 0x000508, "Member 'UContextualAnimSceneActorComponent::OnJoinedSceneDelegate' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, OnLeftSceneDelegate) == 0x000518, "Member 'UContextualAnimSceneActorComponent::OnLeftSceneDelegate' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, OnPlayMontageNotifyBeginDelegate) == 0x000528, "Member 'UContextualAnimSceneActorComponent::OnPlayMontageNotifyBeginDelegate' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, SceneAsset) == 0x000538, "Member 'UContextualAnimSceneActorComponent::SceneAsset' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, bEnableDebug) == 0x000540, "Member 'UContextualAnimSceneActorComponent::bEnableDebug' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, RepBindings) == 0x000548, "Member 'UContextualAnimSceneActorComponent::RepBindings' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, RepLateJoinData) == 0x000598, "Member 'UContextualAnimSceneActorComponent::RepLateJoinData' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, RepTransitionData) == 0x0005D0, "Member 'UContextualAnimSceneActorComponent::RepTransitionData' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, RepTransitionSingleActorData) == 0x0005F8, "Member 'UContextualAnimSceneActorComponent::RepTransitionSingleActorData' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, Bindings) == 0x000620, "Member 'UContextualAnimSceneActorComponent::Bindings' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneActorComponent, IKTargets) == 0x000648, "Member 'UContextualAnimSceneActorComponent::IKTargets' has a wrong offset!");

// Class ContextualAnimation.ContextualAnimRolesAsset
// 0x0010 (0x0040 - 0x0030)
class UContextualAnimRolesAsset final : public UDataAsset
{
public:
	TArray<struct FContextualAnimRoleDefinition>  Roles;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimRolesAsset">();
	}
	static class UContextualAnimRolesAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimRolesAsset>();
	}
};
static_assert(alignof(UContextualAnimRolesAsset) == 0x000008, "Wrong alignment on UContextualAnimRolesAsset");
static_assert(sizeof(UContextualAnimRolesAsset) == 0x000040, "Wrong size on UContextualAnimRolesAsset");
static_assert(offsetof(UContextualAnimRolesAsset, Roles) == 0x000030, "Member 'UContextualAnimRolesAsset::Roles' has a wrong offset!");

// Class ContextualAnimation.ContextualAnimSceneAsset
// 0x0050 (0x0080 - 0x0030)
class UContextualAnimSceneAsset final : public UDataAsset
{
public:
	class UContextualAnimRolesAsset*              RolesAsset;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PrimaryRole;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FContextualAnimSceneSection>    Sections;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EContextualAnimCollisionBehavior              CollisionBehavior;                                 // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FContextualAnimIgnoreChannelsParam> CollisionChannelsToIgnoreParams;                   // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FContextualAnimAttachmentParams> AttachmentParams;                                  // 0x0068(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPrecomputeAlignmentTracks;                        // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SampleRate;                                        // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UAnimSequenceBase* BP_FindAnimationForRole(int32 SectionIdx, int32 AnimSetIdx, class FName Role) const;
	int32 BP_FindAnimSetIndexByAnimation(int32 SectionIdx, const class UAnimSequenceBase* Animation) const;
	struct FTransform BP_GetAlignmentTransformForRoleRelativeToWarpPoint(int32 SectionIdx, int32 AnimSetIdx, class FName Role, float Time) const;
	struct FTransform BP_GetIKTargetTransformForRoleAtTime(int32 SectionIdx, int32 AnimSetIdx, class FName Role, class FName TrackName, float Time) const;
	void BP_GetStartAndEndTimeForWarpSection(int32 SectionIdx, int32 AnimSetIdx, class FName Role, class FName WarpSectionName, float* OutStartTime, float* OutEndTime) const;
	void GetAlignmentPointsForSecondaryRole(EContextualAnimPointType Type, int32 SectionIdx, const struct FContextualAnimSceneBindingContext& Primary, TArray<struct FContextualAnimPoint>* OutResult) const;
	void GetAlignmentPointsForSecondaryRoleConsideringSelectionCriteria(EContextualAnimPointType Type, int32 SectionIdx, const struct FContextualAnimSceneBindingContext& Primary, const struct FContextualAnimSceneBindingContext& Querier, EContextualAnimCriterionToConsider CriterionToConsider, TArray<struct FContextualAnimPoint>* OutResult) const;
	TArray<class FName> GetRoles() const;
	bool Query(class FName Role, struct FContextualAnimQueryResult* OutResult, const struct FContextualAnimQueryParams& QueryParams, const struct FTransform& ToWorldTransform) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSceneAsset">();
	}
	static class UContextualAnimSceneAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSceneAsset>();
	}
};
static_assert(alignof(UContextualAnimSceneAsset) == 0x000008, "Wrong alignment on UContextualAnimSceneAsset");
static_assert(sizeof(UContextualAnimSceneAsset) == 0x000080, "Wrong size on UContextualAnimSceneAsset");
static_assert(offsetof(UContextualAnimSceneAsset, RolesAsset) == 0x000030, "Member 'UContextualAnimSceneAsset::RolesAsset' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneAsset, PrimaryRole) == 0x000038, "Member 'UContextualAnimSceneAsset::PrimaryRole' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneAsset, Sections) == 0x000040, "Member 'UContextualAnimSceneAsset::Sections' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneAsset, Radius) == 0x000050, "Member 'UContextualAnimSceneAsset::Radius' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneAsset, CollisionBehavior) == 0x000054, "Member 'UContextualAnimSceneAsset::CollisionBehavior' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneAsset, CollisionChannelsToIgnoreParams) == 0x000058, "Member 'UContextualAnimSceneAsset::CollisionChannelsToIgnoreParams' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneAsset, AttachmentParams) == 0x000068, "Member 'UContextualAnimSceneAsset::AttachmentParams' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneAsset, bPrecomputeAlignmentTracks) == 0x000078, "Member 'UContextualAnimSceneAsset::bPrecomputeAlignmentTracks' has a wrong offset!");
static_assert(offsetof(UContextualAnimSceneAsset, SampleRate) == 0x00007C, "Member 'UContextualAnimSceneAsset::SampleRate' has a wrong offset!");

// Class ContextualAnimation.ContextualAnimSelectionCriterion
// 0x0008 (0x0030 - 0x0028)
class UContextualAnimSelectionCriterion : public UObject
{
public:
	EContextualAnimCriterionType                  Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion">();
	}
	static class UContextualAnimSelectionCriterion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion>();
	}
};
static_assert(alignof(UContextualAnimSelectionCriterion) == 0x000008, "Wrong alignment on UContextualAnimSelectionCriterion");
static_assert(sizeof(UContextualAnimSelectionCriterion) == 0x000030, "Wrong size on UContextualAnimSelectionCriterion");
static_assert(offsetof(UContextualAnimSelectionCriterion, Type) == 0x000028, "Member 'UContextualAnimSelectionCriterion::Type' has a wrong offset!");

// Class ContextualAnimation.ContextualAnimSelectionCriterion_Blueprint
// 0x0000 (0x0030 - 0x0030)
class UContextualAnimSelectionCriterion_Blueprint final : public UContextualAnimSelectionCriterion
{
public:
	bool BP_DoesQuerierPassCondition(const struct FContextualAnimSceneBindingContext& Primary, const struct FContextualAnimSceneBindingContext& Querier) const;
	const class UContextualAnimSceneAsset* GetSceneAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion_Blueprint">();
	}
	static class UContextualAnimSelectionCriterion_Blueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion_Blueprint>();
	}
};
static_assert(alignof(UContextualAnimSelectionCriterion_Blueprint) == 0x000008, "Wrong alignment on UContextualAnimSelectionCriterion_Blueprint");
static_assert(sizeof(UContextualAnimSelectionCriterion_Blueprint) == 0x000030, "Wrong size on UContextualAnimSelectionCriterion_Blueprint");

// Class ContextualAnimation.ContextualAnimSelectionCriterion_TriggerArea
// 0x0018 (0x0048 - 0x0030)
class UContextualAnimSelectionCriterion_TriggerArea final : public UContextualAnimSelectionCriterion
{
public:
	TArray<struct FVector>                        PolygonPoints;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion_TriggerArea">();
	}
	static class UContextualAnimSelectionCriterion_TriggerArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion_TriggerArea>();
	}
};
static_assert(alignof(UContextualAnimSelectionCriterion_TriggerArea) == 0x000008, "Wrong alignment on UContextualAnimSelectionCriterion_TriggerArea");
static_assert(sizeof(UContextualAnimSelectionCriterion_TriggerArea) == 0x000048, "Wrong size on UContextualAnimSelectionCriterion_TriggerArea");
static_assert(offsetof(UContextualAnimSelectionCriterion_TriggerArea, PolygonPoints) == 0x000030, "Member 'UContextualAnimSelectionCriterion_TriggerArea::PolygonPoints' has a wrong offset!");
static_assert(offsetof(UContextualAnimSelectionCriterion_TriggerArea, Height) == 0x000040, "Member 'UContextualAnimSelectionCriterion_TriggerArea::Height' has a wrong offset!");

// Class ContextualAnimation.ContextualAnimSelectionCriterion_Cone
// 0x0010 (0x0040 - 0x0030)
class UContextualAnimSelectionCriterion_Cone final : public UContextualAnimSelectionCriterion
{
public:
	EContextualAnimCriterionConeMode              Mode;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfAngle;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion_Cone">();
	}
	static class UContextualAnimSelectionCriterion_Cone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion_Cone>();
	}
};
static_assert(alignof(UContextualAnimSelectionCriterion_Cone) == 0x000008, "Wrong alignment on UContextualAnimSelectionCriterion_Cone");
static_assert(sizeof(UContextualAnimSelectionCriterion_Cone) == 0x000040, "Wrong size on UContextualAnimSelectionCriterion_Cone");
static_assert(offsetof(UContextualAnimSelectionCriterion_Cone, Mode) == 0x000030, "Member 'UContextualAnimSelectionCriterion_Cone::Mode' has a wrong offset!");
static_assert(offsetof(UContextualAnimSelectionCriterion_Cone, Distance) == 0x000034, "Member 'UContextualAnimSelectionCriterion_Cone::Distance' has a wrong offset!");
static_assert(offsetof(UContextualAnimSelectionCriterion_Cone, HalfAngle) == 0x000038, "Member 'UContextualAnimSelectionCriterion_Cone::HalfAngle' has a wrong offset!");
static_assert(offsetof(UContextualAnimSelectionCriterion_Cone, Offset) == 0x00003C, "Member 'UContextualAnimSelectionCriterion_Cone::Offset' has a wrong offset!");

// Class ContextualAnimation.ContextualAnimSelectionCriterion_Distance
// 0x0010 (0x0040 - 0x0030)
class UContextualAnimSelectionCriterion_Distance final : public UContextualAnimSelectionCriterion
{
public:
	EContextualAnimCriterionDistanceMode          Mode;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistance;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion_Distance">();
	}
	static class UContextualAnimSelectionCriterion_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion_Distance>();
	}
};
static_assert(alignof(UContextualAnimSelectionCriterion_Distance) == 0x000008, "Wrong alignment on UContextualAnimSelectionCriterion_Distance");
static_assert(sizeof(UContextualAnimSelectionCriterion_Distance) == 0x000040, "Wrong size on UContextualAnimSelectionCriterion_Distance");
static_assert(offsetof(UContextualAnimSelectionCriterion_Distance, Mode) == 0x000030, "Member 'UContextualAnimSelectionCriterion_Distance::Mode' has a wrong offset!");
static_assert(offsetof(UContextualAnimSelectionCriterion_Distance, MinDistance) == 0x000034, "Member 'UContextualAnimSelectionCriterion_Distance::MinDistance' has a wrong offset!");
static_assert(offsetof(UContextualAnimSelectionCriterion_Distance, MaxDistance) == 0x000038, "Member 'UContextualAnimSelectionCriterion_Distance::MaxDistance' has a wrong offset!");

// Class ContextualAnimation.ContextualAnimUtilities
// 0x0000 (0x0028 - 0x0028)
class UContextualAnimUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool BP_CreateContextualAnimSceneBindings(const class UContextualAnimSceneAsset* SceneAsset, const TMap<class FName, struct FContextualAnimSceneBindingContext>& Params_0, struct FContextualAnimSceneBindings* OutBindings);
	static bool BP_CreateContextualAnimSceneBindingsForTwoActors(const class UContextualAnimSceneAsset* SceneAsset, const struct FContextualAnimSceneBindingContext& Primary, const struct FContextualAnimSceneBindingContext& Secondary, struct FContextualAnimSceneBindings* OutBindings);
	static void BP_DrawDebugPose(const class UObject* WorldContextObject, const class UAnimSequenceBase* Animation, float Time, const struct FTransform& LocalToWorldTransform, const struct FLinearColor& Color, float Lifetime, float Thickness);
	static float BP_Montage_GetSectionLength(const class UAnimMontage* Montage, int32 SectionIndex);
	static void BP_Montage_GetSectionStartAndEndTime(const class UAnimMontage* Montage, int32 SectionIndex, float* OutStartTime, float* OutEndTime);
	static float BP_Montage_GetSectionTimeLeftFromPos(const class UAnimMontage* Montage, float Position);
	static class AActor* BP_SceneBinding_GetActor(const struct FContextualAnimSceneBinding& Binding);
	static const class UAnimSequenceBase* BP_SceneBinding_GetAnimationFromBinding(const struct FContextualAnimSceneBindings& Bindings, const struct FContextualAnimSceneBinding& Binding);
	static class FName BP_SceneBinding_GetRoleFromBinding(const struct FContextualAnimSceneBindings& Bindings, const struct FContextualAnimSceneBinding& Binding);
	static class USkeletalMeshComponent* BP_SceneBinding_GetSkeletalMesh(const struct FContextualAnimSceneBinding& Binding);
	static class AActor* BP_SceneBindingContext_GetActor(const struct FContextualAnimSceneBindingContext& BindingContext);
	static const struct FGameplayTagContainer BP_SceneBindingContext_GetGameplayTags(const struct FContextualAnimSceneBindingContext& BindingContext);
	static struct FTransform BP_SceneBindingContext_GetTransform(const struct FContextualAnimSceneBindingContext& BindingContext);
	static struct FVector BP_SceneBindingContext_GetVelocity(const struct FContextualAnimSceneBindingContext& BindingContext);
	static bool BP_SceneBindingContext_HasAllMatchingGameplayTags(const struct FContextualAnimSceneBindingContext& BindingContext, const struct FGameplayTagContainer& TagContainer);
	static bool BP_SceneBindingContext_HasAnyMatchingGameplayTags(const struct FContextualAnimSceneBindingContext& BindingContext, const struct FGameplayTagContainer& TagContainer);
	static bool BP_SceneBindingContext_HasMatchingGameplayTag(const struct FContextualAnimSceneBindingContext& BindingContext, const struct FGameplayTag& TagToCheck);
	static struct FContextualAnimSceneBindingContext BP_SceneBindingContext_MakeFromActor(class AActor* Actor);
	static struct FContextualAnimSceneBindingContext BP_SceneBindingContext_MakeFromActorWithExternalTransform(class AActor* Actor, const struct FTransform& ExternalTransform);
	static void BP_SceneBindings_AddOrUpdateWarpTargetsForBindings(const struct FContextualAnimSceneBindings& Bindings);
	static void BP_SceneBindings_CalculateWarpPoints(const struct FContextualAnimSceneBindings& Bindings, TArray<struct FContextualAnimWarpPoint>* OutWarpPoints);
	static struct FTransform BP_SceneBindings_GetAlignmentTransformForRoleRelativeToOtherRole(const struct FContextualAnimSceneBindings& Bindings, class FName Role, class FName RelativeToRole, float Time);
	static struct FTransform BP_SceneBindings_GetAlignmentTransformForRoleRelativeToWarpPoint(const struct FContextualAnimSceneBindings& Bindings, class FName Role, const struct FContextualAnimWarpPoint& WarpPoint, float Time);
	static struct FTransform BP_SceneBindings_GetAlignmentTransformFromBinding(const struct FContextualAnimSceneBindings& Bindings, const struct FContextualAnimSceneBinding& Binding, const struct FContextualAnimWarpPoint& WarpPoint);
	static const struct FContextualAnimSceneBinding BP_SceneBindings_GetBindingByActor(const struct FContextualAnimSceneBindings& Bindings, const class AActor* Actor);
	static const struct FContextualAnimSceneBinding BP_SceneBindings_GetBindingByRole(const struct FContextualAnimSceneBindings& Bindings, class FName Role);
	static const TArray<struct FContextualAnimSceneBinding> BP_SceneBindings_GetBindings(const struct FContextualAnimSceneBindings& Bindings);
	static const class UContextualAnimSceneAsset* BP_SceneBindings_GetSceneAsset(const struct FContextualAnimSceneBindings& Bindings);
	static void BP_SceneBindings_GetSectionAndAnimSetIndices(const struct FContextualAnimSceneBindings& Bindings, int32* SectionIdx, int32* AnimSetIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimUtilities">();
	}
	static class UContextualAnimUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimUtilities>();
	}
};
static_assert(alignof(UContextualAnimUtilities) == 0x000008, "Wrong alignment on UContextualAnimUtilities");
static_assert(sizeof(UContextualAnimUtilities) == 0x000028, "Wrong size on UContextualAnimUtilities");

}

