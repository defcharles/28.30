#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ContextualActionCodeRuntime

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "ContextualActionCodeRuntime_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class ContextualActionCodeRuntime.FortMovementMode_ExtLogicBaseSwinging
// 0x0038 (0x0158 - 0x0120)
class UFortMovementMode_ExtLogicBaseSwinging : public UFortMovementMode_BaseExtLogic
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortPlayerAnimInstance_SwingingObject> SwingingAnimationLayer;                            // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravitationalAcceleration;                         // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumInitialSpeed;                               // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationMultiplier;                            // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultAcceleration;                               // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NonBrakingFriction;                                // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingFriction;                                   // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingDeceleration;                               // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SwingingTag;                                       // 0x0150(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerDBNO();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementMode_ExtLogicBaseSwinging">();
	}
	static class UFortMovementMode_ExtLogicBaseSwinging* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementMode_ExtLogicBaseSwinging>();
	}
};
static_assert(alignof(UFortMovementMode_ExtLogicBaseSwinging) == 0x000008, "Wrong alignment on UFortMovementMode_ExtLogicBaseSwinging");
static_assert(sizeof(UFortMovementMode_ExtLogicBaseSwinging) == 0x000158, "Wrong size on UFortMovementMode_ExtLogicBaseSwinging");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, SwingingAnimationLayer) == 0x000128, "Member 'UFortMovementMode_ExtLogicBaseSwinging::SwingingAnimationLayer' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, GravitationalAcceleration) == 0x000130, "Member 'UFortMovementMode_ExtLogicBaseSwinging::GravitationalAcceleration' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, MinimumInitialSpeed) == 0x000134, "Member 'UFortMovementMode_ExtLogicBaseSwinging::MinimumInitialSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, AccelerationMultiplier) == 0x000138, "Member 'UFortMovementMode_ExtLogicBaseSwinging::AccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, DefaultAcceleration) == 0x00013C, "Member 'UFortMovementMode_ExtLogicBaseSwinging::DefaultAcceleration' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, NonBrakingFriction) == 0x000140, "Member 'UFortMovementMode_ExtLogicBaseSwinging::NonBrakingFriction' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, BrakingFriction) == 0x000144, "Member 'UFortMovementMode_ExtLogicBaseSwinging::BrakingFriction' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, BrakingDeceleration) == 0x000148, "Member 'UFortMovementMode_ExtLogicBaseSwinging::BrakingDeceleration' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, MaxSpeed) == 0x00014C, "Member 'UFortMovementMode_ExtLogicBaseSwinging::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicBaseSwinging, SwingingTag) == 0x000150, "Member 'UFortMovementMode_ExtLogicBaseSwinging::SwingingTag' has a wrong offset!");

// Class ContextualActionCodeRuntime.FortMovementMode_ExtLogicSwingingObject
// 0x0038 (0x0190 - 0x0158)
class UFortMovementMode_ExtLogicSwingingObject final : public UFortMovementMode_ExtLogicBaseSwinging
{
public:
	struct FVector                                AttachOffset;                                      // 0x0158(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                HandIKOffset;                                      // 0x0170(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlignCharacterToObject;                           // 0x0188(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementMode_ExtLogicSwingingObject">();
	}
	static class UFortMovementMode_ExtLogicSwingingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementMode_ExtLogicSwingingObject>();
	}
};
static_assert(alignof(UFortMovementMode_ExtLogicSwingingObject) == 0x000008, "Wrong alignment on UFortMovementMode_ExtLogicSwingingObject");
static_assert(sizeof(UFortMovementMode_ExtLogicSwingingObject) == 0x000190, "Wrong size on UFortMovementMode_ExtLogicSwingingObject");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingObject, AttachOffset) == 0x000158, "Member 'UFortMovementMode_ExtLogicSwingingObject::AttachOffset' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingObject, HandIKOffset) == 0x000170, "Member 'UFortMovementMode_ExtLogicSwingingObject::HandIKOffset' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingObject, bAlignCharacterToObject) == 0x000188, "Member 'UFortMovementMode_ExtLogicSwingingObject::bAlignCharacterToObject' has a wrong offset!");

// Class ContextualActionCodeRuntime.FortMovementMode_ExtLogicSwingingRope
// 0x0038 (0x0190 - 0x0158)
class UFortMovementMode_ExtLogicSwingingRope final : public UFortMovementMode_ExtLogicBaseSwinging
{
public:
	class UFortInputMappingContext*               InputMappingContext;                               // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           SwingingAscendAction;                              // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           SwingingAscendActionRelease;                       // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumAscendRange;                                // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AscendMaxSpeed;                                    // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DescendMaxSpeed;                                   // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AscendingSettleInterpSpeed;                        // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AscendingSettleAngleThreshold;                     // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_184[0xC];                                      // 0x0184(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementMode_ExtLogicSwingingRope">();
	}
	static class UFortMovementMode_ExtLogicSwingingRope* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementMode_ExtLogicSwingingRope>();
	}
};
static_assert(alignof(UFortMovementMode_ExtLogicSwingingRope) == 0x000008, "Wrong alignment on UFortMovementMode_ExtLogicSwingingRope");
static_assert(sizeof(UFortMovementMode_ExtLogicSwingingRope) == 0x000190, "Wrong size on UFortMovementMode_ExtLogicSwingingRope");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingRope, InputMappingContext) == 0x000158, "Member 'UFortMovementMode_ExtLogicSwingingRope::InputMappingContext' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingRope, SwingingAscendAction) == 0x000160, "Member 'UFortMovementMode_ExtLogicSwingingRope::SwingingAscendAction' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingRope, SwingingAscendActionRelease) == 0x000168, "Member 'UFortMovementMode_ExtLogicSwingingRope::SwingingAscendActionRelease' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingRope, MinimumAscendRange) == 0x000170, "Member 'UFortMovementMode_ExtLogicSwingingRope::MinimumAscendRange' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingRope, AscendMaxSpeed) == 0x000174, "Member 'UFortMovementMode_ExtLogicSwingingRope::AscendMaxSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingRope, DescendMaxSpeed) == 0x000178, "Member 'UFortMovementMode_ExtLogicSwingingRope::DescendMaxSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingRope, AscendingSettleInterpSpeed) == 0x00017C, "Member 'UFortMovementMode_ExtLogicSwingingRope::AscendingSettleInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtLogicSwingingRope, AscendingSettleAngleThreshold) == 0x000180, "Member 'UFortMovementMode_ExtLogicSwingingRope::AscendingSettleAngleThreshold' has a wrong offset!");

// Class ContextualActionCodeRuntime.FortPlayerAnimInstance_Hijacker
// 0x0000 (0x0470 - 0x0470)
class UFortPlayerAnimInstance_Hijacker final : public UFortBaseLayerAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAnimInstance_Hijacker">();
	}
	static class UFortPlayerAnimInstance_Hijacker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerAnimInstance_Hijacker>();
	}
};
static_assert(alignof(UFortPlayerAnimInstance_Hijacker) == 0x000010, "Wrong alignment on UFortPlayerAnimInstance_Hijacker");
static_assert(sizeof(UFortPlayerAnimInstance_Hijacker) == 0x000470, "Wrong size on UFortPlayerAnimInstance_Hijacker");

// Class ContextualActionCodeRuntime.FortPlayerAnimInstance_SwingingObject
// 0x0040 (0x04B0 - 0x0470)
class UFortPlayerAnimInstance_SwingingObject final : public UFortBaseLayerAnimInstance
{
public:
	struct FVector2D                              RelativeVelocity2D;                                // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HandAttachLocation;                                // 0x0478(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeftHandIKAlpha;                                   // 0x0490(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x1C];                                     // 0x0494(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAnimInstance_SwingingObject">();
	}
	static class UFortPlayerAnimInstance_SwingingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerAnimInstance_SwingingObject>();
	}
};
static_assert(alignof(UFortPlayerAnimInstance_SwingingObject) == 0x000010, "Wrong alignment on UFortPlayerAnimInstance_SwingingObject");
static_assert(sizeof(UFortPlayerAnimInstance_SwingingObject) == 0x0004B0, "Wrong size on UFortPlayerAnimInstance_SwingingObject");
static_assert(offsetof(UFortPlayerAnimInstance_SwingingObject, RelativeVelocity2D) == 0x000468, "Member 'UFortPlayerAnimInstance_SwingingObject::RelativeVelocity2D' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance_SwingingObject, HandAttachLocation) == 0x000478, "Member 'UFortPlayerAnimInstance_SwingingObject::HandAttachLocation' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance_SwingingObject, LeftHandIKAlpha) == 0x000490, "Member 'UFortPlayerAnimInstance_SwingingObject::LeftHandIKAlpha' has a wrong offset!");

// Class ContextualActionCodeRuntime.FortSwingingObject
// 0x0050 (0x09D0 - 0x0980)
class AFortSwingingObject : public ABuildingGameplayActor
{
public:
	float                                         MaxSwingAngle;                                     // 0x0980(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCharacterSwingMovementMode;                    // 0x0984(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAscend;                                        // 0x0985(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_986[0x2];                                      // 0x0986(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FixedSwingDirection;                               // 0x0988(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFixedSwingDirection;                           // 0x09A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A1[0x3];                                      // 0x09A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardInteractOffset;                             // 0x09A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightInteractOffset;                               // 0x09A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseClientTransformSmoothing;                      // 0x09AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9AD[0x3];                                      // 0x09AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothingWindow;                                   // 0x09B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B4[0x4];                                      // 0x09B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachPoint;                                       // 0x09B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C0[0x10];                                     // 0x09C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndSwing_BP(class AFortPlayerPawn* AttachedActor);
	void OnStartSwing_BP(class AFortPlayerPawn* AttachedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSwingingObject">();
	}
	static class AFortSwingingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortSwingingObject>();
	}
};
static_assert(alignof(AFortSwingingObject) == 0x000008, "Wrong alignment on AFortSwingingObject");
static_assert(sizeof(AFortSwingingObject) == 0x0009D0, "Wrong size on AFortSwingingObject");
static_assert(offsetof(AFortSwingingObject, MaxSwingAngle) == 0x000980, "Member 'AFortSwingingObject::MaxSwingAngle' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, bUseCharacterSwingMovementMode) == 0x000984, "Member 'AFortSwingingObject::bUseCharacterSwingMovementMode' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, bCanAscend) == 0x000985, "Member 'AFortSwingingObject::bCanAscend' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, FixedSwingDirection) == 0x000988, "Member 'AFortSwingingObject::FixedSwingDirection' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, bUseFixedSwingDirection) == 0x0009A0, "Member 'AFortSwingingObject::bUseFixedSwingDirection' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, ForwardInteractOffset) == 0x0009A4, "Member 'AFortSwingingObject::ForwardInteractOffset' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, RightInteractOffset) == 0x0009A8, "Member 'AFortSwingingObject::RightInteractOffset' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, bUseClientTransformSmoothing) == 0x0009AC, "Member 'AFortSwingingObject::bUseClientTransformSmoothing' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, SmoothingWindow) == 0x0009B0, "Member 'AFortSwingingObject::SmoothingWindow' has a wrong offset!");
static_assert(offsetof(AFortSwingingObject, AttachPoint) == 0x0009B8, "Member 'AFortSwingingObject::AttachPoint' has a wrong offset!");

// Class ContextualActionCodeRuntime.FortSwingingRope
// 0x0038 (0x0A08 - 0x09D0)
class AFortSwingingRope final : public AFortSwingingObject
{
public:
	class UCableComponent*                        CableComponent;                                    // 0x09D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UnattachedCableGravityScale;                       // 0x09D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UnattachedSolverIterations;                        // 0x09DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CableLengthMultiplier;                             // 0x09E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E4[0x24];                                     // 0x09E4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSwingingRope">();
	}
	static class AFortSwingingRope* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortSwingingRope>();
	}
};
static_assert(alignof(AFortSwingingRope) == 0x000008, "Wrong alignment on AFortSwingingRope");
static_assert(sizeof(AFortSwingingRope) == 0x000A08, "Wrong size on AFortSwingingRope");
static_assert(offsetof(AFortSwingingRope, CableComponent) == 0x0009D0, "Member 'AFortSwingingRope::CableComponent' has a wrong offset!");
static_assert(offsetof(AFortSwingingRope, UnattachedCableGravityScale) == 0x0009D8, "Member 'AFortSwingingRope::UnattachedCableGravityScale' has a wrong offset!");
static_assert(offsetof(AFortSwingingRope, UnattachedSolverIterations) == 0x0009DC, "Member 'AFortSwingingRope::UnattachedSolverIterations' has a wrong offset!");
static_assert(offsetof(AFortSwingingRope, CableLengthMultiplier) == 0x0009E0, "Member 'AFortSwingingRope::CableLengthMultiplier' has a wrong offset!");

// Class ContextualActionCodeRuntime.HijackerComponent
// 0x0108 (0x01B0 - 0x00A8)
class UHijackerComponent final : public UFortPawnComponent
{
public:
	struct FVector                                HijackOffset;                                      // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   StartHijackInteractText;                           // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   StartHijackInteractSubText;                        // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   CompleteHijackInteractText;                        // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   CompleteHijackInteractSubText;                     // 0x0108(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortPlayerAnimInstance_Hijacker> HijackerAnimInstanceClass;                         // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequiredInteractionDuration;                       // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HijackCooldown;                                    // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BaseThrownVelocity;                                // 0x0130(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationThresholdForEjectingHijacker;          // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumSpeedForEjectingHijacker;                   // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHijackingStatus                              HijackingStatus;                                   // 0x0150(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x5F];                                     // 0x0151(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnCleanup();
	void BP_OnCompleteHijack();
	void BP_OnHijackCancelled();
	void BP_OnHijackInterrupted();
	void BP_OnStartHijack();
	void CancelHijack_NetMulticast();
	void CancelHijack_Server();
	void EjectHijacker(class AActor* DamageCauser, const float Damage, const struct FVector& EventLocation);
	void HandleOwnerJumpInput(bool bPressed);
	void OnCompleteHijack();
	void OnStartHijack(class AActor* VehicleTarget);
	bool TryHijack(class AActor* VehicleTarget, const struct FInteractionType& InteractionType);

	void BP_CanCompleteHijack(bool* OutCanCompleteHijack) const;
	void BP_CanStartHijack(bool* OutCanStartHijack) const;
	void BP_GetThrownVelocity(class AActor* DamageCauser, const float Damage, const struct FVector& EventLocation, struct FVector* OutVelocity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HijackerComponent">();
	}
	static class UHijackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHijackerComponent>();
	}
};
static_assert(alignof(UHijackerComponent) == 0x000008, "Wrong alignment on UHijackerComponent");
static_assert(sizeof(UHijackerComponent) == 0x0001B0, "Wrong size on UHijackerComponent");
static_assert(offsetof(UHijackerComponent, HijackOffset) == 0x0000A8, "Member 'UHijackerComponent::HijackOffset' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, StartHijackInteractText) == 0x0000C0, "Member 'UHijackerComponent::StartHijackInteractText' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, StartHijackInteractSubText) == 0x0000D8, "Member 'UHijackerComponent::StartHijackInteractSubText' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, CompleteHijackInteractText) == 0x0000F0, "Member 'UHijackerComponent::CompleteHijackInteractText' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, CompleteHijackInteractSubText) == 0x000108, "Member 'UHijackerComponent::CompleteHijackInteractSubText' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, HijackerAnimInstanceClass) == 0x000120, "Member 'UHijackerComponent::HijackerAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, RequiredInteractionDuration) == 0x000128, "Member 'UHijackerComponent::RequiredInteractionDuration' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, HijackCooldown) == 0x00012C, "Member 'UHijackerComponent::HijackCooldown' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, BaseThrownVelocity) == 0x000130, "Member 'UHijackerComponent::BaseThrownVelocity' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, AccelerationThresholdForEjectingHijacker) == 0x000148, "Member 'UHijackerComponent::AccelerationThresholdForEjectingHijacker' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, MinimumSpeedForEjectingHijacker) == 0x00014C, "Member 'UHijackerComponent::MinimumSpeedForEjectingHijacker' has a wrong offset!");
static_assert(offsetof(UHijackerComponent, HijackingStatus) == 0x000150, "Member 'UHijackerComponent::HijackingStatus' has a wrong offset!");

// Class ContextualActionCodeRuntime.Hijack_InteractionOverrideComponent
// 0x0000 (0x00A0 - 0x00A0)
class UHijack_InteractionOverrideComponent final : public UFortVehicleInteractionOverrideComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hijack_InteractionOverrideComponent">();
	}
	static class UHijack_InteractionOverrideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHijack_InteractionOverrideComponent>();
	}
};
static_assert(alignof(UHijack_InteractionOverrideComponent) == 0x000008, "Wrong alignment on UHijack_InteractionOverrideComponent");
static_assert(sizeof(UHijack_InteractionOverrideComponent) == 0x0000A0, "Wrong size on UHijack_InteractionOverrideComponent");

// Class ContextualActionCodeRuntime.RappellingComponent
// 0x07F0 (0x0898 - 0x00A8)
class URappellingComponent final : public UFortPawnComponent
{
public:
	class UInputAction*                           RappelInputAction;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           RappelEndInputAction;                              // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputMappingContext*                   RappelInputMappingContext;                         // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardTraceOffset;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DownwardTraceLength;                               // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConnectionTraceOffset;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceToRappellingEdge;                       // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitiateSwingAngleThreshold;                       // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitiateSwingSpeedThreshold;                       // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceFromRappelPointToSwing;                 // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RappellingSwingTraceLength;                        // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RappellingSwingRecoveryForce;                      // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RappellingSwingLaunchSpeed;                        // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RappellingSwingVerticalAttachOffset;               // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RappellingSwingVerticalDistanceThresholdToSlow;    // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RappellingSwingVerticalMaxSpeedWhileSlowing;       // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RappellingSwingVerticalMinDistanceToAttach;        // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RappellingSwingVerticalMaxDistanceToAttach;        // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RappellingSwingParametersTag;                      // 0x00FC(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSwingingControlParams                 RappellingSwingParameters;                         // 0x0100(0x0738)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ERappellingState                              ReplicatedRappellingState;                         // 0x0838(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_839[0x7];                                      // 0x0839(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RappellingEdge;                                    // 0x0840(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                RappellingNormal;                                  // 0x0858(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URappellingSwingMovementControls*       MovementControls;                                  // 0x0870(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_878[0x20];                                     // 0x0878(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndRappelling();
	void EndRappelling_Server();
	void EndRappellingSwing_Server();
	void OnCapsuleHit(const class UPrimitiveComponent* HitComponent, const class AActor* OtherActor, const class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnEndRappelling();
	void OnInvalidTargeting();
	void OnOwnerMovementModeChanged(class ACharacter* Character, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode);
	void OnRep_RappellingState();
	void OnStartRappelling();
	void OnValidTargeting();
	void RappellingCorrectFallingRotation_Client();
	void StartRappelling();
	void StartRappelling_Server(const struct FVector& NewGravityDirection, const struct FVector& ClientRappellingEdge, const struct FVector& ClientRappellingNormal);
	void StartRappellingSwing_Server();
	void TestToggleGravity();
	void TestToggleGravity_Server();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RappellingComponent">();
	}
	static class URappellingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URappellingComponent>();
	}
};
static_assert(alignof(URappellingComponent) == 0x000008, "Wrong alignment on URappellingComponent");
static_assert(sizeof(URappellingComponent) == 0x000898, "Wrong size on URappellingComponent");
static_assert(offsetof(URappellingComponent, RappelInputAction) == 0x0000A8, "Member 'URappellingComponent::RappelInputAction' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappelEndInputAction) == 0x0000B0, "Member 'URappellingComponent::RappelEndInputAction' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappelInputMappingContext) == 0x0000B8, "Member 'URappellingComponent::RappelInputMappingContext' has a wrong offset!");
static_assert(offsetof(URappellingComponent, ForwardTraceOffset) == 0x0000C0, "Member 'URappellingComponent::ForwardTraceOffset' has a wrong offset!");
static_assert(offsetof(URappellingComponent, DownwardTraceLength) == 0x0000C4, "Member 'URappellingComponent::DownwardTraceLength' has a wrong offset!");
static_assert(offsetof(URappellingComponent, ConnectionTraceOffset) == 0x0000C8, "Member 'URappellingComponent::ConnectionTraceOffset' has a wrong offset!");
static_assert(offsetof(URappellingComponent, MaxDistanceToRappellingEdge) == 0x0000CC, "Member 'URappellingComponent::MaxDistanceToRappellingEdge' has a wrong offset!");
static_assert(offsetof(URappellingComponent, InitiateSwingAngleThreshold) == 0x0000D0, "Member 'URappellingComponent::InitiateSwingAngleThreshold' has a wrong offset!");
static_assert(offsetof(URappellingComponent, InitiateSwingSpeedThreshold) == 0x0000D4, "Member 'URappellingComponent::InitiateSwingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(URappellingComponent, MinDistanceFromRappelPointToSwing) == 0x0000D8, "Member 'URappellingComponent::MinDistanceFromRappelPointToSwing' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingTraceLength) == 0x0000DC, "Member 'URappellingComponent::RappellingSwingTraceLength' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingRecoveryForce) == 0x0000E0, "Member 'URappellingComponent::RappellingSwingRecoveryForce' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingLaunchSpeed) == 0x0000E4, "Member 'URappellingComponent::RappellingSwingLaunchSpeed' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingVerticalAttachOffset) == 0x0000E8, "Member 'URappellingComponent::RappellingSwingVerticalAttachOffset' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingVerticalDistanceThresholdToSlow) == 0x0000EC, "Member 'URappellingComponent::RappellingSwingVerticalDistanceThresholdToSlow' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingVerticalMaxSpeedWhileSlowing) == 0x0000F0, "Member 'URappellingComponent::RappellingSwingVerticalMaxSpeedWhileSlowing' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingVerticalMinDistanceToAttach) == 0x0000F4, "Member 'URappellingComponent::RappellingSwingVerticalMinDistanceToAttach' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingVerticalMaxDistanceToAttach) == 0x0000F8, "Member 'URappellingComponent::RappellingSwingVerticalMaxDistanceToAttach' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingParametersTag) == 0x0000FC, "Member 'URappellingComponent::RappellingSwingParametersTag' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingSwingParameters) == 0x000100, "Member 'URappellingComponent::RappellingSwingParameters' has a wrong offset!");
static_assert(offsetof(URappellingComponent, ReplicatedRappellingState) == 0x000838, "Member 'URappellingComponent::ReplicatedRappellingState' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingEdge) == 0x000840, "Member 'URappellingComponent::RappellingEdge' has a wrong offset!");
static_assert(offsetof(URappellingComponent, RappellingNormal) == 0x000858, "Member 'URappellingComponent::RappellingNormal' has a wrong offset!");
static_assert(offsetof(URappellingComponent, MovementControls) == 0x000870, "Member 'URappellingComponent::MovementControls' has a wrong offset!");

// Class ContextualActionCodeRuntime.RappellingSwingMovementControls
// 0x0000 (0x0030 - 0x0030)
class URappellingSwingMovementControls final : public UFortMovementControls
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RappellingSwingMovementControls">();
	}
	static class URappellingSwingMovementControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<URappellingSwingMovementControls>();
	}
};
static_assert(alignof(URappellingSwingMovementControls) == 0x000008, "Wrong alignment on URappellingSwingMovementControls");
static_assert(sizeof(URappellingSwingMovementControls) == 0x000030, "Wrong size on URappellingSwingMovementControls");

// Class ContextualActionCodeRuntime.SwingingObjectCameraMode
// 0x0030 (0x1BD0 - 0x1BA0)
class USwingingObjectCameraMode final : public UFortCameraMode_ThirdPerson
{
public:
	struct FVector                                MaxSwingAdditionalViewTargetOffset;                // 0x1BA0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSwingFOV;                                       // 0x1BB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BBC[0x14];                                    // 0x1BBC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwingingObjectCameraMode">();
	}
	static class USwingingObjectCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwingingObjectCameraMode>();
	}
};
static_assert(alignof(USwingingObjectCameraMode) == 0x000010, "Wrong alignment on USwingingObjectCameraMode");
static_assert(sizeof(USwingingObjectCameraMode) == 0x001BD0, "Wrong size on USwingingObjectCameraMode");
static_assert(offsetof(USwingingObjectCameraMode, MaxSwingAdditionalViewTargetOffset) == 0x001BA0, "Member 'USwingingObjectCameraMode::MaxSwingAdditionalViewTargetOffset' has a wrong offset!");
static_assert(offsetof(USwingingObjectCameraMode, MaxSwingFOV) == 0x001BB8, "Member 'USwingingObjectCameraMode::MaxSwingFOV' has a wrong offset!");

// Class ContextualActionCodeRuntime.SwingingObjectComponent
// 0x0080 (0x0128 - 0x00A8)
class USwingingObjectComponent final : public UFortPawnComponent
{
public:
	float                                         JumpHorizontalSpeedBoost;                          // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpVerticalSpeedBoost;                            // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumAscendRange;                                // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AscendMaxSpeed;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DescendMaxSpeed;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AscendingSettleInterpSpeed;                        // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AscendingSettleAngleThreshold;                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumTimeBetweenRepeatSwings;                    // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaximumAngleForAutoAttach;                         // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumSpeedForAutoAttach;                         // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortMovementMode_BaseExtLogic> SwingingRopeMovementModeExtension;                 // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortMovementMode_BaseExtLogic> SwingingObjectMovementModeExtension;               // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESwingingState                                SwingingState;                                     // 0x00E0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AFortSwingingObject>     ReplicatedSwingingObject;                          // 0x00E4(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x3C];                                      // 0x00EC(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachToObject_Server(class AFortSwingingObject* Object);
	void BP_OnEndSwing();
	void BP_OnStartSwing();
	void DetachFromObject_Server(bool bJumpExit);
	void HandleOwnerJumpInput(bool bPressed);
	void OnRep_SwingingObject();

	void BP_CanStartSwing(class AFortSwingingObject* SwingTarget, bool* bCanStartSwing) const;
	struct FRotator GetAimRotation() const;
	void GetSwingDeltaAngle(struct FRotator* OutSwingRotation, struct FRotator* OutDeltaRotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwingingObjectComponent">();
	}
	static class USwingingObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwingingObjectComponent>();
	}
};
static_assert(alignof(USwingingObjectComponent) == 0x000008, "Wrong alignment on USwingingObjectComponent");
static_assert(sizeof(USwingingObjectComponent) == 0x000128, "Wrong size on USwingingObjectComponent");
static_assert(offsetof(USwingingObjectComponent, JumpHorizontalSpeedBoost) == 0x0000A8, "Member 'USwingingObjectComponent::JumpHorizontalSpeedBoost' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, JumpVerticalSpeedBoost) == 0x0000AC, "Member 'USwingingObjectComponent::JumpVerticalSpeedBoost' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, MinimumAscendRange) == 0x0000B0, "Member 'USwingingObjectComponent::MinimumAscendRange' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, AscendMaxSpeed) == 0x0000B4, "Member 'USwingingObjectComponent::AscendMaxSpeed' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, DescendMaxSpeed) == 0x0000B8, "Member 'USwingingObjectComponent::DescendMaxSpeed' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, AscendingSettleInterpSpeed) == 0x0000BC, "Member 'USwingingObjectComponent::AscendingSettleInterpSpeed' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, AscendingSettleAngleThreshold) == 0x0000C0, "Member 'USwingingObjectComponent::AscendingSettleAngleThreshold' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, MinimumTimeBetweenRepeatSwings) == 0x0000C4, "Member 'USwingingObjectComponent::MinimumTimeBetweenRepeatSwings' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, MaximumAngleForAutoAttach) == 0x0000C8, "Member 'USwingingObjectComponent::MaximumAngleForAutoAttach' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, MinimumSpeedForAutoAttach) == 0x0000CC, "Member 'USwingingObjectComponent::MinimumSpeedForAutoAttach' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, SwingingRopeMovementModeExtension) == 0x0000D0, "Member 'USwingingObjectComponent::SwingingRopeMovementModeExtension' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, SwingingObjectMovementModeExtension) == 0x0000D8, "Member 'USwingingObjectComponent::SwingingObjectMovementModeExtension' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, SwingingState) == 0x0000E0, "Member 'USwingingObjectComponent::SwingingState' has a wrong offset!");
static_assert(offsetof(USwingingObjectComponent, ReplicatedSwingingObject) == 0x0000E4, "Member 'USwingingObjectComponent::ReplicatedSwingingObject' has a wrong offset!");

}

