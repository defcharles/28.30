#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VaultingCodeRuntime

#include "Basic.hpp"

#include "VaultingCodeRuntime_classes.hpp"
#include "VaultingCodeRuntime_parameters.hpp"


namespace SDK
{

// Function VaultingCodeRuntime.FortMovementMode_ExtLogicHurdle.BP_DestroyProp
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABuildingProp*                    BuildPropToDestroy                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortMovementMode_ExtLogicHurdle::BP_DestroyProp(class ABuildingProp* BuildPropToDestroy)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_DestroyProp");

	Params::FortMovementMode_ExtLogicHurdle_BP_DestroyProp Parms{};

	Parms.BuildPropToDestroy = BuildPropToDestroy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.FortMovementMode_ExtLogicHurdle.BP_GetAnimationMontageInformation
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSynchedActionInfo               SynchedActionInfo                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EHurdleType                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsNarrowOpening                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCrouched                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     AnimMontage                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSectionName                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MontageMiddleSectionName                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortMovementMode_ExtLogicHurdle::BP_GetAnimationMontageInformation(const struct FSynchedActionInfo& SynchedActionInfo, EHurdleType Type, bool bIsNarrowOpening, bool bIsCrouched, class UAnimMontage** AnimMontage, class FName* StartSectionName, class FName* MontageMiddleSectionName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_GetAnimationMontageInformation");

	Params::FortMovementMode_ExtLogicHurdle_BP_GetAnimationMontageInformation Parms{};

	Parms.SynchedActionInfo = std::move(SynchedActionInfo);
	Parms.Type = Type;
	Parms.bIsNarrowOpening = bIsNarrowOpening;
	Parms.bIsCrouched = bIsCrouched;

	UObject::ProcessEvent(Func, &Parms);

	if (AnimMontage != nullptr)
		*AnimMontage = Parms.AnimMontage;

	if (StartSectionName != nullptr)
		*StartSectionName = Parms.StartSectionName;

	if (MontageMiddleSectionName != nullptr)
		*MontageMiddleSectionName = Parms.MontageMiddleSectionName;
}


// Function VaultingCodeRuntime.HurdleComponent.BP_HandleHurdleEnded
// (Event, Protected, BlueprintEvent)

void UHurdleComponent::BP_HandleHurdleEnded()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_HandleHurdleEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.BP_HandleHurdleStarted
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHurdleTargetingData             TargetingData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FSynchedActionInfo               SynchedActionInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UHurdleComponent::BP_HandleHurdleStarted(const struct FHurdleTargetingData& TargetingData, const struct FSynchedActionInfo& SynchedActionInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_HandleHurdleStarted");

	Params::HurdleComponent_BP_HandleHurdleStarted Parms{};

	Parms.TargetingData = std::move(TargetingData);
	Parms.SynchedActionInfo = std::move(SynchedActionInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.BP_HandleSpringJump
// (Event, Protected, BlueprintEvent)

void UHurdleComponent::BP_HandleSpringJump()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_HandleSpringJump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.HandleNavLinkMoveStarted
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FVector                          LinkEndPoint                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleNavLinkMoveStarted(const struct FVector& LinkEndPoint)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleNavLinkMoveStarted");

	Params::HurdleComponent_HandleNavLinkMoveStarted Parms{};

	Parms.LinkEndPoint = std::move(LinkEndPoint);

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.HandleOwnerJumpInput
// (Final, Native, Protected)
// Parameters:
// bool                                    bPressed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleOwnerJumpInput(bool bPressed)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleOwnerJumpInput");

	Params::HurdleComponent_HandleOwnerJumpInput Parms{};

	Parms.bPressed = bPressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.HandleOwnerMovementModeChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PreviousMovementMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleOwnerMovementModeChanged(class ACharacter* Character, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleOwnerMovementModeChanged");

	Params::HurdleComponent_HandleOwnerMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PreviousMovementMode = PreviousMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.HandleOwnerTeleported
// (Final, Native, Protected)
// Parameters:
// class AFortPawn*                        TeleportedOwner                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleOwnerTeleported(class AFortPawn* TeleportedOwner)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleOwnerTeleported");

	Params::HurdleComponent_HandleOwnerTeleported Parms{};

	Parms.TeleportedOwner = TeleportedOwner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.HandleTargetingDataInvalid
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHurdleTargetingData             TargetingData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleTargetingDataInvalid(const struct FHurdleTargetingData& TargetingData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleTargetingDataInvalid");

	Params::HurdleComponent_HandleTargetingDataInvalid Parms{};

	Parms.TargetingData = std::move(TargetingData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.HandleTargetingDataValid
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHurdleTargetingData             TargetingData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleTargetingDataValid(const struct FHurdleTargetingData& TargetingData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleTargetingDataValid");

	Params::HurdleComponent_HandleTargetingDataValid Parms{};

	Parms.TargetingData = std::move(TargetingData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.OnMutatorUpdated
// (Final, Native, Protected)

void UHurdleComponent::OnMutatorUpdated()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMutatorUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.OnPlayerStatePawnSet
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::OnPlayerStatePawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlayerStatePawnSet");

	Params::HurdleComponent_OnPlayerStatePawnSet Parms{};

	Parms.Player = Player;
	Parms.NewPawn = NewPawn;
	Parms.OldPawn = OldPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.OnRep_ReplicatedHurdleState
// (Final, Native, Protected)

void UHurdleComponent::OnRep_ReplicatedHurdleState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedHurdleState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.OnRep_ReplicatedLastTeleportTime
// (Final, Native, Protected)

void UHurdleComponent::OnRep_ReplicatedLastTeleportTime()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedLastTeleportTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.RegisterMutatorUpdatedDelegate
// (Final, Native, Protected)
// Parameters:
// class APawn*                            AffectedPawn                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::RegisterMutatorUpdatedDelegate(class APawn* AffectedPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegisterMutatorUpdatedDelegate");

	Params::HurdleComponent_RegisterMutatorUpdatedDelegate Parms{};

	Parms.AffectedPawn = AffectedPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.ServerStartHurdle
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FReplicatedHurdleTargetingData   InReplicatedTargetingData                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// double                                  ClientLastTeleportTime                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::ServerStartHurdle(const struct FReplicatedHurdleTargetingData& InReplicatedTargetingData, const double ClientLastTeleportTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerStartHurdle");

	Params::HurdleComponent_ServerStartHurdle Parms{};

	Parms.InReplicatedTargetingData = std::move(InReplicatedTargetingData);
	Parms.ClientLastTeleportTime = ClientLastTeleportTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.UnregisterMutatorUpdatedDelegate
// (Final, Native, Protected)

void UHurdleComponent::UnregisterMutatorUpdatedDelegate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnregisterMutatorUpdatedDelegate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.BP_CanStartHurdle
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// bool                                    OutCanStartHurdle                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::BP_CanStartHurdle(bool* OutCanStartHurdle) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_CanStartHurdle");

	Params::HurdleComponent_BP_CanStartHurdle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutCanStartHurdle != nullptr)
		*OutCanStartHurdle = Parms.OutCanStartHurdle;
}


// Function VaultingCodeRuntime.HurdleComponent.BP_IsTacticalSprinting
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHurdleComponent::BP_IsTacticalSprinting() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_IsTacticalSprinting");

	Params::HurdleComponent_BP_IsTacticalSprinting Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function VaultingCodeRuntime.HurdleComponent.BP_UseAutoHurdle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHurdleComponent::BP_UseAutoHurdle() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_UseAutoHurdle");

	Params::HurdleComponent_BP_UseAutoHurdle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function VaultingCodeRuntime.HurdleComponent.GetHurdleHighlightTransform
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UHurdleComponent::GetHurdleHighlightTransform() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHurdleHighlightTransform");

	Params::HurdleComponent_GetHurdleHighlightTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function VaultingCodeRuntime.HurdleComponent.IsUsingGamepad
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHurdleComponent::IsUsingGamepad() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsUsingGamepad");

	Params::HurdleComponent_IsUsingGamepad Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function VaultingCodeRuntime.HurdleComponent.ShouldShowHurdleIndicator
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHurdleComponent::ShouldShowHurdleIndicator() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShouldShowHurdleIndicator");

	Params::HurdleComponent_ShouldShowHurdleIndicator Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function VaultingCodeRuntime.HurdleLibrary.PerformHurdleTargeting
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHurdleInputConfigCache          HurdleInputConfig                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FHurdleTargetingData             OutTargetingData                                       (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIsAutoHurdle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OverrideAimDirection                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHurdleLibrary::PerformHurdleTargeting(const class ACharacter* Character, struct FHurdleInputConfigCache* HurdleInputConfig, struct FHurdleTargetingData* OutTargetingData, bool bIsAutoHurdle, const struct FVector& OverrideAimDirection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PerformHurdleTargeting");

	Params::HurdleLibrary_PerformHurdleTargeting Parms{};

	Parms.Character = Character;
	Parms.bIsAutoHurdle = bIsAutoHurdle;
	Parms.OverrideAimDirection = std::move(OverrideAimDirection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (HurdleInputConfig != nullptr)
		*HurdleInputConfig = std::move(Parms.HurdleInputConfig);

	if (OutTargetingData != nullptr)
		*OutTargetingData = std::move(Parms.OutTargetingData);

	return Parms.ReturnValue;
}

}

