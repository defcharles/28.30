#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JunoProceduralWorld

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "JunoGameNative_structs.hpp"
#include "Engine_structs.hpp"
#include "NetCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "MassRepresentation_structs.hpp"
#include "FortniteGame_structs.hpp"
#include "MassEntity_structs.hpp"
#include "StructUtils_structs.hpp"
#include "DataRegistry_structs.hpp"
#include "Landscape_structs.hpp"
#include "PCG_structs.hpp"
#include "WorldConditions_structs.hpp"


namespace SDK
{

// Enum JunoProceduralWorld.EJunoGetMergedCaveDataRegistryDataResult
// NumValues: 0x0002
enum class EJunoGetMergedCaveDataRegistryDataResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoCaveGeneratorShellType
// NumValues: 0x0005
enum class EJunoCaveGeneratorShellType : uint8
{
	Room                                     = 0,
	Connector                                = 1,
	Entrance                                 = 2,
	Hero                                     = 3,
	FeatureRoom                              = 4,
};

// Enum JunoProceduralWorld.EJunoCaveGeneratorShellSize
// NumValues: 0x0004
enum class EJunoCaveGeneratorShellSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	Hallway                                  = 3,
};

// Enum JunoProceduralWorld.EJunoCaveGeneratorShellTags
// NumValues: 0x0006
enum class EJunoCaveGeneratorShellTags : uint8
{
	BearCave                                 = 0,
	WolfCave                                 = 1,
	TreasureCave                             = 2,
	PirateCave                               = 3,
	AnimalDen                                = 4,
	BossRoom                                 = 5,
};

// Enum JunoProceduralWorld.EJunoCaveGeneratorLayoutTags
// NumValues: 0x0001
enum class EJunoCaveGeneratorLayoutTags : uint8
{
	OroMine                                  = 0,
};

// Enum JunoProceduralWorld.EJunoCaveGeneratorPCGType
// NumValues: 0x0007
enum class EJunoCaveGeneratorPCGType : uint8
{
	GemsAndOre                               = 0,
	GemsAndOre_HighValue                     = 1,
	Mushroom                                 = 2,
	Plants                                   = 3,
	Ceiling                                  = 4,
	Clutter                                  = 5,
	Rare                                     = 6,
};

// Enum JunoProceduralWorld.EAddChainResult
// NumValues: 0x0006
enum class EAddChainResult : uint8
{
	Success                                  = 0,
	NoMatchingShell                          = 1,
	InvalidAttachIndex                       = 2,
	NoExitsLeft                              = 3,
	CannotFitShell                           = 4,
	NoShellsGenerated                        = 5,
};

// Enum JunoProceduralWorld.EJunoCaveTheme_DEPRECATED
// NumValues: 0x0005
enum class EJunoCaveTheme_DEPRECATED : uint8
{
	Grassland                                = 0,
	DarkForest                               = 1,
	Tropical                                 = 2,
	Alpine                                   = 3,
	Desert                                   = 4,
};

// Enum JunoProceduralWorld.EJunoCreateCaveResult
// NumValues: 0x0003
enum class EJunoCreateCaveResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
	Disabled                                 = 2,
};

// Enum JunoProceduralWorld.EJunoQueryCaveDataResult
// NumValues: 0x0004
enum class EJunoQueryCaveDataResult : uint8
{
	NotReady                                 = 0,
	NotAllowed                               = 1,
	Cached                                   = 2,
	NoEntry                                  = 3,
};

// Enum JunoProceduralWorld.EJunoQueryCaveSurfaceDataStateResult
// NumValues: 0x0004
enum class EJunoQueryCaveSurfaceDataStateResult : uint8
{
	NotReady                                 = 0,
	NotAllowed                               = 1,
	Cached                                   = 2,
	NoEntry                                  = 3,
};

// Enum JunoProceduralWorld.EJunoGetCaveSurfaceDataForEntranceResult
// NumValues: 0x0004
enum class EJunoGetCaveSurfaceDataForEntranceResult : uint8
{
	NotReady                                 = 0,
	NotAllowed                               = 1,
	IsACave                                  = 2,
	NotACave                                 = 3,
};

// Enum JunoProceduralWorld.EJunoGetCaveShellInstanceDataResult
// NumValues: 0x0002
enum class EJunoGetCaveShellInstanceDataResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoGetBestCaveResult
// NumValues: 0x0002
enum class EJunoGetBestCaveResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoCalculateCaveDistanceResult
// NumValues: 0x0003
enum class EJunoCalculateCaveDistanceResult : uint8
{
	Success                                  = 0,
	ParentIDsNotCorrect                      = 1,
	ShellsAreNotConnected                    = 2,
};

// Enum JunoProceduralWorld.EJunoGetCaveDataCollectionsFromRegistryResult
// NumValues: 0x0002
enum class EJunoGetCaveDataCollectionsFromRegistryResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoIAVolumeShape
// NumValues: 0x0002
enum class EJunoIAVolumeShape : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
};

// Enum JunoProceduralWorld.EJunoPCGVolumeSource
// NumValues: 0x0002
enum class EJunoPCGVolumeSource : uint8
{
	Transient                                = 0,
	Persistent                               = 1,
};

// Enum JunoProceduralWorld.EJunoFindNextMatchingPOIResourceResult
// NumValues: 0x0002
enum class EJunoFindNextMatchingPOIResourceResult : uint8
{
	Found                                    = 0,
	NotFound                                 = 1,
};

// Enum JunoProceduralWorld.EJunoCreateLevelResult
// NumValues: 0x0002
enum class EJunoCreateLevelResult : uint8
{
	Success                                  = 0,
	Failed                                   = 1,
};

// Enum JunoProceduralWorld.EJunoCompareTagSetsResult
// NumValues: 0x0003
enum class EJunoCompareTagSetsResult : uint8
{
	NoMatch                                  = 0,
	PartialMatch                             = 1,
	FullMatch                                = 2,
};

// Enum JunoProceduralWorld.EJunoResolveWorldSoftObjectPathResult
// NumValues: 0x0003
enum class EJunoResolveWorldSoftObjectPathResult : uint8
{
	Success                                  = 0,
	NotAWorldObject                          = 1,
	InvalidPath                              = 2,
};

// Enum JunoProceduralWorld.EJunoLevelInstanceMode
// NumValues: 0x0003
enum class EJunoLevelInstanceMode : uint8
{
	Disabled                                 = 0,
	StreamingWP                              = 1,
	CellInjection                            = 2,
};

// Enum JunoProceduralWorld.EJunoWorldRegistryType
// NumValues: 0x0003
enum class EJunoWorldRegistryType : uint8
{
	Invalid                                  = 0,
	POI                                      = 1,
	Enemy                                    = 2,
};

// Enum JunoProceduralWorld.EJunoGetWorldTileTransformResult
// NumValues: 0x0002
enum class EJunoGetWorldTileTransformResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoGetWorldTileBoundsResult
// NumValues: 0x0002
enum class EJunoGetWorldTileBoundsResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoTileStatus
// NumValues: 0x0006
enum class EJunoTileStatus : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	Deprecated                               = 2,
	Instantiated                             = 3,
	Reserved                                 = 4,
	OutOfBounds                              = 5,
};

// Enum JunoProceduralWorld.EJunoTileGenerationType
// NumValues: 0x0002
enum class EJunoTileGenerationType : uint8
{
	Unknown                                  = 0,
	Cooked                                   = 1,
};

// Enum JunoProceduralWorld.EJunoWorldTilePOIType
// NumValues: 0x0004
enum class EJunoWorldTilePOIType : uint8
{
	Overworld                                = 0,
	Cave                                     = 1,
	CaveEntrance                             = 2,
	Bridge                                   = 3,
};

// Enum JunoProceduralWorld.EJunoPOISlotState
// NumValues: 0x0005
enum class EJunoPOISlotState : uint8
{
	Normal                                   = 0,
	Unused                                   = 1,
	Cosmetic                                 = 2,
	CaveEntrance                             = 3,
	UnusedNearWorldStart                     = 4,
};

// Enum JunoProceduralWorld.EJunoWorldTileInjectedLevelType
// NumValues: 0x0002
enum class EJunoWorldTileInjectedLevelType : uint8
{
	POI                                      = 0,
	Cave                                     = 1,
};

// Enum JunoProceduralWorld.EPushFrontierResult
// NumValues: 0x0009
enum class EPushFrontierResult : uint8
{
	Continue                                 = 0,
	Success                                  = 1,
	Fail                                     = 2,
	OutOfFrontierNodes                       = 3,
	NoNewFrontierCreated                     = 4,
	ReachedMaxCost                           = 5,
	ReachedMaxSteps                          = 6,
	ReachedDestination                       = 7,
	NoValidResult                            = 8,
};

// Enum JunoProceduralWorld.EPathfinderNodeState
// NumValues: 0x0004
enum class EPathfinderNodeState : uint8
{
	Normal                                   = 0,
	Snap                                     = 1,
	Warp                                     = 2,
	Invalid                                  = 3,
};

// Enum JunoProceduralWorld.EJunoRepresentation
// NumValues: 0x0003
enum class EJunoRepresentation : uint8
{
	None                                     = 0,
	Actor                                    = 1,
	Instance                                 = 2,
};

// Enum JunoProceduralWorld.EJunoPOISize
// NumValues: 0x0009
enum class EJunoPOISize : uint8
{
	None                                     = 0,
	JPOI_1x1                                 = 1,
	JPOI_2x2                                 = 2,
	JPOI_3x3                                 = 3,
	JPOI_4x4                                 = 4,
	JPOI_5x5                                 = 5,
	JPOI_8x8                                 = 8,
	JPOI_10x10                               = 10,
	JPOI_11x11                               = 11,
};

// Enum JunoProceduralWorld.PCGJunoApplyMaskNodeMode
// NumValues: 0x0004
enum class EPCGJunoApplyMaskNodeMode : uint8
{
	Subtract                                 = 0,
	Intersect                                = 1,
	SubtractSmaller                          = 2,
	SubtractLarger                           = 3,
};

// Enum JunoProceduralWorld.ELandmassRiverTier
// NumValues: 0x0001
enum class ELandmassRiverTier : uint8
{
	Default                                  = 0,
};

// Enum JunoProceduralWorld.EQueryPOIStateResult
// NumValues: 0x0004
enum class EQueryPOIStateResult : uint8
{
	NotReady                                 = 0,
	NotAllowed                               = 1,
	Cached                                   = 2,
	NoEntry                                  = 3,
};

// Enum JunoProceduralWorld.EGeneratePOIResult
// NumValues: 0x0002
enum class EGeneratePOIResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoMarkSlotPOIUnusedResult
// NumValues: 0x0002
enum class EJunoMarkSlotPOIUnusedResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoSetSlotPOIMetaDataResult
// NumValues: 0x0002
enum class EJunoSetSlotPOIMetaDataResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EJunoGetMatchingPOIsFromDataRegistryResult
// NumValues: 0x0002
enum class EJunoGetMatchingPOIsFromDataRegistryResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
};

// Enum JunoProceduralWorld.EVerticalDirection
// NumValues: 0x0003
enum class EVerticalDirection : uint8
{
	Both                                     = 0,
	DownwardOnly                             = 1,
	UpwardOnly                               = 2,
};

// Enum JunoProceduralWorld.ELandmassRoadTier
// NumValues: 0x0008
enum class ELandmassRoadTier : uint8
{
	Default                                  = 0,
	Dirt                                     = 1,
	Rural                                    = 2,
	Metropolitan                             = 3,
	Suburban                                 = 4,
	Highway                                  = 5,
	BreadCrumbs                              = 6,
	Hidden                                   = 7,
};

// Enum JunoProceduralWorld.ERouteGenerationState
// NumValues: 0x0003
enum class ERouteGenerationState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	Dormant                                  = 2,
};

// Enum JunoProceduralWorld.ERouteAvoidancePrimitiveType
// NumValues: 0x0003
enum class ERouteAvoidancePrimitiveType : uint8
{
	Disc                                     = 0,
	Curve                                    = 1,
	ProceduralRoutes                         = 2,
};

// Enum JunoProceduralWorld.EProceduralRouteGuideSetSelectMethod
// NumValues: 0x0002
enum class EProceduralRouteGuideSetSelectMethod : uint8
{
	UseTileId                                = 0,
	UseTileIndex                             = 1,
};

// Enum JunoProceduralWorld.EProceduralRiverAnchorType
// NumValues: 0x0004
enum class EProceduralRiverAnchorType : uint8
{
	Source                                   = 0,
	Lake                                     = 1,
	Coastline                                = 2,
	DeepSea                                  = 3,
};

// Enum JunoProceduralWorld.PCGJunoFractalNoise2DMode
// NumValues: 0x0006
enum class EPCGJunoFractalNoise2DMode : uint32
{
	Perlin                                   = 0,
	Caustic                                  = 1,
	Voronoi                                  = 2,
	TiledVoronoi                             = 3,
	Brownian                                 = 4,
	EdgeMask                                 = 5,
};

// Enum JunoProceduralWorld.PCGJunoFractalNoise2DEdgeMode
// NumValues: 0x0003
enum class EPCGJunoFractalNoise2DEdgeMode : uint32
{
	Perlin                                   = 0,
	Caustic                                  = 1,
	Brownian                                 = 2,
};

// Enum JunoProceduralWorld.PCGJunoFractalDensityMode
// NumValues: 0x0004
enum class EPCGJunoFractalDensityMode : uint32
{
	Ignore                                   = 0,
	Set                                      = 1,
	Add                                      = 2,
	Multiply                                 = 3,
};

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorPCGResourceMap
// 0x0050 (0x0050 - 0x0000)
struct FJunoCaveGeneratorPCGResourceMap final
{
public:
	TMap<class FName, int32>                      ResourceWeight;                                    // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveGeneratorPCGResourceMap) == 0x000008, "Wrong alignment on FJunoCaveGeneratorPCGResourceMap");
static_assert(sizeof(FJunoCaveGeneratorPCGResourceMap) == 0x000050, "Wrong size on FJunoCaveGeneratorPCGResourceMap");
static_assert(offsetof(FJunoCaveGeneratorPCGResourceMap, ResourceWeight) == 0x000000, "Member 'FJunoCaveGeneratorPCGResourceMap::ResourceWeight' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoRandomTableKeysIterator
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FJunoRandomTableKeysIterator final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoRandomTableKeysIterator) == 0x000008, "Wrong alignment on FJunoRandomTableKeysIterator");
static_assert(sizeof(FJunoRandomTableKeysIterator) == 0x000018, "Wrong size on FJunoRandomTableKeysIterator");

// ScriptStruct JunoProceduralWorld.JunoBridgePOISelectorParams
// 0x0018 (0x0018 - 0x0000)
struct FJunoBridgePOISelectorParams final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RiverWidth;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoBridgePOISelectorParams) == 0x000008, "Wrong alignment on FJunoBridgePOISelectorParams");
static_assert(sizeof(FJunoBridgePOISelectorParams) == 0x000018, "Wrong size on FJunoBridgePOISelectorParams");
static_assert(offsetof(FJunoBridgePOISelectorParams, Guid) == 0x000000, "Member 'FJunoBridgePOISelectorParams::Guid' has a wrong offset!");
static_assert(offsetof(FJunoBridgePOISelectorParams, RiverWidth) == 0x000010, "Member 'FJunoBridgePOISelectorParams::RiverWidth' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorWorldsList
// 0x0010 (0x0010 - 0x0000)
struct FJunoCaveGeneratorWorldsList final
{
public:
	TArray<struct FSoftObjectPath>                Worlds;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveGeneratorWorldsList) == 0x000008, "Wrong alignment on FJunoCaveGeneratorWorldsList");
static_assert(sizeof(FJunoCaveGeneratorWorldsList) == 0x000010, "Wrong size on FJunoCaveGeneratorWorldsList");
static_assert(offsetof(FJunoCaveGeneratorWorldsList, Worlds) == 0x000000, "Member 'FJunoCaveGeneratorWorldsList::Worlds' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveTeleporterLink
// 0x00D0 (0x00D0 - 0x0000)
struct FJunoCaveTeleporterLink final
{
public:
	struct FTransform                             SurfaceTransform;                                  // 0x0000(0x0060)(Edit, BlueprintVisible, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             CaveTransform;                                     // 0x0060(0x0060)(Edit, BlueprintVisible, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJunoTeleporter>            SurfaceTeleporterClass;                            // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJunoTeleporter>            CaveTeleporterClass;                               // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveTeleporterLink) == 0x000010, "Wrong alignment on FJunoCaveTeleporterLink");
static_assert(sizeof(FJunoCaveTeleporterLink) == 0x0000D0, "Wrong size on FJunoCaveTeleporterLink");
static_assert(offsetof(FJunoCaveTeleporterLink, SurfaceTransform) == 0x000000, "Member 'FJunoCaveTeleporterLink::SurfaceTransform' has a wrong offset!");
static_assert(offsetof(FJunoCaveTeleporterLink, CaveTransform) == 0x000060, "Member 'FJunoCaveTeleporterLink::CaveTransform' has a wrong offset!");
static_assert(offsetof(FJunoCaveTeleporterLink, SurfaceTeleporterClass) == 0x0000C0, "Member 'FJunoCaveTeleporterLink::SurfaceTeleporterClass' has a wrong offset!");
static_assert(offsetof(FJunoCaveTeleporterLink, CaveTeleporterClass) == 0x0000C8, "Member 'FJunoCaveTeleporterLink::CaveTeleporterClass' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveShellInstanceData
// 0x0078 (0x0078 - 0x0000)
struct FJunoCaveShellInstanceData final
{
public:
	int32                                         ExitsUsedMask;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Depth;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Tier;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChainID;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoCaveType                                 Type;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ThemeName;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 ThemeObject;                                       // 0x0018(0x0020)(Edit, BlueprintVisible, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BranchParentShellID;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        EntranceZ;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoBiome                                    EntranceBiome;                                     // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TeleporterTargetPosition;                          // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJunoCaveTeleporterLink>        Teleporters;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveShellInstanceData) == 0x000008, "Wrong alignment on FJunoCaveShellInstanceData");
static_assert(sizeof(FJunoCaveShellInstanceData) == 0x000078, "Wrong size on FJunoCaveShellInstanceData");
static_assert(offsetof(FJunoCaveShellInstanceData, ExitsUsedMask) == 0x000000, "Member 'FJunoCaveShellInstanceData::ExitsUsedMask' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, Depth) == 0x000004, "Member 'FJunoCaveShellInstanceData::Depth' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, Tier) == 0x000008, "Member 'FJunoCaveShellInstanceData::Tier' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, ChainID) == 0x00000C, "Member 'FJunoCaveShellInstanceData::ChainID' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, Type) == 0x000010, "Member 'FJunoCaveShellInstanceData::Type' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, ThemeName) == 0x000014, "Member 'FJunoCaveShellInstanceData::ThemeName' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, ThemeObject) == 0x000018, "Member 'FJunoCaveShellInstanceData::ThemeObject' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, BranchParentShellID) == 0x000038, "Member 'FJunoCaveShellInstanceData::BranchParentShellID' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, EntranceZ) == 0x000040, "Member 'FJunoCaveShellInstanceData::EntranceZ' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, EntranceBiome) == 0x000048, "Member 'FJunoCaveShellInstanceData::EntranceBiome' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, TeleporterTargetPosition) == 0x000050, "Member 'FJunoCaveShellInstanceData::TeleporterTargetPosition' has a wrong offset!");
static_assert(offsetof(FJunoCaveShellInstanceData, Teleporters) == 0x000068, "Member 'FJunoCaveShellInstanceData::Teleporters' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorResourceWorlds
// 0x0060 (0x0060 - 0x0000)
struct FJunoCaveGeneratorResourceWorlds final
{
public:
	TSet<EJunoBiome>                              ValidBiomes;                                       // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                Worlds;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveGeneratorResourceWorlds) == 0x000008, "Wrong alignment on FJunoCaveGeneratorResourceWorlds");
static_assert(sizeof(FJunoCaveGeneratorResourceWorlds) == 0x000060, "Wrong size on FJunoCaveGeneratorResourceWorlds");
static_assert(offsetof(FJunoCaveGeneratorResourceWorlds, ValidBiomes) == 0x000000, "Member 'FJunoCaveGeneratorResourceWorlds::ValidBiomes' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorResourceWorlds, Worlds) == 0x000050, "Member 'FJunoCaveGeneratorResourceWorlds::Worlds' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorIterationContext
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FJunoInstancedActorIterationContext final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoInstancedActorIterationContext) == 0x000008, "Wrong alignment on FJunoInstancedActorIterationContext");
static_assert(sizeof(FJunoInstancedActorIterationContext) == 0x000070, "Wrong size on FJunoInstancedActorIterationContext");

// ScriptStruct JunoProceduralWorld.PCGJunoBiomeEntry
// 0x0028 (0x0028 - 0x0000)
struct FPCGJunoBiomeEntry final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Density;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              BiomeElements;                                     // 0x0008(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoBiomeEntry) == 0x000008, "Wrong alignment on FPCGJunoBiomeEntry");
static_assert(sizeof(FPCGJunoBiomeEntry) == 0x000028, "Wrong size on FPCGJunoBiomeEntry");
static_assert(offsetof(FPCGJunoBiomeEntry, Name) == 0x000000, "Member 'FPCGJunoBiomeEntry::Name' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeEntry, Density) == 0x000004, "Member 'FPCGJunoBiomeEntry::Density' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeEntry, BiomeElements) == 0x000008, "Member 'FPCGJunoBiomeEntry::BiomeElements' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorPOIMarker
// 0x00B0 (0x00B0 - 0x0000)
struct FJunoCaveGeneratorPOIMarker final
{
public:
	TSet<EJunoPOISize>                            ValidSizes;                                        // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0050(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveGeneratorPOIMarker) == 0x000010, "Wrong alignment on FJunoCaveGeneratorPOIMarker");
static_assert(sizeof(FJunoCaveGeneratorPOIMarker) == 0x0000B0, "Wrong size on FJunoCaveGeneratorPOIMarker");
static_assert(offsetof(FJunoCaveGeneratorPOIMarker, ValidSizes) == 0x000000, "Member 'FJunoCaveGeneratorPOIMarker::ValidSizes' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorPOIMarker, Transform) == 0x000050, "Member 'FJunoCaveGeneratorPOIMarker::Transform' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoTerrainWaterInformation
// 0x00C0 (0x00C0 - 0x0000)
struct FJunoTerrainWaterInformation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterSurfaceHeight;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerrainHeight;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterDepth;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x64];                                      // 0x0024(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	EJunoBiomeHabitat                             WaterType;                                         // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x0090(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DirectionMaskIndex;                                // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasNearMiss;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFoundWater;                                       // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearMissEstimatedDistance;                         // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWaterBody*                             FoundWaterBody;                                    // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoTerrainWaterInformation) == 0x000008, "Wrong alignment on FJunoTerrainWaterInformation");
static_assert(sizeof(FJunoTerrainWaterInformation) == 0x0000C0, "Wrong size on FJunoTerrainWaterInformation");
static_assert(offsetof(FJunoTerrainWaterInformation, Location) == 0x000000, "Member 'FJunoTerrainWaterInformation::Location' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, WaterSurfaceHeight) == 0x000018, "Member 'FJunoTerrainWaterInformation::WaterSurfaceHeight' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, TerrainHeight) == 0x00001C, "Member 'FJunoTerrainWaterInformation::TerrainHeight' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, WaterDepth) == 0x000020, "Member 'FJunoTerrainWaterInformation::WaterDepth' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, WaterType) == 0x000088, "Member 'FJunoTerrainWaterInformation::WaterType' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, Direction) == 0x000090, "Member 'FJunoTerrainWaterInformation::Direction' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, Distance) == 0x0000A8, "Member 'FJunoTerrainWaterInformation::Distance' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, DirectionMaskIndex) == 0x0000AC, "Member 'FJunoTerrainWaterInformation::DirectionMaskIndex' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, bWasNearMiss) == 0x0000B0, "Member 'FJunoTerrainWaterInformation::bWasNearMiss' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, bFoundWater) == 0x0000B1, "Member 'FJunoTerrainWaterInformation::bFoundWater' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, NearMissEstimatedDistance) == 0x0000B4, "Member 'FJunoTerrainWaterInformation::NearMissEstimatedDistance' has a wrong offset!");
static_assert(offsetof(FJunoTerrainWaterInformation, FoundWaterBody) == 0x0000B8, "Member 'FJunoTerrainWaterInformation::FoundWaterBody' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorShellData
// 0x01A0 (0x01A8 - 0x0008)
struct FJunoCaveGeneratorShellData final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        World;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EJunoBiome>                              ValidBiomes;                                       // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<EJunoCaveGeneratorShellTags>             ShellTags;                                         // 0x0078(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EJunoCaveGeneratorShellType                   ShellType;                                         // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoCaveGeneratorShellSize                   ShellSize;                                         // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinDepth;                                          // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDepth;                                          // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Version;                                           // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoCaveGeneratorResourceWorlds> ResourceLevels;                                    // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ShellBoundsSize;                                   // 0x00F0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShellBoundsCenter;                                 // 0x0108(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ExitLocations;                                     // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumOfSpawners;                                     // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoCaveGeneratorPOIMarker>    POIMarkers;                                        // 0x0138(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumOfAIPointProviders;                             // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EJunoCaveGeneratorLayoutTags, struct FJunoCaveGeneratorWorldsList> SupportedLayouts;                                  // 0x0150(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasFixedEntrance;                                 // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PersistenceVersion;                                // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveGeneratorShellData) == 0x000008, "Wrong alignment on FJunoCaveGeneratorShellData");
static_assert(sizeof(FJunoCaveGeneratorShellData) == 0x0001A8, "Wrong size on FJunoCaveGeneratorShellData");
static_assert(offsetof(FJunoCaveGeneratorShellData, Name) == 0x000008, "Member 'FJunoCaveGeneratorShellData::Name' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, World) == 0x000010, "Member 'FJunoCaveGeneratorShellData::World' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, ValidBiomes) == 0x000028, "Member 'FJunoCaveGeneratorShellData::ValidBiomes' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, ShellTags) == 0x000078, "Member 'FJunoCaveGeneratorShellData::ShellTags' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, ShellType) == 0x0000C8, "Member 'FJunoCaveGeneratorShellData::ShellType' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, ShellSize) == 0x0000C9, "Member 'FJunoCaveGeneratorShellData::ShellSize' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, MinDepth) == 0x0000CC, "Member 'FJunoCaveGeneratorShellData::MinDepth' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, MaxDepth) == 0x0000D0, "Member 'FJunoCaveGeneratorShellData::MaxDepth' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, bEnabled) == 0x0000D4, "Member 'FJunoCaveGeneratorShellData::bEnabled' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, Version) == 0x0000D8, "Member 'FJunoCaveGeneratorShellData::Version' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, ResourceLevels) == 0x0000E0, "Member 'FJunoCaveGeneratorShellData::ResourceLevels' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, ShellBoundsSize) == 0x0000F0, "Member 'FJunoCaveGeneratorShellData::ShellBoundsSize' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, ShellBoundsCenter) == 0x000108, "Member 'FJunoCaveGeneratorShellData::ShellBoundsCenter' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, ExitLocations) == 0x000120, "Member 'FJunoCaveGeneratorShellData::ExitLocations' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, NumOfSpawners) == 0x000130, "Member 'FJunoCaveGeneratorShellData::NumOfSpawners' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, POIMarkers) == 0x000138, "Member 'FJunoCaveGeneratorShellData::POIMarkers' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, NumOfAIPointProviders) == 0x000148, "Member 'FJunoCaveGeneratorShellData::NumOfAIPointProviders' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, SupportedLayouts) == 0x000150, "Member 'FJunoCaveGeneratorShellData::SupportedLayouts' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, bHasFixedEntrance) == 0x0001A0, "Member 'FJunoCaveGeneratorShellData::bHasFixedEntrance' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorShellData, PersistenceVersion) == 0x0001A4, "Member 'FJunoCaveGeneratorShellData::PersistenceVersion' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.SplineCurvesInfo
// 0x0018 (0x0018 - 0x0000)
struct FSplineCurvesInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PointsNum;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineCurvesInfo) == 0x000008, "Wrong alignment on FSplineCurvesInfo");
static_assert(sizeof(FSplineCurvesInfo) == 0x000018, "Wrong size on FSplineCurvesInfo");
static_assert(offsetof(FSplineCurvesInfo, Name) == 0x000000, "Member 'FSplineCurvesInfo::Name' has a wrong offset!");
static_assert(offsetof(FSplineCurvesInfo, PointsNum) == 0x000010, "Member 'FSplineCurvesInfo::PointsNum' has a wrong offset!");
static_assert(offsetof(FSplineCurvesInfo, Length) == 0x000014, "Member 'FSplineCurvesInfo::Length' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.SplineGuide
// 0x0120 (0x0120 - 0x0000)
struct FSplineGuide final
{
public:
	struct FSplineCurves                          SplineCurves;                                      // 0x0000(0x0070)(NativeAccessSpecifierPublic)
	bool                                          bIsClosedLoop;                                     // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0080(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSplineCurvesInfo                      SplineCurvesInfo;                                  // 0x00E0(0x0018)(Edit, EditConst, NativeAccessSpecifierPublic)
	bool                                          bAllowRandomYaw;                                   // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRandomScaleVariation;                        // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScaleVariation;                                    // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     GuideClass;                                        // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplineGuide) == 0x000010, "Wrong alignment on FSplineGuide");
static_assert(sizeof(FSplineGuide) == 0x000120, "Wrong size on FSplineGuide");
static_assert(offsetof(FSplineGuide, SplineCurves) == 0x000000, "Member 'FSplineGuide::SplineCurves' has a wrong offset!");
static_assert(offsetof(FSplineGuide, bIsClosedLoop) == 0x000070, "Member 'FSplineGuide::bIsClosedLoop' has a wrong offset!");
static_assert(offsetof(FSplineGuide, Transform) == 0x000080, "Member 'FSplineGuide::Transform' has a wrong offset!");
static_assert(offsetof(FSplineGuide, SplineCurvesInfo) == 0x0000E0, "Member 'FSplineGuide::SplineCurvesInfo' has a wrong offset!");
static_assert(offsetof(FSplineGuide, bAllowRandomYaw) == 0x0000F8, "Member 'FSplineGuide::bAllowRandomYaw' has a wrong offset!");
static_assert(offsetof(FSplineGuide, bAllowRandomScaleVariation) == 0x0000F9, "Member 'FSplineGuide::bAllowRandomScaleVariation' has a wrong offset!");
static_assert(offsetof(FSplineGuide, ScaleVariation) == 0x000100, "Member 'FSplineGuide::ScaleVariation' has a wrong offset!");
static_assert(offsetof(FSplineGuide, GuideClass) == 0x000110, "Member 'FSplineGuide::GuideClass' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWaterSplineInjectorParams
// 0x0140 (0x0140 - 0x0000)
struct FJunoWaterSplineInjectorParams final
{
public:
	struct FSplineGuide                           SplineGuide;                                       // 0x0000(0x0120)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRandomYaw;                                   // 0x0124(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRandomScale;                                 // 0x0125(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_126[0x2];                                      // 0x0126(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScaleRange;                                        // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoWaterSplineInjectorParams) == 0x000010, "Wrong alignment on FJunoWaterSplineInjectorParams");
static_assert(sizeof(FJunoWaterSplineInjectorParams) == 0x000140, "Wrong size on FJunoWaterSplineInjectorParams");
static_assert(offsetof(FJunoWaterSplineInjectorParams, SplineGuide) == 0x000000, "Member 'FJunoWaterSplineInjectorParams::SplineGuide' has a wrong offset!");
static_assert(offsetof(FJunoWaterSplineInjectorParams, Seed) == 0x000120, "Member 'FJunoWaterSplineInjectorParams::Seed' has a wrong offset!");
static_assert(offsetof(FJunoWaterSplineInjectorParams, bAllowRandomYaw) == 0x000124, "Member 'FJunoWaterSplineInjectorParams::bAllowRandomYaw' has a wrong offset!");
static_assert(offsetof(FJunoWaterSplineInjectorParams, bAllowRandomScale) == 0x000125, "Member 'FJunoWaterSplineInjectorParams::bAllowRandomScale' has a wrong offset!");
static_assert(offsetof(FJunoWaterSplineInjectorParams, ScaleRange) == 0x000128, "Member 'FJunoWaterSplineInjectorParams::ScaleRange' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorRule
// 0x0050 (0x0058 - 0x0008)
struct FJunoCaveGeneratorRule final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectionWeight;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DepthAttemptThreshold;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfTeleporters;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPrimaryChainLength;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPrimaryChainLength;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryChainHallwayChance;                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNumberOfSecondaryChains;                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfSecondaryChains;                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinSecondaryChainLength;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSecondaryChainLength;                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinStartingDepthOfSecondaryChains;                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStartingDepthOfSecondaryChains;                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSpawnOnSecondaryChains;                        // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondaryChainHallwayChance;                       // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfPOIs;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasePOISpawnChance;                                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPOIsInTeleporterRooms;                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoCaveGeneratorRule) == 0x000008, "Wrong alignment on FJunoCaveGeneratorRule");
static_assert(sizeof(FJunoCaveGeneratorRule) == 0x000058, "Wrong size on FJunoCaveGeneratorRule");
static_assert(offsetof(FJunoCaveGeneratorRule, Name) == 0x000008, "Member 'FJunoCaveGeneratorRule::Name' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, SelectionWeight) == 0x00000C, "Member 'FJunoCaveGeneratorRule::SelectionWeight' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, bEnabled) == 0x000010, "Member 'FJunoCaveGeneratorRule::bEnabled' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, DepthAttemptThreshold) == 0x000014, "Member 'FJunoCaveGeneratorRule::DepthAttemptThreshold' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MaxNumberOfTeleporters) == 0x000018, "Member 'FJunoCaveGeneratorRule::MaxNumberOfTeleporters' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MinPrimaryChainLength) == 0x00001C, "Member 'FJunoCaveGeneratorRule::MinPrimaryChainLength' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MaxPrimaryChainLength) == 0x000020, "Member 'FJunoCaveGeneratorRule::MaxPrimaryChainLength' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, PrimaryChainHallwayChance) == 0x000024, "Member 'FJunoCaveGeneratorRule::PrimaryChainHallwayChance' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MinNumberOfSecondaryChains) == 0x000028, "Member 'FJunoCaveGeneratorRule::MinNumberOfSecondaryChains' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MaxNumberOfSecondaryChains) == 0x00002C, "Member 'FJunoCaveGeneratorRule::MaxNumberOfSecondaryChains' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MinSecondaryChainLength) == 0x000030, "Member 'FJunoCaveGeneratorRule::MinSecondaryChainLength' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MaxSecondaryChainLength) == 0x000034, "Member 'FJunoCaveGeneratorRule::MaxSecondaryChainLength' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MinStartingDepthOfSecondaryChains) == 0x000038, "Member 'FJunoCaveGeneratorRule::MinStartingDepthOfSecondaryChains' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MaxStartingDepthOfSecondaryChains) == 0x00003C, "Member 'FJunoCaveGeneratorRule::MaxStartingDepthOfSecondaryChains' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, bCanSpawnOnSecondaryChains) == 0x000040, "Member 'FJunoCaveGeneratorRule::bCanSpawnOnSecondaryChains' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, SecondaryChainHallwayChance) == 0x000044, "Member 'FJunoCaveGeneratorRule::SecondaryChainHallwayChance' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, MaxNumberOfPOIs) == 0x000048, "Member 'FJunoCaveGeneratorRule::MaxNumberOfPOIs' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, BasePOISpawnChance) == 0x00004C, "Member 'FJunoCaveGeneratorRule::BasePOISpawnChance' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorRule, bAllowPOIsInTeleporterRooms) == 0x000050, "Member 'FJunoCaveGeneratorRule::bAllowPOIsInTeleporterRooms' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorTypeData
// 0x0160 (0x0168 - 0x0008)
struct FJunoCaveGeneratorTypeData final : public FTableRowBase
{
public:
	class FName                                   TypeName;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoCaveGeneratorRule>         Rules;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             SharedRules;                                       // 0x0020(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EJunoCaveType                                 Type;                                              // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EJunoBiome>                              ValidBiomes;                                       // 0x0078(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<EJunoCaveGeneratorShellTags>             ShellTags;                                         // 0x00C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<EJunoCaveGeneratorLayoutTags>            LayoutTags;                                        // 0x0118(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveGeneratorTypeData) == 0x000008, "Wrong alignment on FJunoCaveGeneratorTypeData");
static_assert(sizeof(FJunoCaveGeneratorTypeData) == 0x000168, "Wrong size on FJunoCaveGeneratorTypeData");
static_assert(offsetof(FJunoCaveGeneratorTypeData, TypeName) == 0x000008, "Member 'FJunoCaveGeneratorTypeData::TypeName' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorTypeData, bEnabled) == 0x00000C, "Member 'FJunoCaveGeneratorTypeData::bEnabled' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorTypeData, Rules) == 0x000010, "Member 'FJunoCaveGeneratorTypeData::Rules' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorTypeData, SharedRules) == 0x000020, "Member 'FJunoCaveGeneratorTypeData::SharedRules' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorTypeData, Type) == 0x000070, "Member 'FJunoCaveGeneratorTypeData::Type' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorTypeData, ValidBiomes) == 0x000078, "Member 'FJunoCaveGeneratorTypeData::ValidBiomes' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorTypeData, ShellTags) == 0x0000C8, "Member 'FJunoCaveGeneratorTypeData::ShellTags' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorTypeData, LayoutTags) == 0x000118, "Member 'FJunoCaveGeneratorTypeData::LayoutTags' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorThemeEntry
// 0x0158 (0x0160 - 0x0008)
struct FJunoCaveGeneratorThemeEntry final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UMaterialInterface>      CaveMaterial;                                      // 0x0008(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      DestructibleCaveMaterial;                          // 0x0028(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ThemeResourceDataTable;                            // 0x0048(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              POIDataTable;                                      // 0x0068(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EJunoCaveGeneratorPCGType, struct FJunoCaveGeneratorPCGResourceMap> PCGTypeWeights;                                    // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EJunoBiome>                              Biomes;                                            // 0x00E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bExportTheme;                                      // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ThemeExportName;                                   // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThemeExportPath;                                   // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   TeleporterClass;                                   // 0x0140(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveGeneratorThemeEntry) == 0x000008, "Wrong alignment on FJunoCaveGeneratorThemeEntry");
static_assert(sizeof(FJunoCaveGeneratorThemeEntry) == 0x000160, "Wrong size on FJunoCaveGeneratorThemeEntry");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, CaveMaterial) == 0x000008, "Member 'FJunoCaveGeneratorThemeEntry::CaveMaterial' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, DestructibleCaveMaterial) == 0x000028, "Member 'FJunoCaveGeneratorThemeEntry::DestructibleCaveMaterial' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, ThemeResourceDataTable) == 0x000048, "Member 'FJunoCaveGeneratorThemeEntry::ThemeResourceDataTable' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, POIDataTable) == 0x000068, "Member 'FJunoCaveGeneratorThemeEntry::POIDataTable' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, PCGTypeWeights) == 0x000088, "Member 'FJunoCaveGeneratorThemeEntry::PCGTypeWeights' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, bEnabled) == 0x0000D8, "Member 'FJunoCaveGeneratorThemeEntry::bEnabled' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, Name) == 0x0000DC, "Member 'FJunoCaveGeneratorThemeEntry::Name' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, Biomes) == 0x0000E0, "Member 'FJunoCaveGeneratorThemeEntry::Biomes' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, bExportTheme) == 0x000130, "Member 'FJunoCaveGeneratorThemeEntry::bExportTheme' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, ThemeExportName) == 0x000134, "Member 'FJunoCaveGeneratorThemeEntry::ThemeExportName' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, ThemeExportPath) == 0x000138, "Member 'FJunoCaveGeneratorThemeEntry::ThemeExportPath' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorThemeEntry, TeleporterClass) == 0x000140, "Member 'FJunoCaveGeneratorThemeEntry::TeleporterClass' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorData
// 0x0030 (0x0038 - 0x0008)
struct FJunoCaveGeneratorData final : public FTableRowBase
{
public:
	TArray<struct FJunoCaveGeneratorShellData>    Shells;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJunoCaveGeneratorThemeEntry>   Themes;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJunoCaveGeneratorTypeData>     Types;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveGeneratorData) == 0x000008, "Wrong alignment on FJunoCaveGeneratorData");
static_assert(sizeof(FJunoCaveGeneratorData) == 0x000038, "Wrong size on FJunoCaveGeneratorData");
static_assert(offsetof(FJunoCaveGeneratorData, Shells) == 0x000008, "Member 'FJunoCaveGeneratorData::Shells' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorData, Themes) == 0x000018, "Member 'FJunoCaveGeneratorData::Themes' has a wrong offset!");
static_assert(offsetof(FJunoCaveGeneratorData, Types) == 0x000028, "Member 'FJunoCaveGeneratorData::Types' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveGeneratorResult
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FJunoCaveGeneratorResult final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoCaveGeneratorResult) == 0x000008, "Wrong alignment on FJunoCaveGeneratorResult");
static_assert(sizeof(FJunoCaveGeneratorResult) == 0x000050, "Wrong size on FJunoCaveGeneratorResult");

// ScriptStruct JunoProceduralWorld.JunoCaveConditionalTags
// 0x0028 (0x0028 - 0x0000)
struct FJunoCaveConditionalTags final
{
public:
	EJunoCaveType                                 Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoBiome                                    Biome;                                             // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsToApply;                                       // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveConditionalTags) == 0x000008, "Wrong alignment on FJunoCaveConditionalTags");
static_assert(sizeof(FJunoCaveConditionalTags) == 0x000028, "Wrong size on FJunoCaveConditionalTags");
static_assert(offsetof(FJunoCaveConditionalTags, Type) == 0x000000, "Member 'FJunoCaveConditionalTags::Type' has a wrong offset!");
static_assert(offsetof(FJunoCaveConditionalTags, Biome) == 0x000001, "Member 'FJunoCaveConditionalTags::Biome' has a wrong offset!");
static_assert(offsetof(FJunoCaveConditionalTags, TagsToApply) == 0x000008, "Member 'FJunoCaveConditionalTags::TagsToApply' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoGeneratedCaveShellData
// 0x0130 (0x0130 - 0x0000)
struct FJunoGeneratedCaveShellData final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundsOffset;                                      // 0x0078(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShellID;                                           // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                Levels;                                            // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FJunoCaveShellInstanceData             InstanceData;                                      // 0x00A8(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         PersistenceVersion;                                // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0xC];                                      // 0x0124(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoGeneratedCaveShellData) == 0x000010, "Wrong alignment on FJunoGeneratedCaveShellData");
static_assert(sizeof(FJunoGeneratedCaveShellData) == 0x000130, "Wrong size on FJunoGeneratedCaveShellData");
static_assert(offsetof(FJunoGeneratedCaveShellData, Transform) == 0x000000, "Member 'FJunoGeneratedCaveShellData::Transform' has a wrong offset!");
static_assert(offsetof(FJunoGeneratedCaveShellData, Extent) == 0x000060, "Member 'FJunoGeneratedCaveShellData::Extent' has a wrong offset!");
static_assert(offsetof(FJunoGeneratedCaveShellData, BoundsOffset) == 0x000078, "Member 'FJunoGeneratedCaveShellData::BoundsOffset' has a wrong offset!");
static_assert(offsetof(FJunoGeneratedCaveShellData, ShellID) == 0x000090, "Member 'FJunoGeneratedCaveShellData::ShellID' has a wrong offset!");
static_assert(offsetof(FJunoGeneratedCaveShellData, Levels) == 0x000098, "Member 'FJunoGeneratedCaveShellData::Levels' has a wrong offset!");
static_assert(offsetof(FJunoGeneratedCaveShellData, InstanceData) == 0x0000A8, "Member 'FJunoGeneratedCaveShellData::InstanceData' has a wrong offset!");
static_assert(offsetof(FJunoGeneratedCaveShellData, PersistenceVersion) == 0x000120, "Member 'FJunoGeneratedCaveShellData::PersistenceVersion' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCompressedTransforms
// 0x0230 (0x0230 - 0x0000)
struct alignas(0x10) FJunoCompressedTransforms final
{
public:
	uint8                                         Pad_0[0x230];                                      // 0x0000(0x0230)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoCompressedTransforms) == 0x000010, "Wrong alignment on FJunoCompressedTransforms");
static_assert(sizeof(FJunoCompressedTransforms) == 0x000230, "Wrong size on FJunoCompressedTransforms");

// ScriptStruct JunoProceduralWorld.JunoGenerateTileParams
// 0x0018 (0x0018 - 0x0000)
struct FJunoGenerateTileParams final
{
public:
	class FString                                 TilesToGenerate;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UJunoGenerateTileCommandlet> Commandlet;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoGenerateTileParams) == 0x000008, "Wrong alignment on FJunoGenerateTileParams");
static_assert(sizeof(FJunoGenerateTileParams) == 0x000018, "Wrong size on FJunoGenerateTileParams");
static_assert(offsetof(FJunoGenerateTileParams, TilesToGenerate) == 0x000000, "Member 'FJunoGenerateTileParams::TilesToGenerate' has a wrong offset!");
static_assert(offsetof(FJunoGenerateTileParams, Commandlet) == 0x000010, "Member 'FJunoGenerateTileParams::Commandlet' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoActorInstanceIndex
// 0x0002 (0x0002 - 0x0000)
struct FJunoActorInstanceIndex final
{
public:
	uint16                                        Index;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FJunoActorInstanceIndex) == 0x000002, "Wrong alignment on FJunoActorInstanceIndex");
static_assert(sizeof(FJunoActorInstanceIndex) == 0x000002, "Wrong size on FJunoActorInstanceIndex");
static_assert(offsetof(FJunoActorInstanceIndex, Index) == 0x000000, "Member 'FJunoActorInstanceIndex::Index' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoActorInstanceHandle
// 0x0010 (0x0010 - 0x0000)
struct FJunoActorInstanceHandle final
{
public:
	class UJunoInstancedActorData*                InstancedActorData;                                // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJunoActorInstanceIndex                Index;                                             // 0x0008(0x0002)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoActorInstanceHandle) == 0x000008, "Wrong alignment on FJunoActorInstanceHandle");
static_assert(sizeof(FJunoActorInstanceHandle) == 0x000010, "Wrong size on FJunoActorInstanceHandle");
static_assert(offsetof(FJunoActorInstanceHandle, InstancedActorData) == 0x000000, "Member 'FJunoActorInstanceHandle::InstancedActorData' has a wrong offset!");
static_assert(offsetof(FJunoActorInstanceHandle, Index) == 0x000008, "Member 'FJunoActorInstanceHandle::Index' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.InstancedActorMassSpawnData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FInstancedActorMassSpawnData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInstancedActorMassSpawnData) == 0x000004, "Wrong alignment on FInstancedActorMassSpawnData");
static_assert(sizeof(FInstancedActorMassSpawnData) == 0x000008, "Wrong size on FInstancedActorMassSpawnData");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorDelta
// 0x0004 (0x0010 - 0x000C)
struct FJunoInstancedActorDelta final : public FFastArraySerializerItem
{
public:
	struct FJunoActorInstanceIndex                InstanceIndex;                                     // 0x000C(0x0002)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bDestroyed : 1;                                    // 0x000E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         CurrentLifecyclePhaseIndex;                        // 0x000F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FJunoInstancedActorDelta) == 0x000004, "Wrong alignment on FJunoInstancedActorDelta");
static_assert(sizeof(FJunoInstancedActorDelta) == 0x000010, "Wrong size on FJunoInstancedActorDelta");
static_assert(offsetof(FJunoInstancedActorDelta, InstanceIndex) == 0x00000C, "Member 'FJunoInstancedActorDelta::InstanceIndex' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorDelta, CurrentLifecyclePhaseIndex) == 0x00000F, "Member 'FJunoInstancedActorDelta::CurrentLifecyclePhaseIndex' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorDeltaList
// 0x0070 (0x0178 - 0x0108)
struct FJunoInstancedActorDeltaList final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x58];                                     // 0x0108(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoInstancedActorDelta>       InstanceDeltas;                                    // 0x0160(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoInstancedActorDeltaList) == 0x000008, "Wrong alignment on FJunoInstancedActorDeltaList");
static_assert(sizeof(FJunoInstancedActorDeltaList) == 0x000178, "Wrong size on FJunoInstancedActorDeltaList");
static_assert(offsetof(FJunoInstancedActorDeltaList, InstanceDeltas) == 0x000160, "Member 'FJunoInstancedActorDeltaList::InstanceDeltas' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorSettings
// 0x0098 (0x00A0 - 0x0008)
struct FJunoInstancedActorSettings final : public FTableRowBase
{
public:
	uint8                                         bOverride_bInstancesCastShadows : 1;               // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxActorDistance : 1;                    // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_bDisableAutoDistanceCulling : 1;         // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxInstanceDistance : 1;                 // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxInstanceDistances : 1;                // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LODDistanceScales : 1;                   // 0x0008(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AffectDistanceFieldLighting : 1;         // 0x0008(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DetailedRepresentationLODDistance : 1;   // 0x0008(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ForceLowRepresentationLODDistance : 1;   // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WorldPositionOffsetDisableDistance : 1;  // 0x0009(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_bEjectOnActorMoved : 1;                  // 0x0009(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ActorEjectionMovementThreshold : 1;      // 0x0009(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_bCanBeBuiltUpon : 1;                     // 0x0009(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_bCanEverAffectNavigation : 1;            // 0x0009(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OverrideWorldPartitionGrid : 1;          // 0x0009(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScaleEntityCount : 1;                    // 0x0009(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ActorClass : 1;                          // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_bCanBeDamaged : 1;                       // 0x000A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_bIgnoreModifierVolumes : 1;              // 0x000A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_bControlPhysicsState : 1;                // 0x000A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bInstancesCastShadows;                             // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MaxActorDistance;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAutoDistanceCulling;                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bControlPhysicsState;                              // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MaxInstanceDistance;                               // 0x0020(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<double>                                MaxInstanceDistances;                              // 0x0028(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 LODDistanceScales;                                 // 0x0038(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  AffectDistanceFieldLighting;                       // 0x0048(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	double                                        DetailedRepresentationLODDistance;                 // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ForceLowRepresentationLODDistance;                 // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldPositionOffsetDisableDistance;                // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEjectOnActorMoved;                                // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActorEjectionMovementThreshold;                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeBuiltUpon;                                   // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEverAffectNavigation;                          // 0x0075(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideWorldPartitionGrid;                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleEntityCount;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeDamaged;                                     // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreModifierVolumes;                            // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AppliedSettingsOverrides;                          // 0x0090(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoInstancedActorSettings) == 0x000008, "Wrong alignment on FJunoInstancedActorSettings");
static_assert(sizeof(FJunoInstancedActorSettings) == 0x0000A0, "Wrong size on FJunoInstancedActorSettings");
static_assert(offsetof(FJunoInstancedActorSettings, bInstancesCastShadows) == 0x00000B, "Member 'FJunoInstancedActorSettings::bInstancesCastShadows' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, MaxActorDistance) == 0x000010, "Member 'FJunoInstancedActorSettings::MaxActorDistance' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, bDisableAutoDistanceCulling) == 0x000018, "Member 'FJunoInstancedActorSettings::bDisableAutoDistanceCulling' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, bControlPhysicsState) == 0x000019, "Member 'FJunoInstancedActorSettings::bControlPhysicsState' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, MaxInstanceDistance) == 0x000020, "Member 'FJunoInstancedActorSettings::MaxInstanceDistance' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, MaxInstanceDistances) == 0x000028, "Member 'FJunoInstancedActorSettings::MaxInstanceDistances' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, LODDistanceScales) == 0x000038, "Member 'FJunoInstancedActorSettings::LODDistanceScales' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, AffectDistanceFieldLighting) == 0x000048, "Member 'FJunoInstancedActorSettings::AffectDistanceFieldLighting' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, DetailedRepresentationLODDistance) == 0x000058, "Member 'FJunoInstancedActorSettings::DetailedRepresentationLODDistance' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, ForceLowRepresentationLODDistance) == 0x000060, "Member 'FJunoInstancedActorSettings::ForceLowRepresentationLODDistance' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, WorldPositionOffsetDisableDistance) == 0x000068, "Member 'FJunoInstancedActorSettings::WorldPositionOffsetDisableDistance' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, bEjectOnActorMoved) == 0x00006C, "Member 'FJunoInstancedActorSettings::bEjectOnActorMoved' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, ActorEjectionMovementThreshold) == 0x000070, "Member 'FJunoInstancedActorSettings::ActorEjectionMovementThreshold' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, bCanBeBuiltUpon) == 0x000074, "Member 'FJunoInstancedActorSettings::bCanBeBuiltUpon' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, bCanEverAffectNavigation) == 0x000075, "Member 'FJunoInstancedActorSettings::bCanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, OverrideWorldPartitionGrid) == 0x000078, "Member 'FJunoInstancedActorSettings::OverrideWorldPartitionGrid' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, ScaleEntityCount) == 0x00007C, "Member 'FJunoInstancedActorSettings::ScaleEntityCount' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, ActorClass) == 0x000080, "Member 'FJunoInstancedActorSettings::ActorClass' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, bCanBeDamaged) == 0x000088, "Member 'FJunoInstancedActorSettings::bCanBeDamaged' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, bIgnoreModifierVolumes) == 0x000089, "Member 'FJunoInstancedActorSettings::bIgnoreModifierVolumes' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorSettings, AppliedSettingsOverrides) == 0x000090, "Member 'FJunoInstancedActorSettings::AppliedSettingsOverrides' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorClassSettings
// 0x00B0 (0x00B8 - 0x0008)
struct FJunoInstancedActorClassSettings final : public FTableRowBase
{
public:
	TArray<class FName>                           BaseSettings;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FJunoInstancedActorSettings            OverrideSettings;                                  // 0x0018(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoInstancedActorClassSettings) == 0x000008, "Wrong alignment on FJunoInstancedActorClassSettings");
static_assert(sizeof(FJunoInstancedActorClassSettings) == 0x0000B8, "Wrong size on FJunoInstancedActorClassSettings");
static_assert(offsetof(FJunoInstancedActorClassSettings, BaseSettings) == 0x000008, "Member 'FJunoInstancedActorClassSettings::BaseSettings' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorClassSettings, OverrideSettings) == 0x000018, "Member 'FJunoInstancedActorClassSettings::OverrideSettings' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorTagSet
// 0x0028 (0x0028 - 0x0000)
struct FJunoInstancedActorTagSet final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, EditConst, NativeAccessSpecifierPrivate)
	uint32                                        Hash;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoInstancedActorTagSet) == 0x000008, "Wrong alignment on FJunoInstancedActorTagSet");
static_assert(sizeof(FJunoInstancedActorTagSet) == 0x000028, "Wrong size on FJunoInstancedActorTagSet");
static_assert(offsetof(FJunoInstancedActorTagSet, Tags) == 0x000000, "Member 'FJunoInstancedActorTagSet::Tags' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorTagSet, Hash) == 0x000020, "Member 'FJunoInstancedActorTagSet::Hash' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorVisualizationDesc
// 0x0010 (0x0010 - 0x0000)
struct FJunoInstancedActorVisualizationDesc final
{
public:
	TArray<struct FISMComponentDescriptor>        ISMComponentDescriptors;                           // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoInstancedActorVisualizationDesc) == 0x000008, "Wrong alignment on FJunoInstancedActorVisualizationDesc");
static_assert(sizeof(FJunoInstancedActorVisualizationDesc) == 0x000010, "Wrong size on FJunoInstancedActorVisualizationDesc");
static_assert(offsetof(FJunoInstancedActorVisualizationDesc, ISMComponentDescriptors) == 0x000000, "Member 'FJunoInstancedActorVisualizationDesc::ISMComponentDescriptors' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorSoftVisualizationDesc
// 0x0010 (0x0010 - 0x0000)
struct FJunoInstancedActorSoftVisualizationDesc final
{
public:
	TArray<struct FSoftISMComponentDescriptor>    ISMComponentDescriptors;                           // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoInstancedActorSoftVisualizationDesc) == 0x000008, "Wrong alignment on FJunoInstancedActorSoftVisualizationDesc");
static_assert(sizeof(FJunoInstancedActorSoftVisualizationDesc) == 0x000010, "Wrong size on FJunoInstancedActorSoftVisualizationDesc");
static_assert(offsetof(FJunoInstancedActorSoftVisualizationDesc, ISMComponentDescriptors) == 0x000000, "Member 'FJunoInstancedActorSoftVisualizationDesc::ISMComponentDescriptors' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorVisualizationInfo
// 0x0050 (0x0050 - 0x0000)
struct FJunoInstancedActorVisualizationInfo final
{
public:
	struct FJunoInstancedActorVisualizationDesc   VisualizationDesc;                                 // 0x0000(0x0010)(Edit, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInstancedStaticMeshComponent*>  ISMComponents;                                     // 0x0010(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FStaticMeshInstanceVisualizationDescHandle MassStaticMeshDescHandle;                          // 0x0020(0x0002)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2E];                                      // 0x0022(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoInstancedActorVisualizationInfo) == 0x000008, "Wrong alignment on FJunoInstancedActorVisualizationInfo");
static_assert(sizeof(FJunoInstancedActorVisualizationInfo) == 0x000050, "Wrong size on FJunoInstancedActorVisualizationInfo");
static_assert(offsetof(FJunoInstancedActorVisualizationInfo, VisualizationDesc) == 0x000000, "Member 'FJunoInstancedActorVisualizationInfo::VisualizationDesc' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorVisualizationInfo, ISMComponents) == 0x000010, "Member 'FJunoInstancedActorVisualizationInfo::ISMComponents' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorVisualizationInfo, MassStaticMeshDescHandle) == 0x000020, "Member 'FJunoInstancedActorVisualizationInfo::MassStaticMeshDescHandle' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.InstancedActorDataSharedFragment
// 0x000C (0x000C - 0x0000)
struct FInstancedActorDataSharedFragment final : public FMassSharedFragment
{
public:
	TWeakObjectPtr<class UJunoInstancedActorData> InstanceData;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInstancedActorDataSharedFragment) == 0x000004, "Wrong alignment on FInstancedActorDataSharedFragment");
static_assert(sizeof(FInstancedActorDataSharedFragment) == 0x00000C, "Wrong size on FInstancedActorDataSharedFragment");
static_assert(offsetof(FInstancedActorDataSharedFragment, InstanceData) == 0x000000, "Member 'FInstancedActorDataSharedFragment::InstanceData' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorMeshSwitchFragment
// 0x0002 (0x0002 - 0x0000)
struct FJunoInstancedActorMeshSwitchFragment final : public FMassFragment
{
public:
	struct FStaticMeshInstanceVisualizationDescHandle NewStaticMeshDescHandle;                           // 0x0000(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoInstancedActorMeshSwitchFragment) == 0x000002, "Wrong alignment on FJunoInstancedActorMeshSwitchFragment");
static_assert(sizeof(FJunoInstancedActorMeshSwitchFragment) == 0x000002, "Wrong size on FJunoInstancedActorMeshSwitchFragment");
static_assert(offsetof(FJunoInstancedActorMeshSwitchFragment, NewStaticMeshDescHandle) == 0x000000, "Member 'FJunoInstancedActorMeshSwitchFragment::NewStaticMeshDescHandle' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorFragment
// 0x000C (0x000C - 0x0000)
struct FJunoInstancedActorFragment final : public FMassFragment
{
public:
	TWeakObjectPtr<class UJunoInstancedActorData> InstanceData;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJunoActorInstanceIndex                InstanceIndex;                                     // 0x0008(0x0002)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoInstancedActorFragment) == 0x000004, "Wrong alignment on FJunoInstancedActorFragment");
static_assert(sizeof(FJunoInstancedActorFragment) == 0x00000C, "Wrong size on FJunoInstancedActorFragment");
static_assert(offsetof(FJunoInstancedActorFragment, InstanceData) == 0x000000, "Member 'FJunoInstancedActorFragment::InstanceData' has a wrong offset!");
static_assert(offsetof(FJunoInstancedActorFragment, InstanceIndex) == 0x000008, "Member 'FJunoInstancedActorFragment::InstanceIndex' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorManagerHandle
// 0x0004 (0x0004 - 0x0000)
struct FJunoInstancedActorManagerHandle final
{
public:
	int32                                         ManagerID;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FJunoInstancedActorManagerHandle) == 0x000004, "Wrong alignment on FJunoInstancedActorManagerHandle");
static_assert(sizeof(FJunoInstancedActorManagerHandle) == 0x000004, "Wrong size on FJunoInstancedActorManagerHandle");
static_assert(offsetof(FJunoInstancedActorManagerHandle, ManagerID) == 0x000000, "Member 'FJunoInstancedActorManagerHandle::ManagerID' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoInstancedActorModifierVolumeHandle
// 0x0004 (0x0004 - 0x0000)
struct FJunoInstancedActorModifierVolumeHandle final
{
public:
	int32                                         ModifierVolumeID;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FJunoInstancedActorModifierVolumeHandle) == 0x000004, "Wrong alignment on FJunoInstancedActorModifierVolumeHandle");
static_assert(sizeof(FJunoInstancedActorModifierVolumeHandle) == 0x000004, "Wrong size on FJunoInstancedActorModifierVolumeHandle");
static_assert(offsetof(FJunoInstancedActorModifierVolumeHandle, ModifierVolumeID) == 0x000000, "Member 'FJunoInstancedActorModifierVolumeHandle::ModifierVolumeID' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoLifecyclePhase
// 0x00B0 (0x00B0 - 0x0000)
struct FJunoLifecyclePhase final
{
public:
	struct FScalableFloat                         duration;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bOverrideMesh;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x0030(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMaterials;                                // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bOverrideCollisionEnabled;                         // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             CollisionEnabled;                                  // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHealth;                                   // 0x006A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         Health;                                            // 0x0070(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGameplayTag                           tag;                                               // 0x0098(0x0004)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInstancedStruct                       CustomData;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoLifecyclePhase) == 0x000008, "Wrong alignment on FJunoLifecyclePhase");
static_assert(sizeof(FJunoLifecyclePhase) == 0x0000B0, "Wrong size on FJunoLifecyclePhase");
static_assert(offsetof(FJunoLifecyclePhase, duration) == 0x000000, "Member 'FJunoLifecyclePhase::duration' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, bOverrideMesh) == 0x000028, "Member 'FJunoLifecyclePhase::bOverrideMesh' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, Mesh) == 0x000030, "Member 'FJunoLifecyclePhase::Mesh' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, bOverrideMaterials) == 0x000050, "Member 'FJunoLifecyclePhase::bOverrideMaterials' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, Materials) == 0x000058, "Member 'FJunoLifecyclePhase::Materials' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, bOverrideCollisionEnabled) == 0x000068, "Member 'FJunoLifecyclePhase::bOverrideCollisionEnabled' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, CollisionEnabled) == 0x000069, "Member 'FJunoLifecyclePhase::CollisionEnabled' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, bOverrideHealth) == 0x00006A, "Member 'FJunoLifecyclePhase::bOverrideHealth' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, Health) == 0x000070, "Member 'FJunoLifecyclePhase::Health' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, tag) == 0x000098, "Member 'FJunoLifecyclePhase::tag' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhase, CustomData) == 0x0000A0, "Member 'FJunoLifecyclePhase::CustomData' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoLifecyclePhaseFragment
// 0x0002 (0x0002 - 0x0000)
struct FJunoLifecyclePhaseFragment final : public FMassFragment
{
public:
	uint8                                         PrevPhaseIndex;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentPhaseIndex;                                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoLifecyclePhaseFragment) == 0x000001, "Wrong alignment on FJunoLifecyclePhaseFragment");
static_assert(sizeof(FJunoLifecyclePhaseFragment) == 0x000002, "Wrong size on FJunoLifecyclePhaseFragment");
static_assert(offsetof(FJunoLifecyclePhaseFragment, PrevPhaseIndex) == 0x000000, "Member 'FJunoLifecyclePhaseFragment::PrevPhaseIndex' has a wrong offset!");
static_assert(offsetof(FJunoLifecyclePhaseFragment, CurrentPhaseIndex) == 0x000001, "Member 'FJunoLifecyclePhaseFragment::CurrentPhaseIndex' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoLifecyclePhaseTimeFragment
// 0x0004 (0x0004 - 0x0000)
struct FJunoLifecyclePhaseTimeFragment final : public FMassFragment
{
public:
	float                                         CurrentPhaseTimeElapsed;                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoLifecyclePhaseTimeFragment) == 0x000004, "Wrong alignment on FJunoLifecyclePhaseTimeFragment");
static_assert(sizeof(FJunoLifecyclePhaseTimeFragment) == 0x000004, "Wrong size on FJunoLifecyclePhaseTimeFragment");
static_assert(offsetof(FJunoLifecyclePhaseTimeFragment, CurrentPhaseTimeElapsed) == 0x000000, "Member 'FJunoLifecyclePhaseTimeFragment::CurrentPhaseTimeElapsed' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoLifecycleParameters
// 0x0018 (0x0018 - 0x0000)
struct FJunoLifecycleParameters final : public FMassSharedFragment
{
public:
	TArray<struct FJunoLifecyclePhase>            LifecyclePhases;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x1];                                       // 0x0010(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRepeatLifecyclePhases;                            // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoLifecycleParameters) == 0x000008, "Wrong alignment on FJunoLifecycleParameters");
static_assert(sizeof(FJunoLifecycleParameters) == 0x000018, "Wrong size on FJunoLifecycleParameters");
static_assert(offsetof(FJunoLifecycleParameters, LifecyclePhases) == 0x000000, "Member 'FJunoLifecycleParameters::LifecyclePhases' has a wrong offset!");
static_assert(offsetof(FJunoLifecycleParameters, bRepeatLifecyclePhases) == 0x000011, "Member 'FJunoLifecycleParameters::bRepeatLifecyclePhases' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoLifecycleVisualizationsSharedFragment
// 0x0010 (0x0010 - 0x0000)
struct FJunoLifecycleVisualizationsSharedFragment final : public FMassSharedFragment
{
public:
	TArray<uint8>                                 LifecyclePhaseVisualizations;                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoLifecycleVisualizationsSharedFragment) == 0x000008, "Wrong alignment on FJunoLifecycleVisualizationsSharedFragment");
static_assert(sizeof(FJunoLifecycleVisualizationsSharedFragment) == 0x000010, "Wrong size on FJunoLifecycleVisualizationsSharedFragment");
static_assert(offsetof(FJunoLifecycleVisualizationsSharedFragment, LifecyclePhaseVisualizations) == 0x000000, "Member 'FJunoLifecycleVisualizationsSharedFragment::LifecyclePhaseVisualizations' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPCGVolumePointDataFeatures
// 0x000C (0x000C - 0x0000)
struct FJunoPCGVolumePointDataFeatures final
{
public:
	bool                                          bRotationX;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotationY;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotationZ;                                        // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnActorPathAttribute;                          // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnActorPathAttributeName;                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnActorRepresentationAttributeName;             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoPCGVolumePointDataFeatures) == 0x000004, "Wrong alignment on FJunoPCGVolumePointDataFeatures");
static_assert(sizeof(FJunoPCGVolumePointDataFeatures) == 0x00000C, "Wrong size on FJunoPCGVolumePointDataFeatures");
static_assert(offsetof(FJunoPCGVolumePointDataFeatures, bRotationX) == 0x000000, "Member 'FJunoPCGVolumePointDataFeatures::bRotationX' has a wrong offset!");
static_assert(offsetof(FJunoPCGVolumePointDataFeatures, bRotationY) == 0x000001, "Member 'FJunoPCGVolumePointDataFeatures::bRotationY' has a wrong offset!");
static_assert(offsetof(FJunoPCGVolumePointDataFeatures, bRotationZ) == 0x000002, "Member 'FJunoPCGVolumePointDataFeatures::bRotationZ' has a wrong offset!");
static_assert(offsetof(FJunoPCGVolumePointDataFeatures, bSpawnActorPathAttribute) == 0x000003, "Member 'FJunoPCGVolumePointDataFeatures::bSpawnActorPathAttribute' has a wrong offset!");
static_assert(offsetof(FJunoPCGVolumePointDataFeatures, SpawnActorPathAttributeName) == 0x000004, "Member 'FJunoPCGVolumePointDataFeatures::SpawnActorPathAttributeName' has a wrong offset!");
static_assert(offsetof(FJunoPCGVolumePointDataFeatures, SpawnActorRepresentationAttributeName) == 0x000008, "Member 'FJunoPCGVolumePointDataFeatures::SpawnActorRepresentationAttributeName' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCompressedPoint
// 0x000C (0x000C - 0x0000)
struct FJunoCompressedPoint final
{
public:
	uint16                                        X;                                                 // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Y;                                                 // 0x0002(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Z;                                                 // 0x0004(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotationX;                                         // 0x0006(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotationY;                                         // 0x0007(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotationZ;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x1];                                        // 0x0009(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        ActorSpawnInfoIndex;                               // 0x000A(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCompressedPoint) == 0x000002, "Wrong alignment on FJunoCompressedPoint");
static_assert(sizeof(FJunoCompressedPoint) == 0x00000C, "Wrong size on FJunoCompressedPoint");
static_assert(offsetof(FJunoCompressedPoint, X) == 0x000000, "Member 'FJunoCompressedPoint::X' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPoint, Y) == 0x000002, "Member 'FJunoCompressedPoint::Y' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPoint, Z) == 0x000004, "Member 'FJunoCompressedPoint::Z' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPoint, RotationX) == 0x000006, "Member 'FJunoCompressedPoint::RotationX' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPoint, RotationY) == 0x000007, "Member 'FJunoCompressedPoint::RotationY' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPoint, RotationZ) == 0x000008, "Member 'FJunoCompressedPoint::RotationZ' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPoint, ActorSpawnInfoIndex) == 0x00000A, "Member 'FJunoCompressedPoint::ActorSpawnInfoIndex' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCompressedActorSpawnInfo
// 0x0018 (0x0018 - 0x0000)
struct FJunoCompressedActorSpawnInfo final
{
public:
	class FString                                 ActorToSpawn;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoRepresentation                           Representation;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoCompressedActorSpawnInfo) == 0x000008, "Wrong alignment on FJunoCompressedActorSpawnInfo");
static_assert(sizeof(FJunoCompressedActorSpawnInfo) == 0x000018, "Wrong size on FJunoCompressedActorSpawnInfo");
static_assert(offsetof(FJunoCompressedActorSpawnInfo, ActorToSpawn) == 0x000000, "Member 'FJunoCompressedActorSpawnInfo::ActorToSpawn' has a wrong offset!");
static_assert(offsetof(FJunoCompressedActorSpawnInfo, Representation) == 0x000010, "Member 'FJunoCompressedActorSpawnInfo::Representation' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCompressedPointList
// 0x0080 (0x0080 - 0x0000)
struct FJunoCompressedPointList final
{
public:
	struct FVector                                BoundsMin;                                         // 0x0000(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundsMax;                                         // 0x0018(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              RotationMin;                                       // 0x0030(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              RotationMax;                                       // 0x003C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJunoCompressedPoint>           Points;                                            // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint16                                        HighResPosCount;                                   // 0x0058(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Seed;                                              // 0x005C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJunoCompressedActorSpawnInfo>  ActorSpawnInfo;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FJunoPCGVolumePointDataFeatures        Features;                                          // 0x0070(0x000C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoCompressedPointList) == 0x000008, "Wrong alignment on FJunoCompressedPointList");
static_assert(sizeof(FJunoCompressedPointList) == 0x000080, "Wrong size on FJunoCompressedPointList");
static_assert(offsetof(FJunoCompressedPointList, BoundsMin) == 0x000000, "Member 'FJunoCompressedPointList::BoundsMin' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPointList, BoundsMax) == 0x000018, "Member 'FJunoCompressedPointList::BoundsMax' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPointList, RotationMin) == 0x000030, "Member 'FJunoCompressedPointList::RotationMin' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPointList, RotationMax) == 0x00003C, "Member 'FJunoCompressedPointList::RotationMax' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPointList, Points) == 0x000048, "Member 'FJunoCompressedPointList::Points' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPointList, HighResPosCount) == 0x000058, "Member 'FJunoCompressedPointList::HighResPosCount' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPointList, Seed) == 0x00005C, "Member 'FJunoCompressedPointList::Seed' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPointList, ActorSpawnInfo) == 0x000060, "Member 'FJunoCompressedPointList::ActorSpawnInfo' has a wrong offset!");
static_assert(offsetof(FJunoCompressedPointList, Features) == 0x000070, "Member 'FJunoCompressedPointList::Features' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPOISelectorTeleporterClass
// 0x0010 (0x0010 - 0x0000)
struct FJunoPOISelectorTeleporterClass final
{
public:
	EJunoBiome                                    Biome;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AJunoTeleporter>            Teleporter;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoPOISelectorTeleporterClass) == 0x000008, "Wrong alignment on FJunoPOISelectorTeleporterClass");
static_assert(sizeof(FJunoPOISelectorTeleporterClass) == 0x000010, "Wrong size on FJunoPOISelectorTeleporterClass");
static_assert(offsetof(FJunoPOISelectorTeleporterClass, Biome) == 0x000000, "Member 'FJunoPOISelectorTeleporterClass::Biome' has a wrong offset!");
static_assert(offsetof(FJunoPOISelectorTeleporterClass, Teleporter) == 0x000008, "Member 'FJunoPOISelectorTeleporterClass::Teleporter' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPOISelectorParams
// 0x0030 (0x0030 - 0x0000)
struct FJunoPOISelectorParams final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoPOISize                                  Size;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoBiome                                    Biome;                                             // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SlotTags;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 PoiManager;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoPOISelectorParams) == 0x000008, "Wrong alignment on FJunoPOISelectorParams");
static_assert(sizeof(FJunoPOISelectorParams) == 0x000030, "Wrong size on FJunoPOISelectorParams");
static_assert(offsetof(FJunoPOISelectorParams, Guid) == 0x000000, "Member 'FJunoPOISelectorParams::Guid' has a wrong offset!");
static_assert(offsetof(FJunoPOISelectorParams, Size) == 0x000010, "Member 'FJunoPOISelectorParams::Size' has a wrong offset!");
static_assert(offsetof(FJunoPOISelectorParams, Biome) == 0x000011, "Member 'FJunoPOISelectorParams::Biome' has a wrong offset!");
static_assert(offsetof(FJunoPOISelectorParams, SlotTags) == 0x000018, "Member 'FJunoPOISelectorParams::SlotTags' has a wrong offset!");
static_assert(offsetof(FJunoPOISelectorParams, PoiManager) == 0x000028, "Member 'FJunoPOISelectorParams::PoiManager' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoWorldTilePOI
// 0x01B8 (0x01C0 - 0x0008)
struct FPCGJunoWorldTilePOI final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UWorld>                  WorldAsset;                                        // 0x0008(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  HLODWorldAsset;                                    // 0x0028(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoPOISize                                  Size;                                              // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EJunoPOISize>                            SlotSizes;                                         // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                BoundsSize;                                        // 0x00A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EJunoBiome>                              Biomes;                                            // 0x00B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FName>                             Tags;                                              // 0x0108(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EJunoWorldTilePOIType                         Type;                                              // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaximumCountPerWorld;                              // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EncounterCapabilities;                             // 0x0160(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         EncounterVariantCount;                             // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              EncounterCategoryTable;                            // 0x0188(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     TeleporterOffsets;                                 // 0x01A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PersistenceVersion;                                // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGJunoWorldTilePOI) == 0x000008, "Wrong alignment on FPCGJunoWorldTilePOI");
static_assert(sizeof(FPCGJunoWorldTilePOI) == 0x0001C0, "Wrong size on FPCGJunoWorldTilePOI");
static_assert(offsetof(FPCGJunoWorldTilePOI, WorldAsset) == 0x000008, "Member 'FPCGJunoWorldTilePOI::WorldAsset' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, HLODWorldAsset) == 0x000028, "Member 'FPCGJunoWorldTilePOI::HLODWorldAsset' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, bEnabled) == 0x000048, "Member 'FPCGJunoWorldTilePOI::bEnabled' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, Size) == 0x000049, "Member 'FPCGJunoWorldTilePOI::Size' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, SlotSizes) == 0x000050, "Member 'FPCGJunoWorldTilePOI::SlotSizes' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, BoundsSize) == 0x0000A0, "Member 'FPCGJunoWorldTilePOI::BoundsSize' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, Biomes) == 0x0000B8, "Member 'FPCGJunoWorldTilePOI::Biomes' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, Tags) == 0x000108, "Member 'FPCGJunoWorldTilePOI::Tags' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, Type) == 0x000158, "Member 'FPCGJunoWorldTilePOI::Type' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, MaximumCountPerWorld) == 0x00015C, "Member 'FPCGJunoWorldTilePOI::MaximumCountPerWorld' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, EncounterCapabilities) == 0x000160, "Member 'FPCGJunoWorldTilePOI::EncounterCapabilities' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, EncounterVariantCount) == 0x000180, "Member 'FPCGJunoWorldTilePOI::EncounterVariantCount' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, EncounterCategoryTable) == 0x000188, "Member 'FPCGJunoWorldTilePOI::EncounterCategoryTable' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, TeleporterOffsets) == 0x0001A8, "Member 'FPCGJunoWorldTilePOI::TeleporterOffsets' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOI, PersistenceVersion) == 0x0001B8, "Member 'FPCGJunoWorldTilePOI::PersistenceVersion' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPOIRegistryItem
// 0x01C8 (0x01C8 - 0x0000)
struct FJunoPOIRegistryItem final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPCGJunoWorldTilePOI                   Value;                                             // 0x0008(0x01C0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoPOIRegistryItem) == 0x000008, "Wrong alignment on FJunoPOIRegistryItem");
static_assert(sizeof(FJunoPOIRegistryItem) == 0x0001C8, "Wrong size on FJunoPOIRegistryItem");
static_assert(offsetof(FJunoPOIRegistryItem, Key) == 0x000000, "Member 'FJunoPOIRegistryItem::Key' has a wrong offset!");
static_assert(offsetof(FJunoPOIRegistryItem, Value) == 0x000008, "Member 'FJunoPOIRegistryItem::Value' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCreateLevelWorldPartitionGrid
// 0x0038 (0x0038 - 0x0000)
struct FJunoCreateLevelWorldPartitionGrid final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellSize;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingRange;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockOnSlowStreaming;                             // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Origin;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DebugColor;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoCreateLevelWorldPartitionGrid) == 0x000008, "Wrong alignment on FJunoCreateLevelWorldPartitionGrid");
static_assert(sizeof(FJunoCreateLevelWorldPartitionGrid) == 0x000038, "Wrong size on FJunoCreateLevelWorldPartitionGrid");
static_assert(offsetof(FJunoCreateLevelWorldPartitionGrid, Name) == 0x000000, "Member 'FJunoCreateLevelWorldPartitionGrid::Name' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelWorldPartitionGrid, CellSize) == 0x000004, "Member 'FJunoCreateLevelWorldPartitionGrid::CellSize' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelWorldPartitionGrid, LoadingRange) == 0x000008, "Member 'FJunoCreateLevelWorldPartitionGrid::LoadingRange' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelWorldPartitionGrid, bBlockOnSlowStreaming) == 0x00000C, "Member 'FJunoCreateLevelWorldPartitionGrid::bBlockOnSlowStreaming' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelWorldPartitionGrid, Origin) == 0x000010, "Member 'FJunoCreateLevelWorldPartitionGrid::Origin' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelWorldPartitionGrid, DebugColor) == 0x000020, "Member 'FJunoCreateLevelWorldPartitionGrid::DebugColor' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelWorldPartitionGrid, Priority) == 0x000030, "Member 'FJunoCreateLevelWorldPartitionGrid::Priority' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCreateLevelParams
// 0x0040 (0x0040 - 0x0000)
struct FJunoCreateLevelParams final
{
public:
	class FString                                 LevelPackageName;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJunoCreateLevelWorldPartitionGrid> WorldPartitionGrids;                               // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UHLODLayer*                             WorldPartitionDefaultHLODLayer;                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldPartitionServerStreamingMode            WorldPartitionServerStreamingMode;                 // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldPartitionServerStreamingOutMode         WorldPartitionServerStreamingOutMode;              // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoCreateLevelParams) == 0x000008, "Wrong alignment on FJunoCreateLevelParams");
static_assert(sizeof(FJunoCreateLevelParams) == 0x000040, "Wrong size on FJunoCreateLevelParams");
static_assert(offsetof(FJunoCreateLevelParams, LevelPackageName) == 0x000000, "Member 'FJunoCreateLevelParams::LevelPackageName' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelParams, Actors) == 0x000010, "Member 'FJunoCreateLevelParams::Actors' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelParams, WorldPartitionGrids) == 0x000020, "Member 'FJunoCreateLevelParams::WorldPartitionGrids' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelParams, WorldPartitionDefaultHLODLayer) == 0x000030, "Member 'FJunoCreateLevelParams::WorldPartitionDefaultHLODLayer' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelParams, WorldPartitionServerStreamingMode) == 0x000038, "Member 'FJunoCreateLevelParams::WorldPartitionServerStreamingMode' has a wrong offset!");
static_assert(offsetof(FJunoCreateLevelParams, WorldPartitionServerStreamingOutMode) == 0x000039, "Member 'FJunoCreateLevelParams::WorldPartitionServerStreamingOutMode' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoTerrainGenerationConfiguration
// 0x0058 (0x0058 - 0x0000)
struct FJunoTerrainGenerationConfiguration final
{
public:
	float                                         GenerateStart;                                     // 0x0000(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GenerateRemove;                                    // 0x0004(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        GenerationFlushDistance;                           // 0x0028(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoTerrainGenerationConfiguration) == 0x000008, "Wrong alignment on FJunoTerrainGenerationConfiguration");
static_assert(sizeof(FJunoTerrainGenerationConfiguration) == 0x000058, "Wrong size on FJunoTerrainGenerationConfiguration");
static_assert(offsetof(FJunoTerrainGenerationConfiguration, GenerateStart) == 0x000000, "Member 'FJunoTerrainGenerationConfiguration::GenerateStart' has a wrong offset!");
static_assert(offsetof(FJunoTerrainGenerationConfiguration, GenerateRemove) == 0x000004, "Member 'FJunoTerrainGenerationConfiguration::GenerateRemove' has a wrong offset!");
static_assert(offsetof(FJunoTerrainGenerationConfiguration, GenerationFlushDistance) == 0x000028, "Member 'FJunoTerrainGenerationConfiguration::GenerationFlushDistance' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoReservedAreaPersistentData
// 0x0050 (0x0050 - 0x0000)
struct FJunoReservedAreaPersistentData final
{
public:
	TMap<class FName, struct FBox2D>              Tiles;                                             // 0x0000(0x0050)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoReservedAreaPersistentData) == 0x000008, "Wrong alignment on FJunoReservedAreaPersistentData");
static_assert(sizeof(FJunoReservedAreaPersistentData) == 0x000050, "Wrong size on FJunoReservedAreaPersistentData");
static_assert(offsetof(FJunoReservedAreaPersistentData, Tiles) == 0x000000, "Member 'FJunoReservedAreaPersistentData::Tiles' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPOICellDistributionPersistentData
// 0x0050 (0x0050 - 0x0000)
struct FJunoPOICellDistributionPersistentData final
{
public:
	TMap<class FName, int32>                      POICount;                                          // 0x0000(0x0050)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoPOICellDistributionPersistentData) == 0x000008, "Wrong alignment on FJunoPOICellDistributionPersistentData");
static_assert(sizeof(FJunoPOICellDistributionPersistentData) == 0x000050, "Wrong size on FJunoPOICellDistributionPersistentData");
static_assert(offsetof(FJunoPOICellDistributionPersistentData, POICount) == 0x000000, "Member 'FJunoPOICellDistributionPersistentData::POICount' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo final
{
public:
	TMap<class FName, struct FPersistenceFrameworkLevelSaveSpawnablePtr> Tiles;                                             // 0x0000(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FJunoReservedAreaPersistentData> ReservedAreas;                                     // 0x0050(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FJunoPOICellDistributionPersistentData> PerCellRarePOICounts;                              // 0x00A0(0x0050)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo) == 0x000008, "Wrong alignment on FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo");
static_assert(sizeof(FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo) == 0x0000F0, "Wrong size on FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo");
static_assert(offsetof(FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo, Tiles) == 0x000000, "Member 'FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo::Tiles' has a wrong offset!");
static_assert(offsetof(FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo, ReservedAreas) == 0x000050, "Member 'FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo::ReservedAreas' has a wrong offset!");
static_assert(offsetof(FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo, PerCellRarePOICounts) == 0x0000A0, "Member 'FJunoTileGridPersistenceFeatureData_InGameClass_PersistentInfo::PerCellRarePOICounts' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoTileGridPersistentData
// 0x0050 (0x0050 - 0x0000)
struct FJunoTileGridPersistentData final
{
public:
	TMap<class FName, class AJunoWorldTile*>      Tiles;                                             // 0x0000(0x0050)(SaveGame, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoTileGridPersistentData) == 0x000008, "Wrong alignment on FJunoTileGridPersistentData");
static_assert(sizeof(FJunoTileGridPersistentData) == 0x000050, "Wrong size on FJunoTileGridPersistentData");
static_assert(offsetof(FJunoTileGridPersistentData, Tiles) == 0x000000, "Member 'FJunoTileGridPersistentData::Tiles' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoTileGridSaveData
// 0x00F0 (0x00F0 - 0x0000)
struct FJunoTileGridSaveData final
{
public:
	struct FJunoTileGridPersistentData            Data;                                              // 0x0000(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FJunoReservedAreaPersistentData> ReservedAreas;                                     // 0x0050(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FJunoPOICellDistributionPersistentData> PerCellRarePOICounts;                              // 0x00A0(0x0050)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoTileGridSaveData) == 0x000008, "Wrong alignment on FJunoTileGridSaveData");
static_assert(sizeof(FJunoTileGridSaveData) == 0x0000F0, "Wrong size on FJunoTileGridSaveData");
static_assert(offsetof(FJunoTileGridSaveData, Data) == 0x000000, "Member 'FJunoTileGridSaveData::Data' has a wrong offset!");
static_assert(offsetof(FJunoTileGridSaveData, ReservedAreas) == 0x000050, "Member 'FJunoTileGridSaveData::ReservedAreas' has a wrong offset!");
static_assert(offsetof(FJunoTileGridSaveData, PerCellRarePOICounts) == 0x0000A0, "Member 'FJunoTileGridSaveData::PerCellRarePOICounts' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoTileSelector
// 0x0030 (0x0038 - 0x0008)
struct FJunoTileSelector final : public FTableRowBase
{
public:
	int64                                         Priority;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TileSize;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WorldSize;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             WorldOriginTileOffset;                             // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UJunoWorldTileSelectionBase> TileSelector;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoTileSelector) == 0x000008, "Wrong alignment on FJunoTileSelector");
static_assert(sizeof(FJunoTileSelector) == 0x000038, "Wrong size on FJunoTileSelector");
static_assert(offsetof(FJunoTileSelector, Priority) == 0x000008, "Member 'FJunoTileSelector::Priority' has a wrong offset!");
static_assert(offsetof(FJunoTileSelector, TileSize) == 0x000010, "Member 'FJunoTileSelector::TileSize' has a wrong offset!");
static_assert(offsetof(FJunoTileSelector, WorldSize) == 0x000018, "Member 'FJunoTileSelector::WorldSize' has a wrong offset!");
static_assert(offsetof(FJunoTileSelector, WorldOriginTileOffset) == 0x000020, "Member 'FJunoTileSelector::WorldOriginTileOffset' has a wrong offset!");
static_assert(offsetof(FJunoTileSelector, TileSelector) == 0x000030, "Member 'FJunoTileSelector::TileSelector' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldTileStreamingLevel
// 0x00A8 (0x00A8 - 0x0000)
struct FJunoWorldTileStreamingLevel final
{
public:
	TSoftObjectPtr<class UWorld>                  WorldAsset;                                        // 0x0000(0x0020)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  HLODWorldAsset;                                    // 0x0020(0x0020)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0040(0x0018)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              BoundsOffset;                                      // 0x0058(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              BoundsExtent;                                      // 0x0064(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0070(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  PlayspaceGuid;                                     // 0x0080(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  WorldTileGuid;                                     // 0x0090(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayspaceLevelKey;                                 // 0x00A0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoWorldTileInjectedLevelType               Type;                                              // 0x00A4(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotationBits;                                      // 0x00A5(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoWorldTileStreamingLevel) == 0x000008, "Wrong alignment on FJunoWorldTileStreamingLevel");
static_assert(sizeof(FJunoWorldTileStreamingLevel) == 0x0000A8, "Wrong size on FJunoWorldTileStreamingLevel");
static_assert(offsetof(FJunoWorldTileStreamingLevel, WorldAsset) == 0x000000, "Member 'FJunoWorldTileStreamingLevel::WorldAsset' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, HLODWorldAsset) == 0x000020, "Member 'FJunoWorldTileStreamingLevel::HLODWorldAsset' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, Position) == 0x000040, "Member 'FJunoWorldTileStreamingLevel::Position' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, BoundsOffset) == 0x000058, "Member 'FJunoWorldTileStreamingLevel::BoundsOffset' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, BoundsExtent) == 0x000064, "Member 'FJunoWorldTileStreamingLevel::BoundsExtent' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, Guid) == 0x000070, "Member 'FJunoWorldTileStreamingLevel::Guid' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, PlayspaceGuid) == 0x000080, "Member 'FJunoWorldTileStreamingLevel::PlayspaceGuid' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, WorldTileGuid) == 0x000090, "Member 'FJunoWorldTileStreamingLevel::WorldTileGuid' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, PlayspaceLevelKey) == 0x0000A0, "Member 'FJunoWorldTileStreamingLevel::PlayspaceLevelKey' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, Type) == 0x0000A4, "Member 'FJunoWorldTileStreamingLevel::Type' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevel, RotationBits) == 0x0000A5, "Member 'FJunoWorldTileStreamingLevel::RotationBits' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldTileStreamingLevelEntry
// 0x00AC (0x00B8 - 0x000C)
struct FJunoWorldTileStreamingLevelEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoWorldTileStreamingLevel           Value;                                             // 0x0010(0x00A8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoWorldTileStreamingLevelEntry) == 0x000008, "Wrong alignment on FJunoWorldTileStreamingLevelEntry");
static_assert(sizeof(FJunoWorldTileStreamingLevelEntry) == 0x0000B8, "Wrong size on FJunoWorldTileStreamingLevelEntry");
static_assert(offsetof(FJunoWorldTileStreamingLevelEntry, Value) == 0x000010, "Member 'FJunoWorldTileStreamingLevelEntry::Value' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldTileStreamingLevelFastArray
// 0x0018 (0x0120 - 0x0108)
struct FJunoWorldTileStreamingLevelFastArray final : public FFastArraySerializer
{
public:
	TArray<struct FJunoWorldTileStreamingLevelEntry> Entries;                                           // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AJunoWorldTile*                         WorldTile;                                         // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoWorldTileStreamingLevelFastArray) == 0x000008, "Wrong alignment on FJunoWorldTileStreamingLevelFastArray");
static_assert(sizeof(FJunoWorldTileStreamingLevelFastArray) == 0x000120, "Wrong size on FJunoWorldTileStreamingLevelFastArray");
static_assert(offsetof(FJunoWorldTileStreamingLevelFastArray, Entries) == 0x000108, "Member 'FJunoWorldTileStreamingLevelFastArray::Entries' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileStreamingLevelFastArray, WorldTile) == 0x000118, "Member 'FJunoWorldTileStreamingLevelFastArray::WorldTile' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoDebugWorldTileState
// 0x0020 (0x0020 - 0x0000)
struct FJunoDebugWorldTileState final
{
public:
	class FString                                 TileName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Levels;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoDebugWorldTileState) == 0x000008, "Wrong alignment on FJunoDebugWorldTileState");
static_assert(sizeof(FJunoDebugWorldTileState) == 0x000020, "Wrong size on FJunoDebugWorldTileState");
static_assert(offsetof(FJunoDebugWorldTileState, TileName) == 0x000000, "Member 'FJunoDebugWorldTileState::TileName' has a wrong offset!");
static_assert(offsetof(FJunoDebugWorldTileState, Levels) == 0x000010, "Member 'FJunoDebugWorldTileState::Levels' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoLayerSwap
// 0x0008 (0x0008 - 0x0000)
struct FJunoLayerSwap final
{
public:
	class FName                                   SwapFrom;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwapTo;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoLayerSwap) == 0x000004, "Wrong alignment on FJunoLayerSwap");
static_assert(sizeof(FJunoLayerSwap) == 0x000008, "Wrong size on FJunoLayerSwap");
static_assert(offsetof(FJunoLayerSwap, SwapFrom) == 0x000000, "Member 'FJunoLayerSwap::SwapFrom' has a wrong offset!");
static_assert(offsetof(FJunoLayerSwap, SwapTo) == 0x000004, "Member 'FJunoLayerSwap::SwapTo' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoWorldTilePOISlot
// 0x0040 (0x0048 - 0x0008)
struct FPCGJunoWorldTilePOISlot final : public FTableRowBase
{
public:
	struct FVector                                Position;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Tags;                                              // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EJunoPOISize                                  Size;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  POISlotGuid;                                       // 0x0034(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGJunoWorldTilePOISlot) == 0x000008, "Wrong alignment on FPCGJunoWorldTilePOISlot");
static_assert(sizeof(FPCGJunoWorldTilePOISlot) == 0x000048, "Wrong size on FPCGJunoWorldTilePOISlot");
static_assert(offsetof(FPCGJunoWorldTilePOISlot, Position) == 0x000008, "Member 'FPCGJunoWorldTilePOISlot::Position' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOISlot, Tags) == 0x000020, "Member 'FPCGJunoWorldTilePOISlot::Tags' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOISlot, Size) == 0x000030, "Member 'FPCGJunoWorldTilePOISlot::Size' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTilePOISlot, POISlotGuid) == 0x000034, "Member 'FPCGJunoWorldTilePOISlot::POISlotGuid' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoCaveDataRegistryRow
// 0x0020 (0x0028 - 0x0008)
struct FPCGJunoCaveDataRegistryRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UJunoCaveDataCollectionBase> CaveDataCollection;                                // 0x0008(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoCaveDataRegistryRow) == 0x000008, "Wrong alignment on FPCGJunoCaveDataRegistryRow");
static_assert(sizeof(FPCGJunoCaveDataRegistryRow) == 0x000028, "Wrong size on FPCGJunoCaveDataRegistryRow");
static_assert(offsetof(FPCGJunoCaveDataRegistryRow, CaveDataCollection) == 0x000008, "Member 'FPCGJunoCaveDataRegistryRow::CaveDataCollection' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoWorldTile
// 0x00F0 (0x00F8 - 0x0008)
struct FPCGJunoWorldTile final : public FTableRowBase
{
public:
	EJunoTileStatus                               Status;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoTileGenerationType                       GenerationType;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugTile;                                      // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Version;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataRegistryId                        OriginRegistryId;                                  // 0x0010(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Terrain;                                           // 0x0018(0x0020)(Edit, BlueprintVisible, SaveGame, RepSkip, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MiniMapTexture;                                    // 0x0038(0x0020)(Edit, BlueprintVisible, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  StaticBiomeDecorations;                            // 0x0058(0x0020)(Edit, BlueprintVisible, SaveGame, RepSkip, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          Overlays;                                          // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          PrimaryBiomeResourceVariations;                    // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  PrimaryBiomeResource;                              // 0x0098(0x0020)(BlueprintVisible, BlueprintReadOnly, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoBiome                                    NWBiome;                                           // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoBiome                                    NEBiome;                                           // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoBiome                                    SEBiome;                                           // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoBiome                                    SWBiome;                                           // 0x00BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoLayerSwap>                 LayerSwaps;                                        // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              POISlots;                                          // 0x00D0(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReservedAreaName;                                  // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGJunoWorldTile) == 0x000008, "Wrong alignment on FPCGJunoWorldTile");
static_assert(sizeof(FPCGJunoWorldTile) == 0x0000F8, "Wrong size on FPCGJunoWorldTile");
static_assert(offsetof(FPCGJunoWorldTile, Status) == 0x000008, "Member 'FPCGJunoWorldTile::Status' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, GenerationType) == 0x000009, "Member 'FPCGJunoWorldTile::GenerationType' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, bIsDebugTile) == 0x00000A, "Member 'FPCGJunoWorldTile::bIsDebugTile' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, Version) == 0x00000C, "Member 'FPCGJunoWorldTile::Version' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, OriginRegistryId) == 0x000010, "Member 'FPCGJunoWorldTile::OriginRegistryId' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, Terrain) == 0x000018, "Member 'FPCGJunoWorldTile::Terrain' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, MiniMapTexture) == 0x000038, "Member 'FPCGJunoWorldTile::MiniMapTexture' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, StaticBiomeDecorations) == 0x000058, "Member 'FPCGJunoWorldTile::StaticBiomeDecorations' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, Overlays) == 0x000078, "Member 'FPCGJunoWorldTile::Overlays' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, PrimaryBiomeResourceVariations) == 0x000088, "Member 'FPCGJunoWorldTile::PrimaryBiomeResourceVariations' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, PrimaryBiomeResource) == 0x000098, "Member 'FPCGJunoWorldTile::PrimaryBiomeResource' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, NWBiome) == 0x0000B8, "Member 'FPCGJunoWorldTile::NWBiome' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, NEBiome) == 0x0000B9, "Member 'FPCGJunoWorldTile::NEBiome' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, SEBiome) == 0x0000BA, "Member 'FPCGJunoWorldTile::SEBiome' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, SWBiome) == 0x0000BB, "Member 'FPCGJunoWorldTile::SWBiome' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, LayerSwaps) == 0x0000C0, "Member 'FPCGJunoWorldTile::LayerSwaps' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, POISlots) == 0x0000D0, "Member 'FPCGJunoWorldTile::POISlots' has a wrong offset!");
static_assert(offsetof(FPCGJunoWorldTile, ReservedAreaName) == 0x0000F0, "Member 'FPCGJunoWorldTile::ReservedAreaName' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPOISlotMetaData
// 0x0001 (0x0001 - 0x0000)
struct FJunoPOISlotMetaData final
{
public:
	EJunoPOISlotState                             State;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoPOISlotMetaData) == 0x000001, "Wrong alignment on FJunoPOISlotMetaData");
static_assert(sizeof(FJunoPOISlotMetaData) == 0x000001, "Wrong size on FJunoPOISlotMetaData");
static_assert(offsetof(FJunoPOISlotMetaData, State) == 0x000000, "Member 'FJunoPOISlotMetaData::State' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCaveSurfaceData
// 0x0030 (0x0030 - 0x0000)
struct FJunoCaveSurfaceData final
{
public:
	struct FGuid                                  CaveGuid;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          Entrances;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     EntranceTeleporterTransforms;                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCaveSurfaceData) == 0x000008, "Wrong alignment on FJunoCaveSurfaceData");
static_assert(sizeof(FJunoCaveSurfaceData) == 0x000030, "Wrong size on FJunoCaveSurfaceData");
static_assert(offsetof(FJunoCaveSurfaceData, CaveGuid) == 0x000000, "Member 'FJunoCaveSurfaceData::CaveGuid' has a wrong offset!");
static_assert(offsetof(FJunoCaveSurfaceData, Entrances) == 0x000010, "Member 'FJunoCaveSurfaceData::Entrances' has a wrong offset!");
static_assert(offsetof(FJunoCaveSurfaceData, EntranceTeleporterTransforms) == 0x000020, "Member 'FJunoCaveSurfaceData::EntranceTeleporterTransforms' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoCave
// 0x0010 (0x0010 - 0x0000)
struct FJunoCave final
{
public:
	TArray<class AJunoCaveShellGameplayVolume*>   Shells;                                            // 0x0000(0x0010)(ZeroConstructor, SaveGame, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCave) == 0x000008, "Wrong alignment on FJunoCave");
static_assert(sizeof(FJunoCave) == 0x000010, "Wrong size on FJunoCave");
static_assert(offsetof(FJunoCave, Shells) == 0x000000, "Member 'FJunoCave::Shells' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldTileSaveData_Cave_PersistentInfo
// 0x0020 (0x0020 - 0x0000)
struct FJunoWorldTileSaveData_Cave_PersistentInfo final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPersistenceFrameworkLevelSaveSpawnablePtr> GameplayVolumes;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoWorldTileSaveData_Cave_PersistentInfo) == 0x000008, "Wrong alignment on FJunoWorldTileSaveData_Cave_PersistentInfo");
static_assert(sizeof(FJunoWorldTileSaveData_Cave_PersistentInfo) == 0x000020, "Wrong size on FJunoWorldTileSaveData_Cave_PersistentInfo");
static_assert(offsetof(FJunoWorldTileSaveData_Cave_PersistentInfo, Guid) == 0x000000, "Member 'FJunoWorldTileSaveData_Cave_PersistentInfo::Guid' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileSaveData_Cave_PersistentInfo, GameplayVolumes) == 0x000010, "Member 'FJunoWorldTileSaveData_Cave_PersistentInfo::GameplayVolumes' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldTileSaveData_POI_PersistentInfo
// 0x0030 (0x0030 - 0x0000)
struct FJunoWorldTileSaveData_POI_PersistentInfo final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPersistenceFrameworkLevelSaveSpawnablePtr GameplayVolume;                                    // 0x0010(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoWorldTileSaveData_POI_PersistentInfo) == 0x000008, "Wrong alignment on FJunoWorldTileSaveData_POI_PersistentInfo");
static_assert(sizeof(FJunoWorldTileSaveData_POI_PersistentInfo) == 0x000030, "Wrong size on FJunoWorldTileSaveData_POI_PersistentInfo");
static_assert(offsetof(FJunoWorldTileSaveData_POI_PersistentInfo, Guid) == 0x000000, "Member 'FJunoWorldTileSaveData_POI_PersistentInfo::Guid' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileSaveData_POI_PersistentInfo, GameplayVolume) == 0x000010, "Member 'FJunoWorldTileSaveData_POI_PersistentInfo::GameplayVolume' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldTileSaveData
// 0x0068 (0x0068 - 0x0000)
struct FJunoWorldTileSaveData final
{
public:
	TMap<struct FGuid, struct FJunoPOISlotMetaData> POISlotMetaDatas;                                  // 0x0000(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FJunoCaveSurfaceData>           CaveSurfaceData;                                   // 0x0050(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          bIsCaveSurfaceDataValid;                           // 0x0060(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoWorldTileSaveData) == 0x000008, "Wrong alignment on FJunoWorldTileSaveData");
static_assert(sizeof(FJunoWorldTileSaveData) == 0x000068, "Wrong size on FJunoWorldTileSaveData");
static_assert(offsetof(FJunoWorldTileSaveData, POISlotMetaDatas) == 0x000000, "Member 'FJunoWorldTileSaveData::POISlotMetaDatas' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileSaveData, CaveSurfaceData) == 0x000050, "Member 'FJunoWorldTileSaveData::CaveSurfaceData' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileSaveData, bIsCaveSurfaceDataValid) == 0x000060, "Member 'FJunoWorldTileSaveData::bIsCaveSurfaceDataValid' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldTileSaveData_InGameClass_PersistentInfo
// 0x0088 (0x0088 - 0x0000)
struct FJunoWorldTileSaveData_InGameClass_PersistentInfo final
{
public:
	struct FJunoWorldTileSaveData                 SaveData;                                          // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	TArray<struct FJunoWorldTileSaveData_Cave_PersistentInfo> Caves;                                             // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJunoWorldTileSaveData_POI_PersistentInfo> POIs;                                              // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoWorldTileSaveData_InGameClass_PersistentInfo) == 0x000008, "Wrong alignment on FJunoWorldTileSaveData_InGameClass_PersistentInfo");
static_assert(sizeof(FJunoWorldTileSaveData_InGameClass_PersistentInfo) == 0x000088, "Wrong size on FJunoWorldTileSaveData_InGameClass_PersistentInfo");
static_assert(offsetof(FJunoWorldTileSaveData_InGameClass_PersistentInfo, SaveData) == 0x000000, "Member 'FJunoWorldTileSaveData_InGameClass_PersistentInfo::SaveData' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileSaveData_InGameClass_PersistentInfo, Caves) == 0x000068, "Member 'FJunoWorldTileSaveData_InGameClass_PersistentInfo::Caves' has a wrong offset!");
static_assert(offsetof(FJunoWorldTileSaveData_InGameClass_PersistentInfo, POIs) == 0x000078, "Member 'FJunoWorldTileSaveData_InGameClass_PersistentInfo::POIs' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PathfinderHistory
// 0x0048 (0x0048 - 0x0000)
struct FPathfinderHistory final
{
public:
	struct FVector                                NearestLocationToDestination;                      // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearestLocationToDestinationDistance;              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x24];                                      // 0x001C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalPushSteps;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathfinderHistory) == 0x000008, "Wrong alignment on FPathfinderHistory");
static_assert(sizeof(FPathfinderHistory) == 0x000048, "Wrong size on FPathfinderHistory");
static_assert(offsetof(FPathfinderHistory, NearestLocationToDestination) == 0x000000, "Member 'FPathfinderHistory::NearestLocationToDestination' has a wrong offset!");
static_assert(offsetof(FPathfinderHistory, NearestLocationToDestinationDistance) == 0x000018, "Member 'FPathfinderHistory::NearestLocationToDestinationDistance' has a wrong offset!");
static_assert(offsetof(FPathfinderHistory, TotalPushSteps) == 0x000040, "Member 'FPathfinderHistory::TotalPushSteps' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.ControlPointParameters
// 0x0060 (0x0060 - 0x0000)
struct FControlPointParameters final
{
public:
	float                                         Width;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LayerWidthRatio;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideFalloff;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftSideFalloffFactor;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightSideFalloffFactor;                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftSideLayerFalloffFactor;                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightSideLayerFalloffFactor;                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndFalloff;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SegmentMeshOffset;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             MaterialOverrides;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                MeshScale;                                         // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlPointParameters) == 0x000008, "Wrong alignment on FControlPointParameters");
static_assert(sizeof(FControlPointParameters) == 0x000060, "Wrong size on FControlPointParameters");
static_assert(offsetof(FControlPointParameters, Width) == 0x000000, "Member 'FControlPointParameters::Width' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, LayerWidthRatio) == 0x000004, "Member 'FControlPointParameters::LayerWidthRatio' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, SideFalloff) == 0x000008, "Member 'FControlPointParameters::SideFalloff' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, LeftSideFalloffFactor) == 0x00000C, "Member 'FControlPointParameters::LeftSideFalloffFactor' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, RightSideFalloffFactor) == 0x000010, "Member 'FControlPointParameters::RightSideFalloffFactor' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, LeftSideLayerFalloffFactor) == 0x000014, "Member 'FControlPointParameters::LeftSideLayerFalloffFactor' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, RightSideLayerFalloffFactor) == 0x000018, "Member 'FControlPointParameters::RightSideLayerFalloffFactor' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, EndFalloff) == 0x00001C, "Member 'FControlPointParameters::EndFalloff' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, SegmentMeshOffset) == 0x000020, "Member 'FControlPointParameters::SegmentMeshOffset' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, Mesh) == 0x000028, "Member 'FControlPointParameters::Mesh' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, MaterialOverrides) == 0x000030, "Member 'FControlPointParameters::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, MeshScale) == 0x000040, "Member 'FControlPointParameters::MeshScale' has a wrong offset!");
static_assert(offsetof(FControlPointParameters, bCastShadow) == 0x000058, "Member 'FControlPointParameters::bCastShadow' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.SegmentParameters
// 0x0030 (0x0030 - 0x0000)
struct FSegmentParameters final
{
public:
	class FName                                   LayerName;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRaiseTerrain;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowerTerrain;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLandscapeSplineMeshEntry>      SplineMeshes;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenInGame;                                     // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaceSplineMeshesInStreamingLevels;               // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomSeed;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LDMaxDrawDistance;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslucencySortPriority;                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRenderCustomDepth;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERendererStencilMask                          CustomDepthStencilWriteMask;                       // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomDepthStencilValue;                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSegmentParameters) == 0x000008, "Wrong alignment on FSegmentParameters");
static_assert(sizeof(FSegmentParameters) == 0x000030, "Wrong size on FSegmentParameters");
static_assert(offsetof(FSegmentParameters, LayerName) == 0x000000, "Member 'FSegmentParameters::LayerName' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, bRaiseTerrain) == 0x000004, "Member 'FSegmentParameters::bRaiseTerrain' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, bLowerTerrain) == 0x000005, "Member 'FSegmentParameters::bLowerTerrain' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, SplineMeshes) == 0x000008, "Member 'FSegmentParameters::SplineMeshes' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, bCastShadow) == 0x000018, "Member 'FSegmentParameters::bCastShadow' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, bHiddenInGame) == 0x000019, "Member 'FSegmentParameters::bHiddenInGame' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, bPlaceSplineMeshesInStreamingLevels) == 0x00001A, "Member 'FSegmentParameters::bPlaceSplineMeshesInStreamingLevels' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, RandomSeed) == 0x00001C, "Member 'FSegmentParameters::RandomSeed' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, LDMaxDrawDistance) == 0x000020, "Member 'FSegmentParameters::LDMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, TranslucencySortPriority) == 0x000024, "Member 'FSegmentParameters::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, bRenderCustomDepth) == 0x000028, "Member 'FSegmentParameters::bRenderCustomDepth' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, CustomDepthStencilWriteMask) == 0x000029, "Member 'FSegmentParameters::CustomDepthStencilWriteMask' has a wrong offset!");
static_assert(offsetof(FSegmentParameters, CustomDepthStencilValue) == 0x00002C, "Member 'FSegmentParameters::CustomDepthStencilValue' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PathfinderGuideSet
// 0x0010 (0x0010 - 0x0000)
struct FPathfinderGuideSet final
{
public:
	TArray<struct FSplineGuide>                   Guides;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathfinderGuideSet) == 0x000008, "Wrong alignment on FPathfinderGuideSet");
static_assert(sizeof(FPathfinderGuideSet) == 0x000010, "Wrong size on FPathfinderGuideSet");
static_assert(offsetof(FPathfinderGuideSet, Guides) == 0x000000, "Member 'FPathfinderGuideSet::Guides' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoBiomeElementRow
// 0x0058 (0x0060 - 0x0008)
struct FPCGJunoBiomeElementRow final : public FTableRowBase
{
public:
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Type;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 LayerWeights;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                PositionOffset;                                    // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScaleMinMax;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendToVertical;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomLeanAmount;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoRepresentation                           Representation;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     Actor;                                             // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoBiomeElementRow) == 0x000008, "Wrong alignment on FPCGJunoBiomeElementRow");
static_assert(sizeof(FPCGJunoBiomeElementRow) == 0x000060, "Wrong size on FPCGJunoBiomeElementRow");
static_assert(offsetof(FPCGJunoBiomeElementRow, Weight) == 0x000008, "Member 'FPCGJunoBiomeElementRow::Weight' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeElementRow, Type) == 0x00000C, "Member 'FPCGJunoBiomeElementRow::Type' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeElementRow, LayerWeights) == 0x000010, "Member 'FPCGJunoBiomeElementRow::LayerWeights' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeElementRow, PositionOffset) == 0x000020, "Member 'FPCGJunoBiomeElementRow::PositionOffset' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeElementRow, ScaleMinMax) == 0x000038, "Member 'FPCGJunoBiomeElementRow::ScaleMinMax' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeElementRow, BlendToVertical) == 0x000048, "Member 'FPCGJunoBiomeElementRow::BlendToVertical' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeElementRow, RandomLeanAmount) == 0x00004C, "Member 'FPCGJunoBiomeElementRow::RandomLeanAmount' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeElementRow, Representation) == 0x000050, "Member 'FPCGJunoBiomeElementRow::Representation' has a wrong offset!");
static_assert(offsetof(FPCGJunoBiomeElementRow, Actor) == 0x000058, "Member 'FPCGJunoBiomeElementRow::Actor' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoPOIElementRow
// 0x0038 (0x0040 - 0x0008)
struct FPCGJunoPOIElementRow final : public FTableRowBase
{
public:
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundsMultiplier;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJunoLevelInstance>         POIActor;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingFoundation>        BuildingFoundation;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0020(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoPOIElementRow) == 0x000008, "Wrong alignment on FPCGJunoPOIElementRow");
static_assert(sizeof(FPCGJunoPOIElementRow) == 0x000040, "Wrong size on FPCGJunoPOIElementRow");
static_assert(offsetof(FPCGJunoPOIElementRow, Weight) == 0x000008, "Member 'FPCGJunoPOIElementRow::Weight' has a wrong offset!");
static_assert(offsetof(FPCGJunoPOIElementRow, BoundsMultiplier) == 0x00000C, "Member 'FPCGJunoPOIElementRow::BoundsMultiplier' has a wrong offset!");
static_assert(offsetof(FPCGJunoPOIElementRow, POIActor) == 0x000010, "Member 'FPCGJunoPOIElementRow::POIActor' has a wrong offset!");
static_assert(offsetof(FPCGJunoPOIElementRow, BuildingFoundation) == 0x000018, "Member 'FPCGJunoPOIElementRow::BuildingFoundation' has a wrong offset!");
static_assert(offsetof(FPCGJunoPOIElementRow, Level) == 0x000020, "Member 'FPCGJunoPOIElementRow::Level' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoPOISlotElementRow
// 0x0050 (0x0058 - 0x0008)
struct FPCGJunoPOISlotElementRow final : public FTableRowBase
{
public:
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoPOISize                                  Size;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AJunoPOISlot>               POISlotActor;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              PotentialPOIs;                                     // 0x0018(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TerrainHeightPatch;                                // 0x0038(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoPOISlotElementRow) == 0x000008, "Wrong alignment on FPCGJunoPOISlotElementRow");
static_assert(sizeof(FPCGJunoPOISlotElementRow) == 0x000058, "Wrong size on FPCGJunoPOISlotElementRow");
static_assert(offsetof(FPCGJunoPOISlotElementRow, Weight) == 0x000008, "Member 'FPCGJunoPOISlotElementRow::Weight' has a wrong offset!");
static_assert(offsetof(FPCGJunoPOISlotElementRow, Size) == 0x00000C, "Member 'FPCGJunoPOISlotElementRow::Size' has a wrong offset!");
static_assert(offsetof(FPCGJunoPOISlotElementRow, POISlotActor) == 0x000010, "Member 'FPCGJunoPOISlotElementRow::POISlotActor' has a wrong offset!");
static_assert(offsetof(FPCGJunoPOISlotElementRow, PotentialPOIs) == 0x000018, "Member 'FPCGJunoPOISlotElementRow::PotentialPOIs' has a wrong offset!");
static_assert(offsetof(FPCGJunoPOISlotElementRow, TerrainHeightPatch) == 0x000038, "Member 'FPCGJunoPOISlotElementRow::TerrainHeightPatch' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoAudioElementRow
// 0x0030 (0x0038 - 0x0008)
struct FPCGJunoAudioElementRow final : public FTableRowBase
{
public:
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     AudioActorToSpawn;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAmbientAudioDataAsset>  Level;                                             // 0x0018(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoAudioElementRow) == 0x000008, "Wrong alignment on FPCGJunoAudioElementRow");
static_assert(sizeof(FPCGJunoAudioElementRow) == 0x000038, "Wrong size on FPCGJunoAudioElementRow");
static_assert(offsetof(FPCGJunoAudioElementRow, Weight) == 0x000008, "Member 'FPCGJunoAudioElementRow::Weight' has a wrong offset!");
static_assert(offsetof(FPCGJunoAudioElementRow, AudioActorToSpawn) == 0x000010, "Member 'FPCGJunoAudioElementRow::AudioActorToSpawn' has a wrong offset!");
static_assert(offsetof(FPCGJunoAudioElementRow, Level) == 0x000018, "Member 'FPCGJunoAudioElementRow::Level' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoCullDistanceGameplayTagRow
// 0x0010 (0x0018 - 0x0008)
struct FPCGJunoCullDistanceGameplayTagRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           CullDistanceTag;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndCullDistance;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODInstanceScale;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGJunoCullDistanceGameplayTagRow) == 0x000008, "Wrong alignment on FPCGJunoCullDistanceGameplayTagRow");
static_assert(sizeof(FPCGJunoCullDistanceGameplayTagRow) == 0x000018, "Wrong size on FPCGJunoCullDistanceGameplayTagRow");
static_assert(offsetof(FPCGJunoCullDistanceGameplayTagRow, CullDistanceTag) == 0x000008, "Member 'FPCGJunoCullDistanceGameplayTagRow::CullDistanceTag' has a wrong offset!");
static_assert(offsetof(FPCGJunoCullDistanceGameplayTagRow, EndCullDistance) == 0x00000C, "Member 'FPCGJunoCullDistanceGameplayTagRow::EndCullDistance' has a wrong offset!");
static_assert(offsetof(FPCGJunoCullDistanceGameplayTagRow, LODInstanceScale) == 0x000010, "Member 'FPCGJunoCullDistanceGameplayTagRow::LODInstanceScale' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoStoreDataPin
// 0x0010 (0x0010 - 0x0000)
struct FPCGJunoStoreDataPin final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJunoPCGVolumePointDataFeatures        Features;                                          // 0x0004(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoStoreDataPin) == 0x000004, "Wrong alignment on FPCGJunoStoreDataPin");
static_assert(sizeof(FPCGJunoStoreDataPin) == 0x000010, "Wrong size on FPCGJunoStoreDataPin");
static_assert(offsetof(FPCGJunoStoreDataPin, Name) == 0x000000, "Member 'FPCGJunoStoreDataPin::Name' has a wrong offset!");
static_assert(offsetof(FPCGJunoStoreDataPin, Features) == 0x000004, "Member 'FPCGJunoStoreDataPin::Features' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.ProceduralRiverAnchorConnectionRules
// 0x0368 (0x0368 - 0x0000)
struct FProceduralRiverAnchorConnectionRules final
{
public:
	float                                         MaxConnectionSlope;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     CarveDownNearSourceAnchor;                         // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CarveDownNearTargetAnchor;                         // 0x0090(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     WidthMultNearSourceAnchor;                         // 0x0118(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     WidthMultNearTargetAnchor;                         // 0x01A0(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VelocityMultNearSourceAnchor;                      // 0x0228(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VelocityMultNearTargetAnchor;                      // 0x02B0(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              CoastlineAnchorZRange;                             // 0x0338(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoastlineProbeAboveZeroPercent;                    // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoastlineProbeBelowZeroPercent;                    // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DeepSeaAnchorZRange;                               // 0x0350(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeepSeaAnchorMinDistanceToCoastline;               // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralRiverAnchorConnectionRules) == 0x000008, "Wrong alignment on FProceduralRiverAnchorConnectionRules");
static_assert(sizeof(FProceduralRiverAnchorConnectionRules) == 0x000368, "Wrong size on FProceduralRiverAnchorConnectionRules");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, MaxConnectionSlope) == 0x000000, "Member 'FProceduralRiverAnchorConnectionRules::MaxConnectionSlope' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, CarveDownNearSourceAnchor) == 0x000008, "Member 'FProceduralRiverAnchorConnectionRules::CarveDownNearSourceAnchor' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, CarveDownNearTargetAnchor) == 0x000090, "Member 'FProceduralRiverAnchorConnectionRules::CarveDownNearTargetAnchor' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, WidthMultNearSourceAnchor) == 0x000118, "Member 'FProceduralRiverAnchorConnectionRules::WidthMultNearSourceAnchor' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, WidthMultNearTargetAnchor) == 0x0001A0, "Member 'FProceduralRiverAnchorConnectionRules::WidthMultNearTargetAnchor' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, VelocityMultNearSourceAnchor) == 0x000228, "Member 'FProceduralRiverAnchorConnectionRules::VelocityMultNearSourceAnchor' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, VelocityMultNearTargetAnchor) == 0x0002B0, "Member 'FProceduralRiverAnchorConnectionRules::VelocityMultNearTargetAnchor' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, CoastlineAnchorZRange) == 0x000338, "Member 'FProceduralRiverAnchorConnectionRules::CoastlineAnchorZRange' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, CoastlineProbeAboveZeroPercent) == 0x000348, "Member 'FProceduralRiverAnchorConnectionRules::CoastlineProbeAboveZeroPercent' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, CoastlineProbeBelowZeroPercent) == 0x00034C, "Member 'FProceduralRiverAnchorConnectionRules::CoastlineProbeBelowZeroPercent' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, DeepSeaAnchorZRange) == 0x000350, "Member 'FProceduralRiverAnchorConnectionRules::DeepSeaAnchorZRange' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchorConnectionRules, DeepSeaAnchorMinDistanceToCoastline) == 0x000360, "Member 'FProceduralRiverAnchorConnectionRules::DeepSeaAnchorMinDistanceToCoastline' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.ProceduralRiverShapeRules
// 0x0220 (0x0220 - 0x0000)
struct FProceduralRiverShapeRules final
{
public:
	struct FRuntimeFloatCurve                     DepthCurve;                                        // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     WidthCurve;                                        // 0x0088(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VelocityCurve;                                     // 0x0110(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VelocityBySlope;                                   // 0x0198(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralRiverShapeRules) == 0x000008, "Wrong alignment on FProceduralRiverShapeRules");
static_assert(sizeof(FProceduralRiverShapeRules) == 0x000220, "Wrong size on FProceduralRiverShapeRules");
static_assert(offsetof(FProceduralRiverShapeRules, DepthCurve) == 0x000000, "Member 'FProceduralRiverShapeRules::DepthCurve' has a wrong offset!");
static_assert(offsetof(FProceduralRiverShapeRules, WidthCurve) == 0x000088, "Member 'FProceduralRiverShapeRules::WidthCurve' has a wrong offset!");
static_assert(offsetof(FProceduralRiverShapeRules, VelocityCurve) == 0x000110, "Member 'FProceduralRiverShapeRules::VelocityCurve' has a wrong offset!");
static_assert(offsetof(FProceduralRiverShapeRules, VelocityBySlope) == 0x000198, "Member 'FProceduralRiverShapeRules::VelocityBySlope' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.RouteClassAvoidance
// 0x0010 (0x0010 - 0x0000)
struct FRouteClassAvoidance final
{
public:
	TSubclassOf<class ALandmassProceduralRoute>   RouteClassesToAvoid;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRouteClassAvoidance) == 0x000008, "Wrong alignment on FRouteClassAvoidance");
static_assert(sizeof(FRouteClassAvoidance) == 0x000010, "Wrong size on FRouteClassAvoidance");
static_assert(offsetof(FRouteClassAvoidance, RouteClassesToAvoid) == 0x000000, "Member 'FRouteClassAvoidance::RouteClassesToAvoid' has a wrong offset!");
static_assert(offsetof(FRouteClassAvoidance, Distance) == 0x000008, "Member 'FRouteClassAvoidance::Distance' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.LandmassPathfinderRules
// 0x00A8 (0x00A8 - 0x0000)
struct FLandmassPathfinderRules final
{
public:
	EVerticalDirection                            VerticalDirection;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSlopeWhileGoingAgainstLegalVerticalDirection;   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFavorGoingDown;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FavorGoingDownWeight;                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGravitationalPotentialEnergy;                  // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartingGravitationalPotentialEnergy;              // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlope;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalCostMultiplier;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideRollCostMultiplier;                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SearchConeInDegrees;                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackStop;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SearchPointsNum;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestinationRadius;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimalViableDistance;                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapDistance;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCost;                                           // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSteps;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TooCloseDistanceRatio;                             // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeuristicToDestinationWeight;                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBoostDistance;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostIntensity;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnappedSpeedMultiplier;                            // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRouteClassAvoidance>           RouteClassesAvoidances;                            // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WarpFixedCost;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarpAngleConstraint;                               // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWarpingDistance;                                // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWarpingZDelta;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPercentageOfLandOnEachSide;                     // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarpZoneApproximatedGreaterHalfWidth;              // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarpZoneApproximatedLesserHalfWidth;               // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWarpZoneDifficultTerrain;                      // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarpZoneDifficultTerrainWidth;                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarpZoneDifficultTerrainCostMult;                  // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileDimension;                                     // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileEdgeAvoidanceDistance;                         // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandmassPathfinderRules) == 0x000008, "Wrong alignment on FLandmassPathfinderRules");
static_assert(sizeof(FLandmassPathfinderRules) == 0x0000A8, "Wrong size on FLandmassPathfinderRules");
static_assert(offsetof(FLandmassPathfinderRules, VerticalDirection) == 0x000000, "Member 'FLandmassPathfinderRules::VerticalDirection' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MaxSlopeWhileGoingAgainstLegalVerticalDirection) == 0x000004, "Member 'FLandmassPathfinderRules::MaxSlopeWhileGoingAgainstLegalVerticalDirection' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, bFavorGoingDown) == 0x000008, "Member 'FLandmassPathfinderRules::bFavorGoingDown' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, FavorGoingDownWeight) == 0x00000C, "Member 'FLandmassPathfinderRules::FavorGoingDownWeight' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, bUseGravitationalPotentialEnergy) == 0x000010, "Member 'FLandmassPathfinderRules::bUseGravitationalPotentialEnergy' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, StartingGravitationalPotentialEnergy) == 0x000014, "Member 'FLandmassPathfinderRules::StartingGravitationalPotentialEnergy' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MaxSlope) == 0x000018, "Member 'FLandmassPathfinderRules::MaxSlope' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, VerticalCostMultiplier) == 0x00001C, "Member 'FLandmassPathfinderRules::VerticalCostMultiplier' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, SideRollCostMultiplier) == 0x000020, "Member 'FLandmassPathfinderRules::SideRollCostMultiplier' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, SearchRadius) == 0x000024, "Member 'FLandmassPathfinderRules::SearchRadius' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, SearchConeInDegrees) == 0x000028, "Member 'FLandmassPathfinderRules::SearchConeInDegrees' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, BackStop) == 0x000038, "Member 'FLandmassPathfinderRules::BackStop' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, SearchPointsNum) == 0x00003C, "Member 'FLandmassPathfinderRules::SearchPointsNum' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, DestinationRadius) == 0x000040, "Member 'FLandmassPathfinderRules::DestinationRadius' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MinimalViableDistance) == 0x000044, "Member 'FLandmassPathfinderRules::MinimalViableDistance' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, SnapDistance) == 0x000048, "Member 'FLandmassPathfinderRules::SnapDistance' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MaxCost) == 0x00004C, "Member 'FLandmassPathfinderRules::MaxCost' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MaxSteps) == 0x000050, "Member 'FLandmassPathfinderRules::MaxSteps' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, TooCloseDistanceRatio) == 0x000054, "Member 'FLandmassPathfinderRules::TooCloseDistanceRatio' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, HeuristicToDestinationWeight) == 0x000058, "Member 'FLandmassPathfinderRules::HeuristicToDestinationWeight' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MaxBoostDistance) == 0x00005C, "Member 'FLandmassPathfinderRules::MaxBoostDistance' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, BoostIntensity) == 0x000060, "Member 'FLandmassPathfinderRules::BoostIntensity' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, SnappedSpeedMultiplier) == 0x000064, "Member 'FLandmassPathfinderRules::SnappedSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, RouteClassesAvoidances) == 0x000068, "Member 'FLandmassPathfinderRules::RouteClassesAvoidances' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, WarpFixedCost) == 0x000078, "Member 'FLandmassPathfinderRules::WarpFixedCost' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, WarpAngleConstraint) == 0x00007C, "Member 'FLandmassPathfinderRules::WarpAngleConstraint' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MaxWarpingDistance) == 0x000080, "Member 'FLandmassPathfinderRules::MaxWarpingDistance' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MaxWarpingZDelta) == 0x000084, "Member 'FLandmassPathfinderRules::MaxWarpingZDelta' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, MinPercentageOfLandOnEachSide) == 0x000088, "Member 'FLandmassPathfinderRules::MinPercentageOfLandOnEachSide' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, WarpZoneApproximatedGreaterHalfWidth) == 0x00008C, "Member 'FLandmassPathfinderRules::WarpZoneApproximatedGreaterHalfWidth' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, WarpZoneApproximatedLesserHalfWidth) == 0x000090, "Member 'FLandmassPathfinderRules::WarpZoneApproximatedLesserHalfWidth' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, bUseWarpZoneDifficultTerrain) == 0x000094, "Member 'FLandmassPathfinderRules::bUseWarpZoneDifficultTerrain' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, WarpZoneDifficultTerrainWidth) == 0x000098, "Member 'FLandmassPathfinderRules::WarpZoneDifficultTerrainWidth' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, WarpZoneDifficultTerrainCostMult) == 0x00009C, "Member 'FLandmassPathfinderRules::WarpZoneDifficultTerrainCostMult' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, TileDimension) == 0x0000A0, "Member 'FLandmassPathfinderRules::TileDimension' has a wrong offset!");
static_assert(offsetof(FLandmassPathfinderRules, TileEdgeAvoidanceDistance) == 0x0000A4, "Member 'FLandmassPathfinderRules::TileEdgeAvoidanceDistance' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.ProceduralRiverGenRules
// 0x0630 (0x0630 - 0x0000)
struct FProceduralRiverGenRules final
{
public:
	struct FProceduralRiverAnchorConnectionRules  AnchorConnectionRules;                             // 0x0000(0x0368)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FProceduralRiverShapeRules             ProceduralRiverShapeRules;                         // 0x0368(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLandmassPathfinderRules               PathfinderRules;                                   // 0x0588(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralRiverGenRules) == 0x000008, "Wrong alignment on FProceduralRiverGenRules");
static_assert(sizeof(FProceduralRiverGenRules) == 0x000630, "Wrong size on FProceduralRiverGenRules");
static_assert(offsetof(FProceduralRiverGenRules, AnchorConnectionRules) == 0x000000, "Member 'FProceduralRiverGenRules::AnchorConnectionRules' has a wrong offset!");
static_assert(offsetof(FProceduralRiverGenRules, ProceduralRiverShapeRules) == 0x000368, "Member 'FProceduralRiverGenRules::ProceduralRiverShapeRules' has a wrong offset!");
static_assert(offsetof(FProceduralRiverGenRules, PathfinderRules) == 0x000588, "Member 'FProceduralRiverGenRules::PathfinderRules' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoLivingWorldStaticPointProviderClusterEntryData
// 0x0038 (0x0038 - 0x0000)
struct FJunoLivingWorldStaticPointProviderClusterEntryData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0018(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoLivingWorldStaticPointProviderClusterEntryData) == 0x000008, "Wrong alignment on FJunoLivingWorldStaticPointProviderClusterEntryData");
static_assert(sizeof(FJunoLivingWorldStaticPointProviderClusterEntryData) == 0x000038, "Wrong size on FJunoLivingWorldStaticPointProviderClusterEntryData");
static_assert(offsetof(FJunoLivingWorldStaticPointProviderClusterEntryData, Location) == 0x000000, "Member 'FJunoLivingWorldStaticPointProviderClusterEntryData::Location' has a wrong offset!");
static_assert(offsetof(FJunoLivingWorldStaticPointProviderClusterEntryData, Tags) == 0x000018, "Member 'FJunoLivingWorldStaticPointProviderClusterEntryData::Tags' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoLivingWorldStaticPointProviderClusterEntry
// 0x0018 (0x0018 - 0x0000)
struct FJunoLivingWorldStaticPointProviderClusterEntry final
{
public:
	TSubclassOf<class AJunoLivingWorldStaticPointProvider> PointProviderTemplate;                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJunoLivingWorldStaticPointProviderClusterEntryData> DataList;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoLivingWorldStaticPointProviderClusterEntry) == 0x000008, "Wrong alignment on FJunoLivingWorldStaticPointProviderClusterEntry");
static_assert(sizeof(FJunoLivingWorldStaticPointProviderClusterEntry) == 0x000018, "Wrong size on FJunoLivingWorldStaticPointProviderClusterEntry");
static_assert(offsetof(FJunoLivingWorldStaticPointProviderClusterEntry, PointProviderTemplate) == 0x000000, "Member 'FJunoLivingWorldStaticPointProviderClusterEntry::PointProviderTemplate' has a wrong offset!");
static_assert(offsetof(FJunoLivingWorldStaticPointProviderClusterEntry, DataList) == 0x000008, "Member 'FJunoLivingWorldStaticPointProviderClusterEntry::DataList' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.LWMClusterPointInfo
// 0x0018 (0x0018 - 0x0000)
struct FLWMClusterPointInfo final
{
public:
	class UJunoLivingWorldLightStaticPointProvider* PointProvider;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavAgentSelector                      SupportedAgents;                                   // 0x0008(0x0004)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWMClusterPointInfo) == 0x000008, "Wrong alignment on FLWMClusterPointInfo");
static_assert(sizeof(FLWMClusterPointInfo) == 0x000018, "Wrong size on FLWMClusterPointInfo");
static_assert(offsetof(FLWMClusterPointInfo, PointProvider) == 0x000000, "Member 'FLWMClusterPointInfo::PointProvider' has a wrong offset!");
static_assert(offsetof(FLWMClusterPointInfo, SupportedAgents) == 0x000008, "Member 'FLWMClusterPointInfo::SupportedAgents' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPOIInstanceData
// 0x0018 (0x0018 - 0x0000)
struct FJunoPOIInstanceData final
{
public:
	TArray<class FName>                           Tags;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	EJunoBiome                                    SlotBiome;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoPOIInstanceData) == 0x000008, "Wrong alignment on FJunoPOIInstanceData");
static_assert(sizeof(FJunoPOIInstanceData) == 0x000018, "Wrong size on FJunoPOIInstanceData");
static_assert(offsetof(FJunoPOIInstanceData, Tags) == 0x000000, "Member 'FJunoPOIInstanceData::Tags' has a wrong offset!");
static_assert(offsetof(FJunoPOIInstanceData, SlotBiome) == 0x000010, "Member 'FJunoPOIInstanceData::SlotBiome' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPOIData
// 0x0120 (0x0120 - 0x0000)
struct FJunoPOIData final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundsOffset;                                      // 0x0078(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                Levels;                                            // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                HLODLevels;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FJunoPOIInstanceData                   InstanceData;                                      // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EncounterCapabilities;                             // 0x00C8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         EncounterVariantCount;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              EncounterCategoryTable;                            // 0x00F0(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RegistryItemName;                                  // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PersistenceVersion;                                // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoPOIData) == 0x000010, "Wrong alignment on FJunoPOIData");
static_assert(sizeof(FJunoPOIData) == 0x000120, "Wrong size on FJunoPOIData");
static_assert(offsetof(FJunoPOIData, Transform) == 0x000000, "Member 'FJunoPOIData::Transform' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, Extent) == 0x000060, "Member 'FJunoPOIData::Extent' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, BoundsOffset) == 0x000078, "Member 'FJunoPOIData::BoundsOffset' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, Levels) == 0x000090, "Member 'FJunoPOIData::Levels' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, HLODLevels) == 0x0000A0, "Member 'FJunoPOIData::HLODLevels' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, InstanceData) == 0x0000B0, "Member 'FJunoPOIData::InstanceData' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, EncounterCapabilities) == 0x0000C8, "Member 'FJunoPOIData::EncounterCapabilities' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, EncounterVariantCount) == 0x0000E8, "Member 'FJunoPOIData::EncounterVariantCount' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, EncounterCategoryTable) == 0x0000F0, "Member 'FJunoPOIData::EncounterCategoryTable' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, RegistryItemName) == 0x000110, "Member 'FJunoPOIData::RegistryItemName' has a wrong offset!");
static_assert(offsetof(FJunoPOIData, PersistenceVersion) == 0x000114, "Member 'FJunoPOIData::PersistenceVersion' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoPOIManagerSlot
// 0x0040 (0x0040 - 0x0000)
struct FJunoPOIManagerSlot final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoBiome                                    Biome;                                             // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoPOISize                                  Size;                                              // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoPOIManagerSlot) == 0x000008, "Wrong alignment on FJunoPOIManagerSlot");
static_assert(sizeof(FJunoPOIManagerSlot) == 0x000040, "Wrong size on FJunoPOIManagerSlot");
static_assert(offsetof(FJunoPOIManagerSlot, Location) == 0x000000, "Member 'FJunoPOIManagerSlot::Location' has a wrong offset!");
static_assert(offsetof(FJunoPOIManagerSlot, Guid) == 0x000018, "Member 'FJunoPOIManagerSlot::Guid' has a wrong offset!");
static_assert(offsetof(FJunoPOIManagerSlot, Biome) == 0x000028, "Member 'FJunoPOIManagerSlot::Biome' has a wrong offset!");
static_assert(offsetof(FJunoPOIManagerSlot, Size) == 0x000029, "Member 'FJunoPOIManagerSlot::Size' has a wrong offset!");
static_assert(offsetof(FJunoPOIManagerSlot, Tags) == 0x000030, "Member 'FJunoPOIManagerSlot::Tags' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoRoadAINavigationClusterEntry
// 0x0048 (0x0048 - 0x0000)
struct FJunoRoadAINavigationClusterEntry final
{
public:
	TSubclassOf<class AFortAthenaPatrolPath>      PatrolPathTemplate;                                // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortAthenaPatrolPoint>     PatrolPointTemplate;                               // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x0028(0x0020)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoRoadAINavigationClusterEntry) == 0x000008, "Wrong alignment on FJunoRoadAINavigationClusterEntry");
static_assert(sizeof(FJunoRoadAINavigationClusterEntry) == 0x000048, "Wrong size on FJunoRoadAINavigationClusterEntry");
static_assert(offsetof(FJunoRoadAINavigationClusterEntry, PatrolPathTemplate) == 0x000000, "Member 'FJunoRoadAINavigationClusterEntry::PatrolPathTemplate' has a wrong offset!");
static_assert(offsetof(FJunoRoadAINavigationClusterEntry, PatrolPointTemplate) == 0x000008, "Member 'FJunoRoadAINavigationClusterEntry::PatrolPointTemplate' has a wrong offset!");
static_assert(offsetof(FJunoRoadAINavigationClusterEntry, Points) == 0x000010, "Member 'FJunoRoadAINavigationClusterEntry::Points' has a wrong offset!");
static_assert(offsetof(FJunoRoadAINavigationClusterEntry, Width) == 0x000020, "Member 'FJunoRoadAINavigationClusterEntry::Width' has a wrong offset!");
static_assert(offsetof(FJunoRoadAINavigationClusterEntry, Tags) == 0x000028, "Member 'FJunoRoadAINavigationClusterEntry::Tags' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.RoadPatrolPathInfo
// 0x0008 (0x0008 - 0x0000)
struct FRoadPatrolPathInfo final
{
public:
	class AFortAthenaPatrolPath*                  PatrolPath;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoadPatrolPathInfo) == 0x000008, "Wrong alignment on FRoadPatrolPathInfo");
static_assert(sizeof(FRoadPatrolPathInfo) == 0x000008, "Wrong size on FRoadPatrolPathInfo");
static_assert(offsetof(FRoadPatrolPathInfo, PatrolPath) == 0x000000, "Member 'FRoadPatrolPathInfo::PatrolPath' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.CaveShellSpawnLimitData
// 0x0078 (0x0078 - 0x0000)
struct FCaveShellSpawnLimitData final
{
public:
	struct FScalableFloat                         MaxNumberOfSpawn;                                  // 0x0000(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         EventMemoryResetDurationsHours;                    // 0x0028(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         MinDistanceToTeleporter;                           // 0x0050(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCaveShellSpawnLimitData) == 0x000008, "Wrong alignment on FCaveShellSpawnLimitData");
static_assert(sizeof(FCaveShellSpawnLimitData) == 0x000078, "Wrong size on FCaveShellSpawnLimitData");
static_assert(offsetof(FCaveShellSpawnLimitData, MaxNumberOfSpawn) == 0x000000, "Member 'FCaveShellSpawnLimitData::MaxNumberOfSpawn' has a wrong offset!");
static_assert(offsetof(FCaveShellSpawnLimitData, EventMemoryResetDurationsHours) == 0x000028, "Member 'FCaveShellSpawnLimitData::EventMemoryResetDurationsHours' has a wrong offset!");
static_assert(offsetof(FCaveShellSpawnLimitData, MinDistanceToTeleporter) == 0x000050, "Member 'FCaveShellSpawnLimitData::MinDistanceToTeleporter' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.CaveSpawnEvent
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FCaveSpawnEvent final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCaveSpawnEvent) == 0x000004, "Wrong alignment on FCaveSpawnEvent");
static_assert(sizeof(FCaveSpawnEvent) == 0x00001C, "Wrong size on FCaveSpawnEvent");

// ScriptStruct JunoProceduralWorld.CaveSpawnPointProviderMemory
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCaveSpawnPointProviderMemory final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCaveSpawnPointProviderMemory) == 0x000008, "Wrong alignment on FCaveSpawnPointProviderMemory");
static_assert(sizeof(FCaveSpawnPointProviderMemory) == 0x000028, "Wrong size on FCaveSpawnPointProviderMemory");

// ScriptStruct JunoProceduralWorld.CaveShellID
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FCaveShellID final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCaveShellID) == 0x000004, "Wrong alignment on FCaveShellID");
static_assert(sizeof(FCaveShellID) == 0x000014, "Wrong size on FCaveShellID");

// ScriptStruct JunoProceduralWorld.DendrogramLeafAttributes
// 0x0020 (0x0020 - 0x0000)
struct FDendrogramLeafAttributes final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceScale;                                     // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeafTypeName;                                      // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDendrogramLeafAttributes) == 0x000008, "Wrong alignment on FDendrogramLeafAttributes");
static_assert(sizeof(FDendrogramLeafAttributes) == 0x000020, "Wrong size on FDendrogramLeafAttributes");
static_assert(offsetof(FDendrogramLeafAttributes, Location) == 0x000000, "Member 'FDendrogramLeafAttributes::Location' has a wrong offset!");
static_assert(offsetof(FDendrogramLeafAttributes, DistanceScale) == 0x000018, "Member 'FDendrogramLeafAttributes::DistanceScale' has a wrong offset!");
static_assert(offsetof(FDendrogramLeafAttributes, LeafTypeName) == 0x00001C, "Member 'FDendrogramLeafAttributes::LeafTypeName' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.DendrogramClusterOutput
// 0x0068 (0x0068 - 0x0000)
struct FDendrogramClusterOutput final
{
public:
	int32                                         NodeLevel;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeaf;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	class AActor*                                 ConnectedActorA;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ConnectedActorB;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDendrogramLeafAttributes              LeafAAttributes;                                   // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FDendrogramLeafAttributes              LeafBAttributes;                                   // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDendrogramClusterOutput) == 0x000008, "Wrong alignment on FDendrogramClusterOutput");
static_assert(sizeof(FDendrogramClusterOutput) == 0x000068, "Wrong size on FDendrogramClusterOutput");
static_assert(offsetof(FDendrogramClusterOutput, NodeLevel) == 0x000000, "Member 'FDendrogramClusterOutput::NodeLevel' has a wrong offset!");
static_assert(offsetof(FDendrogramClusterOutput, bIsLeaf) == 0x000004, "Member 'FDendrogramClusterOutput::bIsLeaf' has a wrong offset!");
static_assert(offsetof(FDendrogramClusterOutput, Actors) == 0x000008, "Member 'FDendrogramClusterOutput::Actors' has a wrong offset!");
static_assert(offsetof(FDendrogramClusterOutput, ConnectedActorA) == 0x000018, "Member 'FDendrogramClusterOutput::ConnectedActorA' has a wrong offset!");
static_assert(offsetof(FDendrogramClusterOutput, ConnectedActorB) == 0x000020, "Member 'FDendrogramClusterOutput::ConnectedActorB' has a wrong offset!");
static_assert(offsetof(FDendrogramClusterOutput, LeafAAttributes) == 0x000028, "Member 'FDendrogramClusterOutput::LeafAAttributes' has a wrong offset!");
static_assert(offsetof(FDendrogramClusterOutput, LeafBAttributes) == 0x000048, "Member 'FDendrogramClusterOutput::LeafBAttributes' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.ProceduralRoadGenRules
// 0x0138 (0x0138 - 0x0000)
struct FProceduralRoadGenRules final
{
public:
	struct FLandmassPathfinderRules               PathfinderRules;                                   // 0x0000(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FControlPointParameters                ControlPointParams;                                // 0x00A8(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSegmentParameters                     SegmentParams;                                     // 0x0108(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralRoadGenRules) == 0x000008, "Wrong alignment on FProceduralRoadGenRules");
static_assert(sizeof(FProceduralRoadGenRules) == 0x000138, "Wrong size on FProceduralRoadGenRules");
static_assert(offsetof(FProceduralRoadGenRules, PathfinderRules) == 0x000000, "Member 'FProceduralRoadGenRules::PathfinderRules' has a wrong offset!");
static_assert(offsetof(FProceduralRoadGenRules, ControlPointParams) == 0x0000A8, "Member 'FProceduralRoadGenRules::ControlPointParams' has a wrong offset!");
static_assert(offsetof(FProceduralRoadGenRules, SegmentParams) == 0x000108, "Member 'FProceduralRoadGenRules::SegmentParams' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.LandmassPCGRouteInput
// 0x0018 (0x0018 - 0x0000)
struct FLandmassPCGRouteInput final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPCGSpatialData*>                Data;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandmassPCGRouteInput) == 0x000008, "Wrong alignment on FLandmassPCGRouteInput");
static_assert(sizeof(FLandmassPCGRouteInput) == 0x000018, "Wrong size on FLandmassPCGRouteInput");
static_assert(offsetof(FLandmassPCGRouteInput, Name) == 0x000000, "Member 'FLandmassPCGRouteInput::Name' has a wrong offset!");
static_assert(offsetof(FLandmassPCGRouteInput, Data) == 0x000008, "Member 'FLandmassPCGRouteInput::Data' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.RouteAvoidancePrimitive
// 0x0030 (0x0030 - 0x0000)
struct FRouteAvoidancePrimitive final
{
public:
	ERouteAvoidancePrimitiveType                  Type;                                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DiscLocation;                                      // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALandmassProceduralRoute*               ProceduralRoutes;                                  // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRouteAvoidancePrimitive) == 0x000008, "Wrong alignment on FRouteAvoidancePrimitive");
static_assert(sizeof(FRouteAvoidancePrimitive) == 0x000030, "Wrong size on FRouteAvoidancePrimitive");
static_assert(offsetof(FRouteAvoidancePrimitive, Type) == 0x000000, "Member 'FRouteAvoidancePrimitive::Type' has a wrong offset!");
static_assert(offsetof(FRouteAvoidancePrimitive, DiscLocation) == 0x000008, "Member 'FRouteAvoidancePrimitive::DiscLocation' has a wrong offset!");
static_assert(offsetof(FRouteAvoidancePrimitive, SplineComponent) == 0x000018, "Member 'FRouteAvoidancePrimitive::SplineComponent' has a wrong offset!");
static_assert(offsetof(FRouteAvoidancePrimitive, ProceduralRoutes) == 0x000020, "Member 'FRouteAvoidancePrimitive::ProceduralRoutes' has a wrong offset!");
static_assert(offsetof(FRouteAvoidancePrimitive, Distance) == 0x000028, "Member 'FRouteAvoidancePrimitive::Distance' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.ProceduralRouteJunoTileInfo
// 0x000C (0x000C - 0x0000)
struct FProceduralRouteJunoTileInfo final
{
public:
	int32                                         TileIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileId;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralRouteGuideSetSelectMethod          GuideSetSelectMethod;                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralRouteJunoTileInfo) == 0x000004, "Wrong alignment on FProceduralRouteJunoTileInfo");
static_assert(sizeof(FProceduralRouteJunoTileInfo) == 0x00000C, "Wrong size on FProceduralRouteJunoTileInfo");
static_assert(offsetof(FProceduralRouteJunoTileInfo, TileIndex) == 0x000000, "Member 'FProceduralRouteJunoTileInfo::TileIndex' has a wrong offset!");
static_assert(offsetof(FProceduralRouteJunoTileInfo, TileId) == 0x000004, "Member 'FProceduralRouteJunoTileInfo::TileId' has a wrong offset!");
static_assert(offsetof(FProceduralRouteJunoTileInfo, GuideSetSelectMethod) == 0x000008, "Member 'FProceduralRouteJunoTileInfo::GuideSetSelectMethod' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.ProceduralRiverAnchor
// 0x0018 (0x0018 - 0x0000)
struct FProceduralRiverAnchor final
{
public:
	struct FVector2D                              Location2D;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralRiverAnchorType                    Type;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupId;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralRiverAnchor) == 0x000008, "Wrong alignment on FProceduralRiverAnchor");
static_assert(sizeof(FProceduralRiverAnchor) == 0x000018, "Wrong size on FProceduralRiverAnchor");
static_assert(offsetof(FProceduralRiverAnchor, Location2D) == 0x000000, "Member 'FProceduralRiverAnchor::Location2D' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchor, Type) == 0x000010, "Member 'FProceduralRiverAnchor::Type' has a wrong offset!");
static_assert(offsetof(FProceduralRiverAnchor, GroupId) == 0x000014, "Member 'FProceduralRiverAnchor::GroupId' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.SegmentInterpResult
// 0x0138 (0x0138 - 0x0000)
struct FSegmentInterpResult final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosInterp;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LayerWidth;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftFalloff;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightFalloff;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftLayerFalloff;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightLayerFalloff;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Pos;                                               // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tangent;                                           // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Binormal;                                          // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftPos;                                           // 0x0070(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightPos;                                          // 0x0088(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FalloffLeftPos;                                    // 0x00A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FalloffRightPos;                                   // 0x00B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LayerLeftPos;                                      // 0x00D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LayerRightPos;                                     // 0x00E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LayerFalloffLeftPos;                               // 0x0100(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LayerFalloffRightPos;                              // 0x0118(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartEndFalloff;                                   // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSegmentInterpResult) == 0x000008, "Wrong alignment on FSegmentInterpResult");
static_assert(sizeof(FSegmentInterpResult) == 0x000138, "Wrong size on FSegmentInterpResult");
static_assert(offsetof(FSegmentInterpResult, Time) == 0x000000, "Member 'FSegmentInterpResult::Time' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, CosInterp) == 0x000004, "Member 'FSegmentInterpResult::CosInterp' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, Width) == 0x000008, "Member 'FSegmentInterpResult::Width' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, LayerWidth) == 0x00000C, "Member 'FSegmentInterpResult::LayerWidth' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, LeftFalloff) == 0x000010, "Member 'FSegmentInterpResult::LeftFalloff' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, RightFalloff) == 0x000014, "Member 'FSegmentInterpResult::RightFalloff' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, LeftLayerFalloff) == 0x000018, "Member 'FSegmentInterpResult::LeftLayerFalloff' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, RightLayerFalloff) == 0x00001C, "Member 'FSegmentInterpResult::RightLayerFalloff' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, Roll) == 0x000020, "Member 'FSegmentInterpResult::Roll' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, Pos) == 0x000028, "Member 'FSegmentInterpResult::Pos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, Tangent) == 0x000040, "Member 'FSegmentInterpResult::Tangent' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, Binormal) == 0x000058, "Member 'FSegmentInterpResult::Binormal' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, LeftPos) == 0x000070, "Member 'FSegmentInterpResult::LeftPos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, RightPos) == 0x000088, "Member 'FSegmentInterpResult::RightPos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, FalloffLeftPos) == 0x0000A0, "Member 'FSegmentInterpResult::FalloffLeftPos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, FalloffRightPos) == 0x0000B8, "Member 'FSegmentInterpResult::FalloffRightPos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, LayerLeftPos) == 0x0000D0, "Member 'FSegmentInterpResult::LayerLeftPos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, LayerRightPos) == 0x0000E8, "Member 'FSegmentInterpResult::LayerRightPos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, LayerFalloffLeftPos) == 0x000100, "Member 'FSegmentInterpResult::LayerFalloffLeftPos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, LayerFalloffRightPos) == 0x000118, "Member 'FSegmentInterpResult::LayerFalloffRightPos' has a wrong offset!");
static_assert(offsetof(FSegmentInterpResult, StartEndFalloff) == 0x000130, "Member 'FSegmentInterpResult::StartEndFalloff' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.InterpSegment
// 0x0070 (0x0070 - 0x0000)
struct FInterpSegment final
{
public:
	struct FInterpCurveVector                     SplineInfo;                                        // 0x0000(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineLength;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineLengthBeforeThis;                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartFalloffFraction;                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndFalloffFraction;                                // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWidth;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndWidth;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLayerWidth;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndLayerWidth;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffStartLeftSide;                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffEndLeftSide;                                // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffStartRightSide;                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffEndRightSide;                               // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffStartLeftSideLayer;                         // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffEndLeftSideLayer;                           // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffStartRightSideLayer;                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffEndRightSideLayer;                          // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRollDegrees;                                  // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRollDegrees;                                    // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRoll;                                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRoll;                                           // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMeshOffset;                                   // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndMeshOffset;                                     // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpSegment) == 0x000008, "Wrong alignment on FInterpSegment");
static_assert(sizeof(FInterpSegment) == 0x000070, "Wrong size on FInterpSegment");
static_assert(offsetof(FInterpSegment, SplineInfo) == 0x000000, "Member 'FInterpSegment::SplineInfo' has a wrong offset!");
static_assert(offsetof(FInterpSegment, SplineLength) == 0x000018, "Member 'FInterpSegment::SplineLength' has a wrong offset!");
static_assert(offsetof(FInterpSegment, SplineLengthBeforeThis) == 0x00001C, "Member 'FInterpSegment::SplineLengthBeforeThis' has a wrong offset!");
static_assert(offsetof(FInterpSegment, StartFalloffFraction) == 0x000020, "Member 'FInterpSegment::StartFalloffFraction' has a wrong offset!");
static_assert(offsetof(FInterpSegment, EndFalloffFraction) == 0x000024, "Member 'FInterpSegment::EndFalloffFraction' has a wrong offset!");
static_assert(offsetof(FInterpSegment, StartWidth) == 0x000028, "Member 'FInterpSegment::StartWidth' has a wrong offset!");
static_assert(offsetof(FInterpSegment, EndWidth) == 0x00002C, "Member 'FInterpSegment::EndWidth' has a wrong offset!");
static_assert(offsetof(FInterpSegment, StartLayerWidth) == 0x000030, "Member 'FInterpSegment::StartLayerWidth' has a wrong offset!");
static_assert(offsetof(FInterpSegment, EndLayerWidth) == 0x000034, "Member 'FInterpSegment::EndLayerWidth' has a wrong offset!");
static_assert(offsetof(FInterpSegment, FalloffStartLeftSide) == 0x000038, "Member 'FInterpSegment::FalloffStartLeftSide' has a wrong offset!");
static_assert(offsetof(FInterpSegment, FalloffEndLeftSide) == 0x00003C, "Member 'FInterpSegment::FalloffEndLeftSide' has a wrong offset!");
static_assert(offsetof(FInterpSegment, FalloffStartRightSide) == 0x000040, "Member 'FInterpSegment::FalloffStartRightSide' has a wrong offset!");
static_assert(offsetof(FInterpSegment, FalloffEndRightSide) == 0x000044, "Member 'FInterpSegment::FalloffEndRightSide' has a wrong offset!");
static_assert(offsetof(FInterpSegment, FalloffStartLeftSideLayer) == 0x000048, "Member 'FInterpSegment::FalloffStartLeftSideLayer' has a wrong offset!");
static_assert(offsetof(FInterpSegment, FalloffEndLeftSideLayer) == 0x00004C, "Member 'FInterpSegment::FalloffEndLeftSideLayer' has a wrong offset!");
static_assert(offsetof(FInterpSegment, FalloffStartRightSideLayer) == 0x000050, "Member 'FInterpSegment::FalloffStartRightSideLayer' has a wrong offset!");
static_assert(offsetof(FInterpSegment, FalloffEndRightSideLayer) == 0x000054, "Member 'FInterpSegment::FalloffEndRightSideLayer' has a wrong offset!");
static_assert(offsetof(FInterpSegment, StartRollDegrees) == 0x000058, "Member 'FInterpSegment::StartRollDegrees' has a wrong offset!");
static_assert(offsetof(FInterpSegment, EndRollDegrees) == 0x00005C, "Member 'FInterpSegment::EndRollDegrees' has a wrong offset!");
static_assert(offsetof(FInterpSegment, StartRoll) == 0x000060, "Member 'FInterpSegment::StartRoll' has a wrong offset!");
static_assert(offsetof(FInterpSegment, EndRoll) == 0x000064, "Member 'FInterpSegment::EndRoll' has a wrong offset!");
static_assert(offsetof(FInterpSegment, StartMeshOffset) == 0x000068, "Member 'FInterpSegment::StartMeshOffset' has a wrong offset!");
static_assert(offsetof(FInterpSegment, EndMeshOffset) == 0x00006C, "Member 'FInterpSegment::EndMeshOffset' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.BridgeSpawnInfo
// 0x0030 (0x0030 - 0x0000)
struct FBridgeSpawnInfo final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBridgeSpawnInfo) == 0x000008, "Wrong alignment on FBridgeSpawnInfo");
static_assert(sizeof(FBridgeSpawnInfo) == 0x000030, "Wrong size on FBridgeSpawnInfo");
static_assert(offsetof(FBridgeSpawnInfo, Start) == 0x000000, "Member 'FBridgeSpawnInfo::Start' has a wrong offset!");
static_assert(offsetof(FBridgeSpawnInfo, End) == 0x000018, "Member 'FBridgeSpawnInfo::End' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoPathfindContext
// 0x0010 (0x00C0 - 0x00B0)
struct FPCGJunoPathfindContext final : public FPCGContext
{
public:
	TWeakObjectPtr<class ALandmassProceduralRoute> LandmassProceduralRoute;                           // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPCGJunoPathfindContext) == 0x000008, "Wrong alignment on FPCGJunoPathfindContext");
static_assert(sizeof(FPCGJunoPathfindContext) == 0x0000C0, "Wrong size on FPCGJunoPathfindContext");
static_assert(offsetof(FPCGJunoPathfindContext, LandmassProceduralRoute) == 0x0000B0, "Member 'FPCGJunoPathfindContext::LandmassProceduralRoute' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoRoadAINavigationContext
// 0x0030 (0x00E0 - 0x00B0)
struct FPCGJunoRoadAINavigationContext final : public FPCGContext
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    RoadClusterClass;                                  // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    PatrolPathClass;                                   // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    PatrolPointClass;                                  // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPCGManagedActors*                      ManagedActors;                                     // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoRoadAINavigationContext) == 0x000008, "Wrong alignment on FPCGJunoRoadAINavigationContext");
static_assert(sizeof(FPCGJunoRoadAINavigationContext) == 0x0000E0, "Wrong size on FPCGJunoRoadAINavigationContext");
static_assert(offsetof(FPCGJunoRoadAINavigationContext, RoadClusterClass) == 0x0000C0, "Member 'FPCGJunoRoadAINavigationContext::RoadClusterClass' has a wrong offset!");
static_assert(offsetof(FPCGJunoRoadAINavigationContext, PatrolPathClass) == 0x0000C8, "Member 'FPCGJunoRoadAINavigationContext::PatrolPathClass' has a wrong offset!");
static_assert(offsetof(FPCGJunoRoadAINavigationContext, PatrolPointClass) == 0x0000D0, "Member 'FPCGJunoRoadAINavigationContext::PatrolPointClass' has a wrong offset!");
static_assert(offsetof(FPCGJunoRoadAINavigationContext, ManagedActors) == 0x0000D8, "Member 'FPCGJunoRoadAINavigationContext::ManagedActors' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoSpawnLivingWorldStaticPointTag
// 0x0038 (0x0038 - 0x0000)
struct FPCGJunoSpawnLivingWorldStaticPointTag final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   AttributeName;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinValue;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxValue;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoSpawnLivingWorldStaticPointTag) == 0x000008, "Wrong alignment on FPCGJunoSpawnLivingWorldStaticPointTag");
static_assert(sizeof(FPCGJunoSpawnLivingWorldStaticPointTag) == 0x000038, "Wrong size on FPCGJunoSpawnLivingWorldStaticPointTag");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointTag, Tags) == 0x000000, "Member 'FPCGJunoSpawnLivingWorldStaticPointTag::Tags' has a wrong offset!");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointTag, AttributeName) == 0x000020, "Member 'FPCGJunoSpawnLivingWorldStaticPointTag::AttributeName' has a wrong offset!");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointTag, MinValue) == 0x000028, "Member 'FPCGJunoSpawnLivingWorldStaticPointTag::MinValue' has a wrong offset!");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointTag, MaxValue) == 0x000030, "Member 'FPCGJunoSpawnLivingWorldStaticPointTag::MaxValue' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoSpawnLivingWorldStaticPointTagConditionSet
// 0x0018 (0x0018 - 0x0000)
struct FPCGJunoSpawnLivingWorldStaticPointTagConditionSet final
{
public:
	bool                                          bOverridePreviousTags;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExclusiveConditionalTags;                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPCGJunoSpawnLivingWorldStaticPointTag> ConditionalTags;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoSpawnLivingWorldStaticPointTagConditionSet) == 0x000008, "Wrong alignment on FPCGJunoSpawnLivingWorldStaticPointTagConditionSet");
static_assert(sizeof(FPCGJunoSpawnLivingWorldStaticPointTagConditionSet) == 0x000018, "Wrong size on FPCGJunoSpawnLivingWorldStaticPointTagConditionSet");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointTagConditionSet, bOverridePreviousTags) == 0x000000, "Member 'FPCGJunoSpawnLivingWorldStaticPointTagConditionSet::bOverridePreviousTags' has a wrong offset!");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointTagConditionSet, bExclusiveConditionalTags) == 0x000001, "Member 'FPCGJunoSpawnLivingWorldStaticPointTagConditionSet::bExclusiveConditionalTags' has a wrong offset!");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointTagConditionSet, ConditionalTags) == 0x000008, "Member 'FPCGJunoSpawnLivingWorldStaticPointTagConditionSet::ConditionalTags' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.PCGJunoSpawnLivingWorldStaticPointContext
// 0x0028 (0x00D8 - 0x00B0)
struct FPCGJunoSpawnLivingWorldStaticPointContext final : public FPCGContext
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    StaticPointClass;                                  // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    PointClusterClass;                                 // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPCGManagedActors*                      ManagedActors;                                     // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGJunoSpawnLivingWorldStaticPointContext) == 0x000008, "Wrong alignment on FPCGJunoSpawnLivingWorldStaticPointContext");
static_assert(sizeof(FPCGJunoSpawnLivingWorldStaticPointContext) == 0x0000D8, "Wrong size on FPCGJunoSpawnLivingWorldStaticPointContext");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointContext, StaticPointClass) == 0x0000C0, "Member 'FPCGJunoSpawnLivingWorldStaticPointContext::StaticPointClass' has a wrong offset!");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointContext, PointClusterClass) == 0x0000C8, "Member 'FPCGJunoSpawnLivingWorldStaticPointContext::PointClusterClass' has a wrong offset!");
static_assert(offsetof(FPCGJunoSpawnLivingWorldStaticPointContext, ManagedActors) == 0x0000D0, "Member 'FPCGJunoSpawnLivingWorldStaticPointContext::ManagedActors' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldConditionBiome
// 0x0038 (0x0048 - 0x0010)
struct FJunoWorldConditionBiome final : public FWorldConditionCommonActorBase
{
public:
	struct FWorldConditionContextDataRef          ActorRef;                                          // 0x0010(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EJunoBiome>                            AllowedBiomes;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanBeSecondaryBiome;                              // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJunoBiomeHabitat>                     AllowedHabitats;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanBeSecondaryHabitat;                            // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoWorldConditionBiome) == 0x000008, "Wrong alignment on FJunoWorldConditionBiome");
static_assert(sizeof(FJunoWorldConditionBiome) == 0x000048, "Wrong size on FJunoWorldConditionBiome");
static_assert(offsetof(FJunoWorldConditionBiome, ActorRef) == 0x000010, "Member 'FJunoWorldConditionBiome::ActorRef' has a wrong offset!");
static_assert(offsetof(FJunoWorldConditionBiome, AllowedBiomes) == 0x000018, "Member 'FJunoWorldConditionBiome::AllowedBiomes' has a wrong offset!");
static_assert(offsetof(FJunoWorldConditionBiome, bCanBeSecondaryBiome) == 0x000028, "Member 'FJunoWorldConditionBiome::bCanBeSecondaryBiome' has a wrong offset!");
static_assert(offsetof(FJunoWorldConditionBiome, AllowedHabitats) == 0x000030, "Member 'FJunoWorldConditionBiome::AllowedHabitats' has a wrong offset!");
static_assert(offsetof(FJunoWorldConditionBiome, bCanBeSecondaryHabitat) == 0x000040, "Member 'FJunoWorldConditionBiome::bCanBeSecondaryHabitat' has a wrong offset!");

// ScriptStruct JunoProceduralWorld.JunoWorldRegistryEntry
// 0x0040 (0x0040 - 0x0000)
struct FJunoWorldRegistryEntry final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0018(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoWorldRegistryEntry) == 0x000008, "Wrong alignment on FJunoWorldRegistryEntry");
static_assert(sizeof(FJunoWorldRegistryEntry) == 0x000040, "Wrong size on FJunoWorldRegistryEntry");
static_assert(offsetof(FJunoWorldRegistryEntry, Location) == 0x000000, "Member 'FJunoWorldRegistryEntry::Location' has a wrong offset!");
static_assert(offsetof(FJunoWorldRegistryEntry, GameplayTags) == 0x000018, "Member 'FJunoWorldRegistryEntry::GameplayTags' has a wrong offset!");

}

