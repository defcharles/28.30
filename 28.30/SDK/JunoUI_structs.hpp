#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JunoUI

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "JunoLowMemoryFallbackRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "JunoGameNative_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Enum JunoUI.EBlockedDirection
// NumValues: 0x0004
enum class EBlockedDirection : uint8
{
	Top                                      = 0,
	Right                                    = 1,
	Bottom                                   = 2,
	Left                                     = 3,
};

// Enum JunoUI.EJunoBangVisibility
// NumValues: 0x0003
enum class EJunoBangVisibility : uint8
{
	Hidden                                   = 0,
	UnviewedBang                             = 1,
	UnacquiredBang                           = 2,
};

// Enum JunoUI.EBuildingLimitationState
// NumValues: 0x0004
enum class EBuildingLimitationState : uint8
{
	WithinLimits                             = 0,
	ThresholdCrossed                         = 1,
	NearingMaxOut                            = 2,
	MaxedOut                                 = 3,
};

// Enum JunoUI.EDisassemblingStationInventoryState
// NumValues: 0x0003
enum class EDisassemblingStationInventoryState : uint8
{
	CanCraft                                 = 0,
	InputIsEmpty                             = 1,
	OutputFull                               = 2,
};

// Enum JunoUI.EJunoEnchantmentScreenState
// NumValues: 0x0003
enum class EJunoEnchantmentScreenState : uint8
{
	WeaponSelection                          = 0,
	EnchantmentSelection                     = 1,
	Count                                    = 2,
};

// Enum JunoUI.EJunoEnchantButtonState
// NumValues: 0x0005
enum class EJunoEnchantButtonState : uint8
{
	CanEnchant                               = 0,
	NotEnoughResources                       = 1,
	NoAvailableEnchantments                  = 2,
	SlotsFull                                = 3,
	CanCancelEnchant                         = 4,
};

// Enum JunoUI.EJunoEnchantmentState
// NumValues: 0x0004
enum class EJunoEnchantmentState : uint8
{
	Empty                                    = 0,
	Occupied                                 = 1,
	Preview                                  = 2,
	Updated                                  = 3,
};

// Enum JunoUI.EJunoHudMenuScreen
// NumValues: 0x0005
enum class EJunoHudMenuScreen : uint8
{
	InventoryScreen                          = 0,
	CraftingScreen                           = 1,
	CollectionScreen                         = 2,
	BuildingScreen                           = 3,
	Max_None                                 = 4,
};

// Enum JunoUI.EJunoSwapItemType
// NumValues: 0x0005
enum class EJunoSwapItemType : uint8
{
	None                                     = 0,
	Source                                   = 1,
	SelectedDestination                      = 2,
	PotentialDestination                     = 3,
	GearDestinationInvalid                   = 4,
};

// Enum JunoUI.EJunoBedAssignmentActionType
// NumValues: 0x0004
enum class EJunoBedAssignmentActionType : uint8
{
	None                                     = 0,
	AssignEmpty                              = 1,
	ReassignExisting                         = 2,
	UnassignExisting                         = 3,
};

// Enum JunoUI.EJunoCraftButtonState
// NumValues: 0x0003
enum class EJunoCraftButtonState : uint8
{
	CanCraft                                 = 0,
	CannotCraft                              = 1,
	StopCraft                                = 2,
};

// Enum JunoUI.ESelectRecipeButtonState
// NumValues: 0x0003
enum class ESelectRecipeButtonState : uint8
{
	SelectRecipeHeroState                    = 0,
	SelectRecipeCommonState                  = 1,
	DepositState                             = 2,
};

// Enum JunoUI.ECraftingStationsInventoryState
// NumValues: 0x0003
enum class ECraftingStationsInventoryState : uint8
{
	CanCraft                                 = 0,
	MissingIngredients                       = 1,
	OutputFull                               = 2,
};

// Enum JunoUI.EJunoInventoryModalOperation
// NumValues: 0x0003
enum class EJunoInventoryModalOperation : uint8
{
	None                                     = 0,
	MoveAll                                  = 1,
	MergeAll                                 = 2,
};

// Enum JunoUI.EJunoMapMarkerCustomizationEntryType
// NumValues: 0x0002
enum class EJunoMapMarkerCustomizationEntryType : uint8
{
	Icon                                     = 0,
	Color                                    = 1,
};

// Enum JunoUI.EJunoPickupStreamAnim
// NumValues: 0x0003
enum class EJunoPickupStreamAnim : uint8
{
	None                                     = 0,
	Intro                                    = 1,
	Update                                   = 2,
};

// Enum JunoUI.EJunoHealthBarType
// NumValues: 0x0002
enum class EJunoHealthBarType : uint8
{
	Health                                   = 0,
	Overshield                               = 1,
};

// ScriptStruct JunoUI.RecipeFocus
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FRecipeFocus final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecipeFocus) == 0x000004, "Wrong alignment on FRecipeFocus");
static_assert(sizeof(FRecipeFocus) == 0x000008, "Wrong size on FRecipeFocus");

// ScriptStruct JunoUI.RecipeCategoryChange
// 0x0020 (0x0020 - 0x0000)
struct FRecipeCategoryChange final
{
public:
	struct FGameplayTagContainer                  FilterTags;                                        // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecipeCategoryChange) == 0x000008, "Wrong alignment on FRecipeCategoryChange");
static_assert(sizeof(FRecipeCategoryChange) == 0x000020, "Wrong size on FRecipeCategoryChange");
static_assert(offsetof(FRecipeCategoryChange, FilterTags) == 0x000000, "Member 'FRecipeCategoryChange::FilterTags' has a wrong offset!");

// ScriptStruct JunoUI.CanCraftRecipeChange
// 0x0001 (0x0001 - 0x0000)
struct FCanCraftRecipeChange final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCanCraftRecipeChange) == 0x000001, "Wrong alignment on FCanCraftRecipeChange");
static_assert(sizeof(FCanCraftRecipeChange) == 0x000001, "Wrong size on FCanCraftRecipeChange");

// ScriptStruct JunoUI.JunoBiomeUIDisplayData
// 0x0038 (0x0038 - 0x0000)
struct FJunoBiomeUIDisplayData final
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 Icon;                                              // 0x0018(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoBiomeUIDisplayData) == 0x000008, "Wrong alignment on FJunoBiomeUIDisplayData");
static_assert(sizeof(FJunoBiomeUIDisplayData) == 0x000038, "Wrong size on FJunoBiomeUIDisplayData");
static_assert(offsetof(FJunoBiomeUIDisplayData, DisplayText) == 0x000000, "Member 'FJunoBiomeUIDisplayData::DisplayText' has a wrong offset!");
static_assert(offsetof(FJunoBiomeUIDisplayData, Icon) == 0x000018, "Member 'FJunoBiomeUIDisplayData::Icon' has a wrong offset!");

// ScriptStruct JunoUI.JunoMemoryMessage
// 0x0001 (0x0001 - 0x0000)
struct FJunoMemoryMessage final
{
public:
	EBuildingLimitationState                      BuildingLimitationState;                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoMemoryMessage) == 0x000001, "Wrong alignment on FJunoMemoryMessage");
static_assert(sizeof(FJunoMemoryMessage) == 0x000001, "Wrong size on FJunoMemoryMessage");
static_assert(offsetof(FJunoMemoryMessage, BuildingLimitationState) == 0x000000, "Member 'FJunoMemoryMessage::BuildingLimitationState' has a wrong offset!");

// ScriptStruct JunoUI.JunoBuildingMemoryThreshold
// 0x0008 (0x0010 - 0x0008)
struct FJunoBuildingMemoryThreshold final : public FTableRowBase
{
public:
	int32                                         BuildingPercentLimit;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoLowMemoryState                           MemoryStateLimit;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingLimitationState                      LimitationState;                                   // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoBuildingMemoryThreshold) == 0x000008, "Wrong alignment on FJunoBuildingMemoryThreshold");
static_assert(sizeof(FJunoBuildingMemoryThreshold) == 0x000010, "Wrong size on FJunoBuildingMemoryThreshold");
static_assert(offsetof(FJunoBuildingMemoryThreshold, BuildingPercentLimit) == 0x000008, "Member 'FJunoBuildingMemoryThreshold::BuildingPercentLimit' has a wrong offset!");
static_assert(offsetof(FJunoBuildingMemoryThreshold, MemoryStateLimit) == 0x00000C, "Member 'FJunoBuildingMemoryThreshold::MemoryStateLimit' has a wrong offset!");
static_assert(offsetof(FJunoBuildingMemoryThreshold, LimitationState) == 0x00000D, "Member 'FJunoBuildingMemoryThreshold::LimitationState' has a wrong offset!");

// ScriptStruct JunoUI.JunoGuidedBuildingUIData
// 0x000C (0x000C - 0x0000)
struct FJunoGuidedBuildingUIData final
{
public:
	bool                                          bIsGuidedBuildingSet;                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalStagesInSet;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraIngredientsInSet;                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoGuidedBuildingUIData) == 0x000004, "Wrong alignment on FJunoGuidedBuildingUIData");
static_assert(sizeof(FJunoGuidedBuildingUIData) == 0x00000C, "Wrong size on FJunoGuidedBuildingUIData");
static_assert(offsetof(FJunoGuidedBuildingUIData, bIsGuidedBuildingSet) == 0x000000, "Member 'FJunoGuidedBuildingUIData::bIsGuidedBuildingSet' has a wrong offset!");
static_assert(offsetof(FJunoGuidedBuildingUIData, TotalStagesInSet) == 0x000004, "Member 'FJunoGuidedBuildingUIData::TotalStagesInSet' has a wrong offset!");
static_assert(offsetof(FJunoGuidedBuildingUIData, ExtraIngredientsInSet) == 0x000008, "Member 'FJunoGuidedBuildingUIData::ExtraIngredientsInSet' has a wrong offset!");

// ScriptStruct JunoUI.JunoMarkerMaterialInstances
// 0x0010 (0x0010 - 0x0000)
struct FJunoMarkerMaterialInstances final
{
public:
	TArray<class UMaterialInstanceDynamic*>       Instances;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoMarkerMaterialInstances) == 0x000008, "Wrong alignment on FJunoMarkerMaterialInstances");
static_assert(sizeof(FJunoMarkerMaterialInstances) == 0x000010, "Wrong size on FJunoMarkerMaterialInstances");
static_assert(offsetof(FJunoMarkerMaterialInstances, Instances) == 0x000000, "Member 'FJunoMarkerMaterialInstances::Instances' has a wrong offset!");

// ScriptStruct JunoUI.TrackedTouchData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FTrackedTouchData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrackedTouchData) == 0x000004, "Wrong alignment on FTrackedTouchData");
static_assert(sizeof(FTrackedTouchData) == 0x00000C, "Wrong size on FTrackedTouchData");

// ScriptStruct JunoUI.JunoMapZoomBounds
// 0x0008 (0x0008 - 0x0000)
struct FJunoMapZoomBounds final
{
public:
	float                                         MinZoom;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumZoom;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoMapZoomBounds) == 0x000004, "Wrong alignment on FJunoMapZoomBounds");
static_assert(sizeof(FJunoMapZoomBounds) == 0x000008, "Wrong size on FJunoMapZoomBounds");
static_assert(offsetof(FJunoMapZoomBounds, MinZoom) == 0x000000, "Member 'FJunoMapZoomBounds::MinZoom' has a wrong offset!");
static_assert(offsetof(FJunoMapZoomBounds, MaximumZoom) == 0x000004, "Member 'FJunoMapZoomBounds::MaximumZoom' has a wrong offset!");

// ScriptStruct JunoUI.JunoHudMenuTabRequest
// 0x0030 (0x0030 - 0x0000)
struct FJunoHudMenuTabRequest final
{
public:
	class FName                                   NameId;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommonButtonBase>          ButtonType;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommonUserWidget>          ContentType;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoHudMenuTabRequest) == 0x000008, "Wrong alignment on FJunoHudMenuTabRequest");
static_assert(sizeof(FJunoHudMenuTabRequest) == 0x000030, "Wrong size on FJunoHudMenuTabRequest");
static_assert(offsetof(FJunoHudMenuTabRequest, NameId) == 0x000000, "Member 'FJunoHudMenuTabRequest::NameId' has a wrong offset!");
static_assert(offsetof(FJunoHudMenuTabRequest, DisplayName) == 0x000008, "Member 'FJunoHudMenuTabRequest::DisplayName' has a wrong offset!");
static_assert(offsetof(FJunoHudMenuTabRequest, ButtonType) == 0x000020, "Member 'FJunoHudMenuTabRequest::ButtonType' has a wrong offset!");
static_assert(offsetof(FJunoHudMenuTabRequest, ContentType) == 0x000028, "Member 'FJunoHudMenuTabRequest::ContentType' has a wrong offset!");

// ScriptStruct JunoUI.JunoIngredientInfo
// 0x0028 (0x0028 - 0x0000)
struct FJunoIngredientInfo final
{
public:
	TSoftObjectPtr<class UFortItemDefinition>     Ingredient;                                        // 0x0000(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredCount;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnedCount;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoIngredientInfo) == 0x000008, "Wrong alignment on FJunoIngredientInfo");
static_assert(sizeof(FJunoIngredientInfo) == 0x000028, "Wrong size on FJunoIngredientInfo");
static_assert(offsetof(FJunoIngredientInfo, Ingredient) == 0x000000, "Member 'FJunoIngredientInfo::Ingredient' has a wrong offset!");
static_assert(offsetof(FJunoIngredientInfo, RequiredCount) == 0x000020, "Member 'FJunoIngredientInfo::RequiredCount' has a wrong offset!");
static_assert(offsetof(FJunoIngredientInfo, OwnedCount) == 0x000024, "Member 'FJunoIngredientInfo::OwnedCount' has a wrong offset!");

// ScriptStruct JunoUI.JunoInventoryGroupUIData
// 0x0040 (0x0040 - 0x0000)
struct FJunoInventoryGroupUIData final
{
public:
	struct FGameplayTag                           GroupTag;                                          // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 OptionalIcon;                                      // 0x0020(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoInventoryGroupUIData) == 0x000008, "Wrong alignment on FJunoInventoryGroupUIData");
static_assert(sizeof(FJunoInventoryGroupUIData) == 0x000040, "Wrong size on FJunoInventoryGroupUIData");
static_assert(offsetof(FJunoInventoryGroupUIData, GroupTag) == 0x000000, "Member 'FJunoInventoryGroupUIData::GroupTag' has a wrong offset!");
static_assert(offsetof(FJunoInventoryGroupUIData, DisplayName) == 0x000008, "Member 'FJunoInventoryGroupUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FJunoInventoryGroupUIData, OptionalIcon) == 0x000020, "Member 'FJunoInventoryGroupUIData::OptionalIcon' has a wrong offset!");

// ScriptStruct JunoUI.JunoInventoryGroupUIDataList
// 0x0010 (0x0010 - 0x0000)
struct FJunoInventoryGroupUIDataList final
{
public:
	TArray<struct FJunoInventoryGroupUIData>      GroupDataList;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoInventoryGroupUIDataList) == 0x000008, "Wrong alignment on FJunoInventoryGroupUIDataList");
static_assert(sizeof(FJunoInventoryGroupUIDataList) == 0x000010, "Wrong size on FJunoInventoryGroupUIDataList");
static_assert(offsetof(FJunoInventoryGroupUIDataList, GroupDataList) == 0x000000, "Member 'FJunoInventoryGroupUIDataList::GroupDataList' has a wrong offset!");

// ScriptStruct JunoUI.JunoItemSpawnerListEntries
// 0x0010 (0x0010 - 0x0000)
struct FJunoItemSpawnerListEntries final
{
public:
	TArray<class UJunoItemSpawnerListEntry*>      ListEntries;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoItemSpawnerListEntries) == 0x000008, "Wrong alignment on FJunoItemSpawnerListEntries");
static_assert(sizeof(FJunoItemSpawnerListEntries) == 0x000010, "Wrong size on FJunoItemSpawnerListEntries");
static_assert(offsetof(FJunoItemSpawnerListEntries, ListEntries) == 0x000000, "Member 'FJunoItemSpawnerListEntries::ListEntries' has a wrong offset!");

// ScriptStruct JunoUI.JunoItemSpawnerItemTagOrder
// 0x0010 (0x0010 - 0x0000)
struct FJunoItemSpawnerItemTagOrder final
{
public:
	TArray<struct FGameplayTag>                   ItemTags;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoItemSpawnerItemTagOrder) == 0x000008, "Wrong alignment on FJunoItemSpawnerItemTagOrder");
static_assert(sizeof(FJunoItemSpawnerItemTagOrder) == 0x000010, "Wrong size on FJunoItemSpawnerItemTagOrder");
static_assert(offsetof(FJunoItemSpawnerItemTagOrder, ItemTags) == 0x000000, "Member 'FJunoItemSpawnerItemTagOrder::ItemTags' has a wrong offset!");

// ScriptStruct JunoUI.JunoModalSceneOperation
// 0x0010 (0x0010 - 0x0000)
struct FJunoModalSceneOperation final
{
public:
	class UDynamicUIScene*                        ModalScene;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Payload;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoModalSceneOperation) == 0x000008, "Wrong alignment on FJunoModalSceneOperation");
static_assert(sizeof(FJunoModalSceneOperation) == 0x000010, "Wrong size on FJunoModalSceneOperation");
static_assert(offsetof(FJunoModalSceneOperation, ModalScene) == 0x000000, "Member 'FJunoModalSceneOperation::ModalScene' has a wrong offset!");
static_assert(offsetof(FJunoModalSceneOperation, Payload) == 0x000008, "Member 'FJunoModalSceneOperation::Payload' has a wrong offset!");

// ScriptStruct JunoUI.JunoModalSelectionChoice
// 0x0038 (0x0038 - 0x0000)
struct FJunoModalSelectionChoice final
{
public:
	class FText                                   SelectionTitle;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Action;                                            // 0x0018(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              SelectionDelegate;                                 // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoModalSelectionChoice) == 0x000008, "Wrong alignment on FJunoModalSelectionChoice");
static_assert(sizeof(FJunoModalSelectionChoice) == 0x000038, "Wrong size on FJunoModalSelectionChoice");
static_assert(offsetof(FJunoModalSelectionChoice, SelectionTitle) == 0x000000, "Member 'FJunoModalSelectionChoice::SelectionTitle' has a wrong offset!");
static_assert(offsetof(FJunoModalSelectionChoice, Action) == 0x000018, "Member 'FJunoModalSelectionChoice::Action' has a wrong offset!");
static_assert(offsetof(FJunoModalSelectionChoice, SelectionDelegate) == 0x000028, "Member 'FJunoModalSelectionChoice::SelectionDelegate' has a wrong offset!");

// ScriptStruct JunoUI.JunoQuickBuildSlotData
// 0x0038 (0x0038 - 0x0000)
struct FJunoQuickBuildSlotData final
{
public:
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0000(0x0020)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoQuickBuildSlotData) == 0x000008, "Wrong alignment on FJunoQuickBuildSlotData");
static_assert(sizeof(FJunoQuickBuildSlotData) == 0x000038, "Wrong size on FJunoQuickBuildSlotData");
static_assert(offsetof(FJunoQuickBuildSlotData, Icon) == 0x000000, "Member 'FJunoQuickBuildSlotData::Icon' has a wrong offset!");
static_assert(offsetof(FJunoQuickBuildSlotData, DisplayName) == 0x000020, "Member 'FJunoQuickBuildSlotData::DisplayName' has a wrong offset!");

// ScriptStruct JunoUI.CountUnviewedRecipesInCategoryArgs
// 0x0020 (0x0020 - 0x0000)
struct FCountUnviewedRecipesInCategoryArgs final
{
public:
	class AFortPlayerController*                  PlayerController;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CraftingObject;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CategoryTag;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SubCategoryTag;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyKnownRecipes;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCountUnacquiredRecipes;                           // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCountUnviewedRecipesInCategoryArgs) == 0x000008, "Wrong alignment on FCountUnviewedRecipesInCategoryArgs");
static_assert(sizeof(FCountUnviewedRecipesInCategoryArgs) == 0x000020, "Wrong size on FCountUnviewedRecipesInCategoryArgs");
static_assert(offsetof(FCountUnviewedRecipesInCategoryArgs, PlayerController) == 0x000000, "Member 'FCountUnviewedRecipesInCategoryArgs::PlayerController' has a wrong offset!");
static_assert(offsetof(FCountUnviewedRecipesInCategoryArgs, CraftingObject) == 0x000008, "Member 'FCountUnviewedRecipesInCategoryArgs::CraftingObject' has a wrong offset!");
static_assert(offsetof(FCountUnviewedRecipesInCategoryArgs, CategoryTag) == 0x000010, "Member 'FCountUnviewedRecipesInCategoryArgs::CategoryTag' has a wrong offset!");
static_assert(offsetof(FCountUnviewedRecipesInCategoryArgs, SubCategoryTag) == 0x000014, "Member 'FCountUnviewedRecipesInCategoryArgs::SubCategoryTag' has a wrong offset!");
static_assert(offsetof(FCountUnviewedRecipesInCategoryArgs, bOnlyKnownRecipes) == 0x000018, "Member 'FCountUnviewedRecipesInCategoryArgs::bOnlyKnownRecipes' has a wrong offset!");
static_assert(offsetof(FCountUnviewedRecipesInCategoryArgs, bCountUnacquiredRecipes) == 0x000019, "Member 'FCountUnviewedRecipesInCategoryArgs::bCountUnacquiredRecipes' has a wrong offset!");

// ScriptStruct JunoUI.JunoNPCStateUIData
// 0x0048 (0x0048 - 0x0000)
struct FJunoNPCStateUIData final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UObject>                 PrimaryIcon;                                       // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 SecondaryIcon;                                     // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoNPCStateUIData) == 0x000008, "Wrong alignment on FJunoNPCStateUIData");
static_assert(sizeof(FJunoNPCStateUIData) == 0x000048, "Wrong size on FJunoNPCStateUIData");
static_assert(offsetof(FJunoNPCStateUIData, Priority) == 0x000000, "Member 'FJunoNPCStateUIData::Priority' has a wrong offset!");
static_assert(offsetof(FJunoNPCStateUIData, PrimaryIcon) == 0x000008, "Member 'FJunoNPCStateUIData::PrimaryIcon' has a wrong offset!");
static_assert(offsetof(FJunoNPCStateUIData, SecondaryIcon) == 0x000028, "Member 'FJunoNPCStateUIData::SecondaryIcon' has a wrong offset!");

// ScriptStruct JunoUI.JunoVillageRewardEntryInfo
// 0x0080 (0x0080 - 0x0000)
struct FJunoVillageRewardEntryInfo final
{
public:
	int32                                         AwesomeLevel;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAwesomePerkReward                     AwesomePerkReward;                                 // 0x0008(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         NewVillagerSlotCount;                              // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJunoKnowledgeBundle*>           KnowledgeBundles;                                  // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ButtonIndex;                                       // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexWithinGroup;                                  // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ButtonsWithinGroup;                                // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoVillageRewardEntryInfo) == 0x000008, "Wrong alignment on FJunoVillageRewardEntryInfo");
static_assert(sizeof(FJunoVillageRewardEntryInfo) == 0x000080, "Wrong size on FJunoVillageRewardEntryInfo");
static_assert(offsetof(FJunoVillageRewardEntryInfo, AwesomeLevel) == 0x000000, "Member 'FJunoVillageRewardEntryInfo::AwesomeLevel' has a wrong offset!");
static_assert(offsetof(FJunoVillageRewardEntryInfo, AwesomePerkReward) == 0x000008, "Member 'FJunoVillageRewardEntryInfo::AwesomePerkReward' has a wrong offset!");
static_assert(offsetof(FJunoVillageRewardEntryInfo, NewVillagerSlotCount) == 0x000058, "Member 'FJunoVillageRewardEntryInfo::NewVillagerSlotCount' has a wrong offset!");
static_assert(offsetof(FJunoVillageRewardEntryInfo, KnowledgeBundles) == 0x000060, "Member 'FJunoVillageRewardEntryInfo::KnowledgeBundles' has a wrong offset!");
static_assert(offsetof(FJunoVillageRewardEntryInfo, ButtonIndex) == 0x000070, "Member 'FJunoVillageRewardEntryInfo::ButtonIndex' has a wrong offset!");
static_assert(offsetof(FJunoVillageRewardEntryInfo, IndexWithinGroup) == 0x000074, "Member 'FJunoVillageRewardEntryInfo::IndexWithinGroup' has a wrong offset!");
static_assert(offsetof(FJunoVillageRewardEntryInfo, ButtonsWithinGroup) == 0x000078, "Member 'FJunoVillageRewardEntryInfo::ButtonsWithinGroup' has a wrong offset!");

// ScriptStruct JunoUI.JunoFreeBuildCategoryUIDataEntry
// 0x0058 (0x0058 - 0x0000)
struct FJunoFreeBuildCategoryUIDataEntry final
{
public:
	struct FGameplayTag                           CategoryTag;                                       // 0x0000(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              CategoryIcon;                                      // 0x0008(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CategoryTitle;                                     // 0x0028(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CategoryDescription;                               // 0x0040(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoFreeBuildCategoryUIDataEntry) == 0x000008, "Wrong alignment on FJunoFreeBuildCategoryUIDataEntry");
static_assert(sizeof(FJunoFreeBuildCategoryUIDataEntry) == 0x000058, "Wrong size on FJunoFreeBuildCategoryUIDataEntry");
static_assert(offsetof(FJunoFreeBuildCategoryUIDataEntry, CategoryTag) == 0x000000, "Member 'FJunoFreeBuildCategoryUIDataEntry::CategoryTag' has a wrong offset!");
static_assert(offsetof(FJunoFreeBuildCategoryUIDataEntry, CategoryIcon) == 0x000008, "Member 'FJunoFreeBuildCategoryUIDataEntry::CategoryIcon' has a wrong offset!");
static_assert(offsetof(FJunoFreeBuildCategoryUIDataEntry, CategoryTitle) == 0x000028, "Member 'FJunoFreeBuildCategoryUIDataEntry::CategoryTitle' has a wrong offset!");
static_assert(offsetof(FJunoFreeBuildCategoryUIDataEntry, CategoryDescription) == 0x000040, "Member 'FJunoFreeBuildCategoryUIDataEntry::CategoryDescription' has a wrong offset!");

// ScriptStruct JunoUI.JunoFreeBuildSubCategoryUIDataEntry
// 0x0020 (0x0020 - 0x0000)
struct FJunoFreeBuildSubCategoryUIDataEntry final
{
public:
	struct FGameplayTag                           SubCategoryTag;                                    // 0x0000(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SubCategoryTitle;                                  // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoFreeBuildSubCategoryUIDataEntry) == 0x000008, "Wrong alignment on FJunoFreeBuildSubCategoryUIDataEntry");
static_assert(sizeof(FJunoFreeBuildSubCategoryUIDataEntry) == 0x000020, "Wrong size on FJunoFreeBuildSubCategoryUIDataEntry");
static_assert(offsetof(FJunoFreeBuildSubCategoryUIDataEntry, SubCategoryTag) == 0x000000, "Member 'FJunoFreeBuildSubCategoryUIDataEntry::SubCategoryTag' has a wrong offset!");
static_assert(offsetof(FJunoFreeBuildSubCategoryUIDataEntry, SubCategoryTitle) == 0x000008, "Member 'FJunoFreeBuildSubCategoryUIDataEntry::SubCategoryTitle' has a wrong offset!");

// ScriptStruct JunoUI.GridListSlotInfo
// 0x0024 (0x0024 - 0x0000)
struct FGridListSlotInfo final
{
public:
	class FName                                   SlotType;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsPerRow;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                ItemPadding;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridListSlotInfo) == 0x000004, "Wrong alignment on FGridListSlotInfo");
static_assert(sizeof(FGridListSlotInfo) == 0x000024, "Wrong size on FGridListSlotInfo");
static_assert(offsetof(FGridListSlotInfo, SlotType) == 0x000000, "Member 'FGridListSlotInfo::SlotType' has a wrong offset!");
static_assert(offsetof(FGridListSlotInfo, Height) == 0x000004, "Member 'FGridListSlotInfo::Height' has a wrong offset!");
static_assert(offsetof(FGridListSlotInfo, Width) == 0x000008, "Member 'FGridListSlotInfo::Width' has a wrong offset!");
static_assert(offsetof(FGridListSlotInfo, ItemsPerRow) == 0x00000C, "Member 'FGridListSlotInfo::ItemsPerRow' has a wrong offset!");
static_assert(offsetof(FGridListSlotInfo, ItemPadding) == 0x000010, "Member 'FGridListSlotInfo::ItemPadding' has a wrong offset!");

// ScriptStruct JunoUI.GridListViewInfo
// 0x0030 (0x0030 - 0x0000)
struct FGridListViewInfo final
{
public:
	TSubclassOf<class UUserWidget>                UserWidgetClass;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGridListSlotInfo                      GridListSlotInfo;                                  // 0x0008(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridListViewInfo) == 0x000008, "Wrong alignment on FGridListViewInfo");
static_assert(sizeof(FGridListViewInfo) == 0x000030, "Wrong size on FGridListViewInfo");
static_assert(offsetof(FGridListViewInfo, UserWidgetClass) == 0x000000, "Member 'FGridListViewInfo::UserWidgetClass' has a wrong offset!");
static_assert(offsetof(FGridListViewInfo, GridListSlotInfo) == 0x000008, "Member 'FGridListViewInfo::GridListSlotInfo' has a wrong offset!");

// ScriptStruct JunoUI.JunoCraftingStationUIDataEntry
// 0x00F0 (0x00F0 - 0x0000)
struct FJunoCraftingStationUIDataEntry final
{
public:
	struct FGameplayTag                           SourceTag;                                         // 0x0000(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CraftingObjectRef;                                 // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            CraftStationIcon;                                  // 0x0030(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoCraftingStationUIDataEntry) == 0x000010, "Wrong alignment on FJunoCraftingStationUIDataEntry");
static_assert(sizeof(FJunoCraftingStationUIDataEntry) == 0x0000F0, "Wrong size on FJunoCraftingStationUIDataEntry");
static_assert(offsetof(FJunoCraftingStationUIDataEntry, SourceTag) == 0x000000, "Member 'FJunoCraftingStationUIDataEntry::SourceTag' has a wrong offset!");
static_assert(offsetof(FJunoCraftingStationUIDataEntry, CraftingObjectRef) == 0x000008, "Member 'FJunoCraftingStationUIDataEntry::CraftingObjectRef' has a wrong offset!");
static_assert(offsetof(FJunoCraftingStationUIDataEntry, CraftStationIcon) == 0x000030, "Member 'FJunoCraftingStationUIDataEntry::CraftStationIcon' has a wrong offset!");

// ScriptStruct JunoUI.GridListSlotInfoContainer
// 0x0010 (0x0010 - 0x0000)
struct FGridListSlotInfoContainer final
{
public:
	TArray<struct FGridListSlotInfo>              GridListInfo;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridListSlotInfoContainer) == 0x000008, "Wrong alignment on FGridListSlotInfoContainer");
static_assert(sizeof(FGridListSlotInfoContainer) == 0x000010, "Wrong size on FGridListSlotInfoContainer");
static_assert(offsetof(FGridListSlotInfoContainer, GridListInfo) == 0x000000, "Member 'FGridListSlotInfoContainer::GridListInfo' has a wrong offset!");

// ScriptStruct JunoUI.JunoModalDescription
// 0x0088 (0x0088 - 0x0000)
struct FJunoModalDescription final
{
public:
	class UDynamicUIScene*                        ModalScene;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ConfirmButtonText;                                 // 0x0038(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CancelButtonText;                                  // 0x0050(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    ConfirmAction;                                     // 0x0068(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    CancelAction;                                      // 0x0078(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoModalDescription) == 0x000008, "Wrong alignment on FJunoModalDescription");
static_assert(sizeof(FJunoModalDescription) == 0x000088, "Wrong size on FJunoModalDescription");
static_assert(offsetof(FJunoModalDescription, ModalScene) == 0x000000, "Member 'FJunoModalDescription::ModalScene' has a wrong offset!");
static_assert(offsetof(FJunoModalDescription, Title) == 0x000008, "Member 'FJunoModalDescription::Title' has a wrong offset!");
static_assert(offsetof(FJunoModalDescription, Description) == 0x000020, "Member 'FJunoModalDescription::Description' has a wrong offset!");
static_assert(offsetof(FJunoModalDescription, ConfirmButtonText) == 0x000038, "Member 'FJunoModalDescription::ConfirmButtonText' has a wrong offset!");
static_assert(offsetof(FJunoModalDescription, CancelButtonText) == 0x000050, "Member 'FJunoModalDescription::CancelButtonText' has a wrong offset!");
static_assert(offsetof(FJunoModalDescription, ConfirmAction) == 0x000068, "Member 'FJunoModalDescription::ConfirmAction' has a wrong offset!");
static_assert(offsetof(FJunoModalDescription, CancelAction) == 0x000078, "Member 'FJunoModalDescription::CancelAction' has a wrong offset!");

// ScriptStruct JunoUI.JunoMapMarkerEntryInitData
// 0x0038 (0x0038 - 0x0000)
struct FJunoMapMarkerEntryInitData final
{
public:
	EJunoMapMarkerCustomizationEntryType          WidgetEntryType;                                   // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture>                EntryIcon;                                         // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EntryColor;                                        // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoMapMarkerEntryInitData) == 0x000008, "Wrong alignment on FJunoMapMarkerEntryInitData");
static_assert(sizeof(FJunoMapMarkerEntryInitData) == 0x000038, "Wrong size on FJunoMapMarkerEntryInitData");
static_assert(offsetof(FJunoMapMarkerEntryInitData, WidgetEntryType) == 0x000000, "Member 'FJunoMapMarkerEntryInitData::WidgetEntryType' has a wrong offset!");
static_assert(offsetof(FJunoMapMarkerEntryInitData, EntryIcon) == 0x000008, "Member 'FJunoMapMarkerEntryInitData::EntryIcon' has a wrong offset!");
static_assert(offsetof(FJunoMapMarkerEntryInitData, EntryColor) == 0x000028, "Member 'FJunoMapMarkerEntryInitData::EntryColor' has a wrong offset!");

// ScriptStruct JunoUI.JunoVillageUIData
// 0x0138 (0x0138 - 0x0000)
struct FJunoVillageUIData final
{
public:
	class FText                                   POIName;                                           // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJunoMarker                            Marker;                                            // 0x0018(0x0098)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EJunoBiome                                    BiomeType;                                         // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AwesomeLevel;                                      // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAwesomeLevel;                                   // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwesomePoints;                                     // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwesomePointGoal;                                  // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwesomePointFloor;                                 // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwesomePointsNeededForNextLevel;                   // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AwesomeProgressToNextLevel;                        // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AwesomeEffectiveProgressToNextLevel;               // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwesomeLevelFromCurrentPoints;                     // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAwesomeLevelRewardEntry>       AwesomeLevelRewardEntries;                         // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FJunoAwesomeUpgradeResourceCostList    CurrentUpgradeResourceCosts;                       // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FAwesomePerkReward>             UnlockedPlayerPerks;                               // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActiveCampNPCEntry>            ActiveNPCEntries;                                  // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxNPCs;                                           // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UJunoKnowledgeBundle>> KnowledgeBundles;                                  // 0x0120(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UFortItemDefinition*                    VillageCenterItemDefinition;                       // 0x0130(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoVillageUIData) == 0x000008, "Wrong alignment on FJunoVillageUIData");
static_assert(sizeof(FJunoVillageUIData) == 0x000138, "Wrong size on FJunoVillageUIData");
static_assert(offsetof(FJunoVillageUIData, POIName) == 0x000000, "Member 'FJunoVillageUIData::POIName' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, Marker) == 0x000018, "Member 'FJunoVillageUIData::Marker' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, BiomeType) == 0x0000B0, "Member 'FJunoVillageUIData::BiomeType' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomeLevel) == 0x0000B4, "Member 'FJunoVillageUIData::AwesomeLevel' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, MaxAwesomeLevel) == 0x0000B8, "Member 'FJunoVillageUIData::MaxAwesomeLevel' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomePoints) == 0x0000BC, "Member 'FJunoVillageUIData::AwesomePoints' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomePointGoal) == 0x0000C0, "Member 'FJunoVillageUIData::AwesomePointGoal' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomePointFloor) == 0x0000C4, "Member 'FJunoVillageUIData::AwesomePointFloor' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomePointsNeededForNextLevel) == 0x0000C8, "Member 'FJunoVillageUIData::AwesomePointsNeededForNextLevel' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomeProgressToNextLevel) == 0x0000CC, "Member 'FJunoVillageUIData::AwesomeProgressToNextLevel' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomeEffectiveProgressToNextLevel) == 0x0000D0, "Member 'FJunoVillageUIData::AwesomeEffectiveProgressToNextLevel' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomeLevelFromCurrentPoints) == 0x0000D4, "Member 'FJunoVillageUIData::AwesomeLevelFromCurrentPoints' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, AwesomeLevelRewardEntries) == 0x0000D8, "Member 'FJunoVillageUIData::AwesomeLevelRewardEntries' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, CurrentUpgradeResourceCosts) == 0x0000E8, "Member 'FJunoVillageUIData::CurrentUpgradeResourceCosts' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, UnlockedPlayerPerks) == 0x0000F8, "Member 'FJunoVillageUIData::UnlockedPlayerPerks' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, ActiveNPCEntries) == 0x000108, "Member 'FJunoVillageUIData::ActiveNPCEntries' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, MaxNPCs) == 0x000118, "Member 'FJunoVillageUIData::MaxNPCs' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, KnowledgeBundles) == 0x000120, "Member 'FJunoVillageUIData::KnowledgeBundles' has a wrong offset!");
static_assert(offsetof(FJunoVillageUIData, VillageCenterItemDefinition) == 0x000130, "Member 'FJunoVillageUIData::VillageCenterItemDefinition' has a wrong offset!");

// ScriptStruct JunoUI.JunoHUDShowVillageUpgradeCelebrationEvent
// 0x0020 (0x0020 - 0x0000)
struct FJunoHUDShowVillageUpgradeCelebrationEvent final
{
public:
	class FText                                   VillageName;                                       // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	EJunoBiome                                    Biome;                                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewLevel;                                          // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoHUDShowVillageUpgradeCelebrationEvent) == 0x000008, "Wrong alignment on FJunoHUDShowVillageUpgradeCelebrationEvent");
static_assert(sizeof(FJunoHUDShowVillageUpgradeCelebrationEvent) == 0x000020, "Wrong size on FJunoHUDShowVillageUpgradeCelebrationEvent");
static_assert(offsetof(FJunoHUDShowVillageUpgradeCelebrationEvent, VillageName) == 0x000000, "Member 'FJunoHUDShowVillageUpgradeCelebrationEvent::VillageName' has a wrong offset!");
static_assert(offsetof(FJunoHUDShowVillageUpgradeCelebrationEvent, Biome) == 0x000018, "Member 'FJunoHUDShowVillageUpgradeCelebrationEvent::Biome' has a wrong offset!");
static_assert(offsetof(FJunoHUDShowVillageUpgradeCelebrationEvent, NewLevel) == 0x00001C, "Member 'FJunoHUDShowVillageUpgradeCelebrationEvent::NewLevel' has a wrong offset!");

// ScriptStruct JunoUI.JunoNotificationData
// 0x0050 (0x0050 - 0x0000)
struct FJunoNotificationData final
{
public:
	struct FGameplayTag                           NotificationType;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItemDefinitionBase*>            ItemDefinitions;                                   // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AdditionalTags;                                    // 0x0018(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InitObject;                                        // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoNotificationData) == 0x000008, "Wrong alignment on FJunoNotificationData");
static_assert(sizeof(FJunoNotificationData) == 0x000050, "Wrong size on FJunoNotificationData");
static_assert(offsetof(FJunoNotificationData, NotificationType) == 0x000000, "Member 'FJunoNotificationData::NotificationType' has a wrong offset!");
static_assert(offsetof(FJunoNotificationData, ItemDefinitions) == 0x000008, "Member 'FJunoNotificationData::ItemDefinitions' has a wrong offset!");
static_assert(offsetof(FJunoNotificationData, AdditionalTags) == 0x000018, "Member 'FJunoNotificationData::AdditionalTags' has a wrong offset!");
static_assert(offsetof(FJunoNotificationData, PlayerName) == 0x000038, "Member 'FJunoNotificationData::PlayerName' has a wrong offset!");
static_assert(offsetof(FJunoNotificationData, InitObject) == 0x000048, "Member 'FJunoNotificationData::InitObject' has a wrong offset!");

// ScriptStruct JunoUI.JunoNotificationEvent
// 0x0030 (0x0030 - 0x0000)
struct FJunoNotificationEvent final
{
public:
	struct FGameplayTag                           tag;                                               // 0x0000(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NotificationSoftClass;                             // 0x0008(0x0020)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InitObject;                                        // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoNotificationEvent) == 0x000008, "Wrong alignment on FJunoNotificationEvent");
static_assert(sizeof(FJunoNotificationEvent) == 0x000030, "Wrong size on FJunoNotificationEvent");
static_assert(offsetof(FJunoNotificationEvent, tag) == 0x000000, "Member 'FJunoNotificationEvent::tag' has a wrong offset!");
static_assert(offsetof(FJunoNotificationEvent, NotificationSoftClass) == 0x000008, "Member 'FJunoNotificationEvent::NotificationSoftClass' has a wrong offset!");
static_assert(offsetof(FJunoNotificationEvent, InitObject) == 0x000028, "Member 'FJunoNotificationEvent::InitObject' has a wrong offset!");

// ScriptStruct JunoUI.JunoPlayerIndicatorData
// 0x0048 (0x0048 - 0x0000)
struct FJunoPlayerIndicatorData final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlive;                                          // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       UniqueNetId;                                       // 0x0018(0x0030)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJunoPlayerIndicatorData) == 0x000008, "Wrong alignment on FJunoPlayerIndicatorData");
static_assert(sizeof(FJunoPlayerIndicatorData) == 0x000048, "Wrong size on FJunoPlayerIndicatorData");
static_assert(offsetof(FJunoPlayerIndicatorData, PlayerName) == 0x000000, "Member 'FJunoPlayerIndicatorData::PlayerName' has a wrong offset!");
static_assert(offsetof(FJunoPlayerIndicatorData, bIsAlive) == 0x000010, "Member 'FJunoPlayerIndicatorData::bIsAlive' has a wrong offset!");
static_assert(offsetof(FJunoPlayerIndicatorData, UniqueNetId) == 0x000018, "Member 'FJunoPlayerIndicatorData::UniqueNetId' has a wrong offset!");

// ScriptStruct JunoUI.JunoWidgetSceneAndIndex
// 0x0010 (0x0010 - 0x0000)
struct FJunoWidgetSceneAndIndex final
{
public:
	class UDynamicUIScene*                        WidgetScene;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidgetAllowedIndex;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnDeath;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJunoWidgetSceneAndIndex) == 0x000008, "Wrong alignment on FJunoWidgetSceneAndIndex");
static_assert(sizeof(FJunoWidgetSceneAndIndex) == 0x000010, "Wrong size on FJunoWidgetSceneAndIndex");
static_assert(offsetof(FJunoWidgetSceneAndIndex, WidgetScene) == 0x000000, "Member 'FJunoWidgetSceneAndIndex::WidgetScene' has a wrong offset!");
static_assert(offsetof(FJunoWidgetSceneAndIndex, WidgetAllowedIndex) == 0x000008, "Member 'FJunoWidgetSceneAndIndex::WidgetAllowedIndex' has a wrong offset!");
static_assert(offsetof(FJunoWidgetSceneAndIndex, bRemoveOnDeath) == 0x00000C, "Member 'FJunoWidgetSceneAndIndex::bRemoveOnDeath' has a wrong offset!");

}

