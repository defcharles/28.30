#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DaySequence

#include "Basic.hpp"

#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DaySequence_structs.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class DaySequence.DaySequenceConditionTag
// 0x0020 (0x0048 - 0x0028)
class UDaySequenceConditionTag final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnConditionValueChanged() const;
	bool Evaluate() const;
	class FString GetConditionName() const;
	void SetupBroadcastBindings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceConditionTag">();
	}
	static class UDaySequenceConditionTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequenceConditionTag>();
	}
};
static_assert(alignof(UDaySequenceConditionTag) == 0x000008, "Wrong alignment on UDaySequenceConditionTag");
static_assert(sizeof(UDaySequenceConditionTag) == 0x000048, "Wrong size on UDaySequenceConditionTag");

// Class DaySequence.DaySequenceModifierEasingFunction
// 0x0048 (0x0070 - 0x0028)
class UDaySequenceModifierEasingFunction final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceModifierEasingFunction">();
	}
	static class UDaySequenceModifierEasingFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequenceModifierEasingFunction>();
	}
};
static_assert(alignof(UDaySequenceModifierEasingFunction) == 0x000008, "Wrong alignment on UDaySequenceModifierEasingFunction");
static_assert(sizeof(UDaySequenceModifierEasingFunction) == 0x000070, "Wrong size on UDaySequenceModifierEasingFunction");

// Class DaySequence.DaySequenceModifierComponent
// 0x01B0 (0x03D0 - 0x0220)
class UDaySequenceModifierComponent final : public USceneComponent
{
public:
	class UDaySequenceModifierEasingFunction*     EasingFunction;                                    // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADaySequenceActor*                      TargetActor;                                       // 0x0228(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FComponentReference>            VolumeShapeComponents;                             // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ExternalVolumeBlendTarget;                         // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDaySequence*                           UserDaySequence;                                   // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDaySequence*                           ProceduralDaySequence;                             // 0x0250(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FDaySequenceModifierNamedSequence> AdditionalNamedDaySequences;                       // 0x0258(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FDaySequenceModifierNamedSequence> TransientCollectionSequences;                      // 0x02A8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UDaySequenceCollectionAsset*            DaySequenceCollection;                             // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Bias;                                              // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DayNightCycleTime;                                 // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendAmount;                                       // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomVolumeBlendWeight;                           // 0x0310(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDayNightCycleMode                            DayNightCycle;                                     // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDaySequenceModifierBlendMode                 BlendMode;                                         // 0x0315(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_316[0x2];                                      // 0x0316(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPostReinitializeSubSequences;                    // 0x0318(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnPostEnableModifier;                              // 0x0328(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AActor* OverlappingActor)> OnVolumeBlendTargetOverlapBegin;                   // 0x0338(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AActor* OverlappingActor)> OnVolumeBlendTargetOverlapEnd;                     // 0x0348(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreBias : 1;                                   // 0x0358(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseVolume : 1;                                    // 0x0358(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsComponentEnabled : 1;                           // 0x0358(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsEnabled : 1;                                    // 0x0358(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPreview : 1;                                      // 0x0358(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_358_5 : 1;                                  // 0x0358(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bUseCollection : 1;                                // 0x0358(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_359[0x77];                                     // 0x0359(0x0077)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBoolOverride(class UObject* Object, class FName PropertyName, bool bValue);
	void AddColorMaterialParameterOverride(class UObject* Object, int32 MaterialIndex, class FName ParameterName, const struct FLinearColor& Value);
	void AddColorOverride(class UObject* Object, class FName PropertyName, const struct FLinearColor& Value);
	void AddMaterialOverride(class UObject* Object, int32 MaterialIndex, class UMaterialInterface* Value);
	void AddScalarMaterialParameterOverride(class UObject* Object, int32 MaterialIndex, class FName ParameterName, float Value);
	void AddScalarOverride(class UObject* Object, class FName PropertyName, double Value);
	void AddStaticTimeOfDayOverride(class ADaySequenceActor* Actor, float Hours);
	void AddTransformOverride(class UObject* Object, const struct FTransform& Value);
	void AddVectorOverride(class UObject* Object, class FName PropertyName, const struct FVector& Value);
	void AddVisibilityOverride(class UObject* Object, bool bValue);
	void BindToDaySequenceActor(class ADaySequenceActor* DaySequenceActor);
	void DisableComponent();
	void DisableModifier();
	void EnableComponent();
	void EnableDistanceVolumeBlends(class AActor* InActor);
	void EnableModifier();
	bool IsBlendTargetInAnyVolume();
	void MuteNamedSequence(class FName SequenceKey, bool bState);
	void OnVolumeOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnVolumeOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void ResetOverrides();
	void SetCustomVolumeBlendWeight(float Weight);
	void SetUserDaySequence(class UDaySequence* InDaySequence);
	void UnbindFromDaySequenceActor();

	float GetCurrentBlendWeight() const;
	bool IsNamedSequenceMuted(class FName SequenceKey) const;
	void SetVolumeCollisionEnabled(const ECollisionEnabled InCollisionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceModifierComponent">();
	}
	static class UDaySequenceModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequenceModifierComponent>();
	}
};
static_assert(alignof(UDaySequenceModifierComponent) == 0x000010, "Wrong alignment on UDaySequenceModifierComponent");
static_assert(sizeof(UDaySequenceModifierComponent) == 0x0003D0, "Wrong size on UDaySequenceModifierComponent");
static_assert(offsetof(UDaySequenceModifierComponent, EasingFunction) == 0x000220, "Member 'UDaySequenceModifierComponent::EasingFunction' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, TargetActor) == 0x000228, "Member 'UDaySequenceModifierComponent::TargetActor' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, VolumeShapeComponents) == 0x000230, "Member 'UDaySequenceModifierComponent::VolumeShapeComponents' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, ExternalVolumeBlendTarget) == 0x000240, "Member 'UDaySequenceModifierComponent::ExternalVolumeBlendTarget' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, UserDaySequence) == 0x000248, "Member 'UDaySequenceModifierComponent::UserDaySequence' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, ProceduralDaySequence) == 0x000250, "Member 'UDaySequenceModifierComponent::ProceduralDaySequence' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, AdditionalNamedDaySequences) == 0x000258, "Member 'UDaySequenceModifierComponent::AdditionalNamedDaySequences' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, TransientCollectionSequences) == 0x0002A8, "Member 'UDaySequenceModifierComponent::TransientCollectionSequences' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, DaySequenceCollection) == 0x0002F8, "Member 'UDaySequenceModifierComponent::DaySequenceCollection' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, Bias) == 0x000300, "Member 'UDaySequenceModifierComponent::Bias' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, DayNightCycleTime) == 0x000304, "Member 'UDaySequenceModifierComponent::DayNightCycleTime' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, BlendAmount) == 0x000308, "Member 'UDaySequenceModifierComponent::BlendAmount' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, CustomVolumeBlendWeight) == 0x000310, "Member 'UDaySequenceModifierComponent::CustomVolumeBlendWeight' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, DayNightCycle) == 0x000314, "Member 'UDaySequenceModifierComponent::DayNightCycle' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, BlendMode) == 0x000315, "Member 'UDaySequenceModifierComponent::BlendMode' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, OnPostReinitializeSubSequences) == 0x000318, "Member 'UDaySequenceModifierComponent::OnPostReinitializeSubSequences' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, OnPostEnableModifier) == 0x000328, "Member 'UDaySequenceModifierComponent::OnPostEnableModifier' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, OnVolumeBlendTargetOverlapBegin) == 0x000338, "Member 'UDaySequenceModifierComponent::OnVolumeBlendTargetOverlapBegin' has a wrong offset!");
static_assert(offsetof(UDaySequenceModifierComponent, OnVolumeBlendTargetOverlapEnd) == 0x000348, "Member 'UDaySequenceModifierComponent::OnVolumeBlendTargetOverlapEnd' has a wrong offset!");

// Class DaySequence.DaySequence
// 0x00C8 (0x0130 - 0x0068)
class UDaySequence final : public UMovieSceneSequence
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMovieScene*                            MovieScene;                                        // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaySequenceBindingReferences          BindingReferences;                                 // 0x0078(0x00A0)(Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UObject>                    DirectorClass;                                     // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x0120(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequence">();
	}
	static class UDaySequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequence>();
	}
};
static_assert(alignof(UDaySequence) == 0x000008, "Wrong alignment on UDaySequence");
static_assert(sizeof(UDaySequence) == 0x000130, "Wrong size on UDaySequence");
static_assert(offsetof(UDaySequence, MovieScene) == 0x000070, "Member 'UDaySequence::MovieScene' has a wrong offset!");
static_assert(offsetof(UDaySequence, BindingReferences) == 0x000078, "Member 'UDaySequence::BindingReferences' has a wrong offset!");
static_assert(offsetof(UDaySequence, DirectorClass) == 0x000118, "Member 'UDaySequence::DirectorClass' has a wrong offset!");
static_assert(offsetof(UDaySequence, AssetUserData) == 0x000120, "Member 'UDaySequence::AssetUserData' has a wrong offset!");

// Class DaySequence.DaySequenceActor
// 0x01F0 (0x0480 - 0x0290)
class ADaySequenceActor : public AInfo
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDaySequencePlayer*                     SequencePlayer;                                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DayInterpCurve;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FDaySequenceAssetData> DaySequences;                                      // 0x02B0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FDaySequenceAssetData> TransientCollectionSequences;                      // 0x0300(0x0050)(Transient, NativeAccessSpecifierPublic)
	class UDaySequenceCollectionAsset*            DaySequenceCollection;                             // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bias;                                              // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMovieSceneBindingOverrides*            BindingOverrides;                                  // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReplicatePlayback : 1;                            // 0x0368(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDaySequence*                           RootSequence;                                      // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunDayCycle;                                      // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInterpCurve;                                   // 0x0379(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCollection;                                    // 0x037A(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37B[0x1];                                      // 0x037B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimecode                              DayLength;                                         // 0x037C(0x0014)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimecode                              TimePerCycle;                                      // 0x0390(0x0014)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimecode                              InitialTimeOfDay;                                  // 0x03A4(0x0014)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x78];                                     // 0x03B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UDaySequenceConditionTag>, class UDaySequenceConditionTag*> TrackConditionMap;                                 // 0x0430(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	bool ContainsDaySequence(const class UDaySequence* InDaySequence);
	int32 GetBias(class FName SequenceKey);
	bool IsMuteSequence(class FName SequenceKey);
	void Multicast_SetTimePerCycle(float InHours);
	void MuteSequence(class FName SequenceKey, bool bState);
	void Pause();
	void Play();
	void RemoveStaticTimeOfDay(bool bResumeFromStaticTime);
	void SetBias(class FName SequenceKey, int32 Bias_0);
	void SetDaySequence(class FName SequenceName, class UDaySequence* InDaySequence);
	void SetReplicatePlayback(bool ReplicatePlayback);
	void SetStaticTimeOfDay(float InHours);
	bool SetTimeOfDay(float InHours);
	void SetTimeOfDayPreview(float InHours);

	float GetDayLength() const;
	class UDaySequence* GetDaySequence(class FName SequenceName) const;
	class UDaySequence* GetFirstDaySequence() const;
	float GetInitialTimeOfDay() const;
	class UDaySequencePlayer* GetSequencePlayer() const;
	float GetStaticTimeOfDay() const;
	float GetTimeOfDay() const;
	float GetTimeOfDayPreview() const;
	float GetTimePerCycle() const;
	bool HasStaticTimeOfDay() const;
	bool IsPaused() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceActor">();
	}
	static class ADaySequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADaySequenceActor>();
	}
};
static_assert(alignof(ADaySequenceActor) == 0x000008, "Wrong alignment on ADaySequenceActor");
static_assert(sizeof(ADaySequenceActor) == 0x000480, "Wrong size on ADaySequenceActor");
static_assert(offsetof(ADaySequenceActor, SequencePlayer) == 0x0002A0, "Member 'ADaySequenceActor::SequencePlayer' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, DayInterpCurve) == 0x0002A8, "Member 'ADaySequenceActor::DayInterpCurve' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, DaySequences) == 0x0002B0, "Member 'ADaySequenceActor::DaySequences' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, TransientCollectionSequences) == 0x000300, "Member 'ADaySequenceActor::TransientCollectionSequences' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, DaySequenceCollection) == 0x000350, "Member 'ADaySequenceActor::DaySequenceCollection' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, Bias) == 0x000358, "Member 'ADaySequenceActor::Bias' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, BindingOverrides) == 0x000360, "Member 'ADaySequenceActor::BindingOverrides' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, RootSequence) == 0x000370, "Member 'ADaySequenceActor::RootSequence' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, bRunDayCycle) == 0x000378, "Member 'ADaySequenceActor::bRunDayCycle' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, bUseInterpCurve) == 0x000379, "Member 'ADaySequenceActor::bUseInterpCurve' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, bUseCollection) == 0x00037A, "Member 'ADaySequenceActor::bUseCollection' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, DayLength) == 0x00037C, "Member 'ADaySequenceActor::DayLength' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, TimePerCycle) == 0x000390, "Member 'ADaySequenceActor::TimePerCycle' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, InitialTimeOfDay) == 0x0003A4, "Member 'ADaySequenceActor::InitialTimeOfDay' has a wrong offset!");
static_assert(offsetof(ADaySequenceActor, TrackConditionMap) == 0x000430, "Member 'ADaySequenceActor::TrackConditionMap' has a wrong offset!");

// Class DaySequence.DaySequenceCollectionAsset
// 0x0010 (0x0040 - 0x0030)
class UDaySequenceCollectionAsset final : public UDataAsset
{
public:
	TArray<struct FDaySequenceCollectionEntry>    DaySequences;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceCollectionAsset">();
	}
	static class UDaySequenceCollectionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequenceCollectionAsset>();
	}
};
static_assert(alignof(UDaySequenceCollectionAsset) == 0x000008, "Wrong alignment on UDaySequenceCollectionAsset");
static_assert(sizeof(UDaySequenceCollectionAsset) == 0x000040, "Wrong size on UDaySequenceCollectionAsset");
static_assert(offsetof(UDaySequenceCollectionAsset, DaySequences) == 0x000030, "Member 'UDaySequenceCollectionAsset::DaySequences' has a wrong offset!");

// Class DaySequence.DaySequenceDirector
// 0x0010 (0x0038 - 0x0028)
class UDaySequenceDirector final : public UObject
{
public:
	class UDaySequencePlayer*                     Player;                                            // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubSequenceID;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MovieScenePlayerIndex;                             // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class AActor* GetBoundActor(const struct FMovieSceneObjectBindingID& ObjectBinding);
	TArray<class AActor*> GetBoundActors(const struct FMovieSceneObjectBindingID& ObjectBinding);
	class UObject* GetBoundObject(const struct FMovieSceneObjectBindingID& ObjectBinding);
	TArray<class UObject*> GetBoundObjects(const struct FMovieSceneObjectBindingID& ObjectBinding);
	class UMovieSceneSequence* GetSequence();
	void OnCreated();

	struct FQualifiedFrameTime GetCurrentTime() const;
	struct FQualifiedFrameTime GetMasterSequenceTime() const;
	struct FQualifiedFrameTime GetRootSequenceTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceDirector">();
	}
	static class UDaySequenceDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequenceDirector>();
	}
};
static_assert(alignof(UDaySequenceDirector) == 0x000008, "Wrong alignment on UDaySequenceDirector");
static_assert(sizeof(UDaySequenceDirector) == 0x000038, "Wrong size on UDaySequenceDirector");
static_assert(offsetof(UDaySequenceDirector, Player) == 0x000028, "Member 'UDaySequenceDirector::Player' has a wrong offset!");
static_assert(offsetof(UDaySequenceDirector, SubSequenceID) == 0x000030, "Member 'UDaySequenceDirector::SubSequenceID' has a wrong offset!");
static_assert(offsetof(UDaySequenceDirector, MovieScenePlayerIndex) == 0x000034, "Member 'UDaySequenceDirector::MovieScenePlayerIndex' has a wrong offset!");

// Class DaySequence.DaySequencePlayer
// 0x0008 (0x04E8 - 0x04E0)
class UDaySequencePlayer final : public UMovieSceneSequencePlayer
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequencePlayer">();
	}
	static class UDaySequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequencePlayer>();
	}
};
static_assert(alignof(UDaySequencePlayer) == 0x000008, "Wrong alignment on UDaySequencePlayer");
static_assert(sizeof(UDaySequencePlayer) == 0x0004E8, "Wrong size on UDaySequencePlayer");

// Class DaySequence.DaySequenceProjectSettings
// 0x0030 (0x0060 - 0x0030)
class UDaySequenceProjectSettings final : public UDeveloperSettings
{
public:
	bool                                          bDefaultLockEngineToDisplayRate;                   // 0x0030(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultDisplayRate;                                // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultTickResolution;                             // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUpdateClockSource                            DefaultClockSource;                                // 0x0058(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceProjectSettings">();
	}
	static class UDaySequenceProjectSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequenceProjectSettings>();
	}
};
static_assert(alignof(UDaySequenceProjectSettings) == 0x000008, "Wrong alignment on UDaySequenceProjectSettings");
static_assert(sizeof(UDaySequenceProjectSettings) == 0x000060, "Wrong size on UDaySequenceProjectSettings");
static_assert(offsetof(UDaySequenceProjectSettings, bDefaultLockEngineToDisplayRate) == 0x000030, "Member 'UDaySequenceProjectSettings::bDefaultLockEngineToDisplayRate' has a wrong offset!");
static_assert(offsetof(UDaySequenceProjectSettings, DefaultDisplayRate) == 0x000038, "Member 'UDaySequenceProjectSettings::DefaultDisplayRate' has a wrong offset!");
static_assert(offsetof(UDaySequenceProjectSettings, DefaultTickResolution) == 0x000048, "Member 'UDaySequenceProjectSettings::DefaultTickResolution' has a wrong offset!");
static_assert(offsetof(UDaySequenceProjectSettings, DefaultClockSource) == 0x000058, "Member 'UDaySequenceProjectSettings::DefaultClockSource' has a wrong offset!");

// Class DaySequence.DaySequenceProvider
// 0x0010 (0x02A0 - 0x0290)
class ADaySequenceProvider : public AActor
{
public:
	TArray<class UDaySequence*>                   DaySequenceAssets;                                 // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceProvider">();
	}
	static class ADaySequenceProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADaySequenceProvider>();
	}
};
static_assert(alignof(ADaySequenceProvider) == 0x000008, "Wrong alignment on ADaySequenceProvider");
static_assert(sizeof(ADaySequenceProvider) == 0x0002A0, "Wrong size on ADaySequenceProvider");
static_assert(offsetof(ADaySequenceProvider, DaySequenceAssets) == 0x000290, "Member 'ADaySequenceProvider::DaySequenceAssets' has a wrong offset!");

// Class DaySequence.DaySequenceSubsystem
// 0x0030 (0x0060 - 0x0030)
class UDaySequenceSubsystem final : public UWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(class ADaySequenceActor* NewActor)> OnDaySequenceActorSet;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDaySequenceActor(class ADaySequenceActor* InActor);

	class ADaySequenceActor* GetDaySequenceActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceSubsystem">();
	}
	static class UDaySequenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequenceSubsystem>();
	}
};
static_assert(alignof(UDaySequenceSubsystem) == 0x000008, "Wrong alignment on UDaySequenceSubsystem");
static_assert(sizeof(UDaySequenceSubsystem) == 0x000060, "Wrong size on UDaySequenceSubsystem");
static_assert(offsetof(UDaySequenceSubsystem, OnDaySequenceActorSet) == 0x000030, "Member 'UDaySequenceSubsystem::OnDaySequenceActorSet' has a wrong offset!");

// Class DaySequence.DaySequenceTrack
// 0x0000 (0x00A8 - 0x00A8)
class UDaySequenceTrack final : public UMovieSceneSubTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaySequenceTrack">();
	}
	static class UDaySequenceTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDaySequenceTrack>();
	}
};
static_assert(alignof(UDaySequenceTrack) == 0x000008, "Wrong alignment on UDaySequenceTrack");
static_assert(sizeof(UDaySequenceTrack) == 0x0000A8, "Wrong size on UDaySequenceTrack");

// Class DaySequence.EnvironmentLightingActor
// 0x0030 (0x02D0 - 0x02A0)
class AEnvironmentLightingActor final : public ADaySequenceProvider
{
public:
	class USkyAtmosphereComponent*                SkyAtmosphereComponent;                            // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkyLightComponent*                     SkyLightComponent;                                 // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SunRootComponent;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDirectionalLightComponent*             SunComponent;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UExponentialHeightFogComponent*         ExponentialHeightFogComponent;                     // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVolumetricCloudComponent*              VolumetricCloudComponent;                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentLightingActor">();
	}
	static class AEnvironmentLightingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentLightingActor>();
	}
};
static_assert(alignof(AEnvironmentLightingActor) == 0x000008, "Wrong alignment on AEnvironmentLightingActor");
static_assert(sizeof(AEnvironmentLightingActor) == 0x0002D0, "Wrong size on AEnvironmentLightingActor");
static_assert(offsetof(AEnvironmentLightingActor, SkyAtmosphereComponent) == 0x0002A0, "Member 'AEnvironmentLightingActor::SkyAtmosphereComponent' has a wrong offset!");
static_assert(offsetof(AEnvironmentLightingActor, SkyLightComponent) == 0x0002A8, "Member 'AEnvironmentLightingActor::SkyLightComponent' has a wrong offset!");
static_assert(offsetof(AEnvironmentLightingActor, SunRootComponent) == 0x0002B0, "Member 'AEnvironmentLightingActor::SunRootComponent' has a wrong offset!");
static_assert(offsetof(AEnvironmentLightingActor, SunComponent) == 0x0002B8, "Member 'AEnvironmentLightingActor::SunComponent' has a wrong offset!");
static_assert(offsetof(AEnvironmentLightingActor, ExponentialHeightFogComponent) == 0x0002C0, "Member 'AEnvironmentLightingActor::ExponentialHeightFogComponent' has a wrong offset!");
static_assert(offsetof(AEnvironmentLightingActor, VolumetricCloudComponent) == 0x0002C8, "Member 'AEnvironmentLightingActor::VolumetricCloudComponent' has a wrong offset!");

}

