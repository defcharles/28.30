#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LimeNative

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "LimeNative_structs.hpp"
#include "GameFeatures_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class LimeNative.LimeAnalytics
// 0x0030 (0x0058 - 0x0028)
class ULimeAnalytics : public UObject
{
public:
	TArray<struct FLimeAnalyticsContext>          AnalyticsContexts;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeAnalytics">();
	}
	static class ULimeAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeAnalytics>();
	}
};
static_assert(alignof(ULimeAnalytics) == 0x000008, "Wrong alignment on ULimeAnalytics");
static_assert(sizeof(ULimeAnalytics) == 0x000058, "Wrong size on ULimeAnalytics");
static_assert(offsetof(ULimeAnalytics, AnalyticsContexts) == 0x000028, "Member 'ULimeAnalytics::AnalyticsContexts' has a wrong offset!");

// Class LimeNative.LimeBaseLayerAnimInstance
// 0x0010 (0x0470 - 0x0460)
#pragma pack(push, 0x1)
class alignas(0x10) ULimeBaseLayerAnimInstance : public UFortBaseAnimInstance
{
public:
	uint8                                         bHasIsTargetingTag : 1;                            // 0x0458(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UJunoPlayerAnimInstance> MainAnimInstanceWeakPtr;                           // 0x045C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeBaseLayerAnimInstance">();
	}
	static class ULimeBaseLayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeBaseLayerAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(ULimeBaseLayerAnimInstance) == 0x000010, "Wrong alignment on ULimeBaseLayerAnimInstance");
static_assert(sizeof(ULimeBaseLayerAnimInstance) == 0x000470, "Wrong size on ULimeBaseLayerAnimInstance");
static_assert(offsetof(ULimeBaseLayerAnimInstance, MainAnimInstanceWeakPtr) == 0x00045C, "Member 'ULimeBaseLayerAnimInstance::MainAnimInstanceWeakPtr' has a wrong offset!");

// Class LimeNative.LimeDBNOAnimInstance
// 0x0030 (0x04A0 - 0x0470)
class ULimeDBNOAnimInstance final : public ULimeBaseLayerAnimInstance
{
public:
	EFortPlayerAnimBodyType                       AnimBodyType;                                      // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanAngle;                                         // 0x046C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedAdjustedPlayrate;                             // 0x0470(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAdditiveAlpha;                                 // 0x0474(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed2D;                                           // 0x0478(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementBlendSpaceSpeed2D;                         // 0x047C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMovementBlendSpaceSpeed;                        // 0x0480(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityYawAngle;                             // 0x0484(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNOTurnPlayRate;                                  // 0x0488(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDeltaCurrentTick;                               // 0x048C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDeltaLastTick;                                  // 0x0490(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDeltaSmoothed;                                  // 0x0494(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsOnGround : 1;                                   // 0x0498(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTransition_FullBody_DBNOMove : 1;                 // 0x0498(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTransition_FullBody_DBNOTurn : 1;                 // 0x0498(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsLargeBodyType : 1;                              // 0x0498(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeDBNOAnimInstance">();
	}
	static class ULimeDBNOAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeDBNOAnimInstance>();
	}
};
static_assert(alignof(ULimeDBNOAnimInstance) == 0x000010, "Wrong alignment on ULimeDBNOAnimInstance");
static_assert(sizeof(ULimeDBNOAnimInstance) == 0x0004A0, "Wrong size on ULimeDBNOAnimInstance");
static_assert(offsetof(ULimeDBNOAnimInstance, AnimBodyType) == 0x000468, "Member 'ULimeDBNOAnimInstance::AnimBodyType' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, LeanAngle) == 0x00046C, "Member 'ULimeDBNOAnimInstance::LeanAngle' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, SpeedAdjustedPlayrate) == 0x000470, "Member 'ULimeDBNOAnimInstance::SpeedAdjustedPlayrate' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, LeanAdditiveAlpha) == 0x000474, "Member 'ULimeDBNOAnimInstance::LeanAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, Speed2D) == 0x000478, "Member 'ULimeDBNOAnimInstance::Speed2D' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, MovementBlendSpaceSpeed2D) == 0x00047C, "Member 'ULimeDBNOAnimInstance::MovementBlendSpaceSpeed2D' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, MaxMovementBlendSpaceSpeed) == 0x000480, "Member 'ULimeDBNOAnimInstance::MaxMovementBlendSpaceSpeed' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, LocalVelocityYawAngle) == 0x000484, "Member 'ULimeDBNOAnimInstance::LocalVelocityYawAngle' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, DBNOTurnPlayRate) == 0x000488, "Member 'ULimeDBNOAnimInstance::DBNOTurnPlayRate' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, YawDeltaCurrentTick) == 0x00048C, "Member 'ULimeDBNOAnimInstance::YawDeltaCurrentTick' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, YawDeltaLastTick) == 0x000490, "Member 'ULimeDBNOAnimInstance::YawDeltaLastTick' has a wrong offset!");
static_assert(offsetof(ULimeDBNOAnimInstance, YawDeltaSmoothed) == 0x000494, "Member 'ULimeDBNOAnimInstance::YawDeltaSmoothed' has a wrong offset!");

// Class LimeNative.LimeOverrideManager
// 0x0068 (0x0090 - 0x0028)
class ULimeOverrideManager final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeOverrideManager">();
	}
	static class ULimeOverrideManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeOverrideManager>();
	}
};
static_assert(alignof(ULimeOverrideManager) == 0x000008, "Wrong alignment on ULimeOverrideManager");
static_assert(sizeof(ULimeOverrideManager) == 0x000090, "Wrong size on ULimeOverrideManager");

// Class LimeNative.LimePawnComponentOverrides
// 0x00A8 (0x0150 - 0x00A8)
class ULimePawnComponentOverrides final : public UFortPawnComponent
{
public:
	TArray<struct FLimePawnComponentOverride>     ObjectOverrides;                                   // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortMovementMode_ExtClambering> ClamberingMME;                                     // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLevelSettingsChanged;                            // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSubclassOf<class UAnimInstance>> VehicleAnimLayerOverlayClass;                      // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              DBNOAnimLayerClass;                                // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              DBNOCarriedAnimLayerClass;                         // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              SkydiveAnimLayerClass;                             // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              CurrentAnimLayerClass;                             // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleEnterVehicle();
	void OnLimeSettingsEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);

	bool AreJunoControlsEnabled() const;
	bool IsOrbitCameraEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimePawnComponentOverrides">();
	}
	static class ULimePawnComponentOverrides* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimePawnComponentOverrides>();
	}
};
static_assert(alignof(ULimePawnComponentOverrides) == 0x000008, "Wrong alignment on ULimePawnComponentOverrides");
static_assert(sizeof(ULimePawnComponentOverrides) == 0x000150, "Wrong size on ULimePawnComponentOverrides");
static_assert(offsetof(ULimePawnComponentOverrides, ObjectOverrides) == 0x0000A8, "Member 'ULimePawnComponentOverrides::ObjectOverrides' has a wrong offset!");
static_assert(offsetof(ULimePawnComponentOverrides, ClamberingMME) == 0x0000B8, "Member 'ULimePawnComponentOverrides::ClamberingMME' has a wrong offset!");
static_assert(offsetof(ULimePawnComponentOverrides, OnLevelSettingsChanged) == 0x0000C0, "Member 'ULimePawnComponentOverrides::OnLevelSettingsChanged' has a wrong offset!");
static_assert(offsetof(ULimePawnComponentOverrides, VehicleAnimLayerOverlayClass) == 0x0000D0, "Member 'ULimePawnComponentOverrides::VehicleAnimLayerOverlayClass' has a wrong offset!");
static_assert(offsetof(ULimePawnComponentOverrides, DBNOAnimLayerClass) == 0x000120, "Member 'ULimePawnComponentOverrides::DBNOAnimLayerClass' has a wrong offset!");
static_assert(offsetof(ULimePawnComponentOverrides, DBNOCarriedAnimLayerClass) == 0x000128, "Member 'ULimePawnComponentOverrides::DBNOCarriedAnimLayerClass' has a wrong offset!");
static_assert(offsetof(ULimePawnComponentOverrides, SkydiveAnimLayerClass) == 0x000130, "Member 'ULimePawnComponentOverrides::SkydiveAnimLayerClass' has a wrong offset!");
static_assert(offsetof(ULimePawnComponentOverrides, CurrentAnimLayerClass) == 0x000148, "Member 'ULimePawnComponentOverrides::CurrentAnimLayerClass' has a wrong offset!");

// Class LimeNative.LimeSkydivingAnimInstance
// 0x0090 (0x0500 - 0x0470)
class ULimeSkydivingAnimInstance final : public ULimeBaseLayerAnimInstance
{
public:
	struct FFortAnimInput_Skydiving               Skydiving;                                         // 0x0468(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FreeFall_AimPitch;                                 // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsAccelerating2D : 1;                             // 0x04F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4F1[0xF];                                      // 0x04F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeSkydivingAnimInstance">();
	}
	static class ULimeSkydivingAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeSkydivingAnimInstance>();
	}
};
static_assert(alignof(ULimeSkydivingAnimInstance) == 0x000010, "Wrong alignment on ULimeSkydivingAnimInstance");
static_assert(sizeof(ULimeSkydivingAnimInstance) == 0x000500, "Wrong size on ULimeSkydivingAnimInstance");
static_assert(offsetof(ULimeSkydivingAnimInstance, Skydiving) == 0x000468, "Member 'ULimeSkydivingAnimInstance::Skydiving' has a wrong offset!");
static_assert(offsetof(ULimeSkydivingAnimInstance, FreeFall_AimPitch) == 0x0004E8, "Member 'ULimeSkydivingAnimInstance::FreeFall_AimPitch' has a wrong offset!");
static_assert(offsetof(ULimeSkydivingAnimInstance, AimPitch) == 0x0004EC, "Member 'ULimeSkydivingAnimInstance::AimPitch' has a wrong offset!");

// Class LimeNative.LimeGameFeatureAction_AddLimeAnalytics
// 0x0028 (0x0050 - 0x0028)
class ULimeGameFeatureAction_AddLimeAnalytics final : public UGameFeatureAction
{
public:
	TSoftClassPtr<class UClass>                   LimeAnalyticsClass;                                // 0x0028(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULimeAnalytics*                         LimeAnalyticsInstance;                             // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeGameFeatureAction_AddLimeAnalytics">();
	}
	static class ULimeGameFeatureAction_AddLimeAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeGameFeatureAction_AddLimeAnalytics>();
	}
};
static_assert(alignof(ULimeGameFeatureAction_AddLimeAnalytics) == 0x000008, "Wrong alignment on ULimeGameFeatureAction_AddLimeAnalytics");
static_assert(sizeof(ULimeGameFeatureAction_AddLimeAnalytics) == 0x000050, "Wrong size on ULimeGameFeatureAction_AddLimeAnalytics");
static_assert(offsetof(ULimeGameFeatureAction_AddLimeAnalytics, LimeAnalyticsClass) == 0x000028, "Member 'ULimeGameFeatureAction_AddLimeAnalytics::LimeAnalyticsClass' has a wrong offset!");
static_assert(offsetof(ULimeGameFeatureAction_AddLimeAnalytics, LimeAnalyticsInstance) == 0x000048, "Member 'ULimeGameFeatureAction_AddLimeAnalytics::LimeAnalyticsInstance' has a wrong offset!");

// Class LimeNative.LimePlayerAnimInstance
// 0x0000 (0x1B40 - 0x1B40)
class ULimePlayerAnimInstance final : public UFortPlayerAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimePlayerAnimInstance">();
	}
	static class ULimePlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimePlayerAnimInstance>();
	}
};
static_assert(alignof(ULimePlayerAnimInstance) == 0x000010, "Wrong alignment on ULimePlayerAnimInstance");
static_assert(sizeof(ULimePlayerAnimInstance) == 0x001B40, "Wrong size on ULimePlayerAnimInstance");

// Class LimeNative.LimePlayerAnimInstanceProxy
// 0x0000 (0x1620 - 0x1620)
class ULimePlayerAnimInstanceProxy final : public UFortPlayerAnimInstanceProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimePlayerAnimInstanceProxy">();
	}
	static class ULimePlayerAnimInstanceProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimePlayerAnimInstanceProxy>();
	}
};
static_assert(alignof(ULimePlayerAnimInstanceProxy) == 0x000010, "Wrong alignment on ULimePlayerAnimInstanceProxy");
static_assert(sizeof(ULimePlayerAnimInstanceProxy) == 0x001620, "Wrong size on ULimePlayerAnimInstanceProxy");

// Class LimeNative.LimeCameraMode_OrbitCam
// 0x0000 (0x1BA0 - 0x1BA0)
class ULimeCameraMode_OrbitCam : public UFortCameraMode_ThirdPerson
{
public:
	void OnBecomeActiveBP(class AActor* ViewTarget);
	void UpdateCameraBP(class AActor* ViewTarget, float DeltaTime, struct FTViewTarget& OutVT);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeCameraMode_OrbitCam">();
	}
	static class ULimeCameraMode_OrbitCam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeCameraMode_OrbitCam>();
	}
};
static_assert(alignof(ULimeCameraMode_OrbitCam) == 0x000010, "Wrong alignment on ULimeCameraMode_OrbitCam");
static_assert(sizeof(ULimeCameraMode_OrbitCam) == 0x001BA0, "Wrong size on ULimeCameraMode_OrbitCam");

// Class LimeNative.LimeCameraModeOverrideComponent
// 0x0010 (0x00B8 - 0x00A8)
class ULimeCameraModeOverrideComponent final : public UFortCameraModeOverrideComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULimePawnComponentOverrides*            LimePawnComponentOverrides;                        // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateIsOrbitCameraEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeCameraModeOverrideComponent">();
	}
	static class ULimeCameraModeOverrideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeCameraModeOverrideComponent>();
	}
};
static_assert(alignof(ULimeCameraModeOverrideComponent) == 0x000008, "Wrong alignment on ULimeCameraModeOverrideComponent");
static_assert(sizeof(ULimeCameraModeOverrideComponent) == 0x0000B8, "Wrong size on ULimeCameraModeOverrideComponent");
static_assert(offsetof(ULimeCameraModeOverrideComponent, LimePawnComponentOverrides) == 0x0000B0, "Member 'ULimeCameraModeOverrideComponent::LimePawnComponentOverrides' has a wrong offset!");

// Class LimeNative.DebugObserveLimePlugin
// 0x0008 (0x0030 - 0x0028)
class UDebugObserveLimePlugin final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugObserveLimePlugin">();
	}
	static class UDebugObserveLimePlugin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugObserveLimePlugin>();
	}
};
static_assert(alignof(UDebugObserveLimePlugin) == 0x000008, "Wrong alignment on UDebugObserveLimePlugin");
static_assert(sizeof(UDebugObserveLimePlugin) == 0x000030, "Wrong size on UDebugObserveLimePlugin");

// Class LimeNative.GameFeatureAction_LimeDebug
// 0x0010 (0x0038 - 0x0028)
class UGameFeatureAction_LimeDebug final : public UGameFeatureAction
{
public:
	TArray<class UGameFeatureAction*>             ForcePawnActions;                                  // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_LimeDebug">();
	}
	static class UGameFeatureAction_LimeDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_LimeDebug>();
	}
};
static_assert(alignof(UGameFeatureAction_LimeDebug) == 0x000008, "Wrong alignment on UGameFeatureAction_LimeDebug");
static_assert(sizeof(UGameFeatureAction_LimeDebug) == 0x000038, "Wrong size on UGameFeatureAction_LimeDebug");
static_assert(offsetof(UGameFeatureAction_LimeDebug, ForcePawnActions) == 0x000028, "Member 'UGameFeatureAction_LimeDebug::ForcePawnActions' has a wrong offset!");

// Class LimeNative.LimePawnComponentMood
// 0x0030 (0x00D8 - 0x00A8)
class ULimePawnComponentMood final : public UFortPawnComponent
{
public:
	TMulticastInlineDelegate<void(struct FLimeMoodStateData& NewMood)> OnLimeMoodChangedDelegate;                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLimeMoodStateData                     CurrentMoodState;                                  // 0x00D0(0x0004)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentMoodState();

	const struct FLimeMoodStateData GetCurrentMoodState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimePawnComponentMood">();
	}
	static class ULimePawnComponentMood* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimePawnComponentMood>();
	}
};
static_assert(alignof(ULimePawnComponentMood) == 0x000008, "Wrong alignment on ULimePawnComponentMood");
static_assert(sizeof(ULimePawnComponentMood) == 0x0000D8, "Wrong size on ULimePawnComponentMood");
static_assert(offsetof(ULimePawnComponentMood, OnLimeMoodChangedDelegate) == 0x0000A8, "Member 'ULimePawnComponentMood::OnLimeMoodChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULimePawnComponentMood, CurrentMoodState) == 0x0000D0, "Member 'ULimePawnComponentMood::CurrentMoodState' has a wrong offset!");

// Class LimeNative.LimePawnComponent
// 0x0000 (0x00A8 - 0x00A8)
class ULimePawnComponent final : public UFortPawnComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimePawnComponent">();
	}
	static class ULimePawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimePawnComponent>();
	}
};
static_assert(alignof(ULimePawnComponent) == 0x000008, "Wrong alignment on ULimePawnComponent");
static_assert(sizeof(ULimePawnComponent) == 0x0000A8, "Wrong size on ULimePawnComponent");

// Class LimeNative.LimePawnComponent_EmotionalState
// 0x0090 (0x0138 - 0x00A8)
class ULimePawnComponent_EmotionalState final : public UFortPawnComponent
{
public:
	TMulticastInlineDelegate<void(ELimePawnEmotionalState NewEmotion)> OnLimeCurrentEmotionalStateChangedDelegate;        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELimePawnEmotionalState NewEmotion)> OnLimeCurrentEmotionalStateStartedChange;          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float NewEmotionPercent)> OnLimeCurrentEmotionChangeFinished;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(uint8 EmotionIndex)> OnCheatEmotionIndexChanged;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ELimePawnEmotionalState                       CurrentEmotionalState;                             // 0x00E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLimeEmotionalStateData                TargetEmotionalState;                              // 0x00EC(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         CheatEmotionIndex;                                 // 0x00FC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLimePawnEmotionalStateMappingFromAwesomeLevel> LimePawnEmotionalStateMappingFromAwesomeLevel;     // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetToDefaultEmotionRate;                         // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeToStayAtEmotionInSeconds;                      // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DefaultEmotionHandle;                              // 0x0128(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLimeAwesomeLevelChanged(const int32 NewAwesomeLevel);
	void OnRep_CheatEmotionIndex();
	void OnRep_CurrentEmotionalState();
	void OnRep_TargetEmotionalState();
	void ResetToDefaultEmotionalState();
	void SetCurrentEmotionalState(const ELimePawnEmotionalState NewEmotion);
	void SetEmotionalState(const struct FLimeEmotionalStateData& Emotion);

	ELimePawnEmotionalState GetCurrentEmotionalState() const;
	float GetCurrentEmotionalStateValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimePawnComponent_EmotionalState">();
	}
	static class ULimePawnComponent_EmotionalState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimePawnComponent_EmotionalState>();
	}
};
static_assert(alignof(ULimePawnComponent_EmotionalState) == 0x000008, "Wrong alignment on ULimePawnComponent_EmotionalState");
static_assert(sizeof(ULimePawnComponent_EmotionalState) == 0x000138, "Wrong size on ULimePawnComponent_EmotionalState");
static_assert(offsetof(ULimePawnComponent_EmotionalState, OnLimeCurrentEmotionalStateChangedDelegate) == 0x0000A8, "Member 'ULimePawnComponent_EmotionalState::OnLimeCurrentEmotionalStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, OnLimeCurrentEmotionalStateStartedChange) == 0x0000B8, "Member 'ULimePawnComponent_EmotionalState::OnLimeCurrentEmotionalStateStartedChange' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, OnLimeCurrentEmotionChangeFinished) == 0x0000C8, "Member 'ULimePawnComponent_EmotionalState::OnLimeCurrentEmotionChangeFinished' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, OnCheatEmotionIndexChanged) == 0x0000D8, "Member 'ULimePawnComponent_EmotionalState::OnCheatEmotionIndexChanged' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, CurrentEmotionalState) == 0x0000E8, "Member 'ULimePawnComponent_EmotionalState::CurrentEmotionalState' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, TargetEmotionalState) == 0x0000EC, "Member 'ULimePawnComponent_EmotionalState::TargetEmotionalState' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, CheatEmotionIndex) == 0x0000FC, "Member 'ULimePawnComponent_EmotionalState::CheatEmotionIndex' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, LimePawnEmotionalStateMappingFromAwesomeLevel) == 0x000100, "Member 'ULimePawnComponent_EmotionalState::LimePawnEmotionalStateMappingFromAwesomeLevel' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, ResetToDefaultEmotionRate) == 0x000118, "Member 'ULimePawnComponent_EmotionalState::ResetToDefaultEmotionRate' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, TimeToStayAtEmotionInSeconds) == 0x00011C, "Member 'ULimePawnComponent_EmotionalState::TimeToStayAtEmotionInSeconds' has a wrong offset!");
static_assert(offsetof(ULimePawnComponent_EmotionalState, DefaultEmotionHandle) == 0x000128, "Member 'ULimePawnComponent_EmotionalState::DefaultEmotionHandle' has a wrong offset!");

// Class LimeNative.LimeGlobals
// 0x0000 (0x0028 - 0x0028)
class ULimeGlobals final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimeGlobals">();
	}
	static class ULimeGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimeGlobals>();
	}
};
static_assert(alignof(ULimeGlobals) == 0x000008, "Wrong alignment on ULimeGlobals");
static_assert(sizeof(ULimeGlobals) == 0x000028, "Wrong size on ULimeGlobals");

}

