#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SparksCosmeticsRuntime

#include "Basic.hpp"

#include "SparksCosmeticsRuntime_classes.hpp"
#include "SparksCosmeticsRuntime_parameters.hpp"


namespace SDK
{

// Function SparksCosmeticsRuntime.FortAnimNotifyState_SpawnSparksProp.InitNewNotify
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// ESparksInstrumentType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InLeftHand                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAuxMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagQuery                InSkipActorsWithTag                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   InPropId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    InDefaultMesh                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortAnimNotifyState_SpawnSparksProp::InitNewNotify(ESparksInstrumentType InType, bool InLeftHand, bool InAuxMesh, class FName InSocketName, const struct FGameplayTagQuery& InSkipActorsWithTag, int32 InPropId, class USkeletalMesh* InDefaultMesh) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitNewNotify");

	Params::FortAnimNotifyState_SpawnSparksProp_InitNewNotify Parms{};

	Parms.InType = InType;
	Parms.InLeftHand = InLeftHand;
	Parms.InAuxMesh = InAuxMesh;
	Parms.InSocketName = InSocketName;
	Parms.InSkipActorsWithTag = std::move(InSkipActorsWithTag);
	Parms.InPropId = InPropId;
	Parms.InDefaultMesh = InDefaultMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksAccountItemDefinition.GetInstrumentType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksInstrumentType USparksAccountItemDefinition::GetInstrumentType() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstrumentType");

	Params::SparksAccountItemDefinition_GetInstrumentType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksAccountItemDefinition.GetItemSubtype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksAccountItemSubtype               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksAccountItemSubtype USparksAccountItemDefinition::GetItemSubtype() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetItemSubtype");

	Params::SparksAccountItemDefinition_GetItemSubtype Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksAccountItemDefinition.GetVariantChannelOptionNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutChannelName                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USparksAccountItemDefinition::GetVariantChannelOptionNames(const struct FGameplayTag& ChannelTag, class FText* OutChannelName, TArray<class FString>* OutNames) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVariantChannelOptionNames");

	Params::SparksAccountItemDefinition_GetVariantChannelOptionNames Parms{};

	Parms.ChannelTag = std::move(ChannelTag);

	UObject::ProcessEvent(Func, &Parms);

	if (OutChannelName != nullptr)
		*OutChannelName = std::move(Parms.OutChannelName);

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function SparksCosmeticsRuntime.SparksAccountItemDefinition.GetVariantChannelTags
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGameplayTag>             OutChannelTags                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USparksAccountItemDefinition::GetVariantChannelTags(TArray<struct FGameplayTag>* OutChannelTags) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVariantChannelTags");

	Params::SparksAccountItemDefinition_GetVariantChannelTags Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutChannelTags != nullptr)
		*OutChannelTags = std::move(Parms.OutChannelTags);
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetSparksCosmeticCatalog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USparksCosmeticCatalog*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksCosmeticCatalog* USparksCosmeticCatalog::GetSparksCosmeticCatalog(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSparksCosmeticCatalog");

	Params::SparksCosmeticCatalog_GetSparksCosmeticCatalog Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetItemDefFromAssetID
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USparksAccountItemDefinition*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksAccountItemDefinition* USparksCosmeticCatalog::GetItemDefFromAssetID(const struct FPrimaryAssetId& AssetId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetItemDefFromAssetID");

	Params::SparksCosmeticCatalog_GetItemDefFromAssetID Parms{};

	Parms.AssetId = std::move(AssetId);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetActiveItemDefNamesForSubtype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> USparksCosmeticCatalog::GetActiveItemDefNamesForSubtype(ESparksAccountItemSubtype Subtype) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveItemDefNamesForSubtype");

	Params::SparksCosmeticCatalog_GetActiveItemDefNamesForSubtype Parms{};

	Parms.Subtype = Subtype;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetActiveItemDefNamesForSubtypeAndInstrument
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksInstrumentType                   Instrument                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> USparksCosmeticCatalog::GetActiveItemDefNamesForSubtypeAndInstrument(ESparksAccountItemSubtype Subtype, ESparksInstrumentType Instrument) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveItemDefNamesForSubtypeAndInstrument");

	Params::SparksCosmeticCatalog_GetActiveItemDefNamesForSubtypeAndInstrument Parms{};

	Parms.Subtype = Subtype;
	Parms.Instrument = Instrument;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetItemDef
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USparksAccountItemDefinition*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksAccountItemDefinition* USparksCosmeticCatalog::GetItemDef(class FName InItemName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetItemDef");

	Params::SparksCosmeticCatalog_GetItemDef Parms{};

	Parms.InItemName = InItemName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.AuraStart
// (Final, Native, Protected, BlueprintCallable)

void USparksCosmeticComponent::AuraStart()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AuraStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.AuraStop
// (Final, Native, Protected, BlueprintCallable)

void USparksCosmeticComponent::AuraStop()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AuraStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.Debug_BP_ShowCosmeticPicker
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::Debug_BP_ShowCosmeticPicker(bool bShow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Debug_BP_ShowCosmeticPicker");

	Params::SparksCosmeticComponent_Debug_BP_ShowCosmeticPicker Parms{};

	Parms.bShow = bShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.DebugForceAuraState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBeActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::DebugForceAuraState(bool bShouldBeActive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugForceAuraState");

	Params::SparksCosmeticComponent_DebugForceAuraState Parms{};

	Parms.bShouldBeActive = bShouldBeActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.DoCacheValidJamTracks
// (Final, Native, Private)

void USparksCosmeticComponent::DoCacheValidJamTracks()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DoCacheValidJamTracks");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetCosmeticItems
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USparksAccountItemDefinition*>ItemDefs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::GetCosmeticItems(TArray<class USparksAccountItemDefinition*>* ItemDefs)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCosmeticItems");

	Params::SparksCosmeticComponent_GetCosmeticItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemDefs != nullptr)
		*ItemDefs = std::move(Parms.ItemDefs);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetEquippedJamSongShortnameForIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USparksCosmeticComponent::GetEquippedJamSongShortnameForIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEquippedJamSongShortnameForIndex");

	Params::SparksCosmeticComponent_GetEquippedJamSongShortnameForIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetOwnedJamSongShortnameForIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USparksCosmeticComponent::GetOwnedJamSongShortnameForIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwnedJamSongShortnameForIndex");

	Params::SparksCosmeticComponent_GetOwnedJamSongShortnameForIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetOwnedJamTracksCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksCosmeticComponent::GetOwnedJamTracksCount()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwnedJamTracksCount");

	Params::SparksCosmeticComponent_GetOwnedJamTracksCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.OnMaterialOverridesCleared
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerPawn*                  Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::OnMaterialOverridesCleared(class AFortPlayerPawn* Pawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMaterialOverridesCleared");

	Params::SparksCosmeticComponent_OnMaterialOverridesCleared Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.OnWeaponChanged
// (Final, Native, Protected)
// Parameters:
// class AFortWeapon*                      NewWeapon                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortWeapon*                      PrevWeapon                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::OnWeaponChanged(class AFortWeapon* NewWeapon, class AFortWeapon* PrevWeapon)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnWeaponChanged");

	Params::SparksCosmeticComponent_OnWeaponChanged Parms{};

	Parms.NewWeapon = NewWeapon;
	Parms.PrevWeapon = PrevWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.RefreshMCP
// (Final, Native, Protected, BlueprintCallable)

void USparksCosmeticComponent::RefreshMCP()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RefreshMCP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetActiveAuraItemDef
// (Final, Native, Private)
// Parameters:
// class USparksAuraItemDefinition*        NewAuraItemDef                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetActiveAuraItemDef(class USparksAuraItemDefinition* NewAuraItemDef)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActiveAuraItemDef");

	Params::SparksCosmeticComponent_SetActiveAuraItemDef Parms{};

	Parms.NewAuraItemDef = NewAuraItemDef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetActiveInstrumentItemDef
// (Final, Native, Private)
// Parameters:
// class USparksInstrumentItemDefBase*     InstrumentItemDef                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetActiveInstrumentItemDef(class USparksInstrumentItemDefBase* InstrumentItemDef)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActiveInstrumentItemDef");

	Params::SparksCosmeticComponent_SetActiveInstrumentItemDef Parms{};

	Parms.InstrumentItemDef = InstrumentItemDef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetActiveItemDef
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USparksAccountItemDefinition*     NewItemDef                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetActiveItemDef(class USparksAccountItemDefinition* NewItemDef)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActiveItemDef");

	Params::SparksCosmeticComponent_SetActiveItemDef Parms{};

	Parms.NewItemDef = NewItemDef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetActiveSpotlightAnimDef
// (Final, Native, Private)
// Parameters:
// class USparksSpotlightAnimDefinition*   NewSpotlightDef                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetActiveSpotlightAnimDef(class USparksSpotlightAnimDefinition* NewSpotlightDef)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActiveSpotlightAnimDef");

	Params::SparksCosmeticComponent_SetActiveSpotlightAnimDef Parms{};

	Parms.NewSpotlightDef = NewSpotlightDef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetAuraState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBeActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetAuraState(bool bShouldBeActive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAuraState");

	Params::SparksCosmeticComponent_SetAuraState Parms{};

	Parms.bShouldBeActive = bShouldBeActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetVariantChoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     VariantChannel                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetVariantChoice(ESparksAccountItemSubtype Subtype, ESparksInstrumentType InstrumentType, const struct FGameplayTag& VariantChannel, const class FString& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVariantChoice");

	Params::SparksCosmeticComponent_SetVariantChoice Parms{};

	Parms.Subtype = Subtype;
	Parms.InstrumentType = InstrumentType;
	Parms.VariantChannel = std::move(VariantChannel);
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetAccountItemTypeFromInstrumentType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   Instrument                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksAccountItemSubtype               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksAccountItemSubtype USparksCosmeticComponent::GetAccountItemTypeFromInstrumentType(ESparksInstrumentType Instrument) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAccountItemTypeFromInstrumentType");

	Params::SparksCosmeticComponent_GetAccountItemTypeFromInstrumentType Parms{};

	Parms.Instrument = Instrument;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetChoice
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoice             OutChoice                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     VariantChannel                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCosmeticComponent::GetChoice(struct FSparksVariantChoice* OutChoice, ESparksAccountItemSubtype Subtype, ESparksInstrumentType InstrumentType, const struct FGameplayTag& VariantChannel) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetChoice");

	Params::SparksCosmeticComponent_GetChoice Parms{};

	Parms.Subtype = Subtype;
	Parms.InstrumentType = InstrumentType;
	Parms.VariantChannel = std::move(VariantChannel);

	UObject::ProcessEvent(Func, &Parms);

	if (OutChoice != nullptr)
		*OutChoice = std::move(Parms.OutChoice);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetCosmeticItem
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksInstrumentType                   Instrument                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USparksAccountItemDefinition*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USparksAccountItemDefinition* USparksCosmeticComponent::GetCosmeticItem(ESparksAccountItemSubtype Subtype, ESparksInstrumentType Instrument) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCosmeticItem");

	Params::SparksCosmeticComponent_GetCosmeticItem Parms{};

	Parms.Subtype = Subtype;
	Parms.Instrument = Instrument;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetEquippedJamTracksCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksCosmeticComponent::GetEquippedJamTracksCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEquippedJamTracksCount");

	Params::SparksCosmeticComponent_GetEquippedJamTracksCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetInstrumentAuxiliaryCosmetics
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    OutMesh                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                OutMaterial                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                OutMaterial2                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCosmeticComponent::GetInstrumentAuxiliaryCosmetics(ESparksInstrumentType InstrumentType, class USkeletalMesh** OutMesh, class UMaterialInstance** OutMaterial, class UMaterialInstance** OutMaterial2) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstrumentAuxiliaryCosmetics");

	Params::SparksCosmeticComponent_GetInstrumentAuxiliaryCosmetics Parms{};

	Parms.InstrumentType = InstrumentType;

	UObject::ProcessEvent(Func, &Parms);

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;

	if (OutMaterial != nullptr)
		*OutMaterial = Parms.OutMaterial;

	if (OutMaterial2 != nullptr)
		*OutMaterial2 = Parms.OutMaterial2;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetInstrumentCosmetics
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    OutMesh                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                OutMaterial                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    OutLHMesh                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                OutLHMaterial                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCosmeticComponent::GetInstrumentCosmetics(ESparksInstrumentType InstrumentType, class USkeletalMesh** OutMesh, class UMaterialInstance** OutMaterial, class USkeletalMesh** OutLHMesh, class UMaterialInstance** OutLHMaterial) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstrumentCosmetics");

	Params::SparksCosmeticComponent_GetInstrumentCosmetics Parms{};

	Parms.InstrumentType = InstrumentType;

	UObject::ProcessEvent(Func, &Parms);

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;

	if (OutMaterial != nullptr)
		*OutMaterial = Parms.OutMaterial;

	if (OutLHMesh != nullptr)
		*OutLHMesh = Parms.OutLHMesh;

	if (OutLHMaterial != nullptr)
		*OutLHMaterial = Parms.OutLHMaterial;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetSpotlightAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelSequence* USparksCosmeticComponent::GetSpotlightAnim(ESparksInstrumentType InstrumentType) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSpotlightAnim");

	Params::SparksCosmeticComponent_GetSpotlightAnim Parms{};

	Parms.InstrumentType = InstrumentType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticsCheatManager.GrantSparksCosmeticsLoadedAssets
// (Final, BlueprintAuthorityOnly, Exec, Native, Private, Const)

void USparksCosmeticsCheatManager::GrantSparksCosmeticsLoadedAssets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GrantSparksCosmeticsLoadedAssets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCosmeticsRuntime.SparksCosmeticsCheatManager.GrantSparksSongsLoadedAssets
// (Final, BlueprintAuthorityOnly, Exec, Native, Private, Const)

void USparksCosmeticsCheatManager::GrantSparksSongsLoadedAssets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GrantSparksSongsLoadedAssets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCosmeticsRuntime.SparksInstrumentComponentBase.GetInstrumentType
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksInstrumentType USparksInstrumentComponentBase::GetInstrumentType() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstrumentType");

	Params::SparksInstrumentComponentBase_GetInstrumentType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetAuxFXSystem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemAsset* USparksInstrumentItemDefBase::GetAuxFXSystem(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAuxFXSystem");

	Params::SparksInstrumentItemDefBase_GetAuxFXSystem Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetAuxiliaryMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USparksInstrumentItemDefBase::GetAuxiliaryMaterial(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAuxiliaryMaterial");

	Params::SparksInstrumentItemDefBase_GetAuxiliaryMaterial Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetAuxiliaryMaterial2
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USparksInstrumentItemDefBase::GetAuxiliaryMaterial2(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAuxiliaryMaterial2");

	Params::SparksInstrumentItemDefBase_GetAuxiliaryMaterial2 Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetAuxiliaryMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* USparksInstrumentItemDefBase::GetAuxiliaryMesh(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAuxiliaryMesh");

	Params::SparksInstrumentItemDefBase_GetAuxiliaryMesh Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetLeftHandMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USparksInstrumentItemDefBase::GetLeftHandMaterial(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLeftHandMaterial");

	Params::SparksInstrumentItemDefBase_GetLeftHandMaterial Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetLeftHandMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* USparksInstrumentItemDefBase::GetLeftHandMesh(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLeftHandMesh");

	Params::SparksInstrumentItemDefBase_GetLeftHandMesh Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetLHFXSystem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemAsset* USparksInstrumentItemDefBase::GetLHFXSystem(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLHFXSystem");

	Params::SparksInstrumentItemDefBase_GetLHFXSystem Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetMainFXSystem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemAsset* USparksInstrumentItemDefBase::GetMainFXSystem(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMainFXSystem");

	Params::SparksInstrumentItemDefBase_GetMainFXSystem Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USparksInstrumentItemDefBase::GetMaterial(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterial");

	Params::SparksInstrumentItemDefBase_GetMaterial Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* USparksInstrumentItemDefBase::GetMesh(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMesh");

	Params::SparksInstrumentItemDefBase_GetMesh Parms{};

	Parms.Choices = std::move(Choices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentPreviewActor.GetCurrentChoices
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSparksVariantChoices ASparksInstrumentPreviewActor::GetCurrentChoices() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentChoices");

	Params::SparksInstrumentPreviewActor_GetCurrentChoices Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksItemPreviewOffPawnActor.GetInstrumentType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESparksInstrumentType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksInstrumentType ASparksItemPreviewOffPawnActor::GetInstrumentType()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstrumentType");

	Params::SparksItemPreviewOffPawnActor_GetInstrumentType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.GetJamLoopType
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFMJamLoopType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFMJamLoopType USparksJamEmoteItemDefinition::GetJamLoopType() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetJamLoopType");

	Params::SparksJamEmoteItemDefinition_GetJamLoopType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.GetJamSongMetaData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCatalogData*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCatalogData* USparksJamEmoteItemDefinition::GetJamSongMetaData(const class UObject* WorldContextObject) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetJamSongMetaData");

	Params::SparksJamEmoteItemDefinition_GetJamSongMetaData Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.GetJamSongShortName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USparksJamEmoteItemDefinition::GetJamSongShortName(const class UObject* WorldContextObject) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetJamSongShortName");

	Params::SparksJamEmoteItemDefinition_GetJamSongShortName Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.GetSongItemDef
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USparksSongItemDefinition*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksSongItemDefinition* USparksJamEmoteItemDefinition::GetSongItemDef() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSongItemDef");

	Params::SparksJamEmoteItemDefinition_GetSongItemDef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.IsJamLoopEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AFortPlayerController*            PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksJamEmoteItemDefinition::IsJamLoopEnabled(const class AFortPlayerController* PlayerController) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsJamLoopEnabled");

	Params::SparksJamEmoteItemDefinition_IsJamLoopEnabled Parms{};

	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksPlayerStateComponent.SetSparksInstrumentChoice
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ESparksInstrumentType                   Instrument                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksPlayerStateComponent::SetSparksInstrumentChoice(ESparksInstrumentType Instrument)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSparksInstrumentChoice");

	Params::SparksPlayerStateComponent_SetSparksInstrumentChoice Parms{};

	Parms.Instrument = Instrument;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksPlayerStateComponent.GetSparksInstrumentChoice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksInstrumentType USparksPlayerStateComponent::GetSparksInstrumentChoice() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSparksInstrumentChoice");

	Params::SparksPlayerStateComponent_GetSparksInstrumentChoice Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksSongPreviewActor.OnSongTextureLoaded
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       CoverArt                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASparksSongPreviewActor::OnSongTextureLoaded(class UTexture2D* CoverArt)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSongTextureLoaded");

	Params::SparksSongPreviewActor_OnSongTextureLoaded Parms{};

	Parms.CoverArt = CoverArt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksSongPreviewActor.StartSongPreview
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASparksSongPreviewActor::StartSongPreview()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartSongPreview");

	UObject::ProcessEvent(Func, nullptr);
}

}

