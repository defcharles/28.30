#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LearningAgents

#include "Basic.hpp"

#include "LearningAgents_classes.hpp"
#include "LearningAgents_parameters.hpp"


namespace SDK
{

// Function LearningAgents.FloatAction.AddFloatAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFloatAction*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFloatAction* UFloatAction::AddFloatAction(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddFloatAction");

	Params::FloatAction_AddFloatAction Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.FloatAction.GetFloatAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFloatAction::GetFloatAction(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFloatAction");

	Params::FloatAction_GetFloatAction Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.FloatAction.SetFloatAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFloatAction::SetFloatAction(const int32 AgentId, const float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFloatAction");

	Params::FloatAction_SetFloatAction Parms{};

	Parms.AgentId = AgentId;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.FloatArrayAction.AddFloatArrayAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFloatArrayAction*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFloatArrayAction* UFloatArrayAction::AddFloatArrayAction(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 Num, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddFloatArrayAction");

	Params::FloatArrayAction_AddFloatArrayAction Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Num = Num;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.FloatArrayAction.GetFloatArrayAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           OutValues                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UFloatArrayAction::GetFloatArrayAction(const int32 AgentId, TArray<float>* OutValues)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFloatArrayAction");

	Params::FloatArrayAction_GetFloatArrayAction Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	if (OutValues != nullptr)
		*OutValues = std::move(Parms.OutValues);
}


// Function LearningAgents.FloatArrayAction.SetFloatArrayAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UFloatArrayAction::SetFloatArrayAction(const int32 AgentId, const TArray<float>& Values)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFloatArrayAction");

	Params::FloatArrayAction_SetFloatArrayAction Parms{};

	Parms.AgentId = AgentId;
	Parms.Values = std::move(Values);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.VectorAction.AddVectorAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVectorAction*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVectorAction* UVectorAction::AddVectorAction(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddVectorAction");

	Params::VectorAction_AddVectorAction Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.VectorAction.GetVectorAction
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVectorAction::GetVectorAction(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVectorAction");

	Params::VectorAction_GetVectorAction Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.VectorAction.SetVectorAction
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVectorAction::SetVectorAction(const int32 AgentId, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorAction");

	Params::VectorAction_SetVectorAction Parms{};

	Parms.AgentId = AgentId;
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.VectorArrayAction.AddVectorArrayAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVectorArrayAction*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVectorArrayAction* UVectorArrayAction::AddVectorArrayAction(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 Num, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddVectorArrayAction");

	Params::VectorArrayAction_AddVectorArrayAction Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Num = Num;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.VectorArrayAction.GetVectorArrayAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutVectors                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UVectorArrayAction::GetVectorArrayAction(const int32 AgentId, TArray<struct FVector>* OutVectors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVectorArrayAction");

	Params::VectorArrayAction_GetVectorArrayAction Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	if (OutVectors != nullptr)
		*OutVectors = std::move(Parms.OutVectors);
}


// Function LearningAgents.VectorArrayAction.SetVectorArrayAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Vectors                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UVectorArrayAction::SetVectorArrayAction(const int32 AgentId, const TArray<struct FVector>& Vectors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorArrayAction");

	Params::VectorArrayAction_SetVectorArrayAction Parms{};

	Parms.AgentId = AgentId;
	Parms.Vectors = std::move(Vectors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PlanarVelocityAction.AddPlanarVelocityAction
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis1                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlanarVelocityAction*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlanarVelocityAction* UPlanarVelocityAction::AddPlanarVelocityAction(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale, const struct FVector& Axis0, const struct FVector& Axis1)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPlanarVelocityAction");

	Params::PlanarVelocityAction_AddPlanarVelocityAction Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;
	Parms.Axis0 = std::move(Axis0);
	Parms.Axis1 = std::move(Axis1);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PlanarVelocityAction.GetPlanarVelocityAction
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPlanarVelocityAction::GetPlanarVelocityAction(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlanarVelocityAction");

	Params::PlanarVelocityAction_GetPlanarVelocityAction Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PlanarVelocityAction.SetPlanarVelocityAction
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlanarVelocityAction::SetPlanarVelocityAction(const int32 AgentId, const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlanarVelocityAction");

	Params::PlanarVelocityAction_SetPlanarVelocityAction Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocity = std::move(Velocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.RotationAction.AddRotationAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URotationAction*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URotationAction* URotationAction::AddRotationAction(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddRotationAction");

	Params::RotationAction_AddRotationAction Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.RotationAction.GetRotationAction
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator URotationAction::GetRotationAction(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationAction");

	Params::RotationAction_GetRotationAction Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.RotationAction.GetRotationActionAsQuat
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQuat URotationAction::GetRotationActionAsQuat(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationActionAsQuat");

	Params::RotationAction_GetRotationActionAsQuat Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.RotationAction.GetRotationActionAsRotationVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URotationAction::GetRotationActionAsRotationVector(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationActionAsRotationVector");

	Params::RotationAction_GetRotationActionAsRotationVector Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.RotationArrayAction.AddRotationArrayAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RotationNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URotationArrayAction*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URotationArrayAction* URotationArrayAction::AddRotationArrayAction(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 RotationNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddRotationArrayAction");

	Params::RotationArrayAction_AddRotationArrayAction Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.RotationNum = RotationNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.RotationArrayAction.GetRotationArrayAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRotator>                 OutRotations                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URotationArrayAction::GetRotationArrayAction(const int32 AgentId, TArray<struct FRotator>* OutRotations)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationArrayAction");

	Params::RotationArrayAction_GetRotationArrayAction Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	if (OutRotations != nullptr)
		*OutRotations = std::move(Parms.OutRotations);
}


// Function LearningAgents.RotationArrayAction.GetRotationArrayActionAsQuats
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FQuat>                    OutRotations                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URotationArrayAction::GetRotationArrayActionAsQuats(const int32 AgentId, TArray<struct FQuat>* OutRotations)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationArrayActionAsQuats");

	Params::RotationArrayAction_GetRotationArrayActionAsQuats Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	if (OutRotations != nullptr)
		*OutRotations = std::move(Parms.OutRotations);
}


// Function LearningAgents.RotationArrayAction.GetRotationArrayActionAsRotationVectors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutRotationVectors                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URotationArrayAction::GetRotationArrayActionAsRotationVectors(const int32 AgentId, TArray<struct FVector>* OutRotationVectors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationArrayActionAsRotationVectors");

	Params::RotationArrayAction_GetRotationArrayActionAsRotationVectors Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	if (OutRotationVectors != nullptr)
		*OutRotationVectors = std::move(Parms.OutRotationVectors);
}


// Function LearningAgents.LearningAgentsManagerComponent.AgentsAdded
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULearningAgentsManagerComponent::AgentsAdded(const TArray<int32>& AgentIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AgentsAdded");

	Params::LearningAgentsManagerComponent_AgentsAdded Parms{};

	Parms.AgentIds = std::move(AgentIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManagerComponent.AgentsRemoved
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULearningAgentsManagerComponent::AgentsRemoved(const TArray<int32>& AgentIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AgentsRemoved");

	Params::LearningAgentsManagerComponent_AgentsRemoved Parms{};

	Parms.AgentIds = std::move(AgentIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManagerComponent.AgentsReset
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULearningAgentsManagerComponent::AgentsReset(const TArray<int32>& AgentIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AgentsReset");

	Params::LearningAgentsManagerComponent_AgentsReset Parms{};

	Parms.AgentIds = std::move(AgentIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManagerComponent.GetAgent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              AgentClass                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* ULearningAgentsManagerComponent::GetAgent(const int32 AgentId, const TSubclassOf<class UObject> AgentClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAgent");

	Params::LearningAgentsManagerComponent_GetAgent Parms{};

	Parms.AgentId = AgentId;
	Parms.AgentClass = AgentClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsManagerComponent.GetAgentManager
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ALearningAgentsManager>AgentManagerClass                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALearningAgentsManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALearningAgentsManager* ULearningAgentsManagerComponent::GetAgentManager(const TSubclassOf<class ALearningAgentsManager> AgentManagerClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAgentManager");

	Params::LearningAgentsManagerComponent_GetAgentManager Parms{};

	Parms.AgentManagerClass = AgentManagerClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsManagerComponent.GetAgents
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              AgentClass                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  OutAgents                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULearningAgentsManagerComponent::GetAgents(const TArray<int32>& AgentIds, const TSubclassOf<class UObject> AgentClass, TArray<class UObject*>* OutAgents) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAgents");

	Params::LearningAgentsManagerComponent_GetAgents Parms{};

	Parms.AgentIds = std::move(AgentIds);
	Parms.AgentClass = AgentClass;

	UObject::ProcessEvent(Func, &Parms);

	if (OutAgents != nullptr)
		*OutAgents = std::move(Parms.OutAgents);
}


// Function LearningAgents.LearningAgentsManagerComponent.GetAllAgents
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<class UObject*>                  OutAgents                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           OutAgentIds                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              AgentClass                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsManagerComponent::GetAllAgents(TArray<class UObject*>* OutAgents, TArray<int32>* OutAgentIds, const TSubclassOf<class UObject> AgentClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllAgents");

	Params::LearningAgentsManagerComponent_GetAllAgents Parms{};

	Parms.AgentClass = AgentClass;

	UObject::ProcessEvent(Func, &Parms);

	if (OutAgents != nullptr)
		*OutAgents = std::move(Parms.OutAgents);

	if (OutAgentIds != nullptr)
		*OutAgentIds = std::move(Parms.OutAgentIds);
}


// Function LearningAgents.LearningAgentsManagerComponent.IsSetup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULearningAgentsManagerComponent::IsSetup() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSetup");

	Params::LearningAgentsManagerComponent_IsSetup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsController.EncodeActions
// (Final, Native, Public, BlueprintCallable)

void ULearningAgentsController::EncodeActions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EncodeActions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsController.RunController
// (Final, Native, Public, BlueprintCallable)

void ULearningAgentsController::RunController()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RunController");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsController.SetActions
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULearningAgentsController::SetActions(const TArray<int32>& AgentIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActions");

	Params::LearningAgentsController_SetActions Parms{};

	Parms.AgentIds = std::move(AgentIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsController.SetupController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsController::SetupController(class ULearningAgentsInteractor* InInteractor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetupController");

	Params::LearningAgentsController_SetupController Parms{};

	Parms.InInteractor = InInteractor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsController.GetInteractor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ULearningAgentsInteractor>InteractorClass                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULearningAgentsInteractor*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULearningAgentsInteractor* ULearningAgentsController::GetInteractor(const TSubclassOf<class ULearningAgentsInteractor> InteractorClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInteractor");

	Params::LearningAgentsController_GetInteractor Parms{};

	Parms.InteractorClass = InteractorClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsCritic.EvaluateCritic
// (Final, Native, Public, BlueprintCallable)

void ULearningAgentsCritic::EvaluateCritic()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EvaluateCritic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsCritic.LoadCriticFromAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsCritic::LoadCriticFromAsset(class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LoadCriticFromAsset");

	Params::LearningAgentsCritic_LoadCriticFromAsset Parms{};

	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsCritic.LoadCriticFromSnapshot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFilePath                        File                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsCritic::LoadCriticFromSnapshot(const struct FFilePath& File)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LoadCriticFromSnapshot");

	Params::LearningAgentsCritic_LoadCriticFromSnapshot Parms{};

	Parms.File = std::move(File);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsCritic.SaveCriticToAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsCritic::SaveCriticToAsset(class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SaveCriticToAsset");

	Params::LearningAgentsCritic_SaveCriticToAsset Parms{};

	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsCritic.SetupCritic
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULearningAgentsPolicy*            InPolicy                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLearningAgentsCriticSettings    CriticSettings                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsCritic::SetupCritic(class ULearningAgentsInteractor* InInteractor, class ULearningAgentsPolicy* InPolicy, const struct FLearningAgentsCriticSettings& CriticSettings, class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetupCritic");

	Params::LearningAgentsCritic_SetupCritic Parms{};

	Parms.InInteractor = InInteractor;
	Parms.InPolicy = InPolicy;
	Parms.CriticSettings = std::move(CriticSettings);
	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsCritic.UseCriticFromAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsCritic::UseCriticFromAsset(class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UseCriticFromAsset");

	Params::LearningAgentsCritic_UseCriticFromAsset Parms{};

	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsCritic.GetEstimatedDiscountedReturn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULearningAgentsCritic::GetEstimatedDiscountedReturn(const int32 AgentId) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEstimatedDiscountedReturn");

	Params::LearningAgentsCritic_GetEstimatedDiscountedReturn Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsCritic.SaveCriticToSnapshot
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FFilePath                        File                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsCritic::SaveCriticToSnapshot(const struct FFilePath& File) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SaveCriticToSnapshot");

	Params::LearningAgentsCritic_SaveCriticToSnapshot Parms{};

	Parms.File = std::move(File);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.SplineComponentHelper.AddSplineComponentHelper
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsManagerComponent*  InManagerComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponentHelper*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineComponentHelper* USplineComponentHelper::AddSplineComponentHelper(class ULearningAgentsManagerComponent* InManagerComponent, const class FName Name_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddSplineComponentHelper");

	Params::SplineComponentHelper_AddSplineComponentHelper Parms{};

	Parms.InManagerComponent = InManagerComponent;
	Parms.Name_0 = Name_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.SplineComponentHelper.GetDirectionAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 SplineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponentHelper::GetDirectionAtDistanceAlongSpline(const int32 AgentId, const class USplineComponent* SplineComponent, const float DistanceAlongSpline, const ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDirectionAtDistanceAlongSpline");

	Params::SplineComponentHelper_GetDirectionAtDistanceAlongSpline Parms{};

	Parms.AgentId = AgentId;
	Parms.SplineComponent = SplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.SplineComponentHelper.GetDistanceAlongSplineAtPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 SplineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponentHelper::GetDistanceAlongSplineAtPosition(const int32 AgentId, const class USplineComponent* SplineComponent, const struct FVector& Position, const ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDistanceAlongSplineAtPosition");

	Params::SplineComponentHelper_GetDistanceAlongSplineAtPosition Parms{};

	Parms.AgentId = AgentId;
	Parms.SplineComponent = SplineComponent;
	Parms.Position = std::move(Position);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.SplineComponentHelper.GetNearestPositionOnSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 SplineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponentHelper::GetNearestPositionOnSpline(const int32 AgentId, const class USplineComponent* SplineComponent, const struct FVector& Position, const ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNearestPositionOnSpline");

	Params::SplineComponentHelper_GetNearestPositionOnSpline Parms{};

	Parms.AgentId = AgentId;
	Parms.SplineComponent = SplineComponent;
	Parms.Position = std::move(Position);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.SplineComponentHelper.GetPositionAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 SplineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponentHelper::GetPositionAtDistanceAlongSpline(const int32 AgentId, const class USplineComponent* SplineComponent, const float DistanceAlongSpline, const ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPositionAtDistanceAlongSpline");

	Params::SplineComponentHelper_GetPositionAtDistanceAlongSpline Parms{};

	Parms.AgentId = AgentId;
	Parms.SplineComponent = SplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.SplineComponentHelper.GetPositionsAlongSpline
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<struct FVector>                  OutPositions                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 SplineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PositionNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartDistanceAlongSpline                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StopDistanceAlongSpline                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponentHelper::GetPositionsAlongSpline(TArray<struct FVector>* OutPositions, const int32 AgentId, const class USplineComponent* SplineComponent, const int32 PositionNum, const float StartDistanceAlongSpline, const float StopDistanceAlongSpline, const ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPositionsAlongSpline");

	Params::SplineComponentHelper_GetPositionsAlongSpline Parms{};

	Parms.AgentId = AgentId;
	Parms.SplineComponent = SplineComponent;
	Parms.PositionNum = PositionNum;
	Parms.StartDistanceAlongSpline = StartDistanceAlongSpline;
	Parms.StopDistanceAlongSpline = StopDistanceAlongSpline;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPositions != nullptr)
		*OutPositions = std::move(Parms.OutPositions);
}


// Function LearningAgents.SplineComponentHelper.GetProportionAlongSpline
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 SplineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponentHelper::GetProportionAlongSpline(const int32 AgentId, const class USplineComponent* SplineComponent, const float DistanceAlongSpline) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetProportionAlongSpline");

	Params::SplineComponentHelper_GetProportionAlongSpline Parms{};

	Parms.AgentId = AgentId;
	Parms.SplineComponent = SplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.SplineComponentHelper.GetProportionAlongSplineAsAngle
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 SplineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponentHelper::GetProportionAlongSplineAsAngle(const int32 AgentId, const class USplineComponent* SplineComponent, const float DistanceAlongSpline) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetProportionAlongSplineAsAngle");

	Params::SplineComponentHelper_GetProportionAlongSplineAsAngle Parms{};

	Parms.AgentId = AgentId;
	Parms.SplineComponent = SplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.SplineComponentHelper.GetVelocityAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 SplineComponent                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FiniteDifferenceDelta                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponentHelper::GetVelocityAlongSpline(const int32 AgentId, const class USplineComponent* SplineComponent, const struct FVector& Position, const struct FVector& Velocity, const float FiniteDifferenceDelta, const ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVelocityAlongSpline");

	Params::SplineComponentHelper_GetVelocityAlongSpline Parms{};

	Parms.AgentId = AgentId;
	Parms.SplineComponent = SplineComponent;
	Parms.Position = std::move(Position);
	Parms.Velocity = std::move(Velocity);
	Parms.FiniteDifferenceDelta = FiniteDifferenceDelta;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.ProjectionHelper.AddProjectionHelper
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsManagerComponent*  InManagerComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProjectionHelper*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProjectionHelper* UProjectionHelper::AddProjectionHelper(class ULearningAgentsManagerComponent* InManagerComponent, const class FName Name_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddProjectionHelper");

	Params::ProjectionHelper_AddProjectionHelper Parms{};

	Parms.InManagerComponent = InManagerComponent;
	Parms.Name_0 = Name_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.ProjectionHelper.ProjectPositionRotationOntoGroundPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          OutPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InPosition                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRotation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          LocalForwardVector                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProjectionHelper::ProjectPositionRotationOntoGroundPlane(struct FVector* OutPosition, struct FRotator* OutRotation, const int32 AgentId, const struct FVector& InPosition, const struct FRotator& InRotation, const struct FVector& LocalForwardVector) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ProjectPositionRotationOntoGroundPlane");

	Params::ProjectionHelper_ProjectPositionRotationOntoGroundPlane Parms{};

	Parms.AgentId = AgentId;
	Parms.InPosition = std::move(InPosition);
	Parms.InRotation = std::move(InRotation);
	Parms.LocalForwardVector = std::move(LocalForwardVector);

	UObject::ProcessEvent(Func, &Parms);

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function LearningAgents.ProjectionHelper.ProjectTransformOntoGroundPlane
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalForwardVector                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UProjectionHelper::ProjectTransformOntoGroundPlane(const int32 AgentId, const struct FTransform& Transform, const struct FVector& LocalForwardVector) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ProjectTransformOntoGroundPlane");

	Params::ProjectionHelper_ProjectTransformOntoGroundPlane Parms{};

	Parms.AgentId = AgentId;
	Parms.Transform = std::move(Transform);
	Parms.LocalForwardVector = std::move(LocalForwardVector);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.MeshComponentHelper.AddMeshComponentHelper
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsManagerComponent*  InManagerComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponentHelper*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponentHelper* UMeshComponentHelper::AddMeshComponentHelper(class ULearningAgentsManagerComponent* InManagerComponent, const class FName Name_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddMeshComponentHelper");

	Params::MeshComponentHelper_AddMeshComponentHelper Parms{};

	Parms.InManagerComponent = InManagerComponent;
	Parms.Name_0 = Name_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.MeshComponentHelper.GetMeshBonePositions
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<struct FVector>                  OutBonePositions                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   MeshComponent                                          (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     BoneNames                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UMeshComponentHelper::GetMeshBonePositions(TArray<struct FVector>* OutBonePositions, const int32 AgentId, const class UMeshComponent* MeshComponent, const TArray<class FName>& BoneNames) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMeshBonePositions");

	Params::MeshComponentHelper_GetMeshBonePositions Parms{};

	Parms.AgentId = AgentId;
	Parms.MeshComponent = MeshComponent;
	Parms.BoneNames = std::move(BoneNames);

	UObject::ProcessEvent(Func, &Parms);

	if (OutBonePositions != nullptr)
		*OutBonePositions = std::move(Parms.OutBonePositions);
}


// Function LearningAgents.RayCastHelper.AddRayCastHelper
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsManagerComponent*  InManagerComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URayCastHelper*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URayCastHelper* URayCastHelper::AddRayCastHelper(class ULearningAgentsManagerComponent* InManagerComponent, const class FName Name_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddRayCastHelper");

	Params::RayCastHelper_AddRayCastHelper Parms{};

	Parms.InManagerComponent = InManagerComponent;
	Parms.Name_0 = Name_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.RayCastHelper.RayCastGridHeights
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// TArray<float>                           OutHeights                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   RowNum                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ColNum                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RowWidth                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ColWidth                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHeight                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinHeight                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URayCastHelper::RayCastGridHeights(TArray<float>* OutHeights, const int32 AgentId, const struct FVector& Position, const struct FRotator& Rotation, const int32 RowNum, const int32 ColNum, const float RowWidth, const float ColWidth, const float MaxHeight, const float MinHeight, const ECollisionChannel CollisionChannel) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RayCastGridHeights");

	Params::RayCastHelper_RayCastGridHeights Parms{};

	Parms.AgentId = AgentId;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.RowNum = RowNum;
	Parms.ColNum = ColNum;
	Parms.RowWidth = RowWidth;
	Parms.ColWidth = ColWidth;
	Parms.MaxHeight = MaxHeight;
	Parms.MinHeight = MinHeight;
	Parms.CollisionChannel = CollisionChannel;

	UObject::ProcessEvent(Func, &Parms);

	if (OutHeights != nullptr)
		*OutHeights = std::move(Parms.OutHeights);
}


// Function LearningAgents.RayCastHelper.RayCastRadial
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// TArray<float>                           OutDistances                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   RayNum                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinAngle                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAngle                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRayDist                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalForward                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URayCastHelper::RayCastRadial(TArray<float>* OutDistances, const int32 AgentId, const struct FVector& Position, const struct FRotator& Rotation, const int32 RayNum, const float MinAngle, const float MaxAngle, const float MaxRayDist, const struct FVector& LocalForward, const ECollisionChannel CollisionChannel) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RayCastRadial");

	Params::RayCastHelper_RayCastRadial Parms{};

	Parms.AgentId = AgentId;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.RayNum = RayNum;
	Parms.MinAngle = MinAngle;
	Parms.MaxAngle = MaxAngle;
	Parms.MaxRayDist = MaxRayDist;
	Parms.LocalForward = std::move(LocalForward);
	Parms.CollisionChannel = CollisionChannel;

	UObject::ProcessEvent(Func, &Parms);

	if (OutDistances != nullptr)
		*OutDistances = std::move(Parms.OutDistances);
}


// Function LearningAgents.CollisionMonitorHelper.AddCollisionMonitorHelper
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsManagerComponent*  InManagerComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCollisionMonitorHelper*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCollisionMonitorHelper* UCollisionMonitorHelper::AddCollisionMonitorHelper(class ULearningAgentsManagerComponent* InManagerComponent, const class FName Name_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddCollisionMonitorHelper");

	Params::CollisionMonitorHelper_AddCollisionMonitorHelper Parms{};

	Parms.InManagerComponent = InManagerComponent;
	Parms.Name_0 = Name_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.CollisionMonitorHelper.GetAndResetCollisionOccurred
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCollisionMonitorHelper::GetAndResetCollisionOccurred(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAndResetCollisionOccurred");

	Params::CollisionMonitorHelper_GetAndResetCollisionOccurred Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.CollisionMonitorHelper.HandleOnHit
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCollisionMonitorHelper::HandleOnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleOnHit");

	Params::CollisionMonitorHelper_HandleOnHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.CollisionMonitorHelper.ResetCollisionOccurred
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollisionMonitorHelper::ResetCollisionOccurred(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetCollisionOccurred");

	Params::CollisionMonitorHelper_ResetCollisionOccurred Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.CollisionMonitorHelper.SetComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OtherComponentTag                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollisionMonitorHelper::SetComponent(const int32 AgentId, class UPrimitiveComponent* Component, const class FName OtherComponentTag)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetComponent");

	Params::CollisionMonitorHelper_SetComponent Parms{};

	Parms.AgentId = AgentId;
	Parms.Component = Component;
	Parms.OtherComponentTag = OtherComponentTag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.CollisionMonitorHelper.GetCollisionOccurred
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCollisionMonitorHelper::GetCollisionOccurred(const int32 AgentId) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCollisionOccurred");

	Params::CollisionMonitorHelper_GetCollisionOccurred Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsInteractor.DecodeActions
// (Final, Native, Public, BlueprintCallable)

void ULearningAgentsInteractor::DecodeActions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DecodeActions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsInteractor.EncodeObservations
// (Final, Native, Public, BlueprintCallable)

void ULearningAgentsInteractor::EncodeObservations()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EncodeObservations");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsInteractor.GetActions
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULearningAgentsInteractor::GetActions(const TArray<int32>& AgentIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActions");

	Params::LearningAgentsInteractor_GetActions Parms{};

	Parms.AgentIds = std::move(AgentIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsInteractor.SetObservations
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULearningAgentsInteractor::SetObservations(const TArray<int32>& AgentIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetObservations");

	Params::LearningAgentsInteractor_SetObservations Parms{};

	Parms.AgentIds = std::move(AgentIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsInteractor.SetupActions
// (Native, Event, Public, BlueprintEvent)

void ULearningAgentsInteractor::SetupActions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetupActions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsInteractor.SetupInteractor
// (Final, Native, Public, BlueprintCallable)

void ULearningAgentsInteractor::SetupInteractor()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetupInteractor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsInteractor.SetupObservations
// (Native, Event, Public, BlueprintEvent)

void ULearningAgentsInteractor::SetupObservations()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetupObservations");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsInteractor.GetActionVector
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           OutActionVector                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULearningAgentsInteractor::GetActionVector(const int32 AgentId, TArray<float>* OutActionVector) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActionVector");

	Params::LearningAgentsInteractor_GetActionVector Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	if (OutActionVector != nullptr)
		*OutActionVector = std::move(Parms.OutActionVector);
}


// Function LearningAgents.LearningAgentsInteractor.GetObservationVector
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           OutObservationVector                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULearningAgentsInteractor::GetObservationVector(const int32 AgentId, TArray<float>* OutObservationVector) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetObservationVector");

	Params::LearningAgentsInteractor_GetObservationVector Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	if (OutObservationVector != nullptr)
		*OutObservationVector = std::move(Parms.OutObservationVector);
}


// Function LearningAgents.LearningAgentsManager.AddAgent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Agent                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALearningAgentsManager::AddAgent(class UObject* Agent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAgent");

	Params::LearningAgentsManager_AddAgent Parms{};

	Parms.Agent = Agent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsManager.AddAgents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           OutAgentIds                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  InAgents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALearningAgentsManager::AddAgents(TArray<int32>* OutAgentIds, const TArray<class UObject*>& InAgents)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAgents");

	Params::LearningAgentsManager_AddAgents Parms{};

	Parms.InAgents = std::move(InAgents);

	UObject::ProcessEvent(Func, &Parms);

	if (OutAgentIds != nullptr)
		*OutAgentIds = std::move(Parms.OutAgentIds);
}


// Function LearningAgents.LearningAgentsManager.AddAgentsAsTickPrerequisiteOfManager
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   InAgents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALearningAgentsManager::AddAgentsAsTickPrerequisiteOfManager(const TArray<class AActor*>& InAgents)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAgentsAsTickPrerequisiteOfManager");

	Params::LearningAgentsManager_AddAgentsAsTickPrerequisiteOfManager Parms{};

	Parms.InAgents = std::move(InAgents);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManager.AddManagerAsTickPrerequisiteOfAgents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   InAgents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALearningAgentsManager::AddManagerAsTickPrerequisiteOfAgents(const TArray<class AActor*>& InAgents)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddManagerAsTickPrerequisiteOfAgents");

	Params::LearningAgentsManager_AddManagerAsTickPrerequisiteOfAgents Parms{};

	Parms.InAgents = std::move(InAgents);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManager.RemoveAgent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALearningAgentsManager::RemoveAgent(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAgent");

	Params::LearningAgentsManager_RemoveAgent Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManager.RemoveAgents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALearningAgentsManager::RemoveAgents(const TArray<int32>& AgentIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAgents");

	Params::LearningAgentsManager_RemoveAgents Parms{};

	Parms.AgentIds = std::move(AgentIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManager.RemoveAllAgents
// (Final, Native, Public, BlueprintCallable)

void ALearningAgentsManager::RemoveAllAgents()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAllAgents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsManager.ResetAgent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALearningAgentsManager::ResetAgent(const int32 AgentId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetAgent");

	Params::LearningAgentsManager_ResetAgent Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManager.ResetAgents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALearningAgentsManager::ResetAgents(const TArray<int32>& AgentIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetAgents");

	Params::LearningAgentsManager_ResetAgents Parms{};

	Parms.AgentIds = std::move(AgentIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsManager.ResetAllAgents
// (Final, Native, Public, BlueprintCallable)

void ALearningAgentsManager::ResetAllAgents()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetAllAgents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsManager.GetAgent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              AgentClass                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* ALearningAgentsManager::GetAgent(const int32 AgentId, const TSubclassOf<class UObject> AgentClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAgent");

	Params::LearningAgentsManager_GetAgent Parms{};

	Parms.AgentId = AgentId;
	Parms.AgentClass = AgentClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsManager.GetAgentId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          Agent                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALearningAgentsManager::GetAgentId(class UObject* Agent) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAgentId");

	Params::LearningAgentsManager_GetAgentId Parms{};

	Parms.Agent = Agent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsManager.GetAgentIds
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<int32>                           OutAgentIds                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  InAgents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALearningAgentsManager::GetAgentIds(TArray<int32>* OutAgentIds, const TArray<class UObject*>& InAgents) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAgentIds");

	Params::LearningAgentsManager_GetAgentIds Parms{};

	Parms.InAgents = std::move(InAgents);

	UObject::ProcessEvent(Func, &Parms);

	if (OutAgentIds != nullptr)
		*OutAgentIds = std::move(Parms.OutAgentIds);
}


// Function LearningAgents.LearningAgentsManager.GetAgentNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALearningAgentsManager::GetAgentNum() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAgentNum");

	Params::LearningAgentsManager_GetAgentNum Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsManager.GetAgents
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<class UObject*>                  OutAgents                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           AgentIds                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              AgentClass                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALearningAgentsManager::GetAgents(TArray<class UObject*>* OutAgents, const TArray<int32>& AgentIds, const TSubclassOf<class UObject> AgentClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAgents");

	Params::LearningAgentsManager_GetAgents Parms{};

	Parms.AgentIds = std::move(AgentIds);
	Parms.AgentClass = AgentClass;

	UObject::ProcessEvent(Func, &Parms);

	if (OutAgents != nullptr)
		*OutAgents = std::move(Parms.OutAgents);
}


// Function LearningAgents.LearningAgentsManager.GetAllAgents
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<class UObject*>                  OutAgents                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           OutAgentIds                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              AgentClass                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALearningAgentsManager::GetAllAgents(TArray<class UObject*>* OutAgents, TArray<int32>* OutAgentIds, const TSubclassOf<class UObject> AgentClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllAgents");

	Params::LearningAgentsManager_GetAllAgents Parms{};

	Parms.AgentClass = AgentClass;

	UObject::ProcessEvent(Func, &Parms);

	if (OutAgents != nullptr)
		*OutAgents = std::move(Parms.OutAgents);

	if (OutAgentIds != nullptr)
		*OutAgentIds = std::move(Parms.OutAgentIds);
}


// Function LearningAgents.LearningAgentsManager.GetMaxAgentNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALearningAgentsManager::GetMaxAgentNum() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxAgentNum");

	Params::LearningAgentsManager_GetMaxAgentNum Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsManager.HasAgent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALearningAgentsManager::HasAgent(const int32 AgentId) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasAgent");

	Params::LearningAgentsManager_HasAgent Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsManager.HasAgentObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          Agent                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALearningAgentsManager::HasAgentObject(class UObject* Agent) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasAgentObject");

	Params::LearningAgentsManager_HasAgentObject Parms{};

	Parms.Agent = Agent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsNeuralNetwork.LoadNetworkFromAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsNeuralNetwork::LoadNetworkFromAsset(class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LoadNetworkFromAsset");

	Params::LearningAgentsNeuralNetwork_LoadNetworkFromAsset Parms{};

	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsNeuralNetwork.LoadNetworkFromSnapshot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFilePath                        File                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsNeuralNetwork::LoadNetworkFromSnapshot(const struct FFilePath& File)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LoadNetworkFromSnapshot");

	Params::LearningAgentsNeuralNetwork_LoadNetworkFromSnapshot Parms{};

	Parms.File = std::move(File);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsNeuralNetwork.ResetNetwork
// (Final, Native, Public)

void ULearningAgentsNeuralNetwork::ResetNetwork()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetNetwork");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsNeuralNetwork.SaveNetworkToAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsNeuralNetwork::SaveNetworkToAsset(class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SaveNetworkToAsset");

	Params::LearningAgentsNeuralNetwork_SaveNetworkToAsset Parms{};

	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsNeuralNetwork.SaveNetworkToSnapshot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFilePath                        File                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsNeuralNetwork::SaveNetworkToSnapshot(const struct FFilePath& File)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SaveNetworkToSnapshot");

	Params::LearningAgentsNeuralNetwork_SaveNetworkToSnapshot Parms{};

	Parms.File = std::move(File);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.FloatObservation.AddFloatObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFloatObservation*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFloatObservation* UFloatObservation::AddFloatObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddFloatObservation");

	Params::FloatObservation_AddFloatObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.FloatObservation.SetFloatObservation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Observation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFloatObservation::SetFloatObservation(const int32 AgentId, const float Observation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFloatObservation");

	Params::FloatObservation_SetFloatObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Observation = Observation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.FloatArrayObservation.AddFloatArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFloatArrayObservation*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFloatArrayObservation* UFloatArrayObservation::AddFloatArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 Num, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddFloatArrayObservation");

	Params::FloatArrayObservation_AddFloatArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Num = Num;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.FloatArrayObservation.SetFloatArrayObservation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Observation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UFloatArrayObservation::SetFloatArrayObservation(const int32 AgentId, const TArray<float>& Observation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFloatArrayObservation");

	Params::FloatArrayObservation_SetFloatArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Observation = std::move(Observation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.VectorObservation.AddVectorObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVectorObservation*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVectorObservation* UVectorObservation::AddVectorObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddVectorObservation");

	Params::VectorObservation_AddVectorObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.VectorObservation.SetVectorObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Observation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVectorObservation::SetVectorObservation(const int32 AgentId, const struct FVector& Observation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorObservation");

	Params::VectorObservation_SetVectorObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Observation = std::move(Observation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.VectorArrayObservation.AddVectorArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVectorArrayObservation*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVectorArrayObservation* UVectorArrayObservation::AddVectorArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 Num, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddVectorArrayObservation");

	Params::VectorArrayObservation_AddVectorArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Num = Num;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.VectorArrayObservation.SetVectorArrayObservation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Observation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UVectorArrayObservation::SetVectorArrayObservation(const int32 AgentId, const TArray<struct FVector>& Observation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorArrayObservation");

	Params::VectorArrayObservation_SetVectorArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Observation = std::move(Observation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.EnumObservation.AddEnumObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEnum*                            EnumType                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEnumObservation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnumObservation* UEnumObservation::AddEnumObservation(class ULearningAgentsInteractor* InInteractor, const class UEnum* EnumType, const class FName Name_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddEnumObservation");

	Params::EnumObservation_AddEnumObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.EnumType = EnumType;
	Parms.Name_0 = Name_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.EnumObservation.SetEnumObservation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnumObservation::SetEnumObservation(const int32 AgentId, const uint8 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnumObservation");

	Params::EnumObservation_SetEnumObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.EnumArrayObservation.AddEnumArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEnum*                            EnumType                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EnumNum                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEnumArrayObservation*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnumArrayObservation* UEnumArrayObservation::AddEnumArrayObservation(class ULearningAgentsInteractor* InInteractor, const class UEnum* EnumType, const class FName Name_0, const int32 EnumNum)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddEnumArrayObservation");

	Params::EnumArrayObservation_AddEnumArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.EnumType = EnumType;
	Parms.Name_0 = Name_0;
	Parms.EnumNum = EnumNum;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.EnumArrayObservation.SetEnumArrayObservation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UEnumArrayObservation::SetEnumArrayObservation(const int32 AgentId, const TArray<uint8>& Values)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnumArrayObservation");

	Params::EnumArrayObservation_SetEnumArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Values = std::move(Values);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.TimeObservation.AddTimeObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTimeObservation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimeObservation* UTimeObservation::AddTimeObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddTimeObservation");

	Params::TimeObservation_AddTimeObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.TimeObservation.SetTimeObservation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RelativeTime                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeObservation::SetTimeObservation(const int32 AgentId, const float Time, const float RelativeTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTimeObservation");

	Params::TimeObservation_SetTimeObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Time = Time;
	Parms.RelativeTime = RelativeTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.TimeArrayObservation.AddTimeArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TimeNum                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTimeArrayObservation*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimeArrayObservation* UTimeArrayObservation::AddTimeArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 TimeNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddTimeArrayObservation");

	Params::TimeArrayObservation_AddTimeArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.TimeNum = TimeNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.TimeArrayObservation.SetTimeArrayObservation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Times                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   RelativeTime                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeArrayObservation::SetTimeArrayObservation(const int32 AgentId, const TArray<float>& Times, const float RelativeTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTimeArrayObservation");

	Params::TimeArrayObservation_SetTimeArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Times = std::move(Times);
	Parms.RelativeTime = RelativeTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.AngleObservation.AddAngleObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAngleObservation*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAngleObservation* UAngleObservation::AddAngleObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddAngleObservation");

	Params::AngleObservation_AddAngleObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.AngleObservation.SetAngleObservation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RelativeAngle                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAngleObservation::SetAngleObservation(const int32 AgentId, const float Angle, const float RelativeAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngleObservation");

	Params::AngleObservation_SetAngleObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Angle = Angle;
	Parms.RelativeAngle = RelativeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.AngleArrayObservation.AddAngleArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngleNum                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAngleArrayObservation*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAngleArrayObservation* UAngleArrayObservation::AddAngleArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 AngleNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddAngleArrayObservation");

	Params::AngleArrayObservation_AddAngleArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.AngleNum = AngleNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.AngleArrayObservation.SetAngleArrayObservation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Angles                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   RelativeAngle                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAngleArrayObservation::SetAngleArrayObservation(const int32 AgentId, const TArray<float>& Angles, const float RelativeAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngleArrayObservation");

	Params::AngleArrayObservation_SetAngleArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Angles = std::move(Angles);
	Parms.RelativeAngle = RelativeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.RotationObservation.AddRotationObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URotationObservation*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URotationObservation* URotationObservation::AddRotationObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddRotationObservation");

	Params::RotationObservation_AddRotationObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.RotationObservation.SetRotationObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URotationObservation::SetRotationObservation(const int32 AgentId, const struct FRotator& Rotation, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRotationObservation");

	Params::RotationObservation_SetRotationObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Rotation = std::move(Rotation);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.RotationObservation.SetRotationObservationFromQuat
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            RelativeRotation                                       (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URotationObservation::SetRotationObservationFromQuat(const int32 AgentId, const struct FQuat& Rotation, const struct FQuat& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRotationObservationFromQuat");

	Params::RotationObservation_SetRotationObservationFromQuat Parms{};

	Parms.AgentId = AgentId;
	Parms.Rotation = std::move(Rotation);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.RotationArrayObservation.AddRotationArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RotationNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URotationArrayObservation*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URotationArrayObservation* URotationArrayObservation::AddRotationArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 RotationNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddRotationArrayObservation");

	Params::RotationArrayObservation_AddRotationArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.RotationNum = RotationNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.RotationArrayObservation.SetRotationArrayObservation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRotator>                 Rotations                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URotationArrayObservation::SetRotationArrayObservation(const int32 AgentId, const TArray<struct FRotator>& Rotations, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRotationArrayObservation");

	Params::RotationArrayObservation_SetRotationArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Rotations = std::move(Rotations);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.RotationArrayObservation.SetRotationArrayObservationFromQuats
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FQuat>                    Rotations                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FQuat                            RelativeRotation                                       (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URotationArrayObservation::SetRotationArrayObservationFromQuats(const int32 AgentId, const TArray<struct FQuat>& Rotations, const struct FQuat& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRotationArrayObservationFromQuats");

	Params::RotationArrayObservation_SetRotationArrayObservationFromQuats Parms{};

	Parms.AgentId = AgentId;
	Parms.Rotations = std::move(Rotations);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.DirectionObservation.AddDirectionObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDirectionObservation*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDirectionObservation* UDirectionObservation::AddDirectionObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddDirectionObservation");

	Params::DirectionObservation_AddDirectionObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.DirectionObservation.SetDirectionObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDirectionObservation::SetDirectionObservation(const int32 AgentId, const struct FVector& Direction, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDirectionObservation");

	Params::DirectionObservation_SetDirectionObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Direction = std::move(Direction);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.DirectionArrayObservation.AddDirectionArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DirectionNum                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDirectionArrayObservation*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDirectionArrayObservation* UDirectionArrayObservation::AddDirectionArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 DirectionNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddDirectionArrayObservation");

	Params::DirectionArrayObservation_AddDirectionArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.DirectionNum = DirectionNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.DirectionArrayObservation.SetDirectionArrayObservation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Directions                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDirectionArrayObservation::SetDirectionArrayObservation(const int32 AgentId, const TArray<struct FVector>& Directions, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDirectionArrayObservation");

	Params::DirectionArrayObservation_SetDirectionArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Directions = std::move(Directions);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PlanarDirectionObservation.AddPlanarDirectionObservation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis1                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlanarDirectionObservation*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlanarDirectionObservation* UPlanarDirectionObservation::AddPlanarDirectionObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale, const struct FVector& Axis0, const struct FVector& Axis1)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPlanarDirectionObservation");

	Params::PlanarDirectionObservation_AddPlanarDirectionObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;
	Parms.Axis0 = std::move(Axis0);
	Parms.Axis1 = std::move(Axis1);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PlanarDirectionObservation.SetPlanarDirectionObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPlanarDirectionObservation::SetPlanarDirectionObservation(const int32 AgentId, const struct FVector& Direction, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlanarDirectionObservation");

	Params::PlanarDirectionObservation_SetPlanarDirectionObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Direction = std::move(Direction);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PlanarDirectionArrayObservation.AddPlanarDirectionArrayObservation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DirectionNum                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis1                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlanarDirectionArrayObservation* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlanarDirectionArrayObservation* UPlanarDirectionArrayObservation::AddPlanarDirectionArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 DirectionNum, const float Scale, const struct FVector& Axis0, const struct FVector& Axis1)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPlanarDirectionArrayObservation");

	Params::PlanarDirectionArrayObservation_AddPlanarDirectionArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.DirectionNum = DirectionNum;
	Parms.Scale = Scale;
	Parms.Axis0 = std::move(Axis0);
	Parms.Axis1 = std::move(Axis1);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PlanarDirectionArrayObservation.SetPlanarDirectionArrayObservation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Directions                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPlanarDirectionArrayObservation::SetPlanarDirectionArrayObservation(const int32 AgentId, const TArray<struct FVector>& Directions, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlanarDirectionArrayObservation");

	Params::PlanarDirectionArrayObservation_SetPlanarDirectionArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Directions = std::move(Directions);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PositionObservation.AddPositionObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPositionObservation*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPositionObservation* UPositionObservation::AddPositionObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPositionObservation");

	Params::PositionObservation_AddPositionObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PositionObservation.SetPositionObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RelativePosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPositionObservation::SetPositionObservation(const int32 AgentId, const struct FVector& Position, const struct FVector& RelativePosition, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPositionObservation");

	Params::PositionObservation_SetPositionObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Position = std::move(Position);
	Parms.RelativePosition = std::move(RelativePosition);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PositionArrayObservation.AddPositionArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PositionNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPositionArrayObservation*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPositionArrayObservation* UPositionArrayObservation::AddPositionArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 PositionNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPositionArrayObservation");

	Params::PositionArrayObservation_AddPositionArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.PositionNum = PositionNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PositionArrayObservation.SetPositionArrayObservation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          RelativePosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPositionArrayObservation::SetPositionArrayObservation(int32 AgentId, const TArray<struct FVector>& Positions, const struct FVector& RelativePosition, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPositionArrayObservation");

	Params::PositionArrayObservation_SetPositionArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Positions = std::move(Positions);
	Parms.RelativePosition = std::move(RelativePosition);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarPositionObservation.AddScalarPositionObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScalarPositionObservation*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScalarPositionObservation* UScalarPositionObservation::AddScalarPositionObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddScalarPositionObservation");

	Params::ScalarPositionObservation_AddScalarPositionObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.ScalarPositionObservation.SetScalarPositionObservation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RelativePosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarPositionObservation::SetScalarPositionObservation(const int32 AgentId, const float Position, const float RelativePosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarPositionObservation");

	Params::ScalarPositionObservation_SetScalarPositionObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Position = Position;
	Parms.RelativePosition = RelativePosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarPositionObservation.SetScalarPositionObservationWithAxis
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RelativePosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarPositionObservation::SetScalarPositionObservationWithAxis(const int32 AgentId, const struct FVector& Position, const struct FVector& RelativePosition, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarPositionObservationWithAxis");

	Params::ScalarPositionObservation_SetScalarPositionObservationWithAxis Parms{};

	Parms.AgentId = AgentId;
	Parms.Position = std::move(Position);
	Parms.RelativePosition = std::move(RelativePosition);
	Parms.Axis = std::move(Axis);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarPositionArrayObservation.AddScalarPositionArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PositionNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScalarPositionArrayObservation*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScalarPositionArrayObservation* UScalarPositionArrayObservation::AddScalarPositionArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 PositionNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddScalarPositionArrayObservation");

	Params::ScalarPositionArrayObservation_AddScalarPositionArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.PositionNum = PositionNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.ScalarPositionArrayObservation.SetScalarPositionArrayObservation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   RelativePosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarPositionArrayObservation::SetScalarPositionArrayObservation(const int32 AgentId, const TArray<float>& Positions, const float RelativePosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarPositionArrayObservation");

	Params::ScalarPositionArrayObservation_SetScalarPositionArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Positions = std::move(Positions);
	Parms.RelativePosition = RelativePosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarPositionArrayObservation.SetScalarPositionArrayObservationWithAxis
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          RelativePosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarPositionArrayObservation::SetScalarPositionArrayObservationWithAxis(const int32 AgentId, const TArray<struct FVector>& Positions, const struct FVector& RelativePosition, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarPositionArrayObservationWithAxis");

	Params::ScalarPositionArrayObservation_SetScalarPositionArrayObservationWithAxis Parms{};

	Parms.AgentId = AgentId;
	Parms.Positions = std::move(Positions);
	Parms.RelativePosition = std::move(RelativePosition);
	Parms.Axis = std::move(Axis);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PlanarPositionObservation.AddPlanarPositionObservation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis1                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlanarPositionObservation*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlanarPositionObservation* UPlanarPositionObservation::AddPlanarPositionObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale, const struct FVector& Axis0, const struct FVector& Axis1)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPlanarPositionObservation");

	Params::PlanarPositionObservation_AddPlanarPositionObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;
	Parms.Axis0 = std::move(Axis0);
	Parms.Axis1 = std::move(Axis1);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PlanarPositionObservation.SetPlanarPositionObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RelativePosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPlanarPositionObservation::SetPlanarPositionObservation(const int32 AgentId, const struct FVector& Position, const struct FVector& RelativePosition, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlanarPositionObservation");

	Params::PlanarPositionObservation_SetPlanarPositionObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Position = std::move(Position);
	Parms.RelativePosition = std::move(RelativePosition);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PlanarPositionArrayObservation.AddPlanarPositionArrayObservation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PositionNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis1                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlanarPositionArrayObservation*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlanarPositionArrayObservation* UPlanarPositionArrayObservation::AddPlanarPositionArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 PositionNum, const float Scale, const struct FVector& Axis0, const struct FVector& Axis1)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPlanarPositionArrayObservation");

	Params::PlanarPositionArrayObservation_AddPlanarPositionArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.PositionNum = PositionNum;
	Parms.Scale = Scale;
	Parms.Axis0 = std::move(Axis0);
	Parms.Axis1 = std::move(Axis1);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PlanarPositionArrayObservation.SetPlanarPositionArrayObservation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          RelativePosition                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPlanarPositionArrayObservation::SetPlanarPositionArrayObservation(const int32 AgentId, const TArray<struct FVector>& Positions, const struct FVector& RelativePosition, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlanarPositionArrayObservation");

	Params::PlanarPositionArrayObservation_SetPlanarPositionArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Positions = std::move(Positions);
	Parms.RelativePosition = std::move(RelativePosition);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.VelocityObservation.AddVelocityObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVelocityObservation*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVelocityObservation* UVelocityObservation::AddVelocityObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddVelocityObservation");

	Params::VelocityObservation_AddVelocityObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.VelocityObservation.SetVelocityObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UVelocityObservation::SetVelocityObservation(const int32 AgentId, const struct FVector& Velocity, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVelocityObservation");

	Params::VelocityObservation_SetVelocityObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocity = std::move(Velocity);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.VelocityArrayObservation.AddVelocityArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   VelocityNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVelocityArrayObservation*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVelocityArrayObservation* UVelocityArrayObservation::AddVelocityArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 VelocityNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddVelocityArrayObservation");

	Params::VelocityArrayObservation_AddVelocityArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.VelocityNum = VelocityNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.VelocityArrayObservation.SetVelocityArrayObservation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Velocities                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UVelocityArrayObservation::SetVelocityArrayObservation(const int32 AgentId, const TArray<struct FVector>& Velocities, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVelocityArrayObservation");

	Params::VelocityArrayObservation_SetVelocityArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocities = std::move(Velocities);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarVelocityObservation.AddScalarVelocityObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScalarVelocityObservation*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScalarVelocityObservation* UScalarVelocityObservation::AddScalarVelocityObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddScalarVelocityObservation");

	Params::ScalarVelocityObservation_AddScalarVelocityObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.ScalarVelocityObservation.SetScalarVelocityObservation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Velocity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarVelocityObservation::SetScalarVelocityObservation(const int32 AgentId, const float Velocity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarVelocityObservation");

	Params::ScalarVelocityObservation_SetScalarVelocityObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocity = Velocity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarVelocityObservation.SetScalarVelocityObservationWithAxis
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarVelocityObservation::SetScalarVelocityObservationWithAxis(const int32 AgentId, const struct FVector& Velocity, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarVelocityObservationWithAxis");

	Params::ScalarVelocityObservation_SetScalarVelocityObservationWithAxis Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocity = std::move(Velocity);
	Parms.Axis = std::move(Axis);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarVelocityArrayObservation.AddScalarVelocityArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   VelocityNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScalarVelocityArrayObservation*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScalarVelocityArrayObservation* UScalarVelocityArrayObservation::AddScalarVelocityArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 VelocityNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddScalarVelocityArrayObservation");

	Params::ScalarVelocityArrayObservation_AddScalarVelocityArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.VelocityNum = VelocityNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.ScalarVelocityArrayObservation.SetScalarVelocityArrayObservation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Velocities                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UScalarVelocityArrayObservation::SetScalarVelocityArrayObservation(const int32 AgentId, const TArray<float>& Velocities)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarVelocityArrayObservation");

	Params::ScalarVelocityArrayObservation_SetScalarVelocityArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocities = std::move(Velocities);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarVelocityArrayObservation.SetScalarVelocityArrayObservationWithAxis
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Velocities                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Axis                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarVelocityArrayObservation::SetScalarVelocityArrayObservationWithAxis(const int32 AgentId, const TArray<struct FVector>& Velocities, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarVelocityArrayObservationWithAxis");

	Params::ScalarVelocityArrayObservation_SetScalarVelocityArrayObservationWithAxis Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocities = std::move(Velocities);
	Parms.Axis = std::move(Axis);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PlanarVelocityObservation.AddPlanarVelocityObservation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis1                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlanarVelocityObservation*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlanarVelocityObservation* UPlanarVelocityObservation::AddPlanarVelocityObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale, const struct FVector& Axis0, const struct FVector& Axis1)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPlanarVelocityObservation");

	Params::PlanarVelocityObservation_AddPlanarVelocityObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;
	Parms.Axis0 = std::move(Axis0);
	Parms.Axis1 = std::move(Axis1);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PlanarVelocityObservation.SetPlanarVelocityObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPlanarVelocityObservation::SetPlanarVelocityObservation(const int32 AgentId, const struct FVector& Velocity, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlanarVelocityObservation");

	Params::PlanarVelocityObservation_SetPlanarVelocityObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocity = std::move(Velocity);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.PlanarVelocityArrayObservation.AddPlanarVelocityArrayObservation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   VelocityNum                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis1                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlanarVelocityArrayObservation*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlanarVelocityArrayObservation* UPlanarVelocityArrayObservation::AddPlanarVelocityArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 VelocityNum, const float Scale, const struct FVector& Axis0, const struct FVector& Axis1)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPlanarVelocityArrayObservation");

	Params::PlanarVelocityArrayObservation_AddPlanarVelocityArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.VelocityNum = VelocityNum;
	Parms.Scale = Scale;
	Parms.Axis0 = std::move(Axis0);
	Parms.Axis1 = std::move(Axis1);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.PlanarVelocityArrayObservation.SetPlanarVelocityArrayObservation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Velocities                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPlanarVelocityArrayObservation::SetPlanarVelocityArrayObservation(const int32 AgentId, const TArray<struct FVector>& Velocities, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlanarVelocityArrayObservation");

	Params::PlanarVelocityArrayObservation_SetPlanarVelocityArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.Velocities = std::move(Velocities);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.AngularVelocityObservation.AddAngularVelocityObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAngularVelocityObservation*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAngularVelocityObservation* UAngularVelocityObservation::AddAngularVelocityObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddAngularVelocityObservation");

	Params::AngularVelocityObservation_AddAngularVelocityObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.AngularVelocityObservation.SetAngularVelocityObservation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AngularVelocity                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAngularVelocityObservation::SetAngularVelocityObservation(const int32 AgentId, const struct FVector& AngularVelocity, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularVelocityObservation");

	Params::AngularVelocityObservation_SetAngularVelocityObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.AngularVelocity = std::move(AngularVelocity);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.AngularVelocityArrayObservation.AddAngularVelocityArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularVelocityNum                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAngularVelocityArrayObservation* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAngularVelocityArrayObservation* UAngularVelocityArrayObservation::AddAngularVelocityArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 AngularVelocityNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddAngularVelocityArrayObservation");

	Params::AngularVelocityArrayObservation_AddAngularVelocityArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.AngularVelocityNum = AngularVelocityNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.AngularVelocityArrayObservation.SetAngularVelocityArrayObservation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  AngularVelocities                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAngularVelocityArrayObservation::SetAngularVelocityArrayObservation(const int32 AgentId, const TArray<struct FVector>& AngularVelocities, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularVelocityArrayObservation");

	Params::AngularVelocityArrayObservation_SetAngularVelocityArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.AngularVelocities = std::move(AngularVelocities);
	Parms.RelativeRotation = std::move(RelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarAngularVelocityObservation.AddScalarAngularVelocityObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScalarAngularVelocityObservation*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScalarAngularVelocityObservation* UScalarAngularVelocityObservation::AddScalarAngularVelocityObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddScalarAngularVelocityObservation");

	Params::ScalarAngularVelocityObservation_AddScalarAngularVelocityObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.ScalarAngularVelocityObservation.SetScalarAngularVelocityObservation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularVelocity                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarAngularVelocityObservation::SetScalarAngularVelocityObservation(const int32 AgentId, const float AngularVelocity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarAngularVelocityObservation");

	Params::ScalarAngularVelocityObservation_SetScalarAngularVelocityObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.AngularVelocity = AngularVelocity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarAngularVelocityObservation.SetScalarAngularVelocityObservationWithAxis
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AngularVelocity                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarAngularVelocityObservation::SetScalarAngularVelocityObservationWithAxis(const int32 AgentId, const struct FVector& AngularVelocity, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarAngularVelocityObservationWithAxis");

	Params::ScalarAngularVelocityObservation_SetScalarAngularVelocityObservationWithAxis Parms{};

	Parms.AgentId = AgentId;
	Parms.AngularVelocity = std::move(AngularVelocity);
	Parms.Axis = std::move(Axis);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarAngularVelocityArrayObservation.AddScalarAngularVelocityArrayObservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularVelocityNum                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScalarAngularVelocityArrayObservation*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScalarAngularVelocityArrayObservation* UScalarAngularVelocityArrayObservation::AddScalarAngularVelocityArrayObservation(class ULearningAgentsInteractor* InInteractor, const class FName Name_0, const int32 AngularVelocityNum, const float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddScalarAngularVelocityArrayObservation");

	Params::ScalarAngularVelocityArrayObservation_AddScalarAngularVelocityArrayObservation Parms{};

	Parms.InInteractor = InInteractor;
	Parms.Name_0 = Name_0;
	Parms.AngularVelocityNum = AngularVelocityNum;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.ScalarAngularVelocityArrayObservation.SetScalarAngularVelocityArrayObservation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           AngularVelocities                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UScalarAngularVelocityArrayObservation::SetScalarAngularVelocityArrayObservation(const int32 AgentId, const TArray<float>& AngularVelocities)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarAngularVelocityArrayObservation");

	Params::ScalarAngularVelocityArrayObservation_SetScalarAngularVelocityArrayObservation Parms{};

	Parms.AgentId = AgentId;
	Parms.AngularVelocities = std::move(AngularVelocities);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.ScalarAngularVelocityArrayObservation.SetScalarAngularVelocityArrayObservationWithAxis
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  AngularVelocities                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Axis                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalarAngularVelocityArrayObservation::SetScalarAngularVelocityArrayObservationWithAxis(const int32 AgentId, const TArray<struct FVector>& AngularVelocities, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarAngularVelocityArrayObservationWithAxis");

	Params::ScalarAngularVelocityArrayObservation_SetScalarAngularVelocityArrayObservationWithAxis Parms{};

	Parms.AgentId = AgentId;
	Parms.AngularVelocities = std::move(AngularVelocities);
	Parms.Axis = std::move(Axis);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsPolicy.EvaluatePolicy
// (Final, Native, Public, BlueprintCallable)

void ULearningAgentsPolicy::EvaluatePolicy()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EvaluatePolicy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsPolicy.LoadPolicyFromAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::LoadPolicyFromAsset(class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LoadPolicyFromAsset");

	Params::LearningAgentsPolicy_LoadPolicyFromAsset Parms{};

	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsPolicy.LoadPolicyFromSnapshot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFilePath                        File                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::LoadPolicyFromSnapshot(const struct FFilePath& File)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LoadPolicyFromSnapshot");

	Params::LearningAgentsPolicy_LoadPolicyFromSnapshot Parms{};

	Parms.File = std::move(File);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsPolicy.RunInference
// (Final, Native, Public, BlueprintCallable)

void ULearningAgentsPolicy::RunInference()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RunInference");

	UObject::ProcessEvent(Func, nullptr);
}


// Function LearningAgents.LearningAgentsPolicy.SavePolicyToAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::SavePolicyToAsset(class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SavePolicyToAsset");

	Params::LearningAgentsPolicy_SavePolicyToAsset Parms{};

	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsPolicy.SetActionNoiseScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ActionNoiseScale                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::SetActionNoiseScale(const float ActionNoiseScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActionNoiseScale");

	Params::LearningAgentsPolicy_SetActionNoiseScale Parms{};

	Parms.ActionNoiseScale = ActionNoiseScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsPolicy.SetMemoryState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           InMemoryState                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::SetMemoryState(const int32 AgentId, const TArray<float>& InMemoryState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMemoryState");

	Params::LearningAgentsPolicy_SetMemoryState Parms{};

	Parms.AgentId = AgentId;
	Parms.InMemoryState = std::move(InMemoryState);

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsPolicy.SetupPolicy
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULearningAgentsInteractor*        InInteractor                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLearningAgentsPolicySettings    PolicySettings                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::SetupPolicy(class ULearningAgentsInteractor* InInteractor, const struct FLearningAgentsPolicySettings& PolicySettings, class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetupPolicy");

	Params::LearningAgentsPolicy_SetupPolicy Parms{};

	Parms.InInteractor = InInteractor;
	Parms.PolicySettings = std::move(PolicySettings);
	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsPolicy.UsePolicyFromAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULearningAgentsNeuralNetwork*     NeuralNetworkAsset                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::UsePolicyFromAsset(class ULearningAgentsNeuralNetwork* NeuralNetworkAsset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UsePolicyFromAsset");

	Params::LearningAgentsPolicy_UsePolicyFromAsset Parms{};

	Parms.NeuralNetworkAsset = NeuralNetworkAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function LearningAgents.LearningAgentsPolicy.GetActionNoiseScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULearningAgentsPolicy::GetActionNoiseScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActionNoiseScale");

	Params::LearningAgentsPolicy_GetActionNoiseScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function LearningAgents.LearningAgentsPolicy.GetMemoryState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<float>                           OutMemoryState                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   AgentId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::GetMemoryState(TArray<float>* OutMemoryState, const int32 AgentId) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMemoryState");

	Params::LearningAgentsPolicy_GetMemoryState Parms{};

	Parms.AgentId = AgentId;

	UObject::ProcessEvent(Func, &Parms);

	if (OutMemoryState != nullptr)
		*OutMemoryState = std::move(Parms.OutMemoryState);
}


// Function LearningAgents.LearningAgentsPolicy.SavePolicyToSnapshot
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FFilePath                        File                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULearningAgentsPolicy::SavePolicyToSnapshot(const struct FFilePath& File) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SavePolicyToSnapshot");

	Params::LearningAgentsPolicy_SavePolicyToSnapshot Parms{};

	Parms.File = std::move(File);

	UObject::ProcessEvent(Func, &Parms);
}

}

