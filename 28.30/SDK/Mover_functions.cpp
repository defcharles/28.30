#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mover

#include "Basic.hpp"

#include "Mover_classes.hpp"
#include "Mover_parameters.hpp"


namespace SDK
{

// Function Mover.TurnGeneratorInterface.GetTurn
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FRotator                         TargetOrientation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMoverTickStartData              FullStartState                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMoverDefaultSyncState           MoverState                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTimeStep                   TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ProposedMove                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UMoverBlackboard*                 SimBlackboard                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ITurnGeneratorInterface::GetTurn(const struct FRotator& TargetOrientation, const struct FMoverTickStartData& FullStartState, const struct FMoverDefaultSyncState& MoverState, const struct FMoverTimeStep& TimeStep, const struct FProposedMove& ProposedMove, class UMoverBlackboard* SimBlackboard)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTurn");

	Params::TurnGeneratorInterface_GetTurn Parms{};

	Parms.TargetOrientation = std::move(TargetOrientation);
	Parms.FullStartState = std::move(FullStartState);
	Parms.MoverState = std::move(MoverState);
	Parms.TimeStep = std::move(TimeStep);
	Parms.ProposedMove = std::move(ProposedMove);
	Parms.SimBlackboard = SimBlackboard;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverBasePawn.GetMoverComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMoverComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMoverComponent* AMoverBasePawn::GetMoverComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMoverComponent");

	Params::MoverBasePawn_GetMoverComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetLocationFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMoverDefaultSyncState           SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetLocationFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLocationFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetLocationFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetMoveDirectionIntentFromInputs
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FKinematicDefaultInputs          Inputs                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetMoveDirectionIntentFromInputs(const struct FKinematicDefaultInputs& Inputs)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMoveDirectionIntentFromInputs");

	Params::MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs Parms{};

	Parms.Inputs = std::move(Inputs);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetMoveDirectionIntentFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMoverDefaultSyncState           SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetMoveDirectionIntentFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMoveDirectionIntentFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetOrientationFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMoverDefaultSyncState           SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMoverDataModelBlueprintLibrary::GetOrientationFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetOrientationFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetOrientationFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetVelocityFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMoverDefaultSyncState           SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetVelocityFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetVelocityFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetVelocityFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverDebugComponent.OnHistoryTrackingRollback
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FMoverTimeStep                   NewTimeStep                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FMoverTimeStep                   InvalidatedTimeStep                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnHistoryTrackingRollback(const struct FMoverTimeStep& NewTimeStep, const struct FMoverTimeStep& InvalidatedTimeStep)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnHistoryTrackingRollback");

	Params::MoverDebugComponent_OnHistoryTrackingRollback Parms{};

	Parms.NewTimeStep = std::move(NewTimeStep);
	Parms.InvalidatedTimeStep = std::move(InvalidatedTimeStep);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverDebugComponent.OnMovementSimRollback
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FMoverTimeStep                   NewTimeStep                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FMoverTimeStep                   InvalidatedTimeStep                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnMovementSimRollback(const struct FMoverTimeStep& NewTimeStep, const struct FMoverTimeStep& InvalidatedTimeStep)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMovementSimRollback");

	Params::MoverDebugComponent_OnMovementSimRollback Parms{};

	Parms.NewTimeStep = std::move(NewTimeStep);
	Parms.InvalidatedTimeStep = std::move(InvalidatedTimeStep);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverDebugComponent.OnMovementSimTick
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FMoverTimeStep                   TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnMovementSimTick(const struct FMoverTimeStep& TimeStep)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMovementSimTick");

	Params::MoverDebugComponent_OnMovementSimTick Parms{};

	Parms.TimeStep = std::move(TimeStep);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverDebugComponent.SetHistoryTracking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SecondsToTrack                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SamplesPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDebugComponent::SetHistoryTracking(float SecondsToTrack, float SamplesPerSecond)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHistoryTracking");

	Params::MoverDebugComponent_SetHistoryTracking Parms{};

	Parms.SecondsToTrack = SecondsToTrack;
	Parms.SamplesPerSecond = SamplesPerSecond;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverDebugComponent.GetFutureTrajectory
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                                   FutureSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SamplesPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTrajectorySampleInfo>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTrajectorySampleInfo> UMoverDebugComponent::GetFutureTrajectory(float FutureSeconds, float SamplesPerSecond) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFutureTrajectory");

	Params::MoverDebugComponent_GetFutureTrajectory Parms{};

	Parms.FutureSeconds = FutureSeconds;
	Parms.SamplesPerSecond = SamplesPerSecond;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverDebugComponent.GetPastTrajectory
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// TArray<struct FTrajectorySampleInfo>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTrajectorySampleInfo> UMoverDebugComponent::GetPastTrajectory() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPastTrajectory");

	Params::MoverDebugComponent_GetPastTrajectory Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverInputProducerInterface.ProduceInput
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   SimTimeMs                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMoverInputCmdContext            InputCmdResult                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void IMoverInputProducerInterface::ProduceInput(int32 SimTimeMs, struct FMoverInputCmdContext* InputCmdResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ProduceInput");

	Params::MoverInputProducerInterface_ProduceInput Parms{};

	Parms.SimTimeMs = SimTimeMs;

	UObject::ProcessEvent(Func, &Parms);

	if (InputCmdResult != nullptr)
		*InputCmdResult = std::move(Parms.InputCmdResult);
}


// Function Mover.MoverDataCollectionLibrary.K2_AddDataToCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMoverDataCollection             Collection                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SourceAsRawBytes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDataCollectionLibrary::K2_AddDataToCollection(struct FMoverDataCollection& Collection, const int32& SourceAsRawBytes)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_AddDataToCollection");

	Params::MoverDataCollectionLibrary_K2_AddDataToCollection Parms{};

	Parms.Collection = std::move(Collection);
	Parms.SourceAsRawBytes = SourceAsRawBytes;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Collection = std::move(Parms.Collection);
}


// Function Mover.MoverDataCollectionLibrary.K2_GetDataFromCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    DidSucceed                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMoverDataCollection             Collection                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   TargetAsRawBytes                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDataCollectionLibrary::K2_GetDataFromCollection(bool* DidSucceed, const struct FMoverDataCollection& Collection, int32* TargetAsRawBytes)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_GetDataFromCollection");

	Params::MoverDataCollectionLibrary_K2_GetDataFromCollection Parms{};

	Parms.Collection = std::move(Collection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (DidSucceed != nullptr)
		*DidSucceed = Parms.DidSucceed;

	if (TargetAsRawBytes != nullptr)
		*TargetAsRawBytes = Parms.TargetAsRawBytes;
}


// Function Mover.BaseMovementMode.K2_OnRegistered
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             ModeName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseMovementMode::K2_OnRegistered(const class FName ModeName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnRegistered");

	Params::BaseMovementMode_K2_OnRegistered Parms{};

	Parms.ModeName = ModeName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.BaseMovementMode.K2_OnSimulationTick
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSimulationTickParams            Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMoverTickEndData UBaseMovementMode::K2_OnSimulationTick(const struct FSimulationTickParams& Params_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnSimulationTick");

	Params::BaseMovementMode_K2_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.K2_OnUnregistered
// (Event, Protected, BlueprintEvent)

void UBaseMovementMode::K2_OnUnregistered()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnUnregistered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mover.BaseMovementMode.GetBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMoverBlackboard*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMoverBlackboard* UBaseMovementMode::GetBlackboard() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBlackboard");

	Params::BaseMovementMode_GetBlackboard Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.GetBlackboard_Mutable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMoverBlackboard*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMoverBlackboard* UBaseMovementMode::GetBlackboard_Mutable() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBlackboard_Mutable");

	Params::BaseMovementMode_GetBlackboard_Mutable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.GetMoverComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMoverComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMoverComponent* UBaseMovementMode::GetMoverComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMoverComponent");

	Params::BaseMovementMode_GetMoverComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.K2_OnGenerateMove
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FMoverTickStartData              StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMoverTimeStep                   TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UBaseMovementMode::K2_OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnGenerateMove");

	Params::BaseMovementMode_K2_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.FallingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSimulationTickParams            Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData                OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFallingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSimulationTick");

	Params::FallingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.FallingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMoverTickStartData              StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMoverTimeStep                   TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFallingMode::OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnGenerateMove");

	Params::FallingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	UObject::ProcessEvent(Func, &Parms);

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.FallingMode.ProcessLanded
// (Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFloorCheckResult                FloorResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRelativeBaseInfo                BaseInfo                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData                TickEndData                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFallingMode::ProcessLanded(const struct FFloorCheckResult& FloorResult, struct FVector* Velocity, struct FRelativeBaseInfo* BaseInfo, struct FMoverTickEndData* TickEndData) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ProcessLanded");

	Params::FallingMode_ProcessLanded Parms{};

	Parms.FloorResult = std::move(FloorResult);

	UObject::ProcessEvent(Func, &Parms);

	if (Velocity != nullptr)
		*Velocity = std::move(Parms.Velocity);

	if (BaseInfo != nullptr)
		*BaseInfo = std::move(Parms.BaseInfo);

	if (TickEndData != nullptr)
		*TickEndData = std::move(Parms.TickEndData);
}


// Function Mover.FlyingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSimulationTickParams            Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData                OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFlyingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSimulationTick");

	Params::FlyingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.FlyingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMoverTickStartData              StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMoverTimeStep                   TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFlyingMode::OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnGenerateMove");

	Params::FlyingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	UObject::ProcessEvent(Func, &Parms);

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.SwimmingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSimulationTickParams            Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData                OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void USwimmingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSimulationTick");

	Params::SwimmingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.SwimmingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMoverTickStartData              StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMoverTimeStep                   TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void USwimmingMode::OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnGenerateMove");

	Params::SwimmingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	UObject::ProcessEvent(Func, &Parms);

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.WalkingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSimulationTickParams            Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData                OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UWalkingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSimulationTick");

	Params::WalkingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.WalkingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMoverTickStartData              StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMoverTimeStep                   TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UWalkingMode::OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnGenerateMove");

	Params::WalkingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	UObject::ProcessEvent(Func, &Parms);

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.MovementBaseUtils.GetMovementBaseTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            OutQuat                                                (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::GetMovementBaseTransform(const class UPrimitiveComponent* MovementBase, const class FName BoneName, struct FVector* OutLocation, struct FQuat* OutQuat)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMovementBaseTransform");

	Params::MovementBaseUtils_GetMovementBaseTransform Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutQuat != nullptr)
		*OutQuat = std::move(Parms.OutQuat);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.IsADynamicBase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::IsADynamicBase(const class UPrimitiveComponent* MovementBase)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsADynamicBase");

	Params::MovementBaseUtils_IsADynamicBase Parms{};

	Parms.MovementBase = MovementBase;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformBasedDirectionToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutDirectionWorldSpace                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformBasedDirectionToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& LocalDirection, struct FVector* OutDirectionWorldSpace)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformBasedDirectionToWorld");

	Params::MovementBaseUtils_TransformBasedDirectionToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalDirection = std::move(LocalDirection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutDirectionWorldSpace != nullptr)
		*OutDirectionWorldSpace = std::move(Parms.OutDirectionWorldSpace);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformBasedLocationToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocationWorldSpace                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformBasedLocationToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& LocalLocation, struct FVector* OutLocationWorldSpace)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformBasedLocationToWorld");

	Params::MovementBaseUtils_TransformBasedLocationToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalLocation = std::move(LocalLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocationWorldSpace != nullptr)
		*OutLocationWorldSpace = std::move(Parms.OutLocationWorldSpace);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformBasedRotatorToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         OutWorldSpaceRotator                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformBasedRotatorToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FRotator& LocalRotator, struct FRotator* OutWorldSpaceRotator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformBasedRotatorToWorld");

	Params::MovementBaseUtils_TransformBasedRotatorToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalRotator = std::move(LocalRotator);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutWorldSpaceRotator != nullptr)
		*OutWorldSpaceRotator = std::move(Parms.OutWorldSpaceRotator);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformDirectionToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldSpaceDirection                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocalDirection                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformDirectionToLocal(const struct FQuat& BaseQuat, const struct FVector& WorldSpaceDirection, struct FVector* OutLocalDirection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformDirectionToLocal");

	Params::MovementBaseUtils_TransformDirectionToLocal Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceDirection = std::move(WorldSpaceDirection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocalDirection != nullptr)
		*OutLocalDirection = std::move(Parms.OutLocalDirection);
}


// Function Mover.MovementBaseUtils.TransformDirectionToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutDirectionWorldSpace                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformDirectionToWorld(const struct FQuat& BaseQuat, const struct FVector& LocalDirection, struct FVector* OutDirectionWorldSpace)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformDirectionToWorld");

	Params::MovementBaseUtils_TransformDirectionToWorld Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalDirection = std::move(LocalDirection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutDirectionWorldSpace != nullptr)
		*OutDirectionWorldSpace = std::move(Parms.OutDirectionWorldSpace);
}


// Function Mover.MovementBaseUtils.TransformLocationToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          BasePos                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldSpaceLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocalLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformLocationToLocal(const struct FVector& BasePos, const struct FQuat& BaseQuat, const struct FVector& WorldSpaceLocation, struct FVector* OutLocalLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformLocationToLocal");

	Params::MovementBaseUtils_TransformLocationToLocal Parms{};

	Parms.BasePos = std::move(BasePos);
	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceLocation = std::move(WorldSpaceLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocalLocation != nullptr)
		*OutLocalLocation = std::move(Parms.OutLocalLocation);
}


// Function Mover.MovementBaseUtils.TransformLocationToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          BasePos                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocationWorldSpace                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformLocationToWorld(const struct FVector& BasePos, const struct FQuat& BaseQuat, const struct FVector& LocalLocation, struct FVector* OutLocationWorldSpace)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformLocationToWorld");

	Params::MovementBaseUtils_TransformLocationToWorld Parms{};

	Parms.BasePos = std::move(BasePos);
	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalLocation = std::move(LocalLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocationWorldSpace != nullptr)
		*OutLocationWorldSpace = std::move(Parms.OutLocationWorldSpace);
}


// Function Mover.MovementBaseUtils.TransformRotatorToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldSpaceRotator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         OutLocalRotator                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformRotatorToLocal(const struct FQuat& BaseQuat, const struct FRotator& WorldSpaceRotator, struct FRotator* OutLocalRotator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformRotatorToLocal");

	Params::MovementBaseUtils_TransformRotatorToLocal Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceRotator = std::move(WorldSpaceRotator);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocalRotator != nullptr)
		*OutLocalRotator = std::move(Parms.OutLocalRotator);
}


// Function Mover.MovementBaseUtils.TransformRotatorToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         OutWorldSpaceRotator                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformRotatorToWorld(const struct FQuat& BaseQuat, const struct FRotator& LocalRotator, struct FRotator* OutWorldSpaceRotator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformRotatorToWorld");

	Params::MovementBaseUtils_TransformRotatorToWorld Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalRotator = std::move(LocalRotator);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutWorldSpaceRotator != nullptr)
		*OutWorldSpaceRotator = std::move(Parms.OutWorldSpaceRotator);
}


// Function Mover.MovementBaseUtils.TransformWorldDirectionToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldSpaceDirection                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocalDirection                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformWorldDirectionToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& WorldSpaceDirection, struct FVector* OutLocalDirection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformWorldDirectionToBased");

	Params::MovementBaseUtils_TransformWorldDirectionToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceDirection = std::move(WorldSpaceDirection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocalDirection != nullptr)
		*OutLocalDirection = std::move(Parms.OutLocalDirection);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformWorldLocationToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldSpaceLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocalLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformWorldLocationToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& WorldSpaceLocation, struct FVector* OutLocalLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformWorldLocationToBased");

	Params::MovementBaseUtils_TransformWorldLocationToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceLocation = std::move(WorldSpaceLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocalLocation != nullptr)
		*OutLocalLocation = std::move(Parms.OutLocalLocation);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformWorldRotatorToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldSpaceRotator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         OutLocalRotator                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformWorldRotatorToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FRotator& WorldSpaceRotator, struct FRotator* OutLocalRotator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformWorldRotatorToBased");

	Params::MovementBaseUtils_TransformWorldRotatorToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceRotator = std::move(WorldSpaceRotator);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLocalRotator != nullptr)
		*OutLocalRotator = std::move(Parms.OutLocalRotator);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.CanEscapeGravity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          PriorVelocity                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GravityAccel                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::CanEscapeGravity(const struct FVector& PriorVelocity, const struct FVector& NewVelocity, const struct FVector& GravityAccel, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CanEscapeGravity");

	Params::MovementUtils_CanEscapeGravity Parms{};

	Parms.PriorVelocity = std::move(PriorVelocity);
	Parms.NewVelocity = std::move(NewVelocity);
	Parms.GravityAccel = std::move(GravityAccel);
	Parms.DeltaSeconds = DeltaSeconds;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.CanStepUpOnHitSurface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::CanStepUpOnHitSurface(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CanStepUpOnHitSurface");

	Params::MovementUtils_CanStepUpOnHitSurface Parms{};

	Parms.Hit = std::move(Hit);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeAngularVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         From                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         To                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TurningRateLimit                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMovementUtils::ComputeAngularVelocity(const struct FRotator& From, const struct FRotator& To, float DeltaSeconds, float TurningRateLimit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeAngularVelocity");

	Params::MovementUtils_ComputeAngularVelocity Parms{};

	Parms.From = std::move(From);
	Parms.To = std::move(To);
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.TurningRateLimit = TurningRateLimit;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeControlledFreeMove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFreeMoveParams                  InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UMovementUtils::ComputeControlledFreeMove(const struct FFreeMoveParams& InParams)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeControlledFreeMove");

	Params::MovementUtils_ComputeControlledFreeMove Parms{};

	Parms.InParams = std::move(InParams);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeControlledGroundMove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGroundMoveParams                InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UMovementUtils::ComputeControlledGroundMove(const struct FGroundMoveParams& InParams)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeControlledGroundMove");

	Params::MovementUtils_ComputeControlledGroundMove Parms{};

	Parms.InParams = std::move(InParams);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeDeflectedMoveOntoRamp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          OrigMoveDelta                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       RampHitResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHitFromLineTrace                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeDeflectedMoveOntoRamp(const struct FVector& OrigMoveDelta, const struct FHitResult& RampHitResult, float MaxWalkSlopeCosine, const bool bHitFromLineTrace)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeDeflectedMoveOntoRamp");

	Params::MovementUtils_ComputeDeflectedMoveOntoRamp Parms{};

	Parms.OrigMoveDelta = std::move(OrigMoveDelta);
	Parms.RampHitResult = std::move(RampHitResult);
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;
	Parms.bHitFromLineTrace = bHitFromLineTrace;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeDirectionIntent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          MoveInput                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMoveInputType                          MoveInputType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeDirectionIntent(const struct FVector& MoveInput, EMoveInputType MoveInputType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeDirectionIntent");

	Params::MovementUtils_ComputeDirectionIntent Parms{};

	Parms.MoveInput = std::move(MoveInput);
	Parms.MoveInputType = MoveInputType;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeSlideDelta
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeSlideDelta(const struct FVector& Delta, const float PctOfDeltaToMove, const struct FVector& Normal, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeSlideDelta");

	Params::MovementUtils_ComputeSlideDelta Parms{};

	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Normal = std::move(Normal);
	Parms.Hit = std::move(Hit);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FComputeVelocityParams           InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocity(const struct FComputeVelocityParams& InParams)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeVelocity");

	Params::MovementUtils_ComputeVelocity Parms{};

	Parms.InParams = std::move(InParams);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocityFromGravity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          GravityAccel                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocityFromGravity(const struct FVector& GravityAccel, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeVelocityFromGravity");

	Params::MovementUtils_ComputeVelocityFromGravity Parms{};

	Parms.GravityAccel = std::move(GravityAccel);
	Parms.DeltaSeconds = DeltaSeconds;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocityFromPositions
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          FromPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ToPos                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocityFromPositions(const struct FVector& FromPos, const struct FVector& ToPos, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComputeVelocityFromPositions");

	Params::MovementUtils_ComputeVelocityFromPositions Parms{};

	Parms.FromPos = std::move(FromPos);
	Parms.ToPos = std::move(ToPos);
	Parms.DeltaSeconds = DeltaSeconds;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ConstrainToPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                           MovementPlane                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaintainMagnitude                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ConstrainToPlane(const struct FVector& Vector, const struct FPlane& MovementPlane, bool bMaintainMagnitude)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConstrainToPlane");

	Params::MovementUtils_ConstrainToPlane Parms{};

	Parms.Vector = std::move(Vector);
	Parms.MovementPlane = std::move(MovementPlane);
	Parms.bMaintainMagnitude = bMaintainMagnitude;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.IsExceedingMaxSpeed
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Velocity                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::IsExceedingMaxSpeed(const struct FVector& Velocity, float InMaxSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsExceedingMaxSpeed");

	Params::MovementUtils_IsExceedingMaxSpeed Parms{};

	Parms.Velocity = std::move(Velocity);
	Parms.InMaxSpeed = InMaxSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.IsHitSurfaceWalkable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::IsHitSurfaceWalkable(const struct FHitResult& Hit, float MaxWalkSlopeCosine)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsHitSurfaceWalkable");

	Params::MovementUtils_IsHitSurfaceWalkable Parms{};

	Parms.Hit = std::move(Hit);
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.IsValidLandingSpot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   FloorSweepDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloorCheckResult                OutFloorResult                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::IsValidLandingSpot(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, const struct FVector& Location, const struct FHitResult& Hit, float FloorSweepDistance, float MaxWalkSlopeCosine, struct FFloorCheckResult* OutFloorResult)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValidLandingSpot");

	Params::MovementUtils_IsValidLandingSpot Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.Location = std::move(Location);
	Parms.Hit = std::move(Hit);
	Parms.FloorSweepDistance = FloorSweepDistance;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutFloorResult != nullptr)
		*OutFloorResult = std::move(Parms.OutFloorResult);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TryMoveToFallAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMoverComponent*                  MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FloorSweepDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloorCheckResult                OutFloorResult                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMovementRecord                  MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementUtils::TryMoveToFallAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, float FloorSweepDistance, float MaxWalkSlopeCosine, struct FFloorCheckResult* OutFloorResult, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TryMoveToFallAlongSurface");

	Params::MovementUtils_TryMoveToFallAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;
	Parms.FloorSweepDistance = FloorSweepDistance;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (OutFloorResult != nullptr)
		*OutFloorResult = std::move(Parms.OutFloorResult);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TryMoveToSlideAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMoverComponent*                  MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord                  MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementUtils::TryMoveToSlideAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TryMoveToSlideAlongSurface");

	Params::MovementUtils_TryMoveToSlideAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TrySafeMoveUpdatedComponent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            NewRotation                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ETeleportType                           Teleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord                  MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::TrySafeMoveUpdatedComponent(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, const struct FVector& Delta, const struct FQuat& NewRotation, bool bSweep, struct FHitResult* OutHit, ETeleportType Teleport, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TrySafeMoveUpdatedComponent");

	Params::MovementUtils_TrySafeMoveUpdatedComponent Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.Delta = std::move(Delta);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.Teleport = Teleport;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TryWalkToSlideAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMoverComponent*                  MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord                  MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementUtils::TryWalkToSlideAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, struct FMovementRecord* MoveRecord, float MaxWalkSlopeCosine)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TryWalkToSlideAlongSurface");

	Params::MovementUtils_TryWalkToSlideAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.PlayMoverMontageCallbackProxy.CreateProxyObjectForPlayMoverMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMoverComponent*                  InMoverComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartingPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartingSection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayMoverMontageCallbackProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayMoverMontageCallbackProxy* UPlayMoverMontageCallbackProxy::CreateProxyObjectForPlayMoverMontage(class UMoverComponent* InMoverComponent, class UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, class FName StartingSection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateProxyObjectForPlayMoverMontage");

	Params::PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage Parms{};

	Parms.InMoverComponent = InMoverComponent;
	Parms.MontageToPlay = MontageToPlay;
	Parms.PlayRate = PlayRate;
	Parms.StartingPosition = StartingPosition;
	Parms.StartingSection = StartingSection;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.PlayMoverMontageCallbackProxy.OnMoverMontageEnded
// (Final, Native, Protected)
// Parameters:
// class FName                             IgnoredNotifyName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayMoverMontageCallbackProxy::OnMoverMontageEnded(class FName IgnoredNotifyName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMoverMontageEnded");

	Params::PlayMoverMontageCallbackProxy_OnMoverMontageEnded Parms{};

	Parms.IgnoredNotifyName = IgnoredNotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverComponent.HandleImpact
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMoverOnImpactParams             ImpactParams                                           (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMoverComponent::HandleImpact(struct FMoverOnImpactParams* ImpactParams)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleImpact");

	Params::MoverComponent_HandleImpact Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ImpactParams != nullptr)
		*ImpactParams = std::move(Parms.ImpactParams);
}


// Function Mover.MoverComponent.K2_QueueLayeredMove
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   MoveAsRawData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::K2_QueueLayeredMove(const int32& MoveAsRawData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_QueueLayeredMove");

	Params::MoverComponent_K2_QueueLayeredMove Parms{};

	Parms.MoveAsRawData = MoveAsRawData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverComponent.OnBeginOverlap
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMoverComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnBeginOverlap");

	Params::MoverComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverComponent.PhysicsVolumeChanged
// (Native, Protected)
// Parameters:
// class APhysicsVolume*                   NewVolume                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PhysicsVolumeChanged");

	Params::MoverComponent_PhysicsVolumeChanged Parms{};

	Parms.NewVolume = NewVolume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverComponent.QueueNextMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DesiredModeName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldReenter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::QueueNextMode(class FName DesiredModeName, bool bShouldReenter)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("QueueNextMode");

	Params::MoverComponent_QueueNextMode Parms{};

	Parms.DesiredModeName = DesiredModeName;
	Parms.bShouldReenter = bShouldReenter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverComponent.SetGravityOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bOverrideGravity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GravityAcceleration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::SetGravityOverride(bool bOverrideGravity, const struct FVector& GravityAcceleration)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGravityOverride");

	Params::MoverComponent_SetGravityOverride Parms{};

	Parms.bOverrideGravity = bOverrideGravity;
	Parms.GravityAcceleration = std::move(GravityAcceleration);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.MoverComponent.FindMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UBaseMovementMode>    MovementMode                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseMovementMode*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseMovementMode* UMoverComponent::FindMovementMode(TSubclassOf<class UBaseMovementMode> MovementMode) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindMovementMode");

	Params::MoverComponent_FindMovementMode Parms{};

	Parms.MovementMode = MovementMode;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.FindSharedSettings_BP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UObject>              SharedSetting                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UObject* UMoverComponent::FindSharedSettings_BP(TSubclassOf<class UObject> SharedSetting) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindSharedSettings_BP");

	Params::MoverComponent_FindSharedSettings_BP Parms{};

	Parms.SharedSetting = SharedSetting;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.FindSharedSettings_Mutable_BP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UObject>              SharedSetting                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UMoverComponent::FindSharedSettings_Mutable_BP(TSubclassOf<class UObject> SharedSetting) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindSharedSettings_Mutable_BP");

	Params::MoverComponent_FindSharedSettings_Mutable_BP Parms{};

	Parms.SharedSetting = SharedSetting;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetGravityAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverComponent::GetGravityAcceleration() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGravityAcceleration");

	Params::MoverComponent_GetGravityAcceleration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetLastInputCmd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMoverInputCmdContext      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMoverInputCmdContext UMoverComponent::GetLastInputCmd() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastInputCmd");

	Params::MoverComponent_GetLastInputCmd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetMovementBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UMoverComponent::GetMovementBase() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMovementBase");

	Params::MoverComponent_GetMovementBase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetMovementBaseBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMoverComponent::GetMovementBaseBoneName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMovementBaseBoneName");

	Params::MoverComponent_GetMovementBaseBoneName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetMovementIntent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverComponent::GetMovementIntent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMovementIntent");

	Params::MoverComponent_GetMovementIntent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetMovementModeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMoverComponent::GetMovementModeName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMovementModeName");

	Params::MoverComponent_GetMovementModeName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetSyncState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMoverSyncState            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMoverSyncState UMoverComponent::GetSyncState() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSyncState");

	Params::MoverComponent_GetSyncState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetTargetOrientation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMoverComponent::GetTargetOrientation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTargetOrientation");

	Params::MoverComponent_GetTargetOrientation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetUpDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverComponent::GetUpDirection() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUpDirection");

	Params::MoverComponent_GetUpDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverComponent::GetVelocity() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVelocity");

	Params::MoverComponent_GetVelocity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.HasValidCachedInputCmd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::HasValidCachedInputCmd() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasValidCachedInputCmd");

	Params::MoverComponent_HasValidCachedInputCmd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.HasValidCachedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::HasValidCachedState() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasValidCachedState");

	Params::MoverComponent_HasValidCachedState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.IsAirborne
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::IsAirborne() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAirborne");

	Params::MoverComponent_IsAirborne Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.IsFalling
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::IsFalling() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsFalling");

	Params::MoverComponent_IsFalling Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.IsOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::IsOnGround() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOnGround");

	Params::MoverComponent_IsOnGround Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.IsSlopeSliding
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::IsSlopeSliding() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSlopeSliding");

	Params::MoverComponent_IsSlopeSliding Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.TryGetFloorCheckHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       OutHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::TryGetFloorCheckHitResult(struct FHitResult* OutHitResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TryGetFloorCheckHitResult");

	Params::MoverComponent_TryGetFloorCheckHitResult Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutHitResult != nullptr)
		*OutHitResult = std::move(Parms.OutHitResult);

	return Parms.ReturnValue;
}

}

