#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AtomRuntime

#include "Basic.hpp"

#include "AtomRuntime_classes.hpp"
#include "AtomRuntime_parameters.hpp"


namespace SDK
{

// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.AddPartInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection        PartCollection                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FAtomModelPartInstanceInfo       PartInstance                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAtomPartsCollectionBlueprintLibrary::AddPartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartInstanceInfo& PartInstance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPartInstance");

	Params::AtomPartsCollectionBlueprintLibrary_AddPartInstance Parms{};

	Parms.PartInstance = std::move(PartInstance);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PartCollection != nullptr)
		*PartCollection = std::move(Parms.PartCollection);
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.Conv_ModelPartGuidToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAtomModelPartGuid               InModelPartGuid                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomPartsCollectionBlueprintLibrary::Conv_ModelPartGuidToString(const struct FAtomModelPartGuid& InModelPartGuid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ModelPartGuidToString");

	Params::AtomPartsCollectionBlueprintLibrary_Conv_ModelPartGuidToString Parms{};

	Parms.InModelPartGuid = std::move(InModelPartGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.Conv_StringToModelPartGuid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartGuid               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAtomModelPartGuid UAtomPartsCollectionBlueprintLibrary::Conv_StringToModelPartGuid(const class FString& InString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToModelPartGuid");

	Params::AtomPartsCollectionBlueprintLibrary_Conv_StringToModelPartGuid Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.CreateColorInfoFromColorId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ColorId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartColorInfo          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAtomModelPartColorInfo UAtomPartsCollectionBlueprintLibrary::CreateColorInfoFromColorId(int32 ColorId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateColorInfoFromColorId");

	Params::AtomPartsCollectionBlueprintLibrary_CreateColorInfoFromColorId Parms{};

	Parms.ColorId = ColorId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.FilterGroup
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAtomModel*                       Model                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        PartsCollectionToFilter                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           GroupName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewPartsCollectionName                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::FilterGroup(class UAtomModel* Model, const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& GroupName, const class FString& NewPartsCollectionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FilterGroup");

	Params::AtomPartsCollectionBlueprintLibrary_FilterGroup Parms{};

	Parms.Model = Model;
	Parms.PartsCollectionToFilter = std::move(PartsCollectionToFilter);
	Parms.GroupName = std::move(GroupName);
	Parms.NewPartsCollectionName = std::move(NewPartsCollectionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.FilterNonTransparent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAtomModelPartsCollection        PartsCollectionToFilter                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           NewPartsCollectionName                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::FilterNonTransparent(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& NewPartsCollectionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FilterNonTransparent");

	Params::AtomPartsCollectionBlueprintLibrary_FilterNonTransparent Parms{};

	Parms.PartsCollectionToFilter = std::move(PartsCollectionToFilter);
	Parms.NewPartsCollectionName = std::move(NewPartsCollectionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.FilterSelectionSet
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAtomModelPartsCollection        PartsCollectionToFilter                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           SelectionSetName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewPartsCollectionName                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::FilterSelectionSet(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& SelectionSetName, const class FString& NewPartsCollectionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FilterSelectionSet");

	Params::AtomPartsCollectionBlueprintLibrary_FilterSelectionSet Parms{};

	Parms.PartsCollectionToFilter = std::move(PartsCollectionToFilter);
	Parms.SelectionSetName = std::move(SelectionSetName);
	Parms.NewPartsCollectionName = std::move(NewPartsCollectionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.FilterTransparent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAtomModelPartsCollection        PartsCollectionToFilter                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           NewPartsCollectionName                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::FilterTransparent(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& NewPartsCollectionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FilterTransparent");

	Params::AtomPartsCollectionBlueprintLibrary_FilterTransparent Parms{};

	Parms.PartsCollectionToFilter = std::move(PartsCollectionToFilter);
	Parms.NewPartsCollectionName = std::move(NewPartsCollectionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.GetName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAtomModelPartsCollection        PartsCollection                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomPartsCollectionBlueprintLibrary::GetName(const struct FAtomModelPartsCollection& PartsCollection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetName");

	Params::AtomPartsCollectionBlueprintLibrary_GetName Parms{};

	Parms.PartsCollection = std::move(PartsCollection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.GetParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAtomModelPartsCollection        PartsCollection                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FAtomModelPartInstanceInfo>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FAtomModelPartInstanceInfo> UAtomPartsCollectionBlueprintLibrary::GetParts(const struct FAtomModelPartsCollection& PartsCollection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetParts");

	Params::AtomPartsCollectionBlueprintLibrary_GetParts Parms{};

	Parms.PartsCollection = std::move(PartsCollection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.GetPrimitiveCommonParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAtomPrimitive*                   Primitive                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAtomCommonPartAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomCommonPartAndTransform> UAtomPartsCollectionBlueprintLibrary::GetPrimitiveCommonParts(class UAtomPrimitive* Primitive, double Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPrimitiveCommonParts");

	Params::AtomPartsCollectionBlueprintLibrary_GetPrimitiveCommonParts Parms{};

	Parms.Primitive = Primitive;
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.InitializeCommonParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection        PartsCollection                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAtomModel*                       Model                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveConnectedParts                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllKnobs                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllTubes                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllPins                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::InitializeCommonParts(struct FAtomModelPartsCollection& PartsCollection, const class UAtomModel* Model, float Scale, bool bRemoveConnectedParts, bool bRemoveAllKnobs, bool bRemoveAllTubes, bool bRemoveAllPins)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InitializeCommonParts");

	Params::AtomPartsCollectionBlueprintLibrary_InitializeCommonParts Parms{};

	Parms.PartsCollection = std::move(PartsCollection);
	Parms.Model = Model;
	Parms.Scale = Scale;
	Parms.bRemoveConnectedParts = bRemoveConnectedParts;
	Parms.bRemoveAllKnobs = bRemoveAllKnobs;
	Parms.bRemoveAllTubes = bRemoveAllTubes;
	Parms.bRemoveAllPins = bRemoveAllPins;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	PartsCollection = std::move(Parms.PartsCollection);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.RemovePartInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection        PartCollection                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FAtomModelPartGuid               PartInstanceId                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomPartsCollectionBlueprintLibrary::RemovePartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartGuid& PartInstanceId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RemovePartInstance");

	Params::AtomPartsCollectionBlueprintLibrary_RemovePartInstance Parms{};

	Parms.PartInstanceId = std::move(PartInstanceId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PartCollection != nullptr)
		*PartCollection = std::move(Parms.PartCollection);
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.ReplacePartInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection        PartCollection                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FAtomModelPartInstanceInfo       SourcePartInstance                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAtomModelPartGuid               TargetPartInstanceId                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomPartsCollectionBlueprintLibrary::ReplacePartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartInstanceInfo& SourcePartInstance, const struct FAtomModelPartGuid& TargetPartInstanceId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReplacePartInstance");

	Params::AtomPartsCollectionBlueprintLibrary_ReplacePartInstance Parms{};

	Parms.SourcePartInstance = std::move(SourcePartInstance);
	Parms.TargetPartInstanceId = std::move(TargetPartInstanceId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PartCollection != nullptr)
		*PartCollection = std::move(Parms.PartCollection);
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.SetName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection        PartsCollection                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomPartsCollectionBlueprintLibrary::SetName(struct FAtomModelPartsCollection* PartsCollection, const class FString& Name_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetName");

	Params::AtomPartsCollectionBlueprintLibrary_SetName Parms{};

	Parms.Name_0 = std::move(Name_0);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PartsCollection != nullptr)
		*PartsCollection = std::move(Parms.PartsCollection);
}


// Function AtomRuntime.AtomPrimitiveBlueprintLibrary.GetDefaultPrimitiveScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtomPrimitiveBlueprintLibrary::GetDefaultPrimitiveScale()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDefaultPrimitiveScale");

	Params::AtomPrimitiveBlueprintLibrary_GetDefaultPrimitiveScale Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.CreateAtomGeometryFromCommonPart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ExportStyleName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAtomCommonPartType                     CommonPartType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CommonPartsMeshPath                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::CreateAtomGeometryFromCommonPart(const class FString& ExportStyleName, EAtomCommonPartType CommonPartType, int32 LODIndex, const class FString& CommonPartsMeshPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateAtomGeometryFromCommonPart");

	Params::AtomPrimitiveGeometry_CreateAtomGeometryFromCommonPart Parms{};

	Parms.ExportStyleName = std::move(ExportStyleName);
	Parms.CommonPartType = CommonPartType;
	Parms.LODIndex = LODIndex;
	Parms.CommonPartsMeshPath = std::move(CommonPartsMeshPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.CreateEmptyAtomGeometry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::CreateEmptyAtomGeometry()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateEmptyAtomGeometry");

	Params::AtomPrimitiveGeometry_CreateEmptyAtomGeometry Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.GetNumberOfCommonPartLODs
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ExportStyleName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAtomCommonPartType                     CommonPartType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CommonPartsMeshPath                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAtomPrimitiveGeometry::GetNumberOfCommonPartLODs(const class FString& ExportStyleName, EAtomCommonPartType CommonPartType, const class FString& CommonPartsMeshPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetNumberOfCommonPartLODs");

	Params::AtomPrimitiveGeometry_GetNumberOfCommonPartLODs Parms{};

	Parms.ExportStyleName = std::move(ExportStyleName);
	Parms.CommonPartType = CommonPartType;
	Parms.CommonPartsMeshPath = std::move(CommonPartsMeshPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.Append
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAtomPrimitiveGeometry*           GeometryToAppend                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform3f                     Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::Append(const class UAtomPrimitiveGeometry* GeometryToAppend, const struct FTransform3f& Transform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Append");

	Params::AtomPrimitiveGeometry_Append Parms{};

	Parms.GeometryToAppend = GeometryToAppend;
	Parms.Transform = std::move(Transform);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.AppendAndWeld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAtomPrimitiveGeometry*           GeometryToAppend                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform3f                     Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::AppendAndWeld(const class UAtomPrimitiveGeometry* GeometryToAppend, const struct FTransform3f& Transform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AppendAndWeld");

	Params::AtomPrimitiveGeometry_AppendAndWeld Parms{};

	Parms.GeometryToAppend = GeometryToAppend;
	Parms.Transform = std::move(Transform);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.AttachVerticesToBoneIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BoneIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomPrimitiveGeometry::AttachVerticesToBoneIndex(int32 BoneIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AttachVerticesToBoneIndex");

	Params::AtomPrimitiveGeometry_AttachVerticesToBoneIndex Parms{};

	Parms.BoneIndex = BoneIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.AtomPrimitiveGeometry.AttachVerticesToNamedBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           BoneName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomPrimitiveGeometry::AttachVerticesToNamedBone(const class FString& BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AttachVerticesToNamedBone");

	Params::AtomPrimitiveGeometry_AttachVerticesToNamedBone Parms{};

	Parms.BoneName = std::move(BoneName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.AtomPrimitiveGeometry.BakeScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::BakeScale(float Scale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BakeScale");

	Params::AtomPrimitiveGeometry_BakeScale Parms{};

	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.BakeTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform3f                     Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::BakeTransform(const struct FTransform3f& Transform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BakeTransform");

	Params::AtomPrimitiveGeometry_BakeTransform Parms{};

	Parms.Transform = std::move(Transform);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.BakeTransforms
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTransform3f>             Transforms                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::BakeTransforms(const TArray<struct FTransform3f>& Transforms)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BakeTransforms");

	Params::AtomPrimitiveGeometry_BakeTransforms Parms{};

	Parms.Transforms = std::move(Transforms);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.SetMaterialName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PolygonGroupIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::SetMaterialName(const class FString& Name_0, int32 PolygonGroupIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaterialName");

	Params::AtomPrimitiveGeometry_SetMaterialName Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.PolygonGroupIndex = PolygonGroupIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.SetTiledUVs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TileSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::SetTiledUVs(float TileSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTiledUVs");

	Params::AtomPrimitiveGeometry_SetTiledUVs Parms{};

	Parms.TileSize = TileSize;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.SetVertexColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                           Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::SetVertexColor(const struct FColor& Color)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVertexColor");

	Params::AtomPrimitiveGeometry_SetVertexColor Parms{};

	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.DuplicateGeometry
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::DuplicateGeometry() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DuplicateGeometry");

	Params::AtomPrimitiveGeometry_DuplicateGeometry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.GetBoneIndexForName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           BoneName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAtomPrimitiveGeometry::GetBoneIndexForName(const class FString& BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneIndexForName");

	Params::AtomPrimitiveGeometry_GetBoneIndexForName Parms{};

	Parms.BoneName = std::move(BoneName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.GetMaterialNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UAtomPrimitiveGeometry::GetMaterialNames() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterialNames");

	Params::AtomPrimitiveGeometry_GetMaterialNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.SplitByPolygonGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UAtomPrimitiveGeometry*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAtomPrimitiveGeometry*> UAtomPrimitiveGeometry::SplitByPolygonGroup() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SplitByPolygonGroup");

	Params::AtomPrimitiveGeometry_SplitByPolygonGroup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.ToSimplifiedStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFastBuild                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UAtomPrimitiveGeometry::ToSimplifiedStaticMesh(float Scale, class UObject* Outer_0, const class FString& Name_0, bool bFastBuild) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToSimplifiedStaticMesh");

	Params::AtomPrimitiveGeometry_ToSimplifiedStaticMesh Parms{};

	Parms.Scale = Scale;
	Parms.Outer_0 = Outer_0;
	Parms.Name_0 = std::move(Name_0);
	Parms.bFastBuild = bFastBuild;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetCapsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetCapsGeometry()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCapsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetCapsGeometry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetDetailsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetDetailsGeometry()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDetailsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetDetailsGeometry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPrimitiveGeometryComplexity            PrimitiveGeometryComplexity                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometryContainer::GetGeometry(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGeometry");

	Params::AtomPrimitiveGeometryContainer_GetGeometry Parms{};

	Parms.PrimitiveGeometryComplexity = PrimitiveGeometryComplexity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetGeometryWithMaterialNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPrimitiveGeometryComplexity            PrimitiveGeometryComplexity                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ShellMaterial                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UndersideMaterial                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometryContainer::GetGeometryWithMaterialNames(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity, const class FString& ShellMaterial, const class FString& UndersideMaterial)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGeometryWithMaterialNames");

	Params::AtomPrimitiveGeometryContainer_GetGeometryWithMaterialNames Parms{};

	Parms.PrimitiveGeometryComplexity = PrimitiveGeometryComplexity;
	Parms.ShellMaterial = std::move(ShellMaterial);
	Parms.UndersideMaterial = std::move(UndersideMaterial);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetPartsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetPartsGeometry()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPartsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetPartsGeometry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetScaledCapsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetScaledCapsGeometry(float Scale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledCapsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetScaledCapsGeometry Parms{};

	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetScaledDetailsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetScaledDetailsGeometry(float Scale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledDetailsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetScaledDetailsGeometry Parms{};

	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetScaledGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPrimitiveGeometryComplexity            PrimitiveGeometryComplexity                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometryContainer::GetScaledGeometry(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity, float Scale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledGeometry");

	Params::AtomPrimitiveGeometryContainer_GetScaledGeometry Parms{};

	Parms.PrimitiveGeometryComplexity = PrimitiveGeometryComplexity;
	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetScaledShellGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomPrimitiveGeometryAndTransformReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAtomPrimitiveGeometryAndTransform UAtomPrimitiveGeometryContainer::GetScaledShellGeometry(float Scale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledShellGeometry");

	Params::AtomPrimitiveGeometryContainer_GetScaledShellGeometry Parms{};

	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetShellGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAtomPrimitiveGeometryAndTransformReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAtomPrimitiveGeometryAndTransform UAtomPrimitiveGeometryContainer::GetShellGeometry()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShellGeometry");

	Params::AtomPrimitiveGeometryContainer_GetShellGeometry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetDefaultBoneTransforms
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTransform> UAtomPrimitiveGeometryContainer::GetDefaultBoneTransforms(float Scale) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultBoneTransforms");

	Params::AtomPrimitiveGeometryContainer_GetDefaultBoneTransforms Parms{};

	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetExportStyleName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomPrimitiveGeometryContainer::GetExportStyleName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetExportStyleName");

	Params::AtomPrimitiveGeometryContainer_GetExportStyleName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetAllColorInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<int32, struct FAtomColorInfo>      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<int32, struct FAtomColorInfo> UAtomRuntimeBlueprintLibrary::GetAllColorInfo()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllColorInfo");

	Params::AtomRuntimeBlueprintLibrary_GetAllColorInfo Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetBitPackForColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FColor                           Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAtomRuntimeBlueprintLibrary::GetBitPackForColor(const struct FColor& Color)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetBitPackForColor");

	Params::AtomRuntimeBlueprintLibrary_GetBitPackForColor Parms{};

	Parms.Color = std::move(Color);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetBitPackForColorId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AtomColorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAtomRuntimeBlueprintLibrary::GetBitPackForColorId(int32 AtomColorId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetBitPackForColorId");

	Params::AtomRuntimeBlueprintLibrary_GetBitPackForColorId Parms{};

	Parms.AtomColorId = AtomColorId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetCommonPartAssetDescriptionFromStaticMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomCommonPartAssetDescription  OutDescription                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// EGetCommonPartDescriptionResult         OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomRuntimeBlueprintLibrary::GetCommonPartAssetDescriptionFromStaticMesh(class UStaticMesh* StaticMesh, struct FAtomCommonPartAssetDescription* OutDescription, EGetCommonPartDescriptionResult* OutIsValid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCommonPartAssetDescriptionFromStaticMesh");

	Params::AtomRuntimeBlueprintLibrary_GetCommonPartAssetDescriptionFromStaticMesh Parms{};

	Parms.StaticMesh = StaticMesh;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutDescription != nullptr)
		*OutDescription = std::move(Parms.OutDescription);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetCommonPartCategoryFromType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAtomCommonPartType                     CommonPartType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAtomCommonPartCategory                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAtomCommonPartCategory UAtomRuntimeBlueprintLibrary::GetCommonPartCategoryFromType(EAtomCommonPartType CommonPartType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCommonPartCategoryFromType");

	Params::AtomRuntimeBlueprintLibrary_GetCommonPartCategoryFromType Parms{};

	Parms.CommonPartType = CommonPartType;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetCommonPartDescriptionFromType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EAtomCommonPartType                     CommonPartType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomCommonPartDescription       OutDescription                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UAtomRuntimeBlueprintLibrary::GetCommonPartDescriptionFromType(EAtomCommonPartType CommonPartType, struct FAtomCommonPartDescription* OutDescription)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCommonPartDescriptionFromType");

	Params::AtomRuntimeBlueprintLibrary_GetCommonPartDescriptionFromType Parms{};

	Parms.CommonPartType = CommonPartType;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutDescription != nullptr)
		*OutDescription = std::move(Parms.OutDescription);
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetInfoForColorId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ColorId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomColorInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomColorInfo UAtomRuntimeBlueprintLibrary::GetInfoForColorId(int32 ColorId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetInfoForColorId");

	Params::AtomRuntimeBlueprintLibrary_GetInfoForColorId Parms{};

	Parms.ColorId = ColorId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeSettings.GetColorDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UDataTable*                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDataTable* UAtomRuntimeSettings::GetColorDataTable() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetColorDataTable");

	Params::AtomRuntimeSettings_GetColorDataTable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.DisconnectAllObjectConnections
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FWorldConnectivityHandle         Object                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::DisconnectAllObjectConnections(const struct FWorldConnectivityHandle& Object)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisconnectAllObjectConnections");

	Params::WorldConnectivitySubsystem_DisconnectAllObjectConnections Parms{};

	Parms.Object = std::move(Object);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.WorldConnectivitySubsystem.DisconnectObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FWorldConnectivityHandle         ObjectA                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWorldConnectivityHandle         ObjectB                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::DisconnectObjects(const struct FWorldConnectivityHandle& ObjectA, const struct FWorldConnectivityHandle& ObjectB)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisconnectObjects");

	Params::WorldConnectivitySubsystem_DisconnectObjects Parms{};

	Parms.ObjectA = std::move(ObjectA);
	Parms.ObjectB = std::move(ObjectB);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetAtomModelAssetUserData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomModelAssetUserData*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomModelAssetUserData* UWorldConnectivitySubsystem::GetAtomModelAssetUserData(class UObject* Object)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAtomModelAssetUserData");

	Params::WorldConnectivitySubsystem_GetAtomModelAssetUserData Parms{};

	Parms.Object = Object;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetClosestFieldToPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FWorldConnectivityHandle         Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConnectionFieldGender                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlanarFieldInfo                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlanarFieldInfo UWorldConnectivitySubsystem::GetClosestFieldToPoint(const struct FWorldConnectivityHandle& Handle, const struct FVector& WorldLocation, EConnectionFieldGender Type, bool* bSuccess)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClosestFieldToPoint");

	Params::WorldConnectivitySubsystem_GetClosestFieldToPoint Parms{};

	Parms.Handle = std::move(Handle);
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetConnectedObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FWorldConnectivityHandle         Object                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FWorldConnectivityHandle> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWorldConnectivityHandle> UWorldConnectivitySubsystem::GetConnectedObjects(const struct FWorldConnectivityHandle& Object)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConnectedObjects");

	Params::WorldConnectivitySubsystem_GetConnectedObjects Parms{};

	Parms.Object = std::move(Object);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetConnectedObjectsRecursively
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FWorldConnectivityHandle         Object                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FWorldConnectivityHandle> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWorldConnectivityHandle> UWorldConnectivitySubsystem::GetConnectedObjectsRecursively(const struct FWorldConnectivityHandle& Object)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConnectedObjectsRecursively");

	Params::WorldConnectivitySubsystem_GetConnectedObjectsRecursively Parms{};

	Parms.Object = std::move(Object);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetOverlapPenetrationDepth
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AStaticMeshActor*                 Actor1                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStaticMeshActor*                 Actor2                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UWorldConnectivitySubsystem::GetOverlapPenetrationDepth(class AStaticMeshActor* Actor1, class AStaticMeshActor* Actor2, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOverlapPenetrationDepth");

	Params::WorldConnectivitySubsystem_GetOverlapPenetrationDepth Parms{};

	Parms.Actor1 = Actor1;
	Parms.Actor2 = Actor2;
	Parms.Offset = std::move(Offset);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetPlanarFieldCenter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPlanarFieldInfo                 Field                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UWorldConnectivitySubsystem::GetPlanarFieldCenter(const struct FPlanarFieldInfo& Field)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlanarFieldCenter");

	Params::WorldConnectivitySubsystem_GetPlanarFieldCenter Parms{};

	Parms.Field = std::move(Field);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetPlanarFields
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FWorldConnectivityHandle         Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EConnectionFieldGender                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPlanarFieldInfo>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPlanarFieldInfo> UWorldConnectivitySubsystem::GetPlanarFields(const struct FWorldConnectivityHandle& Handle, EConnectionFieldGender Type)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlanarFields");

	Params::WorldConnectivitySubsystem_GetPlanarFields Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.RegisterConnectivityActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomModel*                       Model                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::RegisterConnectivityActor(const class AActor* Actor, const class UAtomModel* Model)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegisterConnectivityActor");

	Params::WorldConnectivitySubsystem_RegisterConnectivityActor Parms{};

	Parms.Actor = Actor;
	Parms.Model = Model;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.WorldConnectivitySubsystem.RegisterCustomConnectivityActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSerializedConnectivityObjects   ConnectivityObject                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::RegisterCustomConnectivityActor(const class AActor* Actor, const struct FSerializedConnectivityObjects& ConnectivityObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegisterCustomConnectivityActor");

	Params::WorldConnectivitySubsystem_RegisterCustomConnectivityActor Parms{};

	Parms.Actor = Actor;
	Parms.ConnectivityObject = std::move(ConnectivityObject);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.WorldConnectivitySubsystem.RegisterModelActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSerializedConnectivityObjects   Connections                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::RegisterModelActor(const class AActor* Actor, const struct FSerializedConnectivityObjects& Connections)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegisterModelActor");

	Params::WorldConnectivitySubsystem_RegisterModelActor Parms{};

	Parms.Actor = Actor;
	Parms.Connections = std::move(Connections);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.WorldConnectivitySubsystem.RunPlanarConnectivityQuery
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           AtomModelActorToPlace                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AtomModelActorToConnect                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          QueryStartLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          QueryEndLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       QueryCollisionChannel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QueryRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FConnectivityQueryResult> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FConnectivityQueryResult> UWorldConnectivitySubsystem::RunPlanarConnectivityQuery(const class AActor* AtomModelActorToPlace, const class AActor* AtomModelActorToConnect, const struct FVector& QueryStartLocation, const struct FVector& QueryEndLocation, ECollisionChannel QueryCollisionChannel, int32 QueryRadius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RunPlanarConnectivityQuery");

	Params::WorldConnectivitySubsystem_RunPlanarConnectivityQuery Parms{};

	Parms.AtomModelActorToPlace = AtomModelActorToPlace;
	Parms.AtomModelActorToConnect = AtomModelActorToConnect;
	Parms.QueryStartLocation = std::move(QueryStartLocation);
	Parms.QueryEndLocation = std::move(QueryEndLocation);
	Parms.QueryCollisionChannel = QueryCollisionChannel;
	Parms.QueryRadius = QueryRadius;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.TryConnectObjectAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FWorldConnectivityHandle         ObjectToConnect                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       DesiredObjectTransform                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FWorldConnectivityHandle> ConnectionCandidates                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    PerformConnection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldConnectivitySubsystem::TryConnectObjectAtLocation(const struct FWorldConnectivityHandle& ObjectToConnect, const struct FTransform& DesiredObjectTransform, const TArray<struct FWorldConnectivityHandle>& ConnectionCandidates, bool PerformConnection)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TryConnectObjectAtLocation");

	Params::WorldConnectivitySubsystem_TryConnectObjectAtLocation Parms{};

	Parms.ObjectToConnect = std::move(ObjectToConnect);
	Parms.DesiredObjectTransform = std::move(DesiredObjectTransform);
	Parms.ConnectionCandidates = std::move(ConnectionCandidates);
	Parms.PerformConnection = PerformConnection;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.UnregisterConnectivityActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::UnregisterConnectivityActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnregisterConnectivityActor");

	Params::WorldConnectivitySubsystem_UnregisterConnectivityActor Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWorldConnectivityHandle         Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UWorldConnectivitySubsystem::GetActor(const struct FWorldConnectivityHandle& Handle) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActor");

	Params::WorldConnectivitySubsystem_GetActor Parms{};

	Parms.Handle = std::move(Handle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetConnectivityHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWorldConnectivityHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWorldConnectivityHandle UWorldConnectivitySubsystem::GetConnectivityHandle(const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConnectivityHandle");

	Params::WorldConnectivitySubsystem_GetConnectivityHandle Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetConnectivityHandles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FWorldConnectivityHandle> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWorldConnectivityHandle> UWorldConnectivitySubsystem::GetConnectivityHandles(const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConnectivityHandles");

	Params::WorldConnectivitySubsystem_GetConnectivityHandles Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWorldConnectivityHandle         Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTransform                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FTransform UWorldConnectivitySubsystem::GetTransform(const struct FWorldConnectivityHandle& Handle) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransform");

	Params::WorldConnectivitySubsystem_GetTransform Parms{};

	Parms.Handle = std::move(Handle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.PlanarGridStepSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UWorldConnectivitySubsystem::PlanarGridStepSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlanarGridStepSize");

	Params::WorldConnectivitySubsystem_PlanarGridStepSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivityBlueprintLibrary.GetActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWorldConnectivityHandle         Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UWorldConnectivityBlueprintLibrary::GetActor(class UObject* WorldContext, const struct FWorldConnectivityHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetActor");

	Params::WorldConnectivityBlueprintLibrary_GetActor Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivityBlueprintLibrary.GetFieldCenter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlanarFieldInfo                 Field                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UWorldConnectivityBlueprintLibrary::GetFieldCenter(class UObject* WorldContext, const struct FPlanarFieldInfo& Field)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetFieldCenter");

	Params::WorldConnectivityBlueprintLibrary_GetFieldCenter Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Field = std::move(Field);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivityBlueprintLibrary.GetTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWorldConnectivityHandle         Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UWorldConnectivityBlueprintLibrary::GetTransform(class UObject* WorldContext, const struct FWorldConnectivityHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTransform");

	Params::WorldConnectivityBlueprintLibrary_GetTransform Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivityBlueprintLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FWorldConnectivityHandle         Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldConnectivityBlueprintLibrary::IsValid(const struct FWorldConnectivityHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValid");

	Params::WorldConnectivityBlueprintLibrary_IsValid Parms{};

	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetChildIdentifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InChildIdx                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModel::GetChildIdentifier(int32 InChildIdx)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetChildIdentifier");

	Params::AtomModel_GetChildIdentifier Parms{};

	Parms.InChildIdx = InChildIdx;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetPrimitivesForChildArray
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InChildIdx                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAtomModelPrimitiveInstance>OutPrimitives                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAtomModel::GetPrimitivesForChildArray(int32 InChildIdx, TArray<struct FAtomModelPrimitiveInstance>* OutPrimitives)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPrimitivesForChildArray");

	Params::AtomModel_GetPrimitivesForChildArray Parms{};

	Parms.InChildIdx = InChildIdx;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPrimitives != nullptr)
		*OutPrimitives = std::move(Parms.OutPrimitives);
}


// Function AtomRuntime.AtomModel.GetGeneratedMergedMeshes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TSoftObjectPtr<class UStaticMesh>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UStaticMesh>> UAtomModel::GetGeneratedMergedMeshes() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGeneratedMergedMeshes");

	Params::AtomModel_GetGeneratedMergedMeshes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetModelName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModel::GetModelName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetModelName");

	Params::AtomModel_GetModelName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetModelPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModel::GetModelPath() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetModelPath");

	Params::AtomModel_GetModelPath Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetPartsCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomModel::GetPartsCollection() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPartsCollection");

	Params::AtomModel_GetPartsCollection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetTextureForDecorationTextureName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           TextureName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UAtomModel::GetTextureForDecorationTextureName(const class FString& TextureName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTextureForDecorationTextureName");

	Params::AtomModel_GetTextureForDecorationTextureName Parms{};

	Parms.TextureName = std::move(TextureName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModelProcessor.IncrementProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NumSteps                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomModelProcessor::IncrementProgress(int32 NumSteps, const class FString& Message)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IncrementProgress");

	Params::AtomModelProcessor_IncrementProgress Parms{};

	Parms.NumSteps = NumSteps;
	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AtomRuntime.AtomModelProcessor.OnGetProcessModelTargetAssetPath
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAtomModel*                       Model                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        AtomModelPartsCollection                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModelProcessor::OnGetProcessModelTargetAssetPath(class UAtomModel* Model, const struct FAtomModelPartsCollection& AtomModelPartsCollection)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnGetProcessModelTargetAssetPath");

	Params::AtomModelProcessor_OnGetProcessModelTargetAssetPath Parms{};

	Parms.Model = Model;
	Parms.AtomModelPartsCollection = std::move(AtomModelPartsCollection);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModelProcessor.OnGetProcessPrimitiveTargetAssetPath
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAtomModel*                       Model                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitive*                   Primitive                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        AtomModelPartsCollection                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAtomOnProcessPrimitiveSettings  Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModelProcessor::OnGetProcessPrimitiveTargetAssetPath(class UAtomModel* Model, class UAtomPrimitive* Primitive, const struct FAtomModelPartsCollection& AtomModelPartsCollection, const struct FAtomOnProcessPrimitiveSettings& Settings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnGetProcessPrimitiveTargetAssetPath");

	Params::AtomModelProcessor_OnGetProcessPrimitiveTargetAssetPath Parms{};

	Parms.Model = Model;
	Parms.Primitive = Primitive;
	Parms.AtomModelPartsCollection = std::move(AtomModelPartsCollection);
	Parms.Settings = std::move(Settings);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModelProcessor.OnGetTargetAssetPath
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAtomModel*                       Model                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitive*                   Primitive                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        AtomModelPartsCollection                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModelProcessor::OnGetTargetAssetPath(class UAtomModel* Model, class UAtomPrimitive* Primitive, const struct FAtomModelPartsCollection& AtomModelPartsCollection)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnGetTargetAssetPath");

	Params::AtomModelProcessor_OnGetTargetAssetPath Parms{};

	Parms.Model = Model;
	Parms.Primitive = Primitive;
	Parms.AtomModelPartsCollection = std::move(AtomModelPartsCollection);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModelProcessor.OnProcessModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAtomModel*                       Model                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        AtomModelPartsCollection                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UObject>>   ExistingObjects                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// struct FAtomProcessorResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomProcessorResult UAtomModelProcessor::OnProcessModel(class UAtomModel* Model, const struct FAtomModelPartsCollection& AtomModelPartsCollection, const TArray<TSoftObjectPtr<class UObject>>& ExistingObjects)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnProcessModel");

	Params::AtomModelProcessor_OnProcessModel Parms{};

	Parms.Model = Model;
	Parms.AtomModelPartsCollection = std::move(AtomModelPartsCollection);
	Parms.ExistingObjects = std::move(ExistingObjects);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModelProcessor.OnProcessPrimitive
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAtomModel*                       DummyModel                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitive*                   Primitive                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        AtomModelPartsCollection                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAtomOnProcessPrimitiveSettings  Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAtomProcessorResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomProcessorResult UAtomModelProcessor::OnProcessPrimitive(class UAtomModel* DummyModel, class UAtomPrimitive* Primitive, const struct FAtomModelPartsCollection& AtomModelPartsCollection, const struct FAtomOnProcessPrimitiveSettings& Settings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnProcessPrimitive");

	Params::AtomModelProcessor_OnProcessPrimitive Parms{};

	Parms.DummyModel = DummyModel;
	Parms.Primitive = Primitive;
	Parms.AtomModelPartsCollection = std::move(AtomModelPartsCollection);
	Parms.Settings = std::move(Settings);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.AppendAtomProcessorResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomProcessorResult             Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAtomProcessorResult             ResultToAppend                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAtomProcessorResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomProcessorResult UAtomProcessorBlueprintLibrary::AppendAtomProcessorResult(const struct FAtomProcessorResult& Result, const struct FAtomProcessorResult& ResultToAppend)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AppendAtomProcessorResult");

	Params::AtomProcessorBlueprintLibrary_AppendAtomProcessorResult Parms{};

	Parms.Result = std::move(Result);
	Parms.ResultToAppend = std::move(ResultToAppend);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.GetModelProcessor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelProcessorInstance      ProcessorInstance                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UAtomModelProcessor*        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAtomModelProcessor* UAtomProcessorBlueprintLibrary::GetModelProcessor(const struct FAtomModelProcessorInstance& ProcessorInstance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetModelProcessor");

	Params::AtomProcessorBlueprintLibrary_GetModelProcessor Parms{};

	Parms.ProcessorInstance = std::move(ProcessorInstance);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.GetProcessorClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelProcessorInstance      ProcessorInstance                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UClass*                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UClass* UAtomProcessorBlueprintLibrary::GetProcessorClass(const struct FAtomModelProcessorInstance& ProcessorInstance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProcessorClass");

	Params::AtomProcessorBlueprintLibrary_GetProcessorClass Parms{};

	Parms.ProcessorInstance = std::move(ProcessorInstance);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelProcessorInstance      ProcessorInstance                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtomProcessorBlueprintLibrary::IsValid(const struct FAtomModelProcessorInstance& ProcessorInstance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValid");

	Params::AtomProcessorBlueprintLibrary_IsValid Parms{};

	Parms.ProcessorInstance = std::move(ProcessorInstance);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.SetModelProcessor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelProcessorInstance      ProcessorInstance                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UAtomModelProcessor*              ModelProcessor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCustomSettings                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomProcessorBlueprintLibrary::SetModelProcessor(struct FAtomModelProcessorInstance& ProcessorInstance, class UAtomModelProcessor* ModelProcessor, bool bUseCustomSettings)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetModelProcessor");

	Params::AtomProcessorBlueprintLibrary_SetModelProcessor Parms{};

	Parms.ProcessorInstance = std::move(ProcessorInstance);
	Parms.ModelProcessor = ModelProcessor;
	Parms.bUseCustomSettings = bUseCustomSettings;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	ProcessorInstance = std::move(Parms.ProcessorInstance);
}


// Function AtomRuntime.AtomPrimitive.GetMainGroupName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   MainGroupId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAtomPrimitive::GetMainGroupName(int32 MainGroupId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMainGroupName");

	Params::AtomPrimitive_GetMainGroupName Parms{};

	Parms.MainGroupId = MainGroupId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitive.GetSubMainGroupName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   SubMainGroupId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAtomPrimitive::GetSubMainGroupName(int32 SubMainGroupId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSubMainGroupName");

	Params::AtomPrimitive_GetSubMainGroupName Parms{};

	Parms.SubMainGroupId = SubMainGroupId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitive.GetGeometryContainerForExportStyle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ExportStyleName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FallbackExportStyleName                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometryContainer*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometryContainer* UAtomPrimitive::GetGeometryContainerForExportStyle(const class FString& ExportStyleName, const class FString& FallbackExportStyleName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGeometryContainerForExportStyle");

	Params::AtomPrimitive_GetGeometryContainerForExportStyle Parms{};

	Parms.ExportStyleName = std::move(ExportStyleName);
	Parms.FallbackExportStyleName = std::move(FallbackExportStyleName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitive.IsFlexElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtomPrimitive::IsFlexElement() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsFlexElement");

	Params::AtomPrimitive_IsFlexElement Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

