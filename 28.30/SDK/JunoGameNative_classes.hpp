#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JunoGameNative

#include "Basic.hpp"

#include "DeltaFileSystem_structs.hpp"
#include "DataRegistry_structs.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "CraftingRuntime_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "PlayspaceSystem_classes.hpp"
#include "JunoGameNative_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "ModularGameplay_classes.hpp"
#include "FortniteAI_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "SpatialMetricsCore_classes.hpp"
#include "EnergyRuntime_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "MeshNetwork_classes.hpp"
#include "WorldConditions_classes.hpp"
#include "GameplayEventRouter_structs.hpp"
#include "GameFeatures_classes.hpp"
#include "SoundLibrary_classes.hpp"
#include "GameplayStateMachine_classes.hpp"
#include "GameplayGraph_structs.hpp"
#include "FortGameplayGraph_structs.hpp"
#include "FortImGuiCore_classes.hpp"


namespace SDK
{

// Class JunoGameNative.FortAutomationRpcManager_Juno
// 0x0050 (0x00A8 - 0x0058)
class UFortAutomationRpcManager_Juno final : public UFortAutomationRpcManager
{
public:
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAutomationRpcManager_Juno">();
	}
	static class UFortAutomationRpcManager_Juno* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAutomationRpcManager_Juno>();
	}
};
static_assert(alignof(UFortAutomationRpcManager_Juno) == 0x000008, "Wrong alignment on UFortAutomationRpcManager_Juno");
static_assert(sizeof(UFortAutomationRpcManager_Juno) == 0x0000A8, "Wrong size on UFortAutomationRpcManager_Juno");

// Class JunoGameNative.JunoPassiveCraftingAnalyticsComponent
// 0x0048 (0x00E8 - 0x00A0)
class UJunoPassiveCraftingAnalyticsComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoPassiveCraftingItemAndCount       AccumulatedItem;                                   // 0x00A8(0x0010)(SaveGame, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FJunoPassiveCraftingContributorAnalytics> AccumulatedContributors;                           // 0x00B8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FJunoPassiveCraftingItemAndCount> AccumulatedIngredients;                            // 0x00C8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	class FName                                   Recipe;                                            // 0x00D8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        AccumulatedCraftingTime;                           // 0x00E0(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPassiveCraftingAnalyticsComponent">();
	}
	static class UJunoPassiveCraftingAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPassiveCraftingAnalyticsComponent>();
	}
};
static_assert(alignof(UJunoPassiveCraftingAnalyticsComponent) == 0x000008, "Wrong alignment on UJunoPassiveCraftingAnalyticsComponent");
static_assert(sizeof(UJunoPassiveCraftingAnalyticsComponent) == 0x0000E8, "Wrong size on UJunoPassiveCraftingAnalyticsComponent");
static_assert(offsetof(UJunoPassiveCraftingAnalyticsComponent, AccumulatedItem) == 0x0000A8, "Member 'UJunoPassiveCraftingAnalyticsComponent::AccumulatedItem' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingAnalyticsComponent, AccumulatedContributors) == 0x0000B8, "Member 'UJunoPassiveCraftingAnalyticsComponent::AccumulatedContributors' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingAnalyticsComponent, AccumulatedIngredients) == 0x0000C8, "Member 'UJunoPassiveCraftingAnalyticsComponent::AccumulatedIngredients' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingAnalyticsComponent, Recipe) == 0x0000D8, "Member 'UJunoPassiveCraftingAnalyticsComponent::Recipe' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingAnalyticsComponent, AccumulatedCraftingTime) == 0x0000E0, "Member 'UJunoPassiveCraftingAnalyticsComponent::AccumulatedCraftingTime' has a wrong offset!");

// Class JunoGameNative.FortQueryGenerator_PointsOutsideVolume
// 0x0078 (0x0100 - 0x0088)
class UFortQueryGenerator_PointsOutsideVolume final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              NumberOfRingsAroundVolume;                         // 0x00C0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           GenerateInVolume;                                  // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsOutsideVolume">();
	}
	static class UFortQueryGenerator_PointsOutsideVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsOutsideVolume>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsOutsideVolume) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsOutsideVolume");
static_assert(sizeof(UFortQueryGenerator_PointsOutsideVolume) == 0x000100, "Wrong size on UFortQueryGenerator_PointsOutsideVolume");
static_assert(offsetof(UFortQueryGenerator_PointsOutsideVolume, SpaceBetween) == 0x000088, "Member 'UFortQueryGenerator_PointsOutsideVolume::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOutsideVolume, NumberOfRingsAroundVolume) == 0x0000C0, "Member 'UFortQueryGenerator_PointsOutsideVolume::NumberOfRingsAroundVolume' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOutsideVolume, GenerateInVolume) == 0x0000F8, "Member 'UFortQueryGenerator_PointsOutsideVolume::GenerateInVolume' has a wrong offset!");

// Class JunoGameNative.JunoBuildingTrackedActorInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoBuildingTrackedActorInterface final : public IInterface
{
public:
	float GetNetRelevanceDistanceOverride() const;
	int32 GetNumberOfRelevantActors() const;
	bool ShouldBeTrackedByMetrics() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingTrackedActorInterface">();
	}
	static class IJunoBuildingTrackedActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoBuildingTrackedActorInterface>();
	}
};
static_assert(alignof(IJunoBuildingTrackedActorInterface) == 0x000008, "Wrong alignment on IJunoBuildingTrackedActorInterface");
static_assert(sizeof(IJunoBuildingTrackedActorInterface) == 0x000028, "Wrong size on IJunoBuildingTrackedActorInterface");

// Class JunoGameNative.JunoPickup
// 0x0008 (0x07C0 - 0x07B8)
class AJunoPickup final : public AFortPickupAthena
{
public:
	float                                         MaxDropTossSpeed;                                  // 0x07B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPickup">();
	}
	static class AJunoPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPickup>();
	}
};
static_assert(alignof(AJunoPickup) == 0x000008, "Wrong alignment on AJunoPickup");
static_assert(sizeof(AJunoPickup) == 0x0007C0, "Wrong size on AJunoPickup");
static_assert(offsetof(AJunoPickup, MaxDropTossSpeed) == 0x0007B8, "Member 'AJunoPickup::MaxDropTossSpeed' has a wrong offset!");

// Class JunoGameNative.JunoAbility_PlayerPushPhysicsObject
// 0x0130 (0x0C90 - 0x0B60)
class UJunoAbility_PlayerPushPhysicsObject final : public UFortGameplayAbility
{
public:
	EFortPhysicsSimSize                           MaxPhysicsObjectSizeToPush;                        // 0x0B60(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortPhysicsSimSize                           MinPhysicsObjectSizeToPush;                        // 0x0B61(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B62[0x6];                                      // 0x0B62(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  NoTagsPusher;                                      // 0x0B68(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  NoTagsPushedObject;                                // 0x0B88(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           DefaultPushMontage;                                // 0x0BA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPushMontageData>               SpecializedPushMontages;                           // 0x0BB0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      EnergyComponentQuery;                              // 0x0BC0(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EnergyInitialCost;                                 // 0x0C08(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EnergyDrainPerSecond;                              // 0x0C30(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bEnergyExhausted;                                  // 0x0C58(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C59[0x3];                                      // 0x0C59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UFortComponent_Energy>   CachedEnergyComponent;                             // 0x0C5C(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C64[0xC];                                      // 0x0C64(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  TrackedObjectToPush;                               // 0x0C70(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortPhysicsSimSize                           TrackedObjectSimSize;                              // 0x0C78(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C79[0x17];                                     // 0x0C79(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelPushingPhysicsObject();
	void OnEnergyDrained(class UFortComponent_Energy* EnergyComponentDrained);
	void OnEnergyFullyRecharged(class UFortComponent_Energy* EnergyComponentRecharged);
	void OnPlayerHit(class AActor* HitPlayer, class AActor* HitActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void PotentiallyStartUsingEnergy();
	void StopUsingEnergy();

	class UAnimMontage* GetMontageToPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAbility_PlayerPushPhysicsObject">();
	}
	static class UJunoAbility_PlayerPushPhysicsObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAbility_PlayerPushPhysicsObject>();
	}
};
static_assert(alignof(UJunoAbility_PlayerPushPhysicsObject) == 0x000008, "Wrong alignment on UJunoAbility_PlayerPushPhysicsObject");
static_assert(sizeof(UJunoAbility_PlayerPushPhysicsObject) == 0x000C90, "Wrong size on UJunoAbility_PlayerPushPhysicsObject");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, MaxPhysicsObjectSizeToPush) == 0x000B60, "Member 'UJunoAbility_PlayerPushPhysicsObject::MaxPhysicsObjectSizeToPush' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, MinPhysicsObjectSizeToPush) == 0x000B61, "Member 'UJunoAbility_PlayerPushPhysicsObject::MinPhysicsObjectSizeToPush' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, NoTagsPusher) == 0x000B68, "Member 'UJunoAbility_PlayerPushPhysicsObject::NoTagsPusher' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, NoTagsPushedObject) == 0x000B88, "Member 'UJunoAbility_PlayerPushPhysicsObject::NoTagsPushedObject' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, DefaultPushMontage) == 0x000BA8, "Member 'UJunoAbility_PlayerPushPhysicsObject::DefaultPushMontage' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, SpecializedPushMontages) == 0x000BB0, "Member 'UJunoAbility_PlayerPushPhysicsObject::SpecializedPushMontages' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, EnergyComponentQuery) == 0x000BC0, "Member 'UJunoAbility_PlayerPushPhysicsObject::EnergyComponentQuery' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, EnergyInitialCost) == 0x000C08, "Member 'UJunoAbility_PlayerPushPhysicsObject::EnergyInitialCost' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, EnergyDrainPerSecond) == 0x000C30, "Member 'UJunoAbility_PlayerPushPhysicsObject::EnergyDrainPerSecond' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, bEnergyExhausted) == 0x000C58, "Member 'UJunoAbility_PlayerPushPhysicsObject::bEnergyExhausted' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, CachedEnergyComponent) == 0x000C5C, "Member 'UJunoAbility_PlayerPushPhysicsObject::CachedEnergyComponent' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, TrackedObjectToPush) == 0x000C70, "Member 'UJunoAbility_PlayerPushPhysicsObject::TrackedObjectToPush' has a wrong offset!");
static_assert(offsetof(UJunoAbility_PlayerPushPhysicsObject, TrackedObjectSimSize) == 0x000C78, "Member 'UJunoAbility_PlayerPushPhysicsObject::TrackedObjectSimSize' has a wrong offset!");

// Class JunoGameNative.JunoAccountItemDefinitionOverrideManager
// 0x0168 (0x0190 - 0x0028)
class UJunoAccountItemDefinitionOverrideManager : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHeroType*                          JunoHeroDefinition;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DefaultCharacters;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, TSoftClassPtr<class UClass>> PreviewActorClasses;                               // 0x0040(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, struct FGameplayTagContainer> GameplayTagParentsToRemoveFromOverrides;           // 0x0090(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, struct FGameplayTagContainer> GameplayTagsToAdd;                                 // 0x00E0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FPrimaryAssetId, struct FJunoAccountItemDefinitionOverride> Overrides;                                         // 0x0130(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAccountItemDefinitionOverrideManager">();
	}
	static class UJunoAccountItemDefinitionOverrideManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAccountItemDefinitionOverrideManager>();
	}
};
static_assert(alignof(UJunoAccountItemDefinitionOverrideManager) == 0x000008, "Wrong alignment on UJunoAccountItemDefinitionOverrideManager");
static_assert(sizeof(UJunoAccountItemDefinitionOverrideManager) == 0x000190, "Wrong size on UJunoAccountItemDefinitionOverrideManager");
static_assert(offsetof(UJunoAccountItemDefinitionOverrideManager, JunoHeroDefinition) == 0x000030, "Member 'UJunoAccountItemDefinitionOverrideManager::JunoHeroDefinition' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemDefinitionOverrideManager, DefaultCharacters) == 0x000038, "Member 'UJunoAccountItemDefinitionOverrideManager::DefaultCharacters' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemDefinitionOverrideManager, PreviewActorClasses) == 0x000040, "Member 'UJunoAccountItemDefinitionOverrideManager::PreviewActorClasses' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemDefinitionOverrideManager, GameplayTagParentsToRemoveFromOverrides) == 0x000090, "Member 'UJunoAccountItemDefinitionOverrideManager::GameplayTagParentsToRemoveFromOverrides' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemDefinitionOverrideManager, GameplayTagsToAdd) == 0x0000E0, "Member 'UJunoAccountItemDefinitionOverrideManager::GameplayTagsToAdd' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemDefinitionOverrideManager, Overrides) == 0x000130, "Member 'UJunoAccountItemDefinitionOverrideManager::Overrides' has a wrong offset!");

// Class JunoGameNative.JunoPassiveResourcesGatheringComponent
// 0x00D8 (0x0178 - 0x00A0)
class UJunoPassiveResourcesGatheringComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPassiveResourcesGatheringRowRuntime> ActiveGatheringRows;                               // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class AActor* GeneratingActor, int32 GeneratedItemsCount, bool bIsRuntime)> OnPassiveResourceGeneratedDelegate;                // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      MatchingRolesQuery;                                // 0x0110(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FDataTableRowHandle>            GatheringRows;                                     // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    SimulationConfigurationRow;                        // 0x0168(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	bool OverrideGatheringRow(const struct FDataTableRowHandle& GatheringRow);
	void RemoveGatheringRowOverride();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPassiveResourcesGatheringComponent">();
	}
	static class UJunoPassiveResourcesGatheringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPassiveResourcesGatheringComponent>();
	}
};
static_assert(alignof(UJunoPassiveResourcesGatheringComponent) == 0x000008, "Wrong alignment on UJunoPassiveResourcesGatheringComponent");
static_assert(sizeof(UJunoPassiveResourcesGatheringComponent) == 0x000178, "Wrong size on UJunoPassiveResourcesGatheringComponent");
static_assert(offsetof(UJunoPassiveResourcesGatheringComponent, ActiveGatheringRows) == 0x0000C8, "Member 'UJunoPassiveResourcesGatheringComponent::ActiveGatheringRows' has a wrong offset!");
static_assert(offsetof(UJunoPassiveResourcesGatheringComponent, OnPassiveResourceGeneratedDelegate) == 0x0000D8, "Member 'UJunoPassiveResourcesGatheringComponent::OnPassiveResourceGeneratedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoPassiveResourcesGatheringComponent, MatchingRolesQuery) == 0x000110, "Member 'UJunoPassiveResourcesGatheringComponent::MatchingRolesQuery' has a wrong offset!");
static_assert(offsetof(UJunoPassiveResourcesGatheringComponent, GatheringRows) == 0x000158, "Member 'UJunoPassiveResourcesGatheringComponent::GatheringRows' has a wrong offset!");
static_assert(offsetof(UJunoPassiveResourcesGatheringComponent, SimulationConfigurationRow) == 0x000168, "Member 'UJunoPassiveResourcesGatheringComponent::SimulationConfigurationRow' has a wrong offset!");

// Class JunoGameNative.JunoAccountItemOverrideDefinition
// 0x0078 (0x00A8 - 0x0030)
class UJunoAccountItemOverrideDefinition : public UPrimaryDataAsset
{
public:
	struct FGameplayTagContainer                  GameplayTagsToAdd;                                 // 0x0030(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideFrontendTransform;                        // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrontendPreviewScale;                              // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FrontendPreviewPivotOffset;                        // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FrontendPreviewInitialRotation;                    // 0x0070(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PreviewActorClass;                                 // 0x0088(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAccountItemOverrideDefinition">();
	}
	static class UJunoAccountItemOverrideDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAccountItemOverrideDefinition>();
	}
};
static_assert(alignof(UJunoAccountItemOverrideDefinition) == 0x000008, "Wrong alignment on UJunoAccountItemOverrideDefinition");
static_assert(sizeof(UJunoAccountItemOverrideDefinition) == 0x0000A8, "Wrong size on UJunoAccountItemOverrideDefinition");
static_assert(offsetof(UJunoAccountItemOverrideDefinition, GameplayTagsToAdd) == 0x000030, "Member 'UJunoAccountItemOverrideDefinition::GameplayTagsToAdd' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemOverrideDefinition, bOverrideFrontendTransform) == 0x000050, "Member 'UJunoAccountItemOverrideDefinition::bOverrideFrontendTransform' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemOverrideDefinition, FrontendPreviewScale) == 0x000054, "Member 'UJunoAccountItemOverrideDefinition::FrontendPreviewScale' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemOverrideDefinition, FrontendPreviewPivotOffset) == 0x000058, "Member 'UJunoAccountItemOverrideDefinition::FrontendPreviewPivotOffset' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemOverrideDefinition, FrontendPreviewInitialRotation) == 0x000070, "Member 'UJunoAccountItemOverrideDefinition::FrontendPreviewInitialRotation' has a wrong offset!");
static_assert(offsetof(UJunoAccountItemOverrideDefinition, PreviewActorClass) == 0x000088, "Member 'UJunoAccountItemOverrideDefinition::PreviewActorClass' has a wrong offset!");

// Class JunoGameNative.JunoAthenaCharacterItemOverrideDefinition
// 0x0088 (0x0130 - 0x00A8)
class UJunoAthenaCharacterItemOverrideDefinition final : public UJunoAccountItemOverrideDefinition
{
public:
	TSoftObjectPtr<class UAthenaCharacterItemDefinition> BaseAthenaCharacterItemDefinition;                 // 0x00A8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAssembledMeshSchema>    AssembledMeshSchema;                               // 0x00C8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAssembledMeshSchema>    LowDetailsAssembledMeshSchema;                     // 0x00E8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            FrontendAnimMontageIdleOverride;                   // 0x0108(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviewPawnScale;                                  // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseAthenaCharacterItemDefinition(TSoftObjectPtr<class UAthenaCharacterItemDefinition> InBaseAthenaCharacterItemDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAthenaCharacterItemOverrideDefinition">();
	}
	static class UJunoAthenaCharacterItemOverrideDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAthenaCharacterItemOverrideDefinition>();
	}
};
static_assert(alignof(UJunoAthenaCharacterItemOverrideDefinition) == 0x000008, "Wrong alignment on UJunoAthenaCharacterItemOverrideDefinition");
static_assert(sizeof(UJunoAthenaCharacterItemOverrideDefinition) == 0x000130, "Wrong size on UJunoAthenaCharacterItemOverrideDefinition");
static_assert(offsetof(UJunoAthenaCharacterItemOverrideDefinition, BaseAthenaCharacterItemDefinition) == 0x0000A8, "Member 'UJunoAthenaCharacterItemOverrideDefinition::BaseAthenaCharacterItemDefinition' has a wrong offset!");
static_assert(offsetof(UJunoAthenaCharacterItemOverrideDefinition, AssembledMeshSchema) == 0x0000C8, "Member 'UJunoAthenaCharacterItemOverrideDefinition::AssembledMeshSchema' has a wrong offset!");
static_assert(offsetof(UJunoAthenaCharacterItemOverrideDefinition, LowDetailsAssembledMeshSchema) == 0x0000E8, "Member 'UJunoAthenaCharacterItemOverrideDefinition::LowDetailsAssembledMeshSchema' has a wrong offset!");
static_assert(offsetof(UJunoAthenaCharacterItemOverrideDefinition, FrontendAnimMontageIdleOverride) == 0x000108, "Member 'UJunoAthenaCharacterItemOverrideDefinition::FrontendAnimMontageIdleOverride' has a wrong offset!");
static_assert(offsetof(UJunoAthenaCharacterItemOverrideDefinition, PreviewPawnScale) == 0x000128, "Member 'UJunoAthenaCharacterItemOverrideDefinition::PreviewPawnScale' has a wrong offset!");

// Class JunoGameNative.JunoMutator_AutoPickup
// 0x0020 (0x0358 - 0x0338)
class AJunoMutator_AutoPickup final : public AFortAthenaMutator
{
public:
	struct FGameplayTagContainer                  DoNotAutoPickupGameplayTags;                       // 0x0338(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMutator_AutoPickup">();
	}
	static class AJunoMutator_AutoPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoMutator_AutoPickup>();
	}
};
static_assert(alignof(AJunoMutator_AutoPickup) == 0x000008, "Wrong alignment on AJunoMutator_AutoPickup");
static_assert(sizeof(AJunoMutator_AutoPickup) == 0x000358, "Wrong size on AJunoMutator_AutoPickup");
static_assert(offsetof(AJunoMutator_AutoPickup, DoNotAutoPickupGameplayTags) == 0x000338, "Member 'AJunoMutator_AutoPickup::DoNotAutoPickupGameplayTags' has a wrong offset!");

// Class JunoGameNative.JunoAthenaDanceItemOverrideDefinition
// 0x00E8 (0x0190 - 0x00A8)
class UJunoAthenaDanceItemOverrideDefinition final : public UJunoAccountItemOverrideDefinition
{
public:
	TSoftObjectPtr<class UAthenaDanceItemDefinition> BaseAthenaDanceItemDefinition;                     // 0x00A8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            Animation;                                         // 0x00C8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            AnimationFemaleOverride;                           // 0x00E8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortEmoteMapping>              AnimationOverrides;                                // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            FrontEndAnimation;                                 // 0x0118(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            FrontEndAnimationFemaleOverride;                   // 0x0138(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortEmoteMapping>              FrontEndAnimationOverrides;                        // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                GroupEmotePositionOffset;                          // 0x0168(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroupEmotePositionOffsetTolerance;                 // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroupEmoteFollowDistance;                          // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkForwardSpeed;                                  // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseAthenaDanceItemDefinition(TSoftObjectPtr<class UAthenaDanceItemDefinition> InBaseAthenaDanceItemDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAthenaDanceItemOverrideDefinition">();
	}
	static class UJunoAthenaDanceItemOverrideDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAthenaDanceItemOverrideDefinition>();
	}
};
static_assert(alignof(UJunoAthenaDanceItemOverrideDefinition) == 0x000008, "Wrong alignment on UJunoAthenaDanceItemOverrideDefinition");
static_assert(sizeof(UJunoAthenaDanceItemOverrideDefinition) == 0x000190, "Wrong size on UJunoAthenaDanceItemOverrideDefinition");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, BaseAthenaDanceItemDefinition) == 0x0000A8, "Member 'UJunoAthenaDanceItemOverrideDefinition::BaseAthenaDanceItemDefinition' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, Animation) == 0x0000C8, "Member 'UJunoAthenaDanceItemOverrideDefinition::Animation' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, AnimationFemaleOverride) == 0x0000E8, "Member 'UJunoAthenaDanceItemOverrideDefinition::AnimationFemaleOverride' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, AnimationOverrides) == 0x000108, "Member 'UJunoAthenaDanceItemOverrideDefinition::AnimationOverrides' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, FrontEndAnimation) == 0x000118, "Member 'UJunoAthenaDanceItemOverrideDefinition::FrontEndAnimation' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, FrontEndAnimationFemaleOverride) == 0x000138, "Member 'UJunoAthenaDanceItemOverrideDefinition::FrontEndAnimationFemaleOverride' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, FrontEndAnimationOverrides) == 0x000158, "Member 'UJunoAthenaDanceItemOverrideDefinition::FrontEndAnimationOverrides' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, GroupEmotePositionOffset) == 0x000168, "Member 'UJunoAthenaDanceItemOverrideDefinition::GroupEmotePositionOffset' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, GroupEmotePositionOffsetTolerance) == 0x000180, "Member 'UJunoAthenaDanceItemOverrideDefinition::GroupEmotePositionOffsetTolerance' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, GroupEmoteFollowDistance) == 0x000184, "Member 'UJunoAthenaDanceItemOverrideDefinition::GroupEmoteFollowDistance' has a wrong offset!");
static_assert(offsetof(UJunoAthenaDanceItemOverrideDefinition, WalkForwardSpeed) == 0x000188, "Member 'UJunoAthenaDanceItemOverrideDefinition::WalkForwardSpeed' has a wrong offset!");

// Class JunoGameNative.JunoActionConfig
// 0x0010 (0x0038 - 0x0028)
class UJunoActionConfig : public UObject
{
public:
	TSubclassOf<class UJunoAction>                JunoActionClass;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJunoActionExecutionConfig                    JunoActionExecutionConfig;                         // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoActionConfig">();
	}
	static class UJunoActionConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoActionConfig>();
	}
};
static_assert(alignof(UJunoActionConfig) == 0x000008, "Wrong alignment on UJunoActionConfig");
static_assert(sizeof(UJunoActionConfig) == 0x000038, "Wrong size on UJunoActionConfig");
static_assert(offsetof(UJunoActionConfig, JunoActionClass) == 0x000028, "Member 'UJunoActionConfig::JunoActionClass' has a wrong offset!");
static_assert(offsetof(UJunoActionConfig, JunoActionExecutionConfig) == 0x000030, "Member 'UJunoActionConfig::JunoActionExecutionConfig' has a wrong offset!");

// Class JunoGameNative.JunoPersistenceReportGenerator
// 0x0020 (0x0048 - 0x0028)
class UJunoPersistenceReportGenerator final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPersistenceReportGenerator">();
	}
	static class UJunoPersistenceReportGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPersistenceReportGenerator>();
	}
};
static_assert(alignof(UJunoPersistenceReportGenerator) == 0x000008, "Wrong alignment on UJunoPersistenceReportGenerator");
static_assert(sizeof(UJunoPersistenceReportGenerator) == 0x000048, "Wrong size on UJunoPersistenceReportGenerator");

// Class JunoGameNative.JunoActionConfig_StaticMesh
// 0x0008 (0x0040 - 0x0038)
class UJunoActionConfig_StaticMesh final : public UJunoActionConfig
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoActionConfig_StaticMesh">();
	}
	static class UJunoActionConfig_StaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoActionConfig_StaticMesh>();
	}
};
static_assert(alignof(UJunoActionConfig_StaticMesh) == 0x000008, "Wrong alignment on UJunoActionConfig_StaticMesh");
static_assert(sizeof(UJunoActionConfig_StaticMesh) == 0x000040, "Wrong size on UJunoActionConfig_StaticMesh");
static_assert(offsetof(UJunoActionConfig_StaticMesh, StaticMesh) == 0x000038, "Member 'UJunoActionConfig_StaticMesh::StaticMesh' has a wrong offset!");

// Class JunoGameNative.JunoActorAttributeOverrideComponent
// 0x0018 (0x00B8 - 0x00A0)
class UJunoActorAttributeOverrideComponent final : public UFortBuildingActorTagComponent
{
public:
	struct FDataRegistryType                      AttributeOverrideDataRegistry;                     // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataRegistryId                        DataRegistryItemId;                                // 0x00A4(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0xC];                                       // 0x00AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetPrimaryLootTier();
	class FName GetSecondaryLootTier();
	void SetupHealthAttributeSet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoActorAttributeOverrideComponent">();
	}
	static class UJunoActorAttributeOverrideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoActorAttributeOverrideComponent>();
	}
};
static_assert(alignof(UJunoActorAttributeOverrideComponent) == 0x000008, "Wrong alignment on UJunoActorAttributeOverrideComponent");
static_assert(sizeof(UJunoActorAttributeOverrideComponent) == 0x0000B8, "Wrong size on UJunoActorAttributeOverrideComponent");
static_assert(offsetof(UJunoActorAttributeOverrideComponent, AttributeOverrideDataRegistry) == 0x0000A0, "Member 'UJunoActorAttributeOverrideComponent::AttributeOverrideDataRegistry' has a wrong offset!");
static_assert(offsetof(UJunoActorAttributeOverrideComponent, DataRegistryItemId) == 0x0000A4, "Member 'UJunoActorAttributeOverrideComponent::DataRegistryItemId' has a wrong offset!");

// Class JunoGameNative.JunoPersistenceFeatureDataActor
// 0x0040 (0x02D0 - 0x0290)
class AJunoPersistenceFeatureDataActor : public AInfo
{
public:
	uint8                                         Pad_290[0x28];                                     // 0x0290(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SavedActorGuid;                                    // 0x02B8(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Version;                                           // 0x02C8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnedByLevelSaveRecord;                         // 0x02CC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceDirty;                                       // 0x02CD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDirty;                                            // 0x02CE(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CF[0x1];                                      // 0x02CF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPersistentDataModified();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPersistenceFeatureDataActor">();
	}
	static class AJunoPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoPersistenceFeatureDataActor");
static_assert(sizeof(AJunoPersistenceFeatureDataActor) == 0x0002D0, "Wrong size on AJunoPersistenceFeatureDataActor");
static_assert(offsetof(AJunoPersistenceFeatureDataActor, SavedActorGuid) == 0x0002B8, "Member 'AJunoPersistenceFeatureDataActor::SavedActorGuid' has a wrong offset!");
static_assert(offsetof(AJunoPersistenceFeatureDataActor, Version) == 0x0002C8, "Member 'AJunoPersistenceFeatureDataActor::Version' has a wrong offset!");
static_assert(offsetof(AJunoPersistenceFeatureDataActor, bSpawnedByLevelSaveRecord) == 0x0002CC, "Member 'AJunoPersistenceFeatureDataActor::bSpawnedByLevelSaveRecord' has a wrong offset!");
static_assert(offsetof(AJunoPersistenceFeatureDataActor, bForceDirty) == 0x0002CD, "Member 'AJunoPersistenceFeatureDataActor::bForceDirty' has a wrong offset!");
static_assert(offsetof(AJunoPersistenceFeatureDataActor, bDirty) == 0x0002CE, "Member 'AJunoPersistenceFeatureDataActor::bDirty' has a wrong offset!");

// Class JunoGameNative.JunoPlayspaceAccountantFeatureDataActor
// 0x0058 (0x0328 - 0x02D0)
class AJunoPlayspaceAccountantFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      PersistentValueTable;                              // 0x02D8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceAccountantFeatureDataActor">();
	}
	static class AJunoPlayspaceAccountantFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPlayspaceAccountantFeatureDataActor>();
	}
};
static_assert(alignof(AJunoPlayspaceAccountantFeatureDataActor) == 0x000008, "Wrong alignment on AJunoPlayspaceAccountantFeatureDataActor");
static_assert(sizeof(AJunoPlayspaceAccountantFeatureDataActor) == 0x000328, "Wrong size on AJunoPlayspaceAccountantFeatureDataActor");
static_assert(offsetof(AJunoPlayspaceAccountantFeatureDataActor, PersistentValueTable) == 0x0002D8, "Member 'AJunoPlayspaceAccountantFeatureDataActor::PersistentValueTable' has a wrong offset!");

// Class JunoGameNative.JunoActorInstancesReportHandler
// 0x0028 (0x0050 - 0x0028)
class UJunoActorInstancesReportHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoActorInstancesReportHandler">();
	}
	static class UJunoActorInstancesReportHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoActorInstancesReportHandler>();
	}
};
static_assert(alignof(UJunoActorInstancesReportHandler) == 0x000008, "Wrong alignment on UJunoActorInstancesReportHandler");
static_assert(sizeof(UJunoActorInstancesReportHandler) == 0x000050, "Wrong size on UJunoActorInstancesReportHandler");

// Class JunoGameNative.JunoPlayerCampPawnComponent
// 0x0070 (0x0110 - 0x00A0)
class UJunoPlayerCampPawnComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x70];                                      // 0x00A0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAwesomeLevelChanged(const struct FJunoAwesomeLevelChangeData& ChangeData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerCampPawnComponent">();
	}
	static class UJunoPlayerCampPawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerCampPawnComponent>();
	}
};
static_assert(alignof(UJunoPlayerCampPawnComponent) == 0x000008, "Wrong alignment on UJunoPlayerCampPawnComponent");
static_assert(sizeof(UJunoPlayerCampPawnComponent) == 0x000110, "Wrong size on UJunoPlayerCampPawnComponent");

// Class JunoGameNative.JunoAIPersistenceFeatureDataActor
// 0x0130 (0x0400 - 0x02D0)
class AJunoAIPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedAIDataManager                    SavedAIData;                                       // 0x02E0(0x0120)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIPersistenceFeatureDataActor">();
	}
	static class AJunoAIPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoAIPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoAIPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoAIPersistenceFeatureDataActor");
static_assert(sizeof(AJunoAIPersistenceFeatureDataActor) == 0x000400, "Wrong size on AJunoAIPersistenceFeatureDataActor");
static_assert(offsetof(AJunoAIPersistenceFeatureDataActor, SavedAIData) == 0x0002E0, "Member 'AJunoAIPersistenceFeatureDataActor::SavedAIData' has a wrong offset!");

// Class JunoGameNative.JunoAIPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoAIPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIPersistenceFeatureDataInterface">();
	}
	static class IJunoAIPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoAIPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoAIPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoAIPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoAIPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoAIPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoPersistenceFeatureData
// 0x0000 (0x0028 - 0x0028)
class IJunoPersistenceFeatureData final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPersistenceFeatureData">();
	}
	static class IJunoPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoPersistenceFeatureData>();
	}
};
static_assert(alignof(IJunoPersistenceFeatureData) == 0x000008, "Wrong alignment on IJunoPersistenceFeatureData");
static_assert(sizeof(IJunoPersistenceFeatureData) == 0x000028, "Wrong size on IJunoPersistenceFeatureData");

// Class JunoGameNative.JunoAIPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoAIPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIPersistenceFeatureModule">();
	}
	static class UJunoAIPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoAIPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoAIPersistenceFeatureModule");
static_assert(sizeof(UJunoAIPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoAIPersistenceFeatureModule");

// Class JunoGameNative.JunoBasePFWContainer
// 0x00A0 (0x01E0 - 0x0140)
class UJunoBasePFWContainer : public UPersistenceFrameworkContainer
{
public:
	uint8                                         Pad_140[0xA0];                                     // 0x0140(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBasePFWContainer">();
	}
	static class UJunoBasePFWContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBasePFWContainer>();
	}
};
static_assert(alignof(UJunoBasePFWContainer) == 0x000008, "Wrong alignment on UJunoBasePFWContainer");
static_assert(sizeof(UJunoBasePFWContainer) == 0x0001E0, "Wrong size on UJunoBasePFWContainer");

// Class JunoGameNative.JunoPlayerSaveData_Container
// 0x0068 (0x0248 - 0x01E0)
class UJunoPlayerSaveData_Container final : public UJunoBasePFWContainer
{
public:
	struct FPersistenceFrameworkPlayerInfo        PlayerInfo;                                        // 0x01E0(0x0020)(NativeAccessSpecifierPrivate)
	struct FUniqueNetIdRepl                       PlayerNetId;                                       // 0x0200(0x0030)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerSaveData_Container">();
	}
	static class UJunoPlayerSaveData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerSaveData_Container>();
	}
};
static_assert(alignof(UJunoPlayerSaveData_Container) == 0x000008, "Wrong alignment on UJunoPlayerSaveData_Container");
static_assert(sizeof(UJunoPlayerSaveData_Container) == 0x000248, "Wrong size on UJunoPlayerSaveData_Container");
static_assert(offsetof(UJunoPlayerSaveData_Container, PlayerInfo) == 0x0001E0, "Member 'UJunoPlayerSaveData_Container::PlayerInfo' has a wrong offset!");
static_assert(offsetof(UJunoPlayerSaveData_Container, PlayerNetId) == 0x000200, "Member 'UJunoPlayerSaveData_Container::PlayerNetId' has a wrong offset!");

// Class JunoGameNative.JunoBasePFWPersistenceFeatureDataContainer
// 0x0000 (0x01E0 - 0x01E0)
class UJunoBasePFWPersistenceFeatureDataContainer : public UJunoBasePFWContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBasePFWPersistenceFeatureDataContainer">();
	}
	static class UJunoBasePFWPersistenceFeatureDataContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBasePFWPersistenceFeatureDataContainer>();
	}
};
static_assert(alignof(UJunoBasePFWPersistenceFeatureDataContainer) == 0x000008, "Wrong alignment on UJunoBasePFWPersistenceFeatureDataContainer");
static_assert(sizeof(UJunoBasePFWPersistenceFeatureDataContainer) == 0x0001E0, "Wrong size on UJunoBasePFWPersistenceFeatureDataContainer");

// Class JunoGameNative.JunoAIPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoAIPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIPersistenceFeatureData_Container">();
	}
	static class UJunoAIPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoAIPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoAIPersistenceFeatureData_Container");
static_assert(sizeof(UJunoAIPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoAIPersistenceFeatureData_Container");

// Class JunoGameNative.JunoQueryContext_Camp_Extents
// 0x0000 (0x0028 - 0x0028)
class UJunoQueryContext_Camp_Extents final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoQueryContext_Camp_Extents">();
	}
	static class UJunoQueryContext_Camp_Extents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoQueryContext_Camp_Extents>();
	}
};
static_assert(alignof(UJunoQueryContext_Camp_Extents) == 0x000008, "Wrong alignment on UJunoQueryContext_Camp_Extents");
static_assert(sizeof(UJunoQueryContext_Camp_Extents) == 0x000028, "Wrong size on UJunoQueryContext_Camp_Extents");

// Class JunoGameNative.JunoAlterationCraftingComponent
// 0x0010 (0x00B0 - 0x00A0)
class UJunoAlterationCraftingComponent final : public UGameFrameworkComponent
{
public:
	TWeakObjectPtr<class UCraftingObjectComponent> CachedCraftingObjectComponent;                     // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataRegistryType                      WeaponEssenceDataRegistryType;                     // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCraftingStateChanged(const struct FCraftingObjectStateChangedEvent& Event);
	bool OnCheckValidItemType(class AFortPlayerController* Instigator);
	void OnCraftingSuccess(const struct FCraftingObjectSuccessEvent& Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAlterationCraftingComponent">();
	}
	static class UJunoAlterationCraftingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAlterationCraftingComponent>();
	}
};
static_assert(alignof(UJunoAlterationCraftingComponent) == 0x000008, "Wrong alignment on UJunoAlterationCraftingComponent");
static_assert(sizeof(UJunoAlterationCraftingComponent) == 0x0000B0, "Wrong size on UJunoAlterationCraftingComponent");
static_assert(offsetof(UJunoAlterationCraftingComponent, CachedCraftingObjectComponent) == 0x0000A0, "Member 'UJunoAlterationCraftingComponent::CachedCraftingObjectComponent' has a wrong offset!");
static_assert(offsetof(UJunoAlterationCraftingComponent, WeaponEssenceDataRegistryType) == 0x0000A8, "Member 'UJunoAlterationCraftingComponent::WeaponEssenceDataRegistryType' has a wrong offset!");

// Class JunoGameNative.JunoAnalytics
// 0x0000 (0x0028 - 0x0028)
class UJunoAnalytics final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAnalytics">();
	}
	static class UJunoAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAnalytics>();
	}
};
static_assert(alignof(UJunoAnalytics) == 0x000008, "Wrong alignment on UJunoAnalytics");
static_assert(sizeof(UJunoAnalytics) == 0x000028, "Wrong size on UJunoAnalytics");

// Class JunoGameNative.JunoPlayspaceAccountantPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoPlayspaceAccountantPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceAccountantPersistenceFeatureData_Container">();
	}
	static class UJunoPlayspaceAccountantPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceAccountantPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoPlayspaceAccountantPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoPlayspaceAccountantPersistenceFeatureData_Container");
static_assert(sizeof(UJunoPlayspaceAccountantPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoPlayspaceAccountantPersistenceFeatureData_Container");

// Class JunoGameNative.JunoAnimNotifyState_QueueInput
// 0x0068 (0x0098 - 0x0030)
class UJunoAnimNotifyState_QueueInput final : public UAnimNotifyState
{
public:
	bool                                          bQueueMantisInput;                                 // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayEventTagsToQueue;                          // 0x0038(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTagsToRemove;                               // 0x0058(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTagsToAdd;                                  // 0x0078(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAnimNotifyState_QueueInput">();
	}
	static class UJunoAnimNotifyState_QueueInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAnimNotifyState_QueueInput>();
	}
};
static_assert(alignof(UJunoAnimNotifyState_QueueInput) == 0x000008, "Wrong alignment on UJunoAnimNotifyState_QueueInput");
static_assert(sizeof(UJunoAnimNotifyState_QueueInput) == 0x000098, "Wrong size on UJunoAnimNotifyState_QueueInput");
static_assert(offsetof(UJunoAnimNotifyState_QueueInput, bQueueMantisInput) == 0x000030, "Member 'UJunoAnimNotifyState_QueueInput::bQueueMantisInput' has a wrong offset!");
static_assert(offsetof(UJunoAnimNotifyState_QueueInput, GameplayEventTagsToQueue) == 0x000038, "Member 'UJunoAnimNotifyState_QueueInput::GameplayEventTagsToQueue' has a wrong offset!");
static_assert(offsetof(UJunoAnimNotifyState_QueueInput, AbilityTagsToRemove) == 0x000058, "Member 'UJunoAnimNotifyState_QueueInput::AbilityTagsToRemove' has a wrong offset!");
static_assert(offsetof(UJunoAnimNotifyState_QueueInput, AbilityTagsToAdd) == 0x000078, "Member 'UJunoAnimNotifyState_QueueInput::AbilityTagsToAdd' has a wrong offset!");

// Class JunoGameNative.JunoAnimNotifyState_MakeInterruptible
// 0x0040 (0x0070 - 0x0030)
class UJunoAnimNotifyState_MakeInterruptible final : public UAnimNotifyState
{
public:
	struct FGameplayTagContainer                  AbilityTagsToRemove;                               // 0x0030(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTagsToAdd;                                  // 0x0050(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAnimNotifyState_MakeInterruptible">();
	}
	static class UJunoAnimNotifyState_MakeInterruptible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAnimNotifyState_MakeInterruptible>();
	}
};
static_assert(alignof(UJunoAnimNotifyState_MakeInterruptible) == 0x000008, "Wrong alignment on UJunoAnimNotifyState_MakeInterruptible");
static_assert(sizeof(UJunoAnimNotifyState_MakeInterruptible) == 0x000070, "Wrong size on UJunoAnimNotifyState_MakeInterruptible");
static_assert(offsetof(UJunoAnimNotifyState_MakeInterruptible, AbilityTagsToRemove) == 0x000030, "Member 'UJunoAnimNotifyState_MakeInterruptible::AbilityTagsToRemove' has a wrong offset!");
static_assert(offsetof(UJunoAnimNotifyState_MakeInterruptible, AbilityTagsToAdd) == 0x000050, "Member 'UJunoAnimNotifyState_MakeInterruptible::AbilityTagsToAdd' has a wrong offset!");

// Class JunoGameNative.JunoPlayerSaveDataProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoPlayerSaveDataProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerSaveDataProviderInterface">();
	}
	static class IJunoPlayerSaveDataProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoPlayerSaveDataProviderInterface>();
	}
};
static_assert(alignof(IJunoPlayerSaveDataProviderInterface) == 0x000008, "Wrong alignment on IJunoPlayerSaveDataProviderInterface");
static_assert(sizeof(IJunoPlayerSaveDataProviderInterface) == 0x000028, "Wrong size on IJunoPlayerSaveDataProviderInterface");

// Class JunoGameNative.JunoAsyncAction_WaitForEventRouter
// 0x0030 (0x0060 - 0x0030)
class UJunoAsyncAction_WaitForEventRouter final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(class UGameplayEventRouterComponent* EventRouter)> OnGameplayEventRouterAvailable;                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJunoAsyncAction_WaitForEventRouter* WaitForEventRouter(class AActor* ContextActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAsyncAction_WaitForEventRouter">();
	}
	static class UJunoAsyncAction_WaitForEventRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAsyncAction_WaitForEventRouter>();
	}
};
static_assert(alignof(UJunoAsyncAction_WaitForEventRouter) == 0x000008, "Wrong alignment on UJunoAsyncAction_WaitForEventRouter");
static_assert(sizeof(UJunoAsyncAction_WaitForEventRouter) == 0x000060, "Wrong size on UJunoAsyncAction_WaitForEventRouter");
static_assert(offsetof(UJunoAsyncAction_WaitForEventRouter, OnGameplayEventRouterAvailable) == 0x000030, "Member 'UJunoAsyncAction_WaitForEventRouter::OnGameplayEventRouterAvailable' has a wrong offset!");

// Class JunoGameNative.JunoBuilderToolSelectedActorInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoBuilderToolSelectedActorInterface final : public IInterface
{
public:
	void ReceiveSelectionSpawnedByBuilderTool(class AJunoBuilderTool* BuilderTool, class UJunoBuilderToolInteractionBehavior* Behavior, const struct FJunoBuilderToolSelectionSpawnParams& SelectionSpawnParameters);
	void ReceiveSpawnedByBuilderTool(class AJunoBuilderTool* BuilderTool, class UJunoBuilderToolInteractionBehavior* Behavior);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuilderToolSelectedActorInterface">();
	}
	static class IJunoBuilderToolSelectedActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoBuilderToolSelectedActorInterface>();
	}
};
static_assert(alignof(IJunoBuilderToolSelectedActorInterface) == 0x000008, "Wrong alignment on IJunoBuilderToolSelectedActorInterface");
static_assert(sizeof(IJunoBuilderToolSelectedActorInterface) == 0x000028, "Wrong size on IJunoBuilderToolSelectedActorInterface");

// Class JunoGameNative.JunoAdventureGameplayVolume
// 0x0040 (0x0370 - 0x0330)
class AJunoAdventureGameplayVolume final : public AGameplayVolume
{
public:
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldPersist;                                    // 0x0338(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyLinkedPlayspaceOnEndPlay;                  // 0x0339(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33A[0x1E];                                     // 0x033A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SavedActorGuid;                                    // 0x0358(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAdventureGameplayVolume">();
	}
	static class AJunoAdventureGameplayVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoAdventureGameplayVolume>();
	}
};
static_assert(alignof(AJunoAdventureGameplayVolume) == 0x000008, "Wrong alignment on AJunoAdventureGameplayVolume");
static_assert(sizeof(AJunoAdventureGameplayVolume) == 0x000370, "Wrong size on AJunoAdventureGameplayVolume");
static_assert(offsetof(AJunoAdventureGameplayVolume, bShouldPersist) == 0x000338, "Member 'AJunoAdventureGameplayVolume::bShouldPersist' has a wrong offset!");
static_assert(offsetof(AJunoAdventureGameplayVolume, bDestroyLinkedPlayspaceOnEndPlay) == 0x000339, "Member 'AJunoAdventureGameplayVolume::bDestroyLinkedPlayspaceOnEndPlay' has a wrong offset!");
static_assert(offsetof(AJunoAdventureGameplayVolume, SavedActorGuid) == 0x000358, "Member 'AJunoAdventureGameplayVolume::SavedActorGuid' has a wrong offset!");

// Class JunoGameNative.JunoBuildingAccountItemDefBase
// 0x0030 (0x0770 - 0x0740)
class UJunoBuildingAccountItemDefBase : public UAthenaCosmeticItemDefinition
{
public:
	uint8                                         Pad_740[0x8];                                      // 0x0740(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BuildingActorClassToPreview;                       // 0x0748(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JunoBuildingFrontendPreviewScale;                  // 0x0768(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_76C[0x4];                                      // 0x076C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingAccountItemDefBase">();
	}
	static class UJunoBuildingAccountItemDefBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingAccountItemDefBase>();
	}
};
static_assert(alignof(UJunoBuildingAccountItemDefBase) == 0x000008, "Wrong alignment on UJunoBuildingAccountItemDefBase");
static_assert(sizeof(UJunoBuildingAccountItemDefBase) == 0x000770, "Wrong size on UJunoBuildingAccountItemDefBase");
static_assert(offsetof(UJunoBuildingAccountItemDefBase, BuildingActorClassToPreview) == 0x000748, "Member 'UJunoBuildingAccountItemDefBase::BuildingActorClassToPreview' has a wrong offset!");
static_assert(offsetof(UJunoBuildingAccountItemDefBase, JunoBuildingFrontendPreviewScale) == 0x000768, "Member 'UJunoBuildingAccountItemDefBase::JunoBuildingFrontendPreviewScale' has a wrong offset!");

// Class JunoGameNative.JunoBuildingSetAccountItemDefinition
// 0x0000 (0x0770 - 0x0770)
class UJunoBuildingSetAccountItemDefinition final : public UJunoBuildingAccountItemDefBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingSetAccountItemDefinition">();
	}
	static class UJunoBuildingSetAccountItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingSetAccountItemDefinition>();
	}
};
static_assert(alignof(UJunoBuildingSetAccountItemDefinition) == 0x000008, "Wrong alignment on UJunoBuildingSetAccountItemDefinition");
static_assert(sizeof(UJunoBuildingSetAccountItemDefinition) == 0x000770, "Wrong size on UJunoBuildingSetAccountItemDefinition");

// Class JunoGameNative.JunoPlayspacePersistenceComponent
// 0x0028 (0x0120 - 0x00F8)
class UJunoPlayspacePersistenceComponent : public UFortPlayspaceComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UObject>>            RequiredPersistenceFeatureDataClasses;             // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FJunoPersistenceFeature>        PersistenceFeatures;                               // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspacePersistenceComponent">();
	}
	static class UJunoPlayspacePersistenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspacePersistenceComponent>();
	}
};
static_assert(alignof(UJunoPlayspacePersistenceComponent) == 0x000008, "Wrong alignment on UJunoPlayspacePersistenceComponent");
static_assert(sizeof(UJunoPlayspacePersistenceComponent) == 0x000120, "Wrong size on UJunoPlayspacePersistenceComponent");
static_assert(offsetof(UJunoPlayspacePersistenceComponent, RequiredPersistenceFeatureDataClasses) == 0x000100, "Member 'UJunoPlayspacePersistenceComponent::RequiredPersistenceFeatureDataClasses' has a wrong offset!");
static_assert(offsetof(UJunoPlayspacePersistenceComponent, PersistenceFeatures) == 0x000110, "Member 'UJunoPlayspacePersistenceComponent::PersistenceFeatures' has a wrong offset!");

// Class JunoGameNative.JunoRootPlayspacePersistenceComponent
// 0x0000 (0x0120 - 0x0120)
class UJunoRootPlayspacePersistenceComponent final : public UJunoPlayspacePersistenceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRootPlayspacePersistenceComponent">();
	}
	static class UJunoRootPlayspacePersistenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRootPlayspacePersistenceComponent>();
	}
};
static_assert(alignof(UJunoRootPlayspacePersistenceComponent) == 0x000008, "Wrong alignment on UJunoRootPlayspacePersistenceComponent");
static_assert(sizeof(UJunoRootPlayspacePersistenceComponent) == 0x000120, "Wrong size on UJunoRootPlayspacePersistenceComponent");

// Class JunoGameNative.JunoBuildingPropAccountItemDefinition
// 0x0000 (0x0770 - 0x0770)
class UJunoBuildingPropAccountItemDefinition final : public UJunoBuildingAccountItemDefBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingPropAccountItemDefinition">();
	}
	static class UJunoBuildingPropAccountItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingPropAccountItemDefinition>();
	}
};
static_assert(alignof(UJunoBuildingPropAccountItemDefinition) == 0x000008, "Wrong alignment on UJunoBuildingPropAccountItemDefinition");
static_assert(sizeof(UJunoBuildingPropAccountItemDefinition) == 0x000770, "Wrong size on UJunoBuildingPropAccountItemDefinition");

// Class JunoGameNative.JunoBuildingConnectivityBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoBuildingConnectivityBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DebugDrawConnectionLocations(const class UObject* WorldContextObject, const struct FJunoBuildingConnection& Connection);
	static void DebugDrawConnections(const class UObject* WorldContextObject, const struct FJunoBuildingConnectionPointsResult& Candidates, const struct FJunoBuildingConnectionPointsResult& Targets, const struct FJunoBuildingConnection& ChosenConnection, const TArray<struct FJunoBuildingConnection>& Connections);
	static TArray<class UAtomModelAssetUserData*> GetAtomModelAssetUserData(const class UObject* Object);
	static TArray<struct FJunoBuildingConnectionPoint> GetKnobs(const struct FJunoBuildingConnectionPointsResult& Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingConnectivityBlueprintLibrary">();
	}
	static class UJunoBuildingConnectivityBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingConnectivityBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoBuildingConnectivityBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoBuildingConnectivityBlueprintLibrary");
static_assert(sizeof(UJunoBuildingConnectivityBlueprintLibrary) == 0x000028, "Wrong size on UJunoBuildingConnectivityBlueprintLibrary");

// Class JunoGameNative.JunoGameFeatureAction_AddJunoAnalytics
// 0x0008 (0x0030 - 0x0028)
class UJunoGameFeatureAction_AddJunoAnalytics final : public UGameFeatureAction
{
public:
	class UJunoAnalytics*                         JunoAnalytics;                                     // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameFeatureAction_AddJunoAnalytics">();
	}
	static class UJunoGameFeatureAction_AddJunoAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameFeatureAction_AddJunoAnalytics>();
	}
};
static_assert(alignof(UJunoGameFeatureAction_AddJunoAnalytics) == 0x000008, "Wrong alignment on UJunoGameFeatureAction_AddJunoAnalytics");
static_assert(sizeof(UJunoGameFeatureAction_AddJunoAnalytics) == 0x000030, "Wrong size on UJunoGameFeatureAction_AddJunoAnalytics");
static_assert(offsetof(UJunoGameFeatureAction_AddJunoAnalytics, JunoAnalytics) == 0x000028, "Member 'UJunoGameFeatureAction_AddJunoAnalytics::JunoAnalytics' has a wrong offset!");

// Class JunoGameNative.JunoBuildingCosmeticsSettings
// 0x00D8 (0x0108 - 0x0030)
class UJunoBuildingCosmeticsSettings final : public UPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   JunoBuildingSetPreviewActorClass;                  // 0x0030(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JunoBuildingPropPreviewActorClass;                 // 0x0050(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JunoBuildingSetPreviewPrefabAssetClass;            // 0x0070(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JunoBuildingPropPreviewPrefabAssetClass;           // 0x0090(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuildingPartCategoryTag;                           // 0x00B0(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuildingPartSubCategoryTag;                        // 0x00B4(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FText>        PartCategoryNames;                                 // 0x00B8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingCosmeticsSettings">();
	}
	static class UJunoBuildingCosmeticsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingCosmeticsSettings>();
	}
};
static_assert(alignof(UJunoBuildingCosmeticsSettings) == 0x000008, "Wrong alignment on UJunoBuildingCosmeticsSettings");
static_assert(sizeof(UJunoBuildingCosmeticsSettings) == 0x000108, "Wrong size on UJunoBuildingCosmeticsSettings");
static_assert(offsetof(UJunoBuildingCosmeticsSettings, JunoBuildingSetPreviewActorClass) == 0x000030, "Member 'UJunoBuildingCosmeticsSettings::JunoBuildingSetPreviewActorClass' has a wrong offset!");
static_assert(offsetof(UJunoBuildingCosmeticsSettings, JunoBuildingPropPreviewActorClass) == 0x000050, "Member 'UJunoBuildingCosmeticsSettings::JunoBuildingPropPreviewActorClass' has a wrong offset!");
static_assert(offsetof(UJunoBuildingCosmeticsSettings, JunoBuildingSetPreviewPrefabAssetClass) == 0x000070, "Member 'UJunoBuildingCosmeticsSettings::JunoBuildingSetPreviewPrefabAssetClass' has a wrong offset!");
static_assert(offsetof(UJunoBuildingCosmeticsSettings, JunoBuildingPropPreviewPrefabAssetClass) == 0x000090, "Member 'UJunoBuildingCosmeticsSettings::JunoBuildingPropPreviewPrefabAssetClass' has a wrong offset!");
static_assert(offsetof(UJunoBuildingCosmeticsSettings, BuildingPartCategoryTag) == 0x0000B0, "Member 'UJunoBuildingCosmeticsSettings::BuildingPartCategoryTag' has a wrong offset!");
static_assert(offsetof(UJunoBuildingCosmeticsSettings, BuildingPartSubCategoryTag) == 0x0000B4, "Member 'UJunoBuildingCosmeticsSettings::BuildingPartSubCategoryTag' has a wrong offset!");
static_assert(offsetof(UJunoBuildingCosmeticsSettings, PartCategoryNames) == 0x0000B8, "Member 'UJunoBuildingCosmeticsSettings::PartCategoryNames' has a wrong offset!");

// Class JunoGameNative.JunoBuildingPreviewPrefabAsset
// 0x00D0 (0x0360 - 0x0290)
class AJunoBuildingPreviewPrefabAsset final : public AActor
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortUICameraFrameTargetBounds         CameraFrameTargetBounds;                           // 0x02A0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ZoomedInBoundsScale;                               // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x9C];                                     // 0x02C4(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingPreviewPrefabAsset">();
	}
	static class AJunoBuildingPreviewPrefabAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoBuildingPreviewPrefabAsset>();
	}
};
static_assert(alignof(AJunoBuildingPreviewPrefabAsset) == 0x000008, "Wrong alignment on AJunoBuildingPreviewPrefabAsset");
static_assert(sizeof(AJunoBuildingPreviewPrefabAsset) == 0x000360, "Wrong size on AJunoBuildingPreviewPrefabAsset");
static_assert(offsetof(AJunoBuildingPreviewPrefabAsset, CameraFrameTargetBounds) == 0x0002A0, "Member 'AJunoBuildingPreviewPrefabAsset::CameraFrameTargetBounds' has a wrong offset!");
static_assert(offsetof(AJunoBuildingPreviewPrefabAsset, ZoomedInBoundsScale) == 0x0002C0, "Member 'AJunoBuildingPreviewPrefabAsset::ZoomedInBoundsScale' has a wrong offset!");

// Class JunoGameNative.JunoVerbProcessor_RecruitNPC
// 0x0000 (0x00A0 - 0x00A0)
class UJunoVerbProcessor_RecruitNPC final : public UFortObjectiveProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoVerbProcessor_RecruitNPC">();
	}
	static class UJunoVerbProcessor_RecruitNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoVerbProcessor_RecruitNPC>();
	}
};
static_assert(alignof(UJunoVerbProcessor_RecruitNPC) == 0x000008, "Wrong alignment on UJunoVerbProcessor_RecruitNPC");
static_assert(sizeof(UJunoVerbProcessor_RecruitNPC) == 0x0000A0, "Wrong size on UJunoVerbProcessor_RecruitNPC");

// Class JunoGameNative.JunoBuildingProp
// 0x0048 (0x0C10 - 0x0BC8)
class AJunoBuildingProp : public ABuildingProp
{
public:
	uint8                                         Pad_BC8[0x20];                                     // 0x0BC8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoHarvestingComponent*               HarvestingComponent;                               // 0x0BE8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoPhysicsPersistenceComponent*       PhysicsPersistenceComponent;                       // 0x0BF0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BF8[0x10];                                     // 0x0BF8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemDefinitionBase*                    AssociatedItem;                                    // 0x0C08(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const class UItemDefinitionBase* GetAssociatedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingProp">();
	}
	static class AJunoBuildingProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoBuildingProp>();
	}
};
static_assert(alignof(AJunoBuildingProp) == 0x000008, "Wrong alignment on AJunoBuildingProp");
static_assert(sizeof(AJunoBuildingProp) == 0x000C10, "Wrong size on AJunoBuildingProp");
static_assert(offsetof(AJunoBuildingProp, HarvestingComponent) == 0x000BE8, "Member 'AJunoBuildingProp::HarvestingComponent' has a wrong offset!");
static_assert(offsetof(AJunoBuildingProp, PhysicsPersistenceComponent) == 0x000BF0, "Member 'AJunoBuildingProp::PhysicsPersistenceComponent' has a wrong offset!");
static_assert(offsetof(AJunoBuildingProp, AssociatedItem) == 0x000C08, "Member 'AJunoBuildingProp::AssociatedItem' has a wrong offset!");

// Class JunoGameNative.JunoBuildingPropTree
// 0x0008 (0x0C18 - 0x0C10)
class AJunoBuildingPropTree final : public AJunoBuildingProp
{
public:
	class UActorComponent*                        LifeCycleComponent;                                // 0x0C10(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool BlueprintCanDieInLifecyclePhase(const uint8 CurrentPhaseIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingPropTree">();
	}
	static class AJunoBuildingPropTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoBuildingPropTree>();
	}
};
static_assert(alignof(AJunoBuildingPropTree) == 0x000008, "Wrong alignment on AJunoBuildingPropTree");
static_assert(sizeof(AJunoBuildingPropTree) == 0x000C18, "Wrong size on AJunoBuildingPropTree");
static_assert(offsetof(AJunoBuildingPropTree, LifeCycleComponent) == 0x000C10, "Member 'AJunoBuildingPropTree::LifeCycleComponent' has a wrong offset!");

// Class JunoGameNative.JunoReportHandler
// 0x0000 (0x0028 - 0x0028)
class IJunoReportHandler final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoReportHandler">();
	}
	static class IJunoReportHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoReportHandler>();
	}
};
static_assert(alignof(IJunoReportHandler) == 0x000008, "Wrong alignment on IJunoReportHandler");
static_assert(sizeof(IJunoReportHandler) == 0x000028, "Wrong size on IJunoReportHandler");

// Class JunoGameNative.JunoCampActor
// 0x0090 (0x0320 - 0x0290)
class AJunoCampActor final : public AActor
{
public:
	uint8                                         Pad_290[0x60];                                     // 0x0290(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SavedActorGuid;                                    // 0x02F0(0x0010)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlapComponent*                      BoundsComponent;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampActor">();
	}
	static class AJunoCampActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoCampActor>();
	}
};
static_assert(alignof(AJunoCampActor) == 0x000008, "Wrong alignment on AJunoCampActor");
static_assert(sizeof(AJunoCampActor) == 0x000320, "Wrong size on AJunoCampActor");
static_assert(offsetof(AJunoCampActor, SavedActorGuid) == 0x0002F0, "Member 'AJunoCampActor::SavedActorGuid' has a wrong offset!");
static_assert(offsetof(AJunoCampActor, BoundsComponent) == 0x000308, "Member 'AJunoCampActor::BoundsComponent' has a wrong offset!");

// Class JunoGameNative.JunoCampCenterComponent
// 0x00E0 (0x0180 - 0x00A0)
class UJunoCampCenterComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(struct FJunoAwesomeLevelChangeData& ChangeData)> OnJunoCampAwesomeLevelChangedDelegate;             // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FJunoAwesomePointModificationData& ModificationData)> OnJunoCampAwesomePointModificationDelegate;        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x30];                                      // 0x00C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AJunoCampActor>             CampActorClassToSpawn;                             // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CampCenterDestructionDeathReasonTag;               // 0x0100(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoAsyncAction_WaitForEventRouter*    WaitForEventRouterAction;                          // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  LinkedCampActorID;                                 // 0x0110(0x0010)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x60];                                     // 0x0120(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSmartObjectEvent(const struct FSmartObjectEventData& SmartObjectEventData, const class AActor* Actor);
	void NotifyOwnerPlacedByBuilderTool(class AFortPlayerController* FortPC);
	void OnCampAwesomeLevelChanged(const struct FJunoEvent_CampAwesomeLevelChanged& Payload);
	void OnCampAwesomePointModification(const struct FJunoEvent_CampAwesomePointsModified& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampCenterComponent">();
	}
	static class UJunoCampCenterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampCenterComponent>();
	}
};
static_assert(alignof(UJunoCampCenterComponent) == 0x000008, "Wrong alignment on UJunoCampCenterComponent");
static_assert(sizeof(UJunoCampCenterComponent) == 0x000180, "Wrong size on UJunoCampCenterComponent");
static_assert(offsetof(UJunoCampCenterComponent, OnJunoCampAwesomeLevelChangedDelegate) == 0x0000A8, "Member 'UJunoCampCenterComponent::OnJunoCampAwesomeLevelChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoCampCenterComponent, OnJunoCampAwesomePointModificationDelegate) == 0x0000B8, "Member 'UJunoCampCenterComponent::OnJunoCampAwesomePointModificationDelegate' has a wrong offset!");
static_assert(offsetof(UJunoCampCenterComponent, CampActorClassToSpawn) == 0x0000F8, "Member 'UJunoCampCenterComponent::CampActorClassToSpawn' has a wrong offset!");
static_assert(offsetof(UJunoCampCenterComponent, CampCenterDestructionDeathReasonTag) == 0x000100, "Member 'UJunoCampCenterComponent::CampCenterDestructionDeathReasonTag' has a wrong offset!");
static_assert(offsetof(UJunoCampCenterComponent, WaitForEventRouterAction) == 0x000108, "Member 'UJunoCampCenterComponent::WaitForEventRouterAction' has a wrong offset!");
static_assert(offsetof(UJunoCampCenterComponent, LinkedCampActorID) == 0x000110, "Member 'UJunoCampCenterComponent::LinkedCampActorID' has a wrong offset!");

// Class JunoGameNative.JunoTemplatesReportHandler
// 0x0018 (0x0040 - 0x0028)
class UJunoTemplatesReportHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTemplatesReportHandler">();
	}
	static class UJunoTemplatesReportHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTemplatesReportHandler>();
	}
};
static_assert(alignof(UJunoTemplatesReportHandler) == 0x000008, "Wrong alignment on UJunoTemplatesReportHandler");
static_assert(sizeof(UJunoTemplatesReportHandler) == 0x000040, "Wrong size on UJunoTemplatesReportHandler");

// Class JunoGameNative.JunoCampComponentBase
// 0x0000 (0x00A0 - 0x00A0)
class UJunoCampComponentBase : public UGameFrameworkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampComponentBase">();
	}
	static class UJunoCampComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampComponentBase>();
	}
};
static_assert(alignof(UJunoCampComponentBase) == 0x000008, "Wrong alignment on UJunoCampComponentBase");
static_assert(sizeof(UJunoCampComponentBase) == 0x0000A0, "Wrong size on UJunoCampComponentBase");

// Class JunoGameNative.JunoMarkerComponent
// 0x00B0 (0x0150 - 0x00A0)
class UJunoMarkerComponent : public UActorComponent
{
public:
	struct FJunoMarker                            Settings;                                          // 0x00A0(0x0098)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldCreateMarkerOnStart;                        // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMarkerComponent">();
	}
	static class UJunoMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMarkerComponent>();
	}
};
static_assert(alignof(UJunoMarkerComponent) == 0x000008, "Wrong alignment on UJunoMarkerComponent");
static_assert(sizeof(UJunoMarkerComponent) == 0x000150, "Wrong size on UJunoMarkerComponent");
static_assert(offsetof(UJunoMarkerComponent, Settings) == 0x0000A0, "Member 'UJunoMarkerComponent::Settings' has a wrong offset!");
static_assert(offsetof(UJunoMarkerComponent, bShouldCreateMarkerOnStart) == 0x000148, "Member 'UJunoMarkerComponent::bShouldCreateMarkerOnStart' has a wrong offset!");

// Class JunoGameNative.JunoSyncTimeOfDayComponent
// 0x0008 (0x00A8 - 0x00A0)
class UJunoSyncTimeOfDayComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTimeOfDaySyncEnabled(bool bNewTimeOfDaySyncEnabled);

	bool GetTimeOfDaySyncEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoSyncTimeOfDayComponent">();
	}
	static class UJunoSyncTimeOfDayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoSyncTimeOfDayComponent>();
	}
};
static_assert(alignof(UJunoSyncTimeOfDayComponent) == 0x000008, "Wrong alignment on UJunoSyncTimeOfDayComponent");
static_assert(sizeof(UJunoSyncTimeOfDayComponent) == 0x0000A8, "Wrong size on UJunoSyncTimeOfDayComponent");

// Class JunoGameNative.JunoCampMarkerComponent
// 0x0000 (0x0150 - 0x0150)
class UJunoCampMarkerComponent final : public UJunoMarkerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampMarkerComponent">();
	}
	static class UJunoCampMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampMarkerComponent>();
	}
};
static_assert(alignof(UJunoCampMarkerComponent) == 0x000008, "Wrong alignment on UJunoCampMarkerComponent");
static_assert(sizeof(UJunoCampMarkerComponent) == 0x000150, "Wrong size on UJunoCampMarkerComponent");

// Class JunoGameNative.JunoCampMembershipActorComponent
// 0x0088 (0x0168 - 0x00E0)
class UJunoCampMembershipActorComponent final : public UFortAthenaTrackableAIObjectComponent
{
public:
	TMulticastInlineDelegate<void(class AJunoCampActor* NewlyBoundCamp)> OnJunoCampMembershipChanged;                       // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJunoCampActor>          BoundCamp;                                         // 0x0108(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x30];                                     // 0x0110(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ToleranceForMovementUpdates;                       // 0x0140(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UActorComponent* FindBindableLocalCampAtLocationAndReturnComponent(TSubclassOf<class UActorComponent> ComponentClass, const class UObject* WorldContextObject, const struct FVector& Location);
	static class AJunoCampActor* FindBindableLocalCampForActor(const class AActor* Actor);
	static class UActorComponent* FindBindableLocalCampForActorAndReturnComponent(TSubclassOf<class UActorComponent> ComponentClass, const class AActor* Actor);
	static class AJunoCampActor* FindBindableLocalCampForArea(const class AActor* Actor, const struct FBox& AreaBox);
	static class AJunoCampActor* FindBindableLocalCampForLocation(const class UObject* WorldContextObject, const struct FVector& Location);
	static class UJunoCampMembershipActorComponent* FindCampMembershipActorComponentOnActor(const class AActor* Owner);
	static class UActorComponent* FindCampMembershipComponentAndReturnComponent(TSubclassOf<class UActorComponent> ComponentClass, const class AActor* Owner);
	static class UJunoCampMembershipActorComponent* FindOrCreateCampMembershipActorComponentOnActor(const class AActor* Owner);
	static class UActorComponent* FindOrCreateCampMembershipComponentAndReturnComponent(TSubclassOf<class UActorComponent> ComponentClass, const class AActor* Owner);
	static bool HasCampAtBounds(const class UObject* WorldContextObject, const struct FBox& Bounds);
	static bool HasCampAtLocation(const class UObject* WorldContextObject, const struct FVector& Location);

	void AttemptToBindToCamp();
	void HandleBoundCampEndPlayEvent(class AActor* InOwner, EEndPlayReason EndPlayReason);
	void OnRep_BoundCamp();

	class AJunoCampActor* GetBoundCamp() const;
	class UActorComponent* GetBoundComponent(TSubclassOf<class UActorComponent> ComponentClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampMembershipActorComponent">();
	}
	static class UJunoCampMembershipActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampMembershipActorComponent>();
	}
};
static_assert(alignof(UJunoCampMembershipActorComponent) == 0x000008, "Wrong alignment on UJunoCampMembershipActorComponent");
static_assert(sizeof(UJunoCampMembershipActorComponent) == 0x000168, "Wrong size on UJunoCampMembershipActorComponent");
static_assert(offsetof(UJunoCampMembershipActorComponent, OnJunoCampMembershipChanged) == 0x0000E0, "Member 'UJunoCampMembershipActorComponent::OnJunoCampMembershipChanged' has a wrong offset!");
static_assert(offsetof(UJunoCampMembershipActorComponent, BoundCamp) == 0x000108, "Member 'UJunoCampMembershipActorComponent::BoundCamp' has a wrong offset!");
static_assert(offsetof(UJunoCampMembershipActorComponent, ToleranceForMovementUpdates) == 0x000140, "Member 'UJunoCampMembershipActorComponent::ToleranceForMovementUpdates' has a wrong offset!");

// Class JunoGameNative.JunoRainCaptureSubsystemData
// 0x0038 (0x0068 - 0x0030)
class UJunoRainCaptureSubsystemData final : public UPrimaryDataAsset
{
public:
	class UMaterialParameterCollection*           MaterialParameterCollection;                       // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 TextureTarget;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeatherParameterName;                              // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RainOccluderSceneCaptureLocationName;              // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RainOccluderPositionOffset;                        // 0x0048(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateDistanceThreshold;                           // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTimeThreshold;                               // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRainCaptureSubsystemData">();
	}
	static class UJunoRainCaptureSubsystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRainCaptureSubsystemData>();
	}
};
static_assert(alignof(UJunoRainCaptureSubsystemData) == 0x000008, "Wrong alignment on UJunoRainCaptureSubsystemData");
static_assert(sizeof(UJunoRainCaptureSubsystemData) == 0x000068, "Wrong size on UJunoRainCaptureSubsystemData");
static_assert(offsetof(UJunoRainCaptureSubsystemData, MaterialParameterCollection) == 0x000030, "Member 'UJunoRainCaptureSubsystemData::MaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(UJunoRainCaptureSubsystemData, TextureTarget) == 0x000038, "Member 'UJunoRainCaptureSubsystemData::TextureTarget' has a wrong offset!");
static_assert(offsetof(UJunoRainCaptureSubsystemData, WeatherParameterName) == 0x000040, "Member 'UJunoRainCaptureSubsystemData::WeatherParameterName' has a wrong offset!");
static_assert(offsetof(UJunoRainCaptureSubsystemData, RainOccluderSceneCaptureLocationName) == 0x000044, "Member 'UJunoRainCaptureSubsystemData::RainOccluderSceneCaptureLocationName' has a wrong offset!");
static_assert(offsetof(UJunoRainCaptureSubsystemData, RainOccluderPositionOffset) == 0x000048, "Member 'UJunoRainCaptureSubsystemData::RainOccluderPositionOffset' has a wrong offset!");
static_assert(offsetof(UJunoRainCaptureSubsystemData, UpdateDistanceThreshold) == 0x000060, "Member 'UJunoRainCaptureSubsystemData::UpdateDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UJunoRainCaptureSubsystemData, UpdateTimeThreshold) == 0x000064, "Member 'UJunoRainCaptureSubsystemData::UpdateTimeThreshold' has a wrong offset!");

// Class JunoGameNative.JunoCampPersistenceComponent
// 0x0160 (0x0200 - 0x00A0)
class UJunoCampPersistenceComponent final : public UJunoCampComponentBase
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAwesomeLevelSaveData                  AwesomeLevelSaveData;                              // 0x00C0(0x0058)(SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FAICampManagementSaveData              AICampManagementSaveData;                          // 0x0118(0x0020)(SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FNamedPOISaveData                      NamedPOISaveData;                                  // 0x0138(0x00B0)(SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x18];                                     // 0x01E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampPersistenceComponent">();
	}
	static class UJunoCampPersistenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampPersistenceComponent>();
	}
};
static_assert(alignof(UJunoCampPersistenceComponent) == 0x000008, "Wrong alignment on UJunoCampPersistenceComponent");
static_assert(sizeof(UJunoCampPersistenceComponent) == 0x000200, "Wrong size on UJunoCampPersistenceComponent");
static_assert(offsetof(UJunoCampPersistenceComponent, AwesomeLevelSaveData) == 0x0000C0, "Member 'UJunoCampPersistenceComponent::AwesomeLevelSaveData' has a wrong offset!");
static_assert(offsetof(UJunoCampPersistenceComponent, AICampManagementSaveData) == 0x000118, "Member 'UJunoCampPersistenceComponent::AICampManagementSaveData' has a wrong offset!");
static_assert(offsetof(UJunoCampPersistenceComponent, NamedPOISaveData) == 0x000138, "Member 'UJunoCampPersistenceComponent::NamedPOISaveData' has a wrong offset!");

// Class JunoGameNative.JunoCampPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoCampPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampPersistenceFeatureModule">();
	}
	static class UJunoCampPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoCampPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoCampPersistenceFeatureModule");
static_assert(sizeof(UJunoCampPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoCampPersistenceFeatureModule");

// Class JunoGameNative.JunoTemperatureAttributeSet
// 0x0100 (0x0130 - 0x0030)
class UJunoTemperatureAttributeSet final : public UFortAttributeSet
{
public:
	struct FGameplayTagContainer                  BlockedTemperatures;                               // 0x0030(0x0020)(Config, NativeAccessSpecifierPrivate)
	struct FFortGameplayAttributeData             Temperature;                                       // 0x0050(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FFortGameplayAttributeData             ColdResistance;                                    // 0x0078(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FFortGameplayAttributeData             HeatResistance;                                    // 0x00A0(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           CurrentTemperature;                                // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTemperatureRange>              TemperatureRanges;                                 // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FJunoTemperatureChangedEvent& TemperatureChangedEventPayload)> OnTemperatureChanged;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FJunoTemperatureRangesChangedEvent& TemperatureRangesChangedEventPayload)> OnTemperatureRangesChanged;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAddTemperatureTagToActor;                         // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ForcedTemperature;                                 // 0x0104(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x28];                                     // 0x0108(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceTemperature(const struct FGameplayTag& TemperatureToForce);
	void HandleWeatherTemperatureChanged(const struct FJunoEvent_TemperatureChanged& Payload);
	void OnRep_ColdResistance(const struct FFortGameplayAttributeData& OldValue);
	void OnRep_CurrentTemperature(const struct FGameplayTag& OldTemperature);
	void OnRep_HeatResistance(const struct FFortGameplayAttributeData& OldValue);
	void OnRep_Temperature(const struct FFortGameplayAttributeData& OldValue);
	void OnRep_TemperatureRanges();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTemperatureAttributeSet">();
	}
	static class UJunoTemperatureAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTemperatureAttributeSet>();
	}
};
static_assert(alignof(UJunoTemperatureAttributeSet) == 0x000008, "Wrong alignment on UJunoTemperatureAttributeSet");
static_assert(sizeof(UJunoTemperatureAttributeSet) == 0x000130, "Wrong size on UJunoTemperatureAttributeSet");
static_assert(offsetof(UJunoTemperatureAttributeSet, BlockedTemperatures) == 0x000030, "Member 'UJunoTemperatureAttributeSet::BlockedTemperatures' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, Temperature) == 0x000050, "Member 'UJunoTemperatureAttributeSet::Temperature' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, ColdResistance) == 0x000078, "Member 'UJunoTemperatureAttributeSet::ColdResistance' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, HeatResistance) == 0x0000A0, "Member 'UJunoTemperatureAttributeSet::HeatResistance' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, CurrentTemperature) == 0x0000C8, "Member 'UJunoTemperatureAttributeSet::CurrentTemperature' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, TemperatureRanges) == 0x0000D0, "Member 'UJunoTemperatureAttributeSet::TemperatureRanges' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, OnTemperatureChanged) == 0x0000E0, "Member 'UJunoTemperatureAttributeSet::OnTemperatureChanged' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, OnTemperatureRangesChanged) == 0x0000F0, "Member 'UJunoTemperatureAttributeSet::OnTemperatureRangesChanged' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, bAddTemperatureTagToActor) == 0x000100, "Member 'UJunoTemperatureAttributeSet::bAddTemperatureTagToActor' has a wrong offset!");
static_assert(offsetof(UJunoTemperatureAttributeSet, ForcedTemperature) == 0x000104, "Member 'UJunoTemperatureAttributeSet::ForcedTemperature' has a wrong offset!");

// Class JunoGameNative.JunoCampPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoCampPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampPersistenceFeatureData_Container">();
	}
	static class UJunoCampPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoCampPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoCampPersistenceFeatureData_Container");
static_assert(sizeof(UJunoCampPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoCampPersistenceFeatureData_Container");

// Class JunoGameNative.JunoCampRecruitmentComponent
// 0x0050 (0x00F0 - 0x00A0)
class UJunoCampRecruitmentComponent final : public UJunoCampComponentBase
{
public:
	uint8                                         Pad_A0[0x40];                                      // 0x00A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveCampNPCEntry>            ActiveNPCEntries;                                  // 0x00E0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	const TArray<struct FActiveCampNPCEntry> GetActiveNPCEntries();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampRecruitmentComponent">();
	}
	static class UJunoCampRecruitmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampRecruitmentComponent>();
	}
};
static_assert(alignof(UJunoCampRecruitmentComponent) == 0x000008, "Wrong alignment on UJunoCampRecruitmentComponent");
static_assert(sizeof(UJunoCampRecruitmentComponent) == 0x0000F0, "Wrong size on UJunoCampRecruitmentComponent");
static_assert(offsetof(UJunoCampRecruitmentComponent, ActiveNPCEntries) == 0x0000E0, "Member 'UJunoCampRecruitmentComponent::ActiveNPCEntries' has a wrong offset!");

// Class JunoGameNative.JunoWorldConditionWeatherState
// 0x0020 (0x0048 - 0x0028)
class UJunoWorldConditionWeatherState final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleWeatherChanged(const struct FJunoEvent_WeatherPhaseChanged& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldConditionWeatherState">();
	}
	static class UJunoWorldConditionWeatherState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldConditionWeatherState>();
	}
};
static_assert(alignof(UJunoWorldConditionWeatherState) == 0x000008, "Wrong alignment on UJunoWorldConditionWeatherState");
static_assert(sizeof(UJunoWorldConditionWeatherState) == 0x000048, "Wrong size on UJunoWorldConditionWeatherState");

// Class JunoGameNative.JunoWeatherLocationComponent
// 0x0018 (0x00B8 - 0x00A0)
class UJunoWeatherLocationComponent : public UGameFrameworkComponent
{
public:
	TMulticastInlineDelegate<void(const struct FJunoWeatherLocationChangedEvent& Event)> OnLocationChanged;                                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FJunoWeatherLocation                   Location;                                          // 0x00B0(0x0002)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLocationChanged();
	void OnRep_Location(const struct FJunoWeatherLocation& OldLocation);

	struct FJunoWeatherLocation BP_CalculateLocation() const;
	const struct FJunoWeatherLocation GetLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherLocationComponent">();
	}
	static class UJunoWeatherLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeatherLocationComponent>();
	}
};
static_assert(alignof(UJunoWeatherLocationComponent) == 0x000008, "Wrong alignment on UJunoWeatherLocationComponent");
static_assert(sizeof(UJunoWeatherLocationComponent) == 0x0000B8, "Wrong size on UJunoWeatherLocationComponent");
static_assert(offsetof(UJunoWeatherLocationComponent, OnLocationChanged) == 0x0000A0, "Member 'UJunoWeatherLocationComponent::OnLocationChanged' has a wrong offset!");
static_assert(offsetof(UJunoWeatherLocationComponent, Location) == 0x0000B0, "Member 'UJunoWeatherLocationComponent::Location' has a wrong offset!");

// Class JunoGameNative.JunoCampRecruitmentObjectComponent
// 0x00E8 (0x0188 - 0x00A0)
class UJunoCampRecruitmentObjectComponent final : public UGameFrameworkComponent
{
public:
	TMulticastInlineDelegate<void(struct FJunoRecruitmentObjectAssignedData& AssignedData)> OnJunoRecruitmentObjectAssignedChangedDelegate;    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bEnabled)> OnJunoRecruitmentObjectEnableChangeDelegate;       // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	bool                                          bIsEnabled;                                        // 0x00D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoRecruitmentObjectAssignedData     CachedAssignedData;                                // 0x00E0(0x0080)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x28];                                     // 0x0160(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignToPlayer(const class AFortPlayerController* PlayerController, const bool bCheckForDuplicateRecruitmentObjects);
	void HandleDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void HandleOnEmptyRecrutmentObjectInteracted(class AFortPlayerController* InteractingController);
	void OnRep_AssignedData();
	void OnRep_bIsEnabled();

	bool CostlyFindAssignableNPCs(TArray<struct FGameplayTag>* OutAssignableNPCs) const;
	const struct FJunoRecruitmentObjectAssignedData GetAssignedData() const;
	bool IsAssignedToAI() const;
	bool IsAssignedToPlayer() const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampRecruitmentObjectComponent">();
	}
	static class UJunoCampRecruitmentObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampRecruitmentObjectComponent>();
	}
};
static_assert(alignof(UJunoCampRecruitmentObjectComponent) == 0x000008, "Wrong alignment on UJunoCampRecruitmentObjectComponent");
static_assert(sizeof(UJunoCampRecruitmentObjectComponent) == 0x000188, "Wrong size on UJunoCampRecruitmentObjectComponent");
static_assert(offsetof(UJunoCampRecruitmentObjectComponent, OnJunoRecruitmentObjectAssignedChangedDelegate) == 0x0000A0, "Member 'UJunoCampRecruitmentObjectComponent::OnJunoRecruitmentObjectAssignedChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoCampRecruitmentObjectComponent, OnJunoRecruitmentObjectEnableChangeDelegate) == 0x0000C8, "Member 'UJunoCampRecruitmentObjectComponent::OnJunoRecruitmentObjectEnableChangeDelegate' has a wrong offset!");
static_assert(offsetof(UJunoCampRecruitmentObjectComponent, bIsEnabled) == 0x0000D8, "Member 'UJunoCampRecruitmentObjectComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UJunoCampRecruitmentObjectComponent, CachedAssignedData) == 0x0000E0, "Member 'UJunoCampRecruitmentObjectComponent::CachedAssignedData' has a wrong offset!");

// Class JunoGameNative.JunoCampRemovalStatusComponent
// 0x0058 (0x00F8 - 0x00A0)
class UJunoCampRemovalStatusComponent final : public UJunoCampComponentBase
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         SoftRemovalCampComponentUpdateRate;                // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoCampRemovalStatusData             CampRemovalStatusData;                             // 0x00E0(0x000C)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0xC];                                       // 0x00EC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CampRemovalStatusData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampRemovalStatusComponent">();
	}
	static class UJunoCampRemovalStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampRemovalStatusComponent>();
	}
};
static_assert(alignof(UJunoCampRemovalStatusComponent) == 0x000008, "Wrong alignment on UJunoCampRemovalStatusComponent");
static_assert(sizeof(UJunoCampRemovalStatusComponent) == 0x0000F8, "Wrong size on UJunoCampRemovalStatusComponent");
static_assert(offsetof(UJunoCampRemovalStatusComponent, SoftRemovalCampComponentUpdateRate) == 0x0000B0, "Member 'UJunoCampRemovalStatusComponent::SoftRemovalCampComponentUpdateRate' has a wrong offset!");
static_assert(offsetof(UJunoCampRemovalStatusComponent, CampRemovalStatusData) == 0x0000E0, "Member 'UJunoCampRemovalStatusComponent::CampRemovalStatusData' has a wrong offset!");

// Class JunoGameNative.JunoUpdateActionsReportHandler
// 0x0018 (0x0040 - 0x0028)
class UJunoUpdateActionsReportHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoUpdateActionsReportHandler">();
	}
	static class UJunoUpdateActionsReportHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoUpdateActionsReportHandler>();
	}
};
static_assert(alignof(UJunoUpdateActionsReportHandler) == 0x000008, "Wrong alignment on UJunoUpdateActionsReportHandler");
static_assert(sizeof(UJunoUpdateActionsReportHandler) == 0x000040, "Wrong size on UJunoUpdateActionsReportHandler");

// Class JunoGameNative.JunoCaveContainerInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoCaveContainerInterface final : public IInterface
{
public:
	void GetCaveEntrances(TArray<struct FTransform>* Transforms) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveContainerInterface">();
	}
	static class IJunoCaveContainerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoCaveContainerInterface>();
	}
};
static_assert(alignof(IJunoCaveContainerInterface) == 0x000008, "Wrong alignment on IJunoCaveContainerInterface");
static_assert(sizeof(IJunoCaveContainerInterface) == 0x000028, "Wrong size on IJunoCaveContainerInterface");

// Class JunoGameNative.JunoChaosAudioGameStateComponent
// 0x02C0 (0x0360 - 0x00A0)
class UJunoChaosAudioGameStateComponent final : public UFortGameStateComponent
{
public:
	class UPhysicalMaterial*                      FallbackPhysicalMaterial;                          // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CollisionEventSizeParamName;                       // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CollisionTriggerUpdateParamName;                   // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              Collision_Loop;                                    // 0x00B0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CollisionMassToSize;                               // 0x00D0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CollisionVolumeMultiplier;                         // 0x00F8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class UPhysicalMaterial*, struct FChaosAudioEventSizeSounds> CollisionMaterials;                                // 0x0120(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   BreakEventSizeParamName;                           // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              Break_Group_Default;                               // 0x0178(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UPhysicalMaterial*, class USoundBase*> BreakGroupMaterialMap;                             // 0x0198(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BreakMassToSize;                                   // 0x01E8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BreakVolumeMultiplier;                             // 0x0210(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class UPhysicalMaterial*, struct FChaosAudioEventSizeSounds> BreakMaterials;                                    // 0x0238(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, TWeakObjectPtr<class UAudioComponent>> CollisionSoundMap;                                 // 0x0288(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, TWeakObjectPtr<class UAudioComponent>> BreakSoundMap;                                     // 0x02D8(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UAudioEventAggregatorSubsystem*         AudioEventAggregatorSubsystem;                     // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class USoundBase>>      SoftAssets;                                        // 0x0330(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class USoundBase*>                     LoadedAssets;                                      // 0x0340(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USoundBase* GetSingleChaosEventSound(const TMap<class UPhysicalMaterial*, struct FChaosAudioEventSizeSounds>& ChaosEventMaterials, class UPhysicalMaterial* Material, uint8 EventSize);
	void OnActiveSoundBreakEventSoundFinished(class UAudioComponent* Component);
	void OnActiveSoundBreakEventsUpdated(const TArray<struct FSoundBreakEvent>& SoundBreakEvents);
	void OnActiveSoundCollisionEventSoundFinished(class UAudioComponent* Component);
	void OnActiveSoundCollisionEventsUpdated(const TArray<struct FSoundCollisionEvent>& SoundCollisionEvents);
	void OnSoundBreakEvents(const TArray<struct FSoundBreakEvent>& SoundBreakEvents);
	void OnSoundCollisionEvents(const TArray<struct FSoundCollisionEvent>& SoundCollisionEvents);
	void SubscribeToChaosEventRelayEvents();
	void UnSubscribeToChaosEventRelayEvents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoChaosAudioGameStateComponent">();
	}
	static class UJunoChaosAudioGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoChaosAudioGameStateComponent>();
	}
};
static_assert(alignof(UJunoChaosAudioGameStateComponent) == 0x000008, "Wrong alignment on UJunoChaosAudioGameStateComponent");
static_assert(sizeof(UJunoChaosAudioGameStateComponent) == 0x000360, "Wrong size on UJunoChaosAudioGameStateComponent");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, FallbackPhysicalMaterial) == 0x0000A0, "Member 'UJunoChaosAudioGameStateComponent::FallbackPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, CollisionEventSizeParamName) == 0x0000A8, "Member 'UJunoChaosAudioGameStateComponent::CollisionEventSizeParamName' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, CollisionTriggerUpdateParamName) == 0x0000AC, "Member 'UJunoChaosAudioGameStateComponent::CollisionTriggerUpdateParamName' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, Collision_Loop) == 0x0000B0, "Member 'UJunoChaosAudioGameStateComponent::Collision_Loop' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, CollisionMassToSize) == 0x0000D0, "Member 'UJunoChaosAudioGameStateComponent::CollisionMassToSize' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, CollisionVolumeMultiplier) == 0x0000F8, "Member 'UJunoChaosAudioGameStateComponent::CollisionVolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, CollisionMaterials) == 0x000120, "Member 'UJunoChaosAudioGameStateComponent::CollisionMaterials' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, BreakEventSizeParamName) == 0x000170, "Member 'UJunoChaosAudioGameStateComponent::BreakEventSizeParamName' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, Break_Group_Default) == 0x000178, "Member 'UJunoChaosAudioGameStateComponent::Break_Group_Default' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, BreakGroupMaterialMap) == 0x000198, "Member 'UJunoChaosAudioGameStateComponent::BreakGroupMaterialMap' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, BreakMassToSize) == 0x0001E8, "Member 'UJunoChaosAudioGameStateComponent::BreakMassToSize' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, BreakVolumeMultiplier) == 0x000210, "Member 'UJunoChaosAudioGameStateComponent::BreakVolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, BreakMaterials) == 0x000238, "Member 'UJunoChaosAudioGameStateComponent::BreakMaterials' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, CollisionSoundMap) == 0x000288, "Member 'UJunoChaosAudioGameStateComponent::CollisionSoundMap' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, BreakSoundMap) == 0x0002D8, "Member 'UJunoChaosAudioGameStateComponent::BreakSoundMap' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, AudioEventAggregatorSubsystem) == 0x000328, "Member 'UJunoChaosAudioGameStateComponent::AudioEventAggregatorSubsystem' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, SoftAssets) == 0x000330, "Member 'UJunoChaosAudioGameStateComponent::SoftAssets' has a wrong offset!");
static_assert(offsetof(UJunoChaosAudioGameStateComponent, LoadedAssets) == 0x000340, "Member 'UJunoChaosAudioGameStateComponent::LoadedAssets' has a wrong offset!");

// Class JunoGameNative.JunoTeamStart
// 0x0008 (0x02C8 - 0x02C0)
class AJunoTeamStart final : public APlayerStart
{
public:
	float                                         CapsuleRadius;                                     // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleHeight;                                     // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTeamStart">();
	}
	static class AJunoTeamStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoTeamStart>();
	}
};
static_assert(alignof(AJunoTeamStart) == 0x000008, "Wrong alignment on AJunoTeamStart");
static_assert(sizeof(AJunoTeamStart) == 0x0002C8, "Wrong size on AJunoTeamStart");
static_assert(offsetof(AJunoTeamStart, CapsuleRadius) == 0x0002C0, "Member 'AJunoTeamStart::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(AJunoTeamStart, CapsuleHeight) == 0x0002C4, "Member 'AJunoTeamStart::CapsuleHeight' has a wrong offset!");

// Class JunoGameNative.JunoCheatProfilerSubsystem
// 0x0080 (0x00C0 - 0x0040)
class UJunoCheatProfilerSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x80];                                      // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCheatProfilerSubsystem">();
	}
	static class UJunoCheatProfilerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCheatProfilerSubsystem>();
	}
};
static_assert(alignof(UJunoCheatProfilerSubsystem) == 0x000008, "Wrong alignment on UJunoCheatProfilerSubsystem");
static_assert(sizeof(UJunoCheatProfilerSubsystem) == 0x0000C0, "Wrong size on UJunoCheatProfilerSubsystem");

// Class JunoGameNative.JunoBasePFWPersistenceFeatureData
// 0x0018 (0x0040 - 0x0028)
class UJunoBasePFWPersistenceFeatureData : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDirty;                                            // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPersistentDataModified();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBasePFWPersistenceFeatureData">();
	}
	static class UJunoBasePFWPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBasePFWPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoBasePFWPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoBasePFWPersistenceFeatureData");
static_assert(sizeof(UJunoBasePFWPersistenceFeatureData) == 0x000040, "Wrong size on UJunoBasePFWPersistenceFeatureData");
static_assert(offsetof(UJunoBasePFWPersistenceFeatureData, bDirty) == 0x000038, "Member 'UJunoBasePFWPersistenceFeatureData::bDirty' has a wrong offset!");

// Class JunoGameNative.JunoWeatherPersistenceFeatureData
// 0x0018 (0x0058 - 0x0040)
class UJunoWeatherPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoWeatherSaveData                   WeatherSaveData;                                   // 0x0048(0x0010)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherPersistenceFeatureData">();
	}
	static class UJunoWeatherPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeatherPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoWeatherPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoWeatherPersistenceFeatureData");
static_assert(sizeof(UJunoWeatherPersistenceFeatureData) == 0x000058, "Wrong size on UJunoWeatherPersistenceFeatureData");
static_assert(offsetof(UJunoWeatherPersistenceFeatureData, WeatherSaveData) == 0x000048, "Member 'UJunoWeatherPersistenceFeatureData::WeatherSaveData' has a wrong offset!");

// Class JunoGameNative.JunoClosedDoorNavArea
// 0x0000 (0x0048 - 0x0048)
class UJunoClosedDoorNavArea final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClosedDoorNavArea">();
	}
	static class UJunoClosedDoorNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoClosedDoorNavArea>();
	}
};
static_assert(alignof(UJunoClosedDoorNavArea) == 0x000008, "Wrong alignment on UJunoClosedDoorNavArea");
static_assert(sizeof(UJunoClosedDoorNavArea) == 0x000048, "Wrong size on UJunoClosedDoorNavArea");

// Class JunoGameNative.JunoWeatherFXPersistence
// 0x0058 (0x02E8 - 0x0290)
class AJunoWeatherFXPersistence final : public AActor
{
public:
	class UMaterialParameterCollection*           MaterialParameterCollection;                       // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollectionInstance*   CachedMPCInstance;                                 // 0x0298(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           WindPosition;                                      // 0x02A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           WindValueInCave;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWindSpeed;                                      // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GustMaxWindSpeedAddend;                            // 0x02C4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WindScalar;                                        // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WindParamName;                                     // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WindPositionParamName;                             // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WindPreviousPositionParamName;                     // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInCave;                                           // 0x02E4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateWindGust(float IntensityScalar, const struct FVector& GustIntensity, const struct FLinearColor& CurrentWind);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherFXPersistence">();
	}
	static class AJunoWeatherFXPersistence* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoWeatherFXPersistence>();
	}
};
static_assert(alignof(AJunoWeatherFXPersistence) == 0x000008, "Wrong alignment on AJunoWeatherFXPersistence");
static_assert(sizeof(AJunoWeatherFXPersistence) == 0x0002E8, "Wrong size on AJunoWeatherFXPersistence");
static_assert(offsetof(AJunoWeatherFXPersistence, MaterialParameterCollection) == 0x000290, "Member 'AJunoWeatherFXPersistence::MaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, CachedMPCInstance) == 0x000298, "Member 'AJunoWeatherFXPersistence::CachedMPCInstance' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, WindPosition) == 0x0002A0, "Member 'AJunoWeatherFXPersistence::WindPosition' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, WindValueInCave) == 0x0002B0, "Member 'AJunoWeatherFXPersistence::WindValueInCave' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, MaxWindSpeed) == 0x0002C0, "Member 'AJunoWeatherFXPersistence::MaxWindSpeed' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, GustMaxWindSpeedAddend) == 0x0002C4, "Member 'AJunoWeatherFXPersistence::GustMaxWindSpeedAddend' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, WindScalar) == 0x0002D4, "Member 'AJunoWeatherFXPersistence::WindScalar' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, WindParamName) == 0x0002D8, "Member 'AJunoWeatherFXPersistence::WindParamName' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, WindPositionParamName) == 0x0002DC, "Member 'AJunoWeatherFXPersistence::WindPositionParamName' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, WindPreviousPositionParamName) == 0x0002E0, "Member 'AJunoWeatherFXPersistence::WindPreviousPositionParamName' has a wrong offset!");
static_assert(offsetof(AJunoWeatherFXPersistence, bInCave) == 0x0002E4, "Member 'AJunoWeatherFXPersistence::bInCave' has a wrong offset!");

// Class JunoGameNative.JunoClusterUnionComponent
// 0x00C0 (0x0800 - 0x0740)
class UJunoClusterUnionComponent final : public UClusterUnionComponent
{
public:
	uint8                                         Pad_740[0xC0];                                     // 0x0740(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClusterUnionComponent">();
	}
	static class UJunoClusterUnionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoClusterUnionComponent>();
	}
};
static_assert(alignof(UJunoClusterUnionComponent) == 0x000010, "Wrong alignment on UJunoClusterUnionComponent");
static_assert(sizeof(UJunoClusterUnionComponent) == 0x000800, "Wrong size on UJunoClusterUnionComponent");

// Class JunoGameNative.JunoComponent_HealthIndicator
// 0x0040 (0x00E0 - 0x00A0)
class UJunoComponent_HealthIndicator final : public UPawnComponent
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHealth;                                         // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AttachOffset;                                      // 0x00C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Health();
	void OnRep_MaxHealth();
	void OnServerPawnHealthChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoComponent_HealthIndicator">();
	}
	static class UJunoComponent_HealthIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoComponent_HealthIndicator>();
	}
};
static_assert(alignof(UJunoComponent_HealthIndicator) == 0x000008, "Wrong alignment on UJunoComponent_HealthIndicator");
static_assert(sizeof(UJunoComponent_HealthIndicator) == 0x0000E0, "Wrong size on UJunoComponent_HealthIndicator");
static_assert(offsetof(UJunoComponent_HealthIndicator, Health) == 0x0000C0, "Member 'UJunoComponent_HealthIndicator::Health' has a wrong offset!");
static_assert(offsetof(UJunoComponent_HealthIndicator, MaxHealth) == 0x0000C4, "Member 'UJunoComponent_HealthIndicator::MaxHealth' has a wrong offset!");
static_assert(offsetof(UJunoComponent_HealthIndicator, AttachOffset) == 0x0000C8, "Member 'UJunoComponent_HealthIndicator::AttachOffset' has a wrong offset!");

// Class JunoGameNative.JunoWorldPersistenceSubsystem
// 0x00F8 (0x0128 - 0x0030)
class UJunoWorldPersistenceSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableWorldPersistence;                           // 0x0068(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableWorldPersistenceInPIE;                      // 0x0069(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoWorldPersistenceHandler*           WorldPersistenceHandler;                           // 0x0070(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoWorldPersistencePlayerManager*     WorldPersistencePlayerManager;                     // 0x0078(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoWorldPersistenceSubsystemData*     SubsystemData;                                     // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoWorldPersistenceCheckpointManager* CheckpointManager;                                 // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, TWeakObjectPtr<class AJunoPersistentPlayspace>> PersistentPlayspaceMap;                            // 0x0090(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	EJunoWorldSaveDataState                       WorldSaveDataState;                                // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SubsystemDataAssetPath;                            // 0x00E8(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ErrorCodeAllowList;                                // 0x0118(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)

public:
	static struct FGuid GenerateDeterministicMapActorGUID(const class AActor* Actor);
	static void RequestActorSave(class AActor* Actor);
	static bool WasActorSpawnedFromSavedGame(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceSubsystem">();
	}
	static class UJunoWorldPersistenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistenceSubsystem>();
	}
};
static_assert(alignof(UJunoWorldPersistenceSubsystem) == 0x000008, "Wrong alignment on UJunoWorldPersistenceSubsystem");
static_assert(sizeof(UJunoWorldPersistenceSubsystem) == 0x000128, "Wrong size on UJunoWorldPersistenceSubsystem");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, bEnableWorldPersistence) == 0x000068, "Member 'UJunoWorldPersistenceSubsystem::bEnableWorldPersistence' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, bEnableWorldPersistenceInPIE) == 0x000069, "Member 'UJunoWorldPersistenceSubsystem::bEnableWorldPersistenceInPIE' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, WorldPersistenceHandler) == 0x000070, "Member 'UJunoWorldPersistenceSubsystem::WorldPersistenceHandler' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, WorldPersistencePlayerManager) == 0x000078, "Member 'UJunoWorldPersistenceSubsystem::WorldPersistencePlayerManager' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, SubsystemData) == 0x000080, "Member 'UJunoWorldPersistenceSubsystem::SubsystemData' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, CheckpointManager) == 0x000088, "Member 'UJunoWorldPersistenceSubsystem::CheckpointManager' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, PersistentPlayspaceMap) == 0x000090, "Member 'UJunoWorldPersistenceSubsystem::PersistentPlayspaceMap' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, WorldSaveDataState) == 0x0000E0, "Member 'UJunoWorldPersistenceSubsystem::WorldSaveDataState' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, SubsystemDataAssetPath) == 0x0000E8, "Member 'UJunoWorldPersistenceSubsystem::SubsystemDataAssetPath' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystem, ErrorCodeAllowList) == 0x000118, "Member 'UJunoWorldPersistenceSubsystem::ErrorCodeAllowList' has a wrong offset!");

// Class JunoGameNative.JunoComponent_Stamina
// 0x0000 (0x02F0 - 0x02F0)
class UJunoComponent_Stamina final : public UFortComponent_Energy
{
public:
	struct FScalableFloat GetMaxEnergy();
	void SetMaxEnergy(const struct FScalableFloat& NewMaxEnergy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoComponent_Stamina">();
	}
	static class UJunoComponent_Stamina* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoComponent_Stamina>();
	}
};
static_assert(alignof(UJunoComponent_Stamina) == 0x000008, "Wrong alignment on UJunoComponent_Stamina");
static_assert(sizeof(UJunoComponent_Stamina) == 0x0002F0, "Wrong size on UJunoComponent_Stamina");

// Class JunoGameNative.BlockOctreeManager
// 0x0168 (0x03F8 - 0x0290)
class ABlockOctreeManager final : public AInfo
{
public:
	int32                                         RelevancyRadius;                                   // 0x0290(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxISMCsToPopulateAFrame;                          // 0x0294(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderAllBricks;                                  // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0xA7];                                     // 0x0299(0x00A7)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UInstancedStaticMeshComponent*> CellIdToISMC;                                      // 0x0340(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          ISMC;                                              // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInstancedStaticMeshComponent*>  ISMCFreeList;                                      // 0x03A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Positions;                                         // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   Colors;                                            // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   RandomColors;                                      // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Towers(int32 Rows, int32 Cols);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockOctreeManager">();
	}
	static class ABlockOctreeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlockOctreeManager>();
	}
};
static_assert(alignof(ABlockOctreeManager) == 0x000008, "Wrong alignment on ABlockOctreeManager");
static_assert(sizeof(ABlockOctreeManager) == 0x0003F8, "Wrong size on ABlockOctreeManager");
static_assert(offsetof(ABlockOctreeManager, RelevancyRadius) == 0x000290, "Member 'ABlockOctreeManager::RelevancyRadius' has a wrong offset!");
static_assert(offsetof(ABlockOctreeManager, MaxISMCsToPopulateAFrame) == 0x000294, "Member 'ABlockOctreeManager::MaxISMCsToPopulateAFrame' has a wrong offset!");
static_assert(offsetof(ABlockOctreeManager, bRenderAllBricks) == 0x000298, "Member 'ABlockOctreeManager::bRenderAllBricks' has a wrong offset!");
static_assert(offsetof(ABlockOctreeManager, CellIdToISMC) == 0x000340, "Member 'ABlockOctreeManager::CellIdToISMC' has a wrong offset!");
static_assert(offsetof(ABlockOctreeManager, ISMC) == 0x0003A0, "Member 'ABlockOctreeManager::ISMC' has a wrong offset!");
static_assert(offsetof(ABlockOctreeManager, ISMCFreeList) == 0x0003A8, "Member 'ABlockOctreeManager::ISMCFreeList' has a wrong offset!");
static_assert(offsetof(ABlockOctreeManager, Positions) == 0x0003C8, "Member 'ABlockOctreeManager::Positions' has a wrong offset!");
static_assert(offsetof(ABlockOctreeManager, Colors) == 0x0003D8, "Member 'ABlockOctreeManager::Colors' has a wrong offset!");
static_assert(offsetof(ABlockOctreeManager, RandomColors) == 0x0003E8, "Member 'ABlockOctreeManager::RandomColors' has a wrong offset!");

// Class JunoGameNative.JunoConnectableActorInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoConnectableActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectableActorInterface">();
	}
	static class IJunoConnectableActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoConnectableActorInterface>();
	}
};
static_assert(alignof(IJunoConnectableActorInterface) == 0x000008, "Wrong alignment on IJunoConnectableActorInterface");
static_assert(sizeof(IJunoConnectableActorInterface) == 0x000028, "Wrong size on IJunoConnectableActorInterface");

// Class JunoGameNative.JunoWeatherPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoWeatherPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherPersistenceFeatureData_Container">();
	}
	static class UJunoWeatherPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeatherPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoWeatherPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoWeatherPersistenceFeatureData_Container");
static_assert(sizeof(UJunoWeatherPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoWeatherPersistenceFeatureData_Container");

// Class JunoGameNative.JunoConnectedActorLevelPlayspaceComponent
// 0x0000 (0x00F8 - 0x00F8)
class UJunoConnectedActorLevelPlayspaceComponent : public UFortPlayspaceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectedActorLevelPlayspaceComponent">();
	}
	static class UJunoConnectedActorLevelPlayspaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoConnectedActorLevelPlayspaceComponent>();
	}
};
static_assert(alignof(UJunoConnectedActorLevelPlayspaceComponent) == 0x000008, "Wrong alignment on UJunoConnectedActorLevelPlayspaceComponent");
static_assert(sizeof(UJunoConnectedActorLevelPlayspaceComponent) == 0x0000F8, "Wrong size on UJunoConnectedActorLevelPlayspaceComponent");

// Class JunoGameNative.JunoControllerComponent_AFKHandler
// 0x0068 (0x0138 - 0x00D0)
class UJunoControllerComponent_AFKHandler final : public UFortControllerComponent_AFKHandler
{
public:
	class UDataTable*                             AFKEventsDataTable;                                // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x60];                                      // 0x00D8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoControllerComponent_AFKHandler">();
	}
	static class UJunoControllerComponent_AFKHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoControllerComponent_AFKHandler>();
	}
};
static_assert(alignof(UJunoControllerComponent_AFKHandler) == 0x000008, "Wrong alignment on UJunoControllerComponent_AFKHandler");
static_assert(sizeof(UJunoControllerComponent_AFKHandler) == 0x000138, "Wrong size on UJunoControllerComponent_AFKHandler");
static_assert(offsetof(UJunoControllerComponent_AFKHandler, AFKEventsDataTable) == 0x0000D0, "Member 'UJunoControllerComponent_AFKHandler::AFKEventsDataTable' has a wrong offset!");

// Class JunoGameNative.JunoGlobals
// 0x0000 (0x0028 - 0x0028)
class UJunoGlobals final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGlobals">();
	}
	static class UJunoGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGlobals>();
	}
};
static_assert(alignof(UJunoGlobals) == 0x000008, "Wrong alignment on UJunoGlobals");
static_assert(sizeof(UJunoGlobals) == 0x000028, "Wrong size on UJunoGlobals");

// Class JunoGameNative.JunoWeaponCreatureItemDefinition
// 0x0020 (0x0CE0 - 0x0CC0)
class UJunoWeaponCreatureItemDefinition final : public UFortWeaponRangedItemDefinition
{
public:
	TArray<TSubclassOf<class UFortAthenaAISpawnerData>> Debug_CreaturesToSpawn;                            // 0x0CC0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            SpawnEvents;                                       // 0x0CD0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeaponCreatureItemDefinition">();
	}
	static class UJunoWeaponCreatureItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeaponCreatureItemDefinition>();
	}
};
static_assert(alignof(UJunoWeaponCreatureItemDefinition) == 0x000010, "Wrong alignment on UJunoWeaponCreatureItemDefinition");
static_assert(sizeof(UJunoWeaponCreatureItemDefinition) == 0x000CE0, "Wrong size on UJunoWeaponCreatureItemDefinition");
static_assert(offsetof(UJunoWeaponCreatureItemDefinition, Debug_CreaturesToSpawn) == 0x000CC0, "Member 'UJunoWeaponCreatureItemDefinition::Debug_CreaturesToSpawn' has a wrong offset!");
static_assert(offsetof(UJunoWeaponCreatureItemDefinition, SpawnEvents) == 0x000CD0, "Member 'UJunoWeaponCreatureItemDefinition::SpawnEvents' has a wrong offset!");

// Class JunoGameNative.JunoControllerComponent_Indicators
// 0x0100 (0x01A8 - 0x00A8)
class UJunoControllerComponent_Indicators final : public UFortControllerComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowDistance;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HideDistance;                                      // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AFortPawn*>                        VisiblePawnsCache;                                 // 0x00D0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FJunoIndicatorVisibilityQueryEntry> QueryToPawnEntries;                                // 0x0120(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x60];                                     // 0x0130(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuildingHealthBarDisplayMaxDuration;               // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ABuildingActor>          JunoBuildingActor;                                 // 0x0194(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19C[0xC];                                      // 0x019C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnyFortPawnDestroyed(class AActor* FortPawnActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoControllerComponent_Indicators">();
	}
	static class UJunoControllerComponent_Indicators* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoControllerComponent_Indicators>();
	}
};
static_assert(alignof(UJunoControllerComponent_Indicators) == 0x000008, "Wrong alignment on UJunoControllerComponent_Indicators");
static_assert(sizeof(UJunoControllerComponent_Indicators) == 0x0001A8, "Wrong size on UJunoControllerComponent_Indicators");
static_assert(offsetof(UJunoControllerComponent_Indicators, ShowDistance) == 0x0000B8, "Member 'UJunoControllerComponent_Indicators::ShowDistance' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent_Indicators, HideDistance) == 0x0000BC, "Member 'UJunoControllerComponent_Indicators::HideDistance' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent_Indicators, VisiblePawnsCache) == 0x0000D0, "Member 'UJunoControllerComponent_Indicators::VisiblePawnsCache' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent_Indicators, QueryToPawnEntries) == 0x000120, "Member 'UJunoControllerComponent_Indicators::QueryToPawnEntries' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent_Indicators, BuildingHealthBarDisplayMaxDuration) == 0x000190, "Member 'UJunoControllerComponent_Indicators::BuildingHealthBarDisplayMaxDuration' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent_Indicators, JunoBuildingActor) == 0x000194, "Member 'UJunoControllerComponent_Indicators::JunoBuildingActor' has a wrong offset!");

// Class JunoGameNative.JunoControllerComponent_MapMarker
// 0x0000 (0x00A8 - 0x00A8)
class UJunoControllerComponent_MapMarker final : public UFortControllerComponent
{
public:
	void ClientRequestCustomization(const struct FGuid& Guid, const struct FJunoMarker& NewMarker, const class FText& DisplayName);
	void ServerCreateMarker(const struct FGuid& Guid, const struct FJunoMarker& NewMarker, const class FText& DisplayName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoControllerComponent_MapMarker">();
	}
	static class UJunoControllerComponent_MapMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoControllerComponent_MapMarker>();
	}
};
static_assert(alignof(UJunoControllerComponent_MapMarker) == 0x000008, "Wrong alignment on UJunoControllerComponent_MapMarker");
static_assert(sizeof(UJunoControllerComponent_MapMarker) == 0x0000A8, "Wrong size on UJunoControllerComponent_MapMarker");

// Class JunoGameNative.JunoBuildLimitGetter
// 0x0000 (0x0028 - 0x0028)
class UJunoBuildLimitGetter : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildLimitGetter">();
	}
	static class UJunoBuildLimitGetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildLimitGetter>();
	}
};
static_assert(alignof(UJunoBuildLimitGetter) == 0x000008, "Wrong alignment on UJunoBuildLimitGetter");
static_assert(sizeof(UJunoBuildLimitGetter) == 0x000028, "Wrong size on UJunoBuildLimitGetter");

// Class JunoGameNative.JunoMarkersLimitPool
// 0x0000 (0x0028 - 0x0028)
class UJunoMarkersLimitPool final : public UJunoBuildLimitGetter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMarkersLimitPool">();
	}
	static class UJunoMarkersLimitPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMarkersLimitPool>();
	}
};
static_assert(alignof(UJunoMarkersLimitPool) == 0x000008, "Wrong alignment on UJunoMarkersLimitPool");
static_assert(sizeof(UJunoMarkersLimitPool) == 0x000028, "Wrong size on UJunoMarkersLimitPool");

// Class JunoGameNative.JunoControllerComponent_SocialSim
// 0x0010 (0x00B8 - 0x00A8)
class UJunoControllerComponent_SocialSim final : public UFortControllerComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnJunoPlayerPersistenceDataAvailable(const struct FUniqueNetIdRepl& UniquePlayerId, const struct FJunoPlayerSaveData& SaveData);
	void Server_TriggerAwesomeLevelChange(const class AFortPlayerController* TriggeringPlayer);
	void Server_TriggerVillageSelfDestruct();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoControllerComponent_SocialSim">();
	}
	static class UJunoControllerComponent_SocialSim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoControllerComponent_SocialSim>();
	}
};
static_assert(alignof(UJunoControllerComponent_SocialSim) == 0x000008, "Wrong alignment on UJunoControllerComponent_SocialSim");
static_assert(sizeof(UJunoControllerComponent_SocialSim) == 0x0000B8, "Wrong size on UJunoControllerComponent_SocialSim");

// Class JunoGameNative.JunoCraftingAnalytics
// 0x0000 (0x0028 - 0x0028)
class UJunoCraftingAnalytics final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCraftingAnalytics">();
	}
	static class UJunoCraftingAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCraftingAnalytics>();
	}
};
static_assert(alignof(UJunoCraftingAnalytics) == 0x000008, "Wrong alignment on UJunoCraftingAnalytics");
static_assert(sizeof(UJunoCraftingAnalytics) == 0x000028, "Wrong size on UJunoCraftingAnalytics");

// Class JunoGameNative.JunoMapMarkerCustomizationInitData
// 0x00C0 (0x00E8 - 0x0028)
class UJunoMapMarkerCustomizationInitData final : public UObject
{
public:
	struct FGuid                                  MarkerID;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJunoMarker                            NewMarker;                                         // 0x0038(0x0098)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x00D0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMapMarkerCustomizationInitData">();
	}
	static class UJunoMapMarkerCustomizationInitData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMapMarkerCustomizationInitData>();
	}
};
static_assert(alignof(UJunoMapMarkerCustomizationInitData) == 0x000008, "Wrong alignment on UJunoMapMarkerCustomizationInitData");
static_assert(sizeof(UJunoMapMarkerCustomizationInitData) == 0x0000E8, "Wrong size on UJunoMapMarkerCustomizationInitData");
static_assert(offsetof(UJunoMapMarkerCustomizationInitData, MarkerID) == 0x000028, "Member 'UJunoMapMarkerCustomizationInitData::MarkerID' has a wrong offset!");
static_assert(offsetof(UJunoMapMarkerCustomizationInitData, NewMarker) == 0x000038, "Member 'UJunoMapMarkerCustomizationInitData::NewMarker' has a wrong offset!");
static_assert(offsetof(UJunoMapMarkerCustomizationInitData, DisplayName) == 0x0000D0, "Member 'UJunoMapMarkerCustomizationInitData::DisplayName' has a wrong offset!");

// Class JunoGameNative.JunoCraftingGameplayAbility
// 0x0000 (0x0B60 - 0x0B60)
class UJunoCraftingGameplayAbility final : public UFortGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCraftingGameplayAbility">();
	}
	static class UJunoCraftingGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCraftingGameplayAbility>();
	}
};
static_assert(alignof(UJunoCraftingGameplayAbility) == 0x000008, "Wrong alignment on UJunoCraftingGameplayAbility");
static_assert(sizeof(UJunoCraftingGameplayAbility) == 0x000B60, "Wrong size on UJunoCraftingGameplayAbility");

// Class JunoGameNative.JunoInventoryComponent
// 0x0278 (0x0318 - 0x00A0)
class UJunoInventoryComponent : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x70];                                      // 0x00A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoInventoryConfig                   InventoryConfig;                                   // 0x0110(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FName                                   InventoryLootTierGroup;                            // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDropContentsOnOwnerDeath;                   // 0x012C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LootTossSpeed;                                     // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LootTossAngle;                                     // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoInventoryHandle                   InventoryHandle;                                   // 0x0138(0x0024)(Net, SaveGame, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FJunoItemSlotGroup> ItemSlotGroups;                                    // 0x0160(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FJunoReplicatedItemSlotList            ReplicatedItemSlotData;                            // 0x01B0(0x0128)(Net, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(TArray<class UFortItem*>& AddedItems, TArray<class UFortItem*>& RemovedItems)> OnInventoryChangedEvent;                           // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoSelectedSlotData>          SelectedItemGroupSlots;                            // 0x02F0(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFortItem* AddItemToInventory(const class UFortItemDefinition* ItemDefinition, int32 Count);
	void ClientMergeAllItemsPossibleComplete();
	void ClientMoveAllItemsPossibleComplete();
	const class UFortItem* GetOffhandItem();
	void OnOwningBuildingActorKilled(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnRep_InventoryHandle();
	bool RemoveItemFromInventory(const struct FGuid& ItemGuid, int32 Count);
	void ServerAttemptItemMerge(const struct FJunoItemSlot& SourceItemSlot, const struct FJunoItemSlot& DestinationItemSlot, class AActor* SourceInventoryActor, class AActor* DestinationInventoryActor, int32 Count);
	void ServerAttemptItemTransfer(const struct FJunoItemTransferRequest& Request);
	void ServerMergeAllItemsPossible(const class AActor* TargetInventoryActor);
	void ServerMoveAllItemsPossible(class UJunoInventoryComponent* SourceInventoryComponent, class UJunoInventoryComponent* DestinationInventoryComponent, const TArray<struct FGameplayTag>& SourceGroupTags, const TArray<struct FGameplayTag>& DestinationGroupTags);
	void ServerTakeItem(const struct FJunoTakeItemRequest& Request);
	void UseOffHandDurability(float DurabilityPerUse);

	TArray<class UFortWorldItem*> GetInventoryItems() const;
	TArray<class UFortWorldItem*> GetInventoryItemsInGroups(const TArray<struct FGameplayTag>& Groups) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryComponent">();
	}
	static class UJunoInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInventoryComponent>();
	}
};
static_assert(alignof(UJunoInventoryComponent) == 0x000008, "Wrong alignment on UJunoInventoryComponent");
static_assert(sizeof(UJunoInventoryComponent) == 0x000318, "Wrong size on UJunoInventoryComponent");
static_assert(offsetof(UJunoInventoryComponent, InventoryConfig) == 0x000110, "Member 'UJunoInventoryComponent::InventoryConfig' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, InventoryLootTierGroup) == 0x000128, "Member 'UJunoInventoryComponent::InventoryLootTierGroup' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, bShouldDropContentsOnOwnerDeath) == 0x00012C, "Member 'UJunoInventoryComponent::bShouldDropContentsOnOwnerDeath' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, LootTossSpeed) == 0x000130, "Member 'UJunoInventoryComponent::LootTossSpeed' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, LootTossAngle) == 0x000134, "Member 'UJunoInventoryComponent::LootTossAngle' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, InventoryHandle) == 0x000138, "Member 'UJunoInventoryComponent::InventoryHandle' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, ItemSlotGroups) == 0x000160, "Member 'UJunoInventoryComponent::ItemSlotGroups' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, ReplicatedItemSlotData) == 0x0001B0, "Member 'UJunoInventoryComponent::ReplicatedItemSlotData' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, OnInventoryChangedEvent) == 0x0002D8, "Member 'UJunoInventoryComponent::OnInventoryChangedEvent' has a wrong offset!");
static_assert(offsetof(UJunoInventoryComponent, SelectedItemGroupSlots) == 0x0002F0, "Member 'UJunoInventoryComponent::SelectedItemGroupSlots' has a wrong offset!");

// Class JunoGameNative.JunoMeshNetworkWeatherComponent
// 0x0058 (0x01A8 - 0x0150)
class UJunoMeshNetworkWeatherComponent final : public UMeshNetworkComponent
{
public:
	TArray<struct FJunoSynchronizedWeatherState>  SynchronizedWeatherStates;                         // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x48];                                     // 0x0160(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OnSynchronizedWeatherStates();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMeshNetworkWeatherComponent">();
	}
	static class UJunoMeshNetworkWeatherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMeshNetworkWeatherComponent>();
	}
};
static_assert(alignof(UJunoMeshNetworkWeatherComponent) == 0x000008, "Wrong alignment on UJunoMeshNetworkWeatherComponent");
static_assert(sizeof(UJunoMeshNetworkWeatherComponent) == 0x0001A8, "Wrong size on UJunoMeshNetworkWeatherComponent");
static_assert(offsetof(UJunoMeshNetworkWeatherComponent, SynchronizedWeatherStates) == 0x000150, "Member 'UJunoMeshNetworkWeatherComponent::SynchronizedWeatherStates' has a wrong offset!");

// Class JunoGameNative.JunoCraftingInventoryComponent
// 0x0000 (0x0318 - 0x0318)
class UJunoCraftingInventoryComponent final : public UJunoInventoryComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCraftingInventoryComponent">();
	}
	static class UJunoCraftingInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCraftingInventoryComponent>();
	}
};
static_assert(alignof(UJunoCraftingInventoryComponent) == 0x000008, "Wrong alignment on UJunoCraftingInventoryComponent");
static_assert(sizeof(UJunoCraftingInventoryComponent) == 0x000318, "Wrong size on UJunoCraftingInventoryComponent");

// Class JunoGameNative.JunoCraftingLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoCraftingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> FindRecipesCraftableFrom(const class UObject* WorldContextObject, const TArray<struct FItemAndCount>& Ingredients);
	static struct FCraftingMultiKey MakePerPlayerCraftingKey(const class AActor* Instigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCraftingLibrary">();
	}
	static class UJunoCraftingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCraftingLibrary>();
	}
};
static_assert(alignof(UJunoCraftingLibrary) == 0x000008, "Wrong alignment on UJunoCraftingLibrary");
static_assert(sizeof(UJunoCraftingLibrary) == 0x000028, "Wrong size on UJunoCraftingLibrary");

// Class JunoGameNative.JunoMapManagerComponent
// 0x0180 (0x0278 - 0x00F8)
class UJunoMapManagerComponent final : public UFortPlayspaceComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExploredRadius;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x14];                                     // 0x0104(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapExplorationData                    MapExplorationData;                                // 0x0118(0x0120)(Net, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDisplayableTile*>               DisplayableTiles;                                  // 0x0238(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FJunoTileInfo>                  LoadedTiles;                                       // 0x0248(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UTexture2D*                             ClearedFogMask;                                    // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture2D* GetFOWForTile(const int32 TileId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMapManagerComponent">();
	}
	static class UJunoMapManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMapManagerComponent>();
	}
};
static_assert(alignof(UJunoMapManagerComponent) == 0x000008, "Wrong alignment on UJunoMapManagerComponent");
static_assert(sizeof(UJunoMapManagerComponent) == 0x000278, "Wrong size on UJunoMapManagerComponent");
static_assert(offsetof(UJunoMapManagerComponent, ExploredRadius) == 0x000100, "Member 'UJunoMapManagerComponent::ExploredRadius' has a wrong offset!");
static_assert(offsetof(UJunoMapManagerComponent, MapExplorationData) == 0x000118, "Member 'UJunoMapManagerComponent::MapExplorationData' has a wrong offset!");
static_assert(offsetof(UJunoMapManagerComponent, DisplayableTiles) == 0x000238, "Member 'UJunoMapManagerComponent::DisplayableTiles' has a wrong offset!");
static_assert(offsetof(UJunoMapManagerComponent, LoadedTiles) == 0x000248, "Member 'UJunoMapManagerComponent::LoadedTiles' has a wrong offset!");
static_assert(offsetof(UJunoMapManagerComponent, ClearedFogMask) == 0x000258, "Member 'UJunoMapManagerComponent::ClearedFogMask' has a wrong offset!");

// Class JunoGameNative.JunoDeleteActionsReportHandler
// 0x0018 (0x0040 - 0x0028)
class UJunoDeleteActionsReportHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDeleteActionsReportHandler">();
	}
	static class UJunoDeleteActionsReportHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDeleteActionsReportHandler>();
	}
};
static_assert(alignof(UJunoDeleteActionsReportHandler) == 0x000008, "Wrong alignment on UJunoDeleteActionsReportHandler");
static_assert(sizeof(UJunoDeleteActionsReportHandler) == 0x000040, "Wrong size on UJunoDeleteActionsReportHandler");

// Class JunoGameNative.JunoDeltasSaveHandler
// 0x00F0 (0x0118 - 0x0028)
class UJunoDeltasSaveHandler final : public UObject
{
public:
	uint8                                         Pad_28[0xE8];                                      // 0x0028(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UDeltaFileSaveHandler*                  SaveHandler;                                       // 0x0110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDeltasSaveHandler">();
	}
	static class UJunoDeltasSaveHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDeltasSaveHandler>();
	}
};
static_assert(alignof(UJunoDeltasSaveHandler) == 0x000008, "Wrong alignment on UJunoDeltasSaveHandler");
static_assert(sizeof(UJunoDeltasSaveHandler) == 0x000118, "Wrong size on UJunoDeltasSaveHandler");
static_assert(offsetof(UJunoDeltasSaveHandler, SaveHandler) == 0x000110, "Member 'UJunoDeltasSaveHandler::SaveHandler' has a wrong offset!");

// Class JunoGameNative.JunoWorldSettingsPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoWorldSettingsPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldSettingsPersistenceFeatureModule">();
	}
	static class UJunoWorldSettingsPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldSettingsPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoWorldSettingsPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoWorldSettingsPersistenceFeatureModule");
static_assert(sizeof(UJunoWorldSettingsPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoWorldSettingsPersistenceFeatureModule");

// Class JunoGameNative.JunoDestructionBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoDestructionBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FGeometryCollectionSource> GetGeometryCollectionSource(class UAtomModel* AtomModel, class FName SelectionSetFilter);
	static void SetGeometryCollectionMaterialForInstancedMeshes(class UGeometryCollection* GeometryCollection, class UMaterialInterface* OpaqueMaterial, class UMaterialInterface* TransparentMaterial, class UMaterialInterface* GlitterMaterial, class UMaterialInterface* OpalMaterial, class UMaterialInterface* InternalGlowMaterial);
	static void SetGeometryCollectionSourceFromAtomModel(class UGeometryCollection* GeometryCollection, class UAtomModel* AtomModel, class FName SelectionSetFilter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDestructionBlueprintLibrary">();
	}
	static class UJunoDestructionBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDestructionBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoDestructionBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoDestructionBlueprintLibrary");
static_assert(sizeof(UJunoDestructionBlueprintLibrary) == 0x000028, "Wrong size on UJunoDestructionBlueprintLibrary");

// Class JunoGameNative.JunoDumpWorldPersistentContents
// 0x0000 (0x0028 - 0x0028)
class IJunoDumpWorldPersistentContents final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDumpWorldPersistentContents">();
	}
	static class IJunoDumpWorldPersistentContents* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoDumpWorldPersistentContents>();
	}
};
static_assert(alignof(IJunoDumpWorldPersistentContents) == 0x000008, "Wrong alignment on IJunoDumpWorldPersistentContents");
static_assert(sizeof(IJunoDumpWorldPersistentContents) == 0x000028, "Wrong size on IJunoDumpWorldPersistentContents");

// Class JunoGameNative.JunoAwesomeSystemDatabaseComponent
// 0x0018 (0x0110 - 0x00F8)
class UJunoAwesomeSystemDatabaseComponent final : public UFortPlayspaceComponent
{
public:
	class UJunoAwesomeInteractionConfigMappings*  InteractionConfigMappings;                         // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJunoAwesomePlacementConfigMappings*    PlacementConfigMappings;                           // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJunoAwesomePoiConfigMappings*          PoiConfigMappings;                                 // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAwesomeSystemDatabaseComponent">();
	}
	static class UJunoAwesomeSystemDatabaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAwesomeSystemDatabaseComponent>();
	}
};
static_assert(alignof(UJunoAwesomeSystemDatabaseComponent) == 0x000008, "Wrong alignment on UJunoAwesomeSystemDatabaseComponent");
static_assert(sizeof(UJunoAwesomeSystemDatabaseComponent) == 0x000110, "Wrong size on UJunoAwesomeSystemDatabaseComponent");
static_assert(offsetof(UJunoAwesomeSystemDatabaseComponent, InteractionConfigMappings) == 0x0000F8, "Member 'UJunoAwesomeSystemDatabaseComponent::InteractionConfigMappings' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeSystemDatabaseComponent, PlacementConfigMappings) == 0x000100, "Member 'UJunoAwesomeSystemDatabaseComponent::PlacementConfigMappings' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeSystemDatabaseComponent, PoiConfigMappings) == 0x000108, "Member 'UJunoAwesomeSystemDatabaseComponent::PoiConfigMappings' has a wrong offset!");

// Class JunoGameNative.JunoEncounterCheatInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoEncounterCheatInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoEncounterCheatInterface">();
	}
	static class IJunoEncounterCheatInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoEncounterCheatInterface>();
	}
};
static_assert(alignof(IJunoEncounterCheatInterface) == 0x000008, "Wrong alignment on IJunoEncounterCheatInterface");
static_assert(sizeof(IJunoEncounterCheatInterface) == 0x000028, "Wrong size on IJunoEncounterCheatInterface");

// Class JunoGameNative.JunoEssenceLevelComponent
// 0x0000 (0x00A0 - 0x00A0)
class UJunoEssenceLevelComponent final : public UFortWeaponComponent
{
public:
	void OnEquip(class AFortWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoEssenceLevelComponent">();
	}
	static class UJunoEssenceLevelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoEssenceLevelComponent>();
	}
};
static_assert(alignof(UJunoEssenceLevelComponent) == 0x000008, "Wrong alignment on UJunoEssenceLevelComponent");
static_assert(sizeof(UJunoEssenceLevelComponent) == 0x0000A0, "Wrong size on UJunoEssenceLevelComponent");

// Class JunoGameNative.PhysicalStrainHealthRuntimeSettings
// 0x0010 (0x0040 - 0x0030)
class UPhysicalStrainHealthRuntimeSettings final : public UDeveloperSettings
{
public:
	EPhysicalStrainHealthMode                     Mode;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FatigueDamageThresholdPercent;                     // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatigueDamageThresholdMinimum;                     // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalStrainHealthRuntimeSettings">();
	}
	static class UPhysicalStrainHealthRuntimeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalStrainHealthRuntimeSettings>();
	}
};
static_assert(alignof(UPhysicalStrainHealthRuntimeSettings) == 0x000008, "Wrong alignment on UPhysicalStrainHealthRuntimeSettings");
static_assert(sizeof(UPhysicalStrainHealthRuntimeSettings) == 0x000040, "Wrong size on UPhysicalStrainHealthRuntimeSettings");
static_assert(offsetof(UPhysicalStrainHealthRuntimeSettings, Mode) == 0x000030, "Member 'UPhysicalStrainHealthRuntimeSettings::Mode' has a wrong offset!");
static_assert(offsetof(UPhysicalStrainHealthRuntimeSettings, FatigueDamageThresholdPercent) == 0x000034, "Member 'UPhysicalStrainHealthRuntimeSettings::FatigueDamageThresholdPercent' has a wrong offset!");
static_assert(offsetof(UPhysicalStrainHealthRuntimeSettings, FatigueDamageThresholdMinimum) == 0x000038, "Member 'UPhysicalStrainHealthRuntimeSettings::FatigueDamageThresholdMinimum' has a wrong offset!");

// Class JunoGameNative.JunoEventLimiterInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoEventLimiterInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoEventLimiterInterface">();
	}
	static class IJunoEventLimiterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoEventLimiterInterface>();
	}
};
static_assert(alignof(IJunoEventLimiterInterface) == 0x000008, "Wrong alignment on IJunoEventLimiterInterface");
static_assert(sizeof(IJunoEventLimiterInterface) == 0x000028, "Wrong size on IJunoEventLimiterInterface");

// Class JunoGameNative.JunoEventRouterLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoEventRouterLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UGameplayEventRouterComponent* GetGameplayEventRouter(class AActor* ContextActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoEventRouterLibrary">();
	}
	static class UJunoEventRouterLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoEventRouterLibrary>();
	}
};
static_assert(alignof(UJunoEventRouterLibrary) == 0x000008, "Wrong alignment on UJunoEventRouterLibrary");
static_assert(sizeof(UJunoEventRouterLibrary) == 0x000028, "Wrong size on UJunoEventRouterLibrary");

// Class JunoGameNative.JunoWorldSettingsComponent
// 0x0030 (0x00D0 - 0x00A0)
class UJunoWorldSettingsComponent final : public UPlayspaceComponent
{
public:
	TArray<struct FJunoWorldSettingMapping>       OptionalSettingNames;                              // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FJunoWorldSettingRepState>      WorldSettings;                                     // 0x00B0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_WorldSettings(const TArray<struct FJunoWorldSettingRepState>& OldValue);
	void TurnSettingOff(const struct FGameplayTag& SettingName);
	void TurnSettingOn(const struct FGameplayTag& SettingName);

	TArray<struct FGameplayTag> GetAllSettingNames() const;
	bool IsSettingOn(const struct FGameplayTag& SettingName) const;
	bool IsSettingSaved(const struct FGameplayTag& SettingName) const;
	bool IsSettingTainted(const struct FGameplayTag& SettingName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldSettingsComponent">();
	}
	static class UJunoWorldSettingsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldSettingsComponent>();
	}
};
static_assert(alignof(UJunoWorldSettingsComponent) == 0x000008, "Wrong alignment on UJunoWorldSettingsComponent");
static_assert(sizeof(UJunoWorldSettingsComponent) == 0x0000D0, "Wrong size on UJunoWorldSettingsComponent");
static_assert(offsetof(UJunoWorldSettingsComponent, OptionalSettingNames) == 0x0000A0, "Member 'UJunoWorldSettingsComponent::OptionalSettingNames' has a wrong offset!");
static_assert(offsetof(UJunoWorldSettingsComponent, WorldSettings) == 0x0000B0, "Member 'UJunoWorldSettingsComponent::WorldSettings' has a wrong offset!");

// Class JunoGameNative.JunoExampleMacroGenerated_CheatTestSetup
// 0x0048 (0x0078 - 0x0030)
class UJunoExampleMacroGenerated_CheatTestSetup final : public UPFWCheatTestSetup
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoExample_InGameClass*               InGameClass;                                       // 0x0068(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoExampleMacroGenerated_CheatTestSetup">();
	}
	static class UJunoExampleMacroGenerated_CheatTestSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoExampleMacroGenerated_CheatTestSetup>();
	}
};
static_assert(alignof(UJunoExampleMacroGenerated_CheatTestSetup) == 0x000008, "Wrong alignment on UJunoExampleMacroGenerated_CheatTestSetup");
static_assert(sizeof(UJunoExampleMacroGenerated_CheatTestSetup) == 0x000078, "Wrong size on UJunoExampleMacroGenerated_CheatTestSetup");
static_assert(offsetof(UJunoExampleMacroGenerated_CheatTestSetup, InGameClass) == 0x000068, "Member 'UJunoExampleMacroGenerated_CheatTestSetup::InGameClass' has a wrong offset!");

// Class JunoGameNative.JunoExampleMacroGenerated_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoExampleMacroGenerated_Container final : public UJunoBasePFWContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoExampleMacroGenerated_Container">();
	}
	static class UJunoExampleMacroGenerated_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoExampleMacroGenerated_Container>();
	}
};
static_assert(alignof(UJunoExampleMacroGenerated_Container) == 0x000008, "Wrong alignment on UJunoExampleMacroGenerated_Container");
static_assert(sizeof(UJunoExampleMacroGenerated_Container) == 0x0001E0, "Wrong size on UJunoExampleMacroGenerated_Container");

// Class JunoGameNative.JunoAwesomePlacementConfigMappings
// 0x0100 (0x0130 - 0x0030)
class UJunoAwesomePlacementConfigMappings final : public UDataAsset
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             PlacementConfigTable;                              // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x50];                                      // 0x00D8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             CategoryConfigTable;                               // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAwesomePlacementConfigMappings">();
	}
	static class UJunoAwesomePlacementConfigMappings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAwesomePlacementConfigMappings>();
	}
};
static_assert(alignof(UJunoAwesomePlacementConfigMappings) == 0x000008, "Wrong alignment on UJunoAwesomePlacementConfigMappings");
static_assert(sizeof(UJunoAwesomePlacementConfigMappings) == 0x000130, "Wrong size on UJunoAwesomePlacementConfigMappings");
static_assert(offsetof(UJunoAwesomePlacementConfigMappings, PlacementConfigTable) == 0x0000D0, "Member 'UJunoAwesomePlacementConfigMappings::PlacementConfigTable' has a wrong offset!");
static_assert(offsetof(UJunoAwesomePlacementConfigMappings, CategoryConfigTable) == 0x000128, "Member 'UJunoAwesomePlacementConfigMappings::CategoryConfigTable' has a wrong offset!");

// Class JunoGameNative.JunoExample_CheatTestSetup
// 0x0048 (0x0078 - 0x0030)
class UJunoExample_CheatTestSetup final : public UPFWCheatTestSetup
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoExample_InGameClass*               InGameClass;                                       // 0x0068(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoExample_CheatTestSetup">();
	}
	static class UJunoExample_CheatTestSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoExample_CheatTestSetup>();
	}
};
static_assert(alignof(UJunoExample_CheatTestSetup) == 0x000008, "Wrong alignment on UJunoExample_CheatTestSetup");
static_assert(sizeof(UJunoExample_CheatTestSetup) == 0x000078, "Wrong size on UJunoExample_CheatTestSetup");
static_assert(offsetof(UJunoExample_CheatTestSetup, InGameClass) == 0x000068, "Member 'UJunoExample_CheatTestSetup::InGameClass' has a wrong offset!");

// Class JunoGameNative.JunoExample_Container
// 0x0008 (0x01E8 - 0x01E0)
class UJunoExample_Container final : public UJunoBasePFWContainer
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoExample_Container">();
	}
	static class UJunoExample_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoExample_Container>();
	}
};
static_assert(alignof(UJunoExample_Container) == 0x000008, "Wrong alignment on UJunoExample_Container");
static_assert(sizeof(UJunoExample_Container) == 0x0001E8, "Wrong size on UJunoExample_Container");

// Class JunoGameNative.JunoQuestActorSpawnPoint
// 0x0020 (0x02B0 - 0x0290)
class AJunoQuestActorSpawnPoint final : public AActor
{
public:
	struct FGameplayTagContainer                  SpawnTags;                                         // 0x0290(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoQuestActorSpawnPoint">();
	}
	static class AJunoQuestActorSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoQuestActorSpawnPoint>();
	}
};
static_assert(alignof(AJunoQuestActorSpawnPoint) == 0x000008, "Wrong alignment on AJunoQuestActorSpawnPoint");
static_assert(sizeof(AJunoQuestActorSpawnPoint) == 0x0002B0, "Wrong size on AJunoQuestActorSpawnPoint");
static_assert(offsetof(AJunoQuestActorSpawnPoint, SpawnTags) == 0x000290, "Member 'AJunoQuestActorSpawnPoint::SpawnTags' has a wrong offset!");

// Class JunoGameNative.JunoExample_InGameClass
// 0x0008 (0x0030 - 0x0028)
class UJunoExample_InGameClass final : public UObject
{
public:
	int32                                         PersistentData;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransientData;                                     // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoExample_InGameClass">();
	}
	static class UJunoExample_InGameClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoExample_InGameClass>();
	}
};
static_assert(alignof(UJunoExample_InGameClass) == 0x000008, "Wrong alignment on UJunoExample_InGameClass");
static_assert(sizeof(UJunoExample_InGameClass) == 0x000030, "Wrong size on UJunoExample_InGameClass");
static_assert(offsetof(UJunoExample_InGameClass, PersistentData) == 0x000028, "Member 'UJunoExample_InGameClass::PersistentData' has a wrong offset!");
static_assert(offsetof(UJunoExample_InGameClass, TransientData) == 0x00002C, "Member 'UJunoExample_InGameClass::TransientData' has a wrong offset!");

// Class JunoGameNative.JunoExample_Module
// 0x0000 (0x00E0 - 0x00E0)
class UJunoExample_Module final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoExample_Module">();
	}
	static class UJunoExample_Module* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoExample_Module>();
	}
};
static_assert(alignof(UJunoExample_Module) == 0x000008, "Wrong alignment on UJunoExample_Module");
static_assert(sizeof(UJunoExample_Module) == 0x0000E0, "Wrong size on UJunoExample_Module");

// Class JunoGameNative.JunoAwesomeLevelComponent
// 0x0150 (0x01F0 - 0x00A0)
class UJunoAwesomeLevelComponent final : public UJunoCampComponentBase
{
public:
	TMulticastInlineDelegate<void(struct FJunoAwesomeLevelChangeData& ChangeData)> OnJunoAwesomeLevelChangedDelegate;                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FJunoAwesomePointModificationData& ModificationData)> OnJunoAwesomePointModification;                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FJunoCampAwesomeStatsData& AwesomeData)> OnJunoAwesomeComponentReadyDelegate;               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         AwesomeLevel;                                      // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAwesomePoints;                              // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x50];                                      // 0x00D8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AwesomePointGoals;                                 // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJunoAwesomeUpgradeResourceCostList> AwesomeUpgradeResourceCosts;                       // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FJunoAwesomeUpgradeResourceCostList    CurrentUpgradeResourceCosts;                       // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PoiType;                                           // 0x0158(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJunoBiome                                    CampBiomeType;                                     // 0x015C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15D[0x13];                                     // 0x015D(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReadyForUse;                                    // 0x0170(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFromPersistence;                                // 0x0171(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_172[0x26];                                     // 0x0172(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoAwesomePointModificationData      CachedAwesomePointModificationData;                // 0x0198(0x0028)(Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoAwesomeLevelChangeData            CachedAwesomeLevelChangeData;                      // 0x01C0(0x0018)(Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bSkipAwesomeUpgradeResourceChecks;                 // 0x01D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAwesomeLevelRewardEntry>       AwesomeLevelRewardEntries;                         // 0x01E0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BP_OnAwesomeLevelChanged(const struct FJunoAwesomeLevelChangeData& ChangeData);
	void BP_OnAwesomePointsModified(const struct FJunoAwesomePointModificationData& ModificationData);
	void OnAwesomeSettingsInitialized();
	void OnRep_AwesomeLevel();
	void OnRep_bIsReadyForUse();
	void OnRep_CurrentAwesomePoints();
	bool ProcessAwesomePointModifierCheat(int32 AwesomePointAmount, class AActor* SourceActor);
	void TriggerAwesomeLevelChange(const class AFortPlayerController* TriggeringPlayer);

	int32 GetAwesomeLevel() const;
	int32 GetAwesomeLevelFromCurrentPoints() const;
	const TArray<struct FAwesomeLevelRewardEntry> GetAwesomeLevelRewardEntries() const;
	int32 GetAwesomePoints() const;
	int32 GetAwesomePointsNeededForNextLevel() const;
	EJunoBiome GetBiomeType() const;
	int32 GetCurrentAwesomePointFloor() const;
	int32 GetCurrentAwesomePointGoal() const;
	const struct FJunoAwesomeUpgradeResourceCostList GetCurrentUpgradeResourceCosts() const;
	int32 GetMaxAwesomeIndex() const;
	int32 GetMaxAwesomeLevel() const;
	bool HasEnoughAwesomePointsForALevelUp() const;
	EJunoAwesomeLevelUpgradeQueryResult IsAwesomeLevelUpPending(const class AFortPlayerController* TriggeringPlayer) const;
	bool IsReadyForUse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAwesomeLevelComponent">();
	}
	static class UJunoAwesomeLevelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAwesomeLevelComponent>();
	}
};
static_assert(alignof(UJunoAwesomeLevelComponent) == 0x000008, "Wrong alignment on UJunoAwesomeLevelComponent");
static_assert(sizeof(UJunoAwesomeLevelComponent) == 0x0001F0, "Wrong size on UJunoAwesomeLevelComponent");
static_assert(offsetof(UJunoAwesomeLevelComponent, OnJunoAwesomeLevelChangedDelegate) == 0x0000A0, "Member 'UJunoAwesomeLevelComponent::OnJunoAwesomeLevelChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, OnJunoAwesomePointModification) == 0x0000B0, "Member 'UJunoAwesomeLevelComponent::OnJunoAwesomePointModification' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, OnJunoAwesomeComponentReadyDelegate) == 0x0000C0, "Member 'UJunoAwesomeLevelComponent::OnJunoAwesomeComponentReadyDelegate' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, AwesomeLevel) == 0x0000D0, "Member 'UJunoAwesomeLevelComponent::AwesomeLevel' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, CurrentAwesomePoints) == 0x0000D4, "Member 'UJunoAwesomeLevelComponent::CurrentAwesomePoints' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, AwesomePointGoals) == 0x000128, "Member 'UJunoAwesomeLevelComponent::AwesomePointGoals' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, AwesomeUpgradeResourceCosts) == 0x000138, "Member 'UJunoAwesomeLevelComponent::AwesomeUpgradeResourceCosts' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, CurrentUpgradeResourceCosts) == 0x000148, "Member 'UJunoAwesomeLevelComponent::CurrentUpgradeResourceCosts' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, PoiType) == 0x000158, "Member 'UJunoAwesomeLevelComponent::PoiType' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, CampBiomeType) == 0x00015C, "Member 'UJunoAwesomeLevelComponent::CampBiomeType' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, bIsReadyForUse) == 0x000170, "Member 'UJunoAwesomeLevelComponent::bIsReadyForUse' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, bIsFromPersistence) == 0x000171, "Member 'UJunoAwesomeLevelComponent::bIsFromPersistence' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, CachedAwesomePointModificationData) == 0x000198, "Member 'UJunoAwesomeLevelComponent::CachedAwesomePointModificationData' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, CachedAwesomeLevelChangeData) == 0x0001C0, "Member 'UJunoAwesomeLevelComponent::CachedAwesomeLevelChangeData' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, bSkipAwesomeUpgradeResourceChecks) == 0x0001D8, "Member 'UJunoAwesomeLevelComponent::bSkipAwesomeUpgradeResourceChecks' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeLevelComponent, AwesomeLevelRewardEntries) == 0x0001E0, "Member 'UJunoAwesomeLevelComponent::AwesomeLevelRewardEntries' has a wrong offset!");

// Class JunoGameNative.JunoFilteredEventContextCollector
// 0x0000 (0x0028 - 0x0028)
class UJunoFilteredEventContextCollector final : public UFilteredEventContextCollectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFilteredEventContextCollector">();
	}
	static class UJunoFilteredEventContextCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFilteredEventContextCollector>();
	}
};
static_assert(alignof(UJunoFilteredEventContextCollector) == 0x000008, "Wrong alignment on UJunoFilteredEventContextCollector");
static_assert(sizeof(UJunoFilteredEventContextCollector) == 0x000028, "Wrong size on UJunoFilteredEventContextCollector");

// Class JunoGameNative.JunoFogOfWarPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoFogOfWarPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFogOfWarPersistenceFeatureModule">();
	}
	static class UJunoFogOfWarPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFogOfWarPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoFogOfWarPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoFogOfWarPersistenceFeatureModule");
static_assert(sizeof(UJunoFogOfWarPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoFogOfWarPersistenceFeatureModule");

// Class JunoGameNative.PlayspaceComponent_JunoRootCampManagement
// 0x04D8 (0x05D0 - 0x00F8)
class UPlayspaceComponent_JunoRootCampManagement final : public UFortPlayspaceComponent
{
public:
	struct FScalableFloat                         TimeBeforeSoftRemovedCampBecomesHardRemovedInJunoGameTimeHours; // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RunValidityChecksForCampPlacementOnServer;         // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RunValidityChecksForCampPlacementOnClients;        // 0x0148(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BoxExtentsForCampValidityCheck;                    // 0x0170(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BoxExtentsForCampValidityCheckForPOIs;             // 0x0198(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MoveCampWhenNewSquareIsAddedAfterSoftRemoval;      // 0x01C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UDataTable*>                PlayerPerksPerAwesomenessLevel;                    // 0x01E8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<int32, class UDataTable*>                NPCPerksPerAwesomenessLevel;                       // 0x0238(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EJunoBiome, class UDataTable*>           NPCPerksPerBiome;                                  // 0x0288(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoAsyncAction_WaitForEventRouter*    WaitForEventRouterAction;                          // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReplicatedCampData>            ReplicatedCampDatas;                               // 0x0320(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x150];                                    // 0x0330(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPOIEncounterDataForCamps>      LoadedPOIEncounters;                               // 0x0480(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x140];                                    // 0x0490(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlayspaceComponent_JunoRootCampManagement* GetRootPlayspaceJunoCampManagementComponent(const class UObject* WorldContextObject);

	bool IsAValidLocationForANewCamp(const struct FVector& Location, struct FGameplayTagContainer* OutFailureReasons) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceComponent_JunoRootCampManagement">();
	}
	static class UPlayspaceComponent_JunoRootCampManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceComponent_JunoRootCampManagement>();
	}
};
static_assert(alignof(UPlayspaceComponent_JunoRootCampManagement) == 0x000008, "Wrong alignment on UPlayspaceComponent_JunoRootCampManagement");
static_assert(sizeof(UPlayspaceComponent_JunoRootCampManagement) == 0x0005D0, "Wrong size on UPlayspaceComponent_JunoRootCampManagement");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, TimeBeforeSoftRemovedCampBecomesHardRemovedInJunoGameTimeHours) == 0x0000F8, "Member 'UPlayspaceComponent_JunoRootCampManagement::TimeBeforeSoftRemovedCampBecomesHardRemovedInJunoGameTimeHours' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, RunValidityChecksForCampPlacementOnServer) == 0x000120, "Member 'UPlayspaceComponent_JunoRootCampManagement::RunValidityChecksForCampPlacementOnServer' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, RunValidityChecksForCampPlacementOnClients) == 0x000148, "Member 'UPlayspaceComponent_JunoRootCampManagement::RunValidityChecksForCampPlacementOnClients' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, BoxExtentsForCampValidityCheck) == 0x000170, "Member 'UPlayspaceComponent_JunoRootCampManagement::BoxExtentsForCampValidityCheck' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, BoxExtentsForCampValidityCheckForPOIs) == 0x000198, "Member 'UPlayspaceComponent_JunoRootCampManagement::BoxExtentsForCampValidityCheckForPOIs' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, MoveCampWhenNewSquareIsAddedAfterSoftRemoval) == 0x0001C0, "Member 'UPlayspaceComponent_JunoRootCampManagement::MoveCampWhenNewSquareIsAddedAfterSoftRemoval' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, PlayerPerksPerAwesomenessLevel) == 0x0001E8, "Member 'UPlayspaceComponent_JunoRootCampManagement::PlayerPerksPerAwesomenessLevel' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, NPCPerksPerAwesomenessLevel) == 0x000238, "Member 'UPlayspaceComponent_JunoRootCampManagement::NPCPerksPerAwesomenessLevel' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, NPCPerksPerBiome) == 0x000288, "Member 'UPlayspaceComponent_JunoRootCampManagement::NPCPerksPerBiome' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, WaitForEventRouterAction) == 0x000308, "Member 'UPlayspaceComponent_JunoRootCampManagement::WaitForEventRouterAction' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, ReplicatedCampDatas) == 0x000320, "Member 'UPlayspaceComponent_JunoRootCampManagement::ReplicatedCampDatas' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoRootCampManagement, LoadedPOIEncounters) == 0x000480, "Member 'UPlayspaceComponent_JunoRootCampManagement::LoadedPOIEncounters' has a wrong offset!");

// Class JunoGameNative.JunoFogOfWarPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoFogOfWarPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFogOfWarPersistenceFeatureData_Container">();
	}
	static class UJunoFogOfWarPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFogOfWarPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoFogOfWarPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoFogOfWarPersistenceFeatureData_Container");
static_assert(sizeof(UJunoFogOfWarPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoFogOfWarPersistenceFeatureData_Container");

// Class JunoGameNative.JunoFreeBuildBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoFreeBuildBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static const class UFortItemDefinition* GetFreeBuildSpawnableItemDefinition(const class UObject* WorldContextObject, const class FName& Name_0);
	static TArray<class FName> GetFreeBuildSpawnableItems(const class UObject* WorldContextObject);
	static bool IsFreeBuildCostFilteringEnabled(const class UObject* WorldContextObject);
	static bool IsFreeBuildEnabled(const class UObject* WorldContextObject);
	static bool IsItemSpawnerEnabled(const class UObject* WorldContextObject);
	static bool IsPlayerAllowedToFly(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFreeBuildBlueprintLibrary">();
	}
	static class UJunoFreeBuildBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFreeBuildBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoFreeBuildBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoFreeBuildBlueprintLibrary");
static_assert(sizeof(UJunoFreeBuildBlueprintLibrary) == 0x000028, "Wrong size on UJunoFreeBuildBlueprintLibrary");

// Class JunoGameNative.JunoCampPersistenceFeatureDataActor
// 0x0018 (0x02E8 - 0x02D0)
class AJunoCampPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoCampSaveData>              SavedCamps;                                        // 0x02D8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampPersistenceFeatureDataActor">();
	}
	static class AJunoCampPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoCampPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoCampPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoCampPersistenceFeatureDataActor");
static_assert(sizeof(AJunoCampPersistenceFeatureDataActor) == 0x0002E8, "Wrong size on AJunoCampPersistenceFeatureDataActor");
static_assert(offsetof(AJunoCampPersistenceFeatureDataActor, SavedCamps) == 0x0002D8, "Member 'AJunoCampPersistenceFeatureDataActor::SavedCamps' has a wrong offset!");

// Class JunoGameNative.JunoFreeBuildComponent
// 0x0030 (0x00D0 - 0x00A0)
class UJunoFreeBuildComponent final : public UGameFrameworkComponent
{
public:
	struct FDataRegistryType                      SpawnableItemsRegistryType;                        // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFreeBuildEnabled;                               // 0x00A4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsItemSpawnerEnabled;                             // 0x00A5(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPlayerAllowedToFly;                             // 0x00A6(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFreeBuildCostFilteringEnabled;                  // 0x00A7(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasFreeBuildEverEnabled;                          // 0x00A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x27];                                      // 0x00A9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableFreeBuild();
	void EnableFreeBuild();
	void OnPlaylistDataReady(class AFortGameStateAthena* GameState, const class UFortPlaylist* Playlist, const struct FGameplayTagContainer& PlaylistContextTags);
	void OnRep_AnyFreeBuildFlag();
	void OnRep_IsFreeBuildEnabled();
	void OnRep_WasFreeBuildEverEnabled();

	TArray<class FName> GetSpawnableItems() const;
	bool IsFreeBuildCostFilteringEnabled() const;
	bool IsFreeBuildEnabled() const;
	bool IsItemSpawnerEnabled() const;
	bool IsPlayerAllowedToFly() const;
	bool WasFreeBuildEverEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFreeBuildComponent">();
	}
	static class UJunoFreeBuildComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFreeBuildComponent>();
	}
};
static_assert(alignof(UJunoFreeBuildComponent) == 0x000008, "Wrong alignment on UJunoFreeBuildComponent");
static_assert(sizeof(UJunoFreeBuildComponent) == 0x0000D0, "Wrong size on UJunoFreeBuildComponent");
static_assert(offsetof(UJunoFreeBuildComponent, SpawnableItemsRegistryType) == 0x0000A0, "Member 'UJunoFreeBuildComponent::SpawnableItemsRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoFreeBuildComponent, bIsFreeBuildEnabled) == 0x0000A4, "Member 'UJunoFreeBuildComponent::bIsFreeBuildEnabled' has a wrong offset!");
static_assert(offsetof(UJunoFreeBuildComponent, bIsItemSpawnerEnabled) == 0x0000A5, "Member 'UJunoFreeBuildComponent::bIsItemSpawnerEnabled' has a wrong offset!");
static_assert(offsetof(UJunoFreeBuildComponent, bIsPlayerAllowedToFly) == 0x0000A6, "Member 'UJunoFreeBuildComponent::bIsPlayerAllowedToFly' has a wrong offset!");
static_assert(offsetof(UJunoFreeBuildComponent, bIsFreeBuildCostFilteringEnabled) == 0x0000A7, "Member 'UJunoFreeBuildComponent::bIsFreeBuildCostFilteringEnabled' has a wrong offset!");
static_assert(offsetof(UJunoFreeBuildComponent, bWasFreeBuildEverEnabled) == 0x0000A8, "Member 'UJunoFreeBuildComponent::bWasFreeBuildEverEnabled' has a wrong offset!");

// Class JunoGameNative.JunoNavSystemConfig
// 0x0000 (0x00B8 - 0x00B8)
class UJunoNavSystemConfig final : public UAthenaNavSystemConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoNavSystemConfig">();
	}
	static class UJunoNavSystemConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoNavSystemConfig>();
	}
};
static_assert(alignof(UJunoNavSystemConfig) == 0x000008, "Wrong alignment on UJunoNavSystemConfig");
static_assert(sizeof(UJunoNavSystemConfig) == 0x0000B8, "Wrong size on UJunoNavSystemConfig");

// Class JunoGameNative.JunoFreeBuildPersistenceFeatureData
// 0x0018 (0x0058 - 0x0040)
class UJunoFreeBuildPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoFreeBuildSaveData                 FreeBuildSaveData;                                 // 0x0050(0x0002)(SaveGame, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFreeBuildPersistenceFeatureData">();
	}
	static class UJunoFreeBuildPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFreeBuildPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoFreeBuildPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoFreeBuildPersistenceFeatureData");
static_assert(sizeof(UJunoFreeBuildPersistenceFeatureData) == 0x000058, "Wrong size on UJunoFreeBuildPersistenceFeatureData");
static_assert(offsetof(UJunoFreeBuildPersistenceFeatureData, FreeBuildSaveData) == 0x000050, "Member 'UJunoFreeBuildPersistenceFeatureData::FreeBuildSaveData' has a wrong offset!");

// Class JunoGameNative.JunoFreeBuildPersistenceFeatureDataActor
// 0x0018 (0x02E8 - 0x02D0)
class AJunoFreeBuildPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoFreeBuildSaveData                 FreeBuildSaveData;                                 // 0x02E0(0x0002)(SaveGame, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFreeBuildPersistenceFeatureDataActor">();
	}
	static class AJunoFreeBuildPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoFreeBuildPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoFreeBuildPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoFreeBuildPersistenceFeatureDataActor");
static_assert(sizeof(AJunoFreeBuildPersistenceFeatureDataActor) == 0x0002E8, "Wrong size on AJunoFreeBuildPersistenceFeatureDataActor");
static_assert(offsetof(AJunoFreeBuildPersistenceFeatureDataActor, FreeBuildSaveData) == 0x0002E0, "Member 'AJunoFreeBuildPersistenceFeatureDataActor::FreeBuildSaveData' has a wrong offset!");

// Class JunoGameNative.JunoVerbProcessor_GuidedBuildCompleted
// 0x0000 (0x00A0 - 0x00A0)
class UJunoVerbProcessor_GuidedBuildCompleted final : public UFortObjectiveProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoVerbProcessor_GuidedBuildCompleted">();
	}
	static class UJunoVerbProcessor_GuidedBuildCompleted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoVerbProcessor_GuidedBuildCompleted>();
	}
};
static_assert(alignof(UJunoVerbProcessor_GuidedBuildCompleted) == 0x000008, "Wrong alignment on UJunoVerbProcessor_GuidedBuildCompleted");
static_assert(sizeof(UJunoVerbProcessor_GuidedBuildCompleted) == 0x0000A0, "Wrong size on UJunoVerbProcessor_GuidedBuildCompleted");

// Class JunoGameNative.JunoFreeBuildPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoFreeBuildPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFreeBuildPersistenceFeatureModule">();
	}
	static class UJunoFreeBuildPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFreeBuildPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoFreeBuildPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoFreeBuildPersistenceFeatureModule");
static_assert(sizeof(UJunoFreeBuildPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoFreeBuildPersistenceFeatureModule");

// Class JunoGameNative.JunoFreeBuildPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoFreeBuildPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFreeBuildPersistenceFeatureData_Container">();
	}
	static class UJunoFreeBuildPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFreeBuildPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoFreeBuildPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoFreeBuildPersistenceFeatureData_Container");
static_assert(sizeof(UJunoFreeBuildPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoFreeBuildPersistenceFeatureData_Container");

// Class JunoGameNative.JunoAdventurePlayspaceBase
// 0x0028 (0x0710 - 0x06E8)
class AJunoAdventurePlayspaceBase final : public AFortPlayspace
{
public:
	bool                                          bShouldPersist;                                    // 0x06E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E9[0x7];                                      // 0x06E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AdventureTags;                                     // 0x06F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void AppendAdventureTags(const struct FGameplayTagContainer& TagsToAdd);
	void RemoveAdventureTags(const struct FGameplayTagContainer& TagsToRemove);

	bool ContainsController(const class AController* Controller) const;
	const struct FGameplayTagContainer GetAdventureTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAdventurePlayspaceBase">();
	}
	static class AJunoAdventurePlayspaceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoAdventurePlayspaceBase>();
	}
};
static_assert(alignof(AJunoAdventurePlayspaceBase) == 0x000008, "Wrong alignment on AJunoAdventurePlayspaceBase");
static_assert(sizeof(AJunoAdventurePlayspaceBase) == 0x000710, "Wrong size on AJunoAdventurePlayspaceBase");
static_assert(offsetof(AJunoAdventurePlayspaceBase, bShouldPersist) == 0x0006E8, "Member 'AJunoAdventurePlayspaceBase::bShouldPersist' has a wrong offset!");
static_assert(offsetof(AJunoAdventurePlayspaceBase, AdventureTags) == 0x0006F0, "Member 'AJunoAdventurePlayspaceBase::AdventureTags' has a wrong offset!");

// Class JunoGameNative.JunoGameStateComponent_WorldReactionsManager
// 0x0050 (0x0368 - 0x0318)
class UJunoGameStateComponent_WorldReactionsManager final : public UFortGameStateComponent_WorldReactionsManager
{
public:
	uint8                                         Pad_318[0x50];                                     // 0x0318(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameStateComponent_WorldReactionsManager">();
	}
	static class UJunoGameStateComponent_WorldReactionsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameStateComponent_WorldReactionsManager>();
	}
};
static_assert(alignof(UJunoGameStateComponent_WorldReactionsManager) == 0x000008, "Wrong alignment on UJunoGameStateComponent_WorldReactionsManager");
static_assert(sizeof(UJunoGameStateComponent_WorldReactionsManager) == 0x000368, "Wrong size on UJunoGameStateComponent_WorldReactionsManager");

// Class JunoGameNative.JunoGameStateSettings
// 0x0008 (0x00A8 - 0x00A0)
class UJunoGameStateSettings final : public UGameStateComponent
{
public:
	class UJunoRuntimeSettings*                   PreOverrideRuntimeSettings;                        // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameStateSettings">();
	}
	static class UJunoGameStateSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameStateSettings>();
	}
};
static_assert(alignof(UJunoGameStateSettings) == 0x000008, "Wrong alignment on UJunoGameStateSettings");
static_assert(sizeof(UJunoGameStateSettings) == 0x0000A8, "Wrong size on UJunoGameStateSettings");
static_assert(offsetof(UJunoGameStateSettings, PreOverrideRuntimeSettings) == 0x0000A0, "Member 'UJunoGameStateSettings::PreOverrideRuntimeSettings' has a wrong offset!");

// Class JunoGameNative.JunoRuntimeSettings
// 0x0008 (0x0038 - 0x0030)
class UJunoRuntimeSettings final : public UDeveloperSettings
{
public:
	bool                                          bPawnsUseProbeCollision;                           // 0x0030(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCharacterBasedMovementIgnorePhysicsBase;          // 0x0031(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCharacterStayBasedInAir;                          // 0x0032(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuoyancyEnabled;                                  // 0x0033(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRuntimeSettings">();
	}
	static class UJunoRuntimeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRuntimeSettings>();
	}
};
static_assert(alignof(UJunoRuntimeSettings) == 0x000008, "Wrong alignment on UJunoRuntimeSettings");
static_assert(sizeof(UJunoRuntimeSettings) == 0x000038, "Wrong size on UJunoRuntimeSettings");
static_assert(offsetof(UJunoRuntimeSettings, bPawnsUseProbeCollision) == 0x000030, "Member 'UJunoRuntimeSettings::bPawnsUseProbeCollision' has a wrong offset!");
static_assert(offsetof(UJunoRuntimeSettings, bCharacterBasedMovementIgnorePhysicsBase) == 0x000031, "Member 'UJunoRuntimeSettings::bCharacterBasedMovementIgnorePhysicsBase' has a wrong offset!");
static_assert(offsetof(UJunoRuntimeSettings, bCharacterStayBasedInAir) == 0x000032, "Member 'UJunoRuntimeSettings::bCharacterStayBasedInAir' has a wrong offset!");
static_assert(offsetof(UJunoRuntimeSettings, bBuoyancyEnabled) == 0x000033, "Member 'UJunoRuntimeSettings::bBuoyancyEnabled' has a wrong offset!");

// Class JunoGameNative.JunoGameStateTemperatureComponent
// 0x00C0 (0x0160 - 0x00A0)
class UJunoGameStateTemperatureComponent final : public UGameStateComponent
{
public:
	TMap<struct FGameplayTag, struct FScalableFloat> TemperatureToFloatMap;                             // 0x00A0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FScalableFloat> TemperatureThresholdsMap;                          // 0x00F0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FFloatRange                            TemperatureRange;                                  // 0x0140(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMaximumTemperature() const;
	float GetMinimumTemperature() const;
	TArray<struct FTemperatureRange> GetTemperatureRanges() const;
	float TemperatureToFloat(const struct FGameplayTag& Temperature) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameStateTemperatureComponent">();
	}
	static class UJunoGameStateTemperatureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameStateTemperatureComponent>();
	}
};
static_assert(alignof(UJunoGameStateTemperatureComponent) == 0x000008, "Wrong alignment on UJunoGameStateTemperatureComponent");
static_assert(sizeof(UJunoGameStateTemperatureComponent) == 0x000160, "Wrong size on UJunoGameStateTemperatureComponent");
static_assert(offsetof(UJunoGameStateTemperatureComponent, TemperatureToFloatMap) == 0x0000A0, "Member 'UJunoGameStateTemperatureComponent::TemperatureToFloatMap' has a wrong offset!");
static_assert(offsetof(UJunoGameStateTemperatureComponent, TemperatureThresholdsMap) == 0x0000F0, "Member 'UJunoGameStateTemperatureComponent::TemperatureThresholdsMap' has a wrong offset!");
static_assert(offsetof(UJunoGameStateTemperatureComponent, TemperatureRange) == 0x000140, "Member 'UJunoGameStateTemperatureComponent::TemperatureRange' has a wrong offset!");

// Class JunoGameNative.JunoGameStateWeatherComponent
// 0x0030 (0x00D0 - 0x00A0)
class UJunoGameStateWeatherComponent final : public UGameStateComponent
{
public:
	class UDataTable*                             SeasonTable;                                       // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJunoWeatherStateComponent> LocalizedWeatherStateSubclass;                     // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoPlayspacePersistenceFeatureHelper* WeatherPersistenceFeatureHelper;                   // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UJunoWeatherStateComponent* FindWeatherState(const struct FJunoWeatherLocation& Location);
	void ForceWeatherState(class FName NewWeatherType, class FName OptionalLocation);
	void HandleWeatherStatesSetup(const TArray<class UJunoWeatherStateComponent*>& WeatherStates);
	void OnNextWeatherQueueChanged(const class UJunoWeatherStateComponent* WeatherState);
	void OnWeatherPhaseChanged(const class UJunoWeatherStateComponent* WeatherState);
	void SetAutoTransitioning(bool bAutoTransitionWeather);
	void TransitionWeatherNow(class FName OptionalLocation);
	void TransitionWeatherNowTo(const struct FJunoWeatherPhase& NewWeatherPhase, const struct FJunoWeatherPhase& NewNextWeatherPhase, const struct FJunoWeatherLocation& OptionalLocation);

	TArray<class UJunoWeatherStateComponent*> GetWeatherStates() const;
	bool IsAutoTransitioning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameStateWeatherComponent">();
	}
	static class UJunoGameStateWeatherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameStateWeatherComponent>();
	}
};
static_assert(alignof(UJunoGameStateWeatherComponent) == 0x000008, "Wrong alignment on UJunoGameStateWeatherComponent");
static_assert(sizeof(UJunoGameStateWeatherComponent) == 0x0000D0, "Wrong size on UJunoGameStateWeatherComponent");
static_assert(offsetof(UJunoGameStateWeatherComponent, SeasonTable) == 0x0000A0, "Member 'UJunoGameStateWeatherComponent::SeasonTable' has a wrong offset!");
static_assert(offsetof(UJunoGameStateWeatherComponent, LocalizedWeatherStateSubclass) == 0x0000A8, "Member 'UJunoGameStateWeatherComponent::LocalizedWeatherStateSubclass' has a wrong offset!");
static_assert(offsetof(UJunoGameStateWeatherComponent, WeatherPersistenceFeatureHelper) == 0x0000B8, "Member 'UJunoGameStateWeatherComponent::WeatherPersistenceFeatureHelper' has a wrong offset!");

// Class JunoGameNative.JunoGeneratePersistenceAssetsReportCommandlet
// 0x0000 (0x0080 - 0x0080)
class UJunoGeneratePersistenceAssetsReportCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGeneratePersistenceAssetsReportCommandlet">();
	}
	static class UJunoGeneratePersistenceAssetsReportCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGeneratePersistenceAssetsReportCommandlet>();
	}
};
static_assert(alignof(UJunoGeneratePersistenceAssetsReportCommandlet) == 0x000008, "Wrong alignment on UJunoGeneratePersistenceAssetsReportCommandlet");
static_assert(sizeof(UJunoGeneratePersistenceAssetsReportCommandlet) == 0x000080, "Wrong size on UJunoGeneratePersistenceAssetsReportCommandlet");

// Class JunoGameNative.JunoGeometryCollectionAssemblerComponent
// 0x0180 (0x0220 - 0x00A0)
class UJunoGeometryCollectionAssemblerComponent final : public UActorComponent
{
public:
	float                                         AssemblyRatioInterpSpeed;                          // 0x00A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJunoGeometryCollectionAssemblerDurationType  DurationType;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LayerHeight;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LayerCount;                                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TimeToAssemble;                                    // 0x00B0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SingleGeometryTimeToAssemble;                      // 0x00D8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DisassembledZDistance;                             // 0x0100(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DisassembledZDistanceRandomRatio;                  // 0x0128(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DisassembledRotationAmount;                        // 0x0150(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bFreeMemoryWhenNotAnimating;                       // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UGeometryCollectionComponent*, struct FJunoGeometryCollectionAssemblerGCInfo> GeometryCollectionInfos;                           // 0x0180(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(float AssemblyRatio, bool bAssembling)> OnAssemblyVisualsAnimationStart;                   // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(float AssemblyRatio, int32 NumGeometriesInMovement)> OnAssemblyVisualsAnimationUpdated;                 // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(float AssemblyRatio)> OnAssemblyVisualsAnimationEnd;                     // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FJunoGeometryCollectionAssemblerTargetData TargetData;                                        // 0x0200(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x18];                                     // 0x0208(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsActorAssembled(const class AActor* Actor);

	void OnRep_TargetData();
	void SetFreeMemoryWhenNotAnimating(bool bValue);

	float GetAssemblyRatio() const;
	bool IsAssembled() const;
	bool IsAssembling() const;
	bool IsDisassembled() const;
	bool IsDisassembling() const;
	bool IsUpdating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGeometryCollectionAssemblerComponent">();
	}
	static class UJunoGeometryCollectionAssemblerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGeometryCollectionAssemblerComponent>();
	}
};
static_assert(alignof(UJunoGeometryCollectionAssemblerComponent) == 0x000008, "Wrong alignment on UJunoGeometryCollectionAssemblerComponent");
static_assert(sizeof(UJunoGeometryCollectionAssemblerComponent) == 0x000220, "Wrong size on UJunoGeometryCollectionAssemblerComponent");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, AssemblyRatioInterpSpeed) == 0x0000A0, "Member 'UJunoGeometryCollectionAssemblerComponent::AssemblyRatioInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, DurationType) == 0x0000A4, "Member 'UJunoGeometryCollectionAssemblerComponent::DurationType' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, LayerHeight) == 0x0000A8, "Member 'UJunoGeometryCollectionAssemblerComponent::LayerHeight' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, LayerCount) == 0x0000AC, "Member 'UJunoGeometryCollectionAssemblerComponent::LayerCount' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, TimeToAssemble) == 0x0000B0, "Member 'UJunoGeometryCollectionAssemblerComponent::TimeToAssemble' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, SingleGeometryTimeToAssemble) == 0x0000D8, "Member 'UJunoGeometryCollectionAssemblerComponent::SingleGeometryTimeToAssemble' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, DisassembledZDistance) == 0x000100, "Member 'UJunoGeometryCollectionAssemblerComponent::DisassembledZDistance' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, DisassembledZDistanceRandomRatio) == 0x000128, "Member 'UJunoGeometryCollectionAssemblerComponent::DisassembledZDistanceRandomRatio' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, DisassembledRotationAmount) == 0x000150, "Member 'UJunoGeometryCollectionAssemblerComponent::DisassembledRotationAmount' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, bFreeMemoryWhenNotAnimating) == 0x000178, "Member 'UJunoGeometryCollectionAssemblerComponent::bFreeMemoryWhenNotAnimating' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, GeometryCollectionInfos) == 0x000180, "Member 'UJunoGeometryCollectionAssemblerComponent::GeometryCollectionInfos' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, OnAssemblyVisualsAnimationStart) == 0x0001D0, "Member 'UJunoGeometryCollectionAssemblerComponent::OnAssemblyVisualsAnimationStart' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, OnAssemblyVisualsAnimationUpdated) == 0x0001E0, "Member 'UJunoGeometryCollectionAssemblerComponent::OnAssemblyVisualsAnimationUpdated' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, OnAssemblyVisualsAnimationEnd) == 0x0001F0, "Member 'UJunoGeometryCollectionAssemblerComponent::OnAssemblyVisualsAnimationEnd' has a wrong offset!");
static_assert(offsetof(UJunoGeometryCollectionAssemblerComponent, TargetData) == 0x000200, "Member 'UJunoGeometryCollectionAssemblerComponent::TargetData' has a wrong offset!");

// Class JunoGameNative.JunoGuidedBuildingBCOInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoGuidedBuildingBCOInterface final : public IInterface
{
public:
	void SetParentGuidedBuilding(class AJunoGuidedBuildingActor* OurGuidedBuild);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGuidedBuildingBCOInterface">();
	}
	static class IJunoGuidedBuildingBCOInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoGuidedBuildingBCOInterface>();
	}
};
static_assert(alignof(IJunoGuidedBuildingBCOInterface) == 0x000008, "Wrong alignment on IJunoGuidedBuildingBCOInterface");
static_assert(sizeof(IJunoGuidedBuildingBCOInterface) == 0x000028, "Wrong size on IJunoGuidedBuildingBCOInterface");

// Class JunoGameNative.JunoInputMappingComponent
// 0x0028 (0x00C8 - 0x00A0)
class UJunoInputMappingComponent final : public UGameFrameworkComponent
{
public:
	bool                                          bPopDefaultContext;                                // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoInputMapping                      DesiredInputMapping;                               // 0x00A8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJunoInputAlternateDisplayText> DisplayTexts;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void PopContext(class UJunoInputControllerComponent* JunoInputController);
	void PushContext(class UJunoInputControllerComponent* JunoInputController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInputMappingComponent">();
	}
	static class UJunoInputMappingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInputMappingComponent>();
	}
};
static_assert(alignof(UJunoInputMappingComponent) == 0x000008, "Wrong alignment on UJunoInputMappingComponent");
static_assert(sizeof(UJunoInputMappingComponent) == 0x0000C8, "Wrong size on UJunoInputMappingComponent");
static_assert(offsetof(UJunoInputMappingComponent, bPopDefaultContext) == 0x0000A0, "Member 'UJunoInputMappingComponent::bPopDefaultContext' has a wrong offset!");
static_assert(offsetof(UJunoInputMappingComponent, DesiredInputMapping) == 0x0000A8, "Member 'UJunoInputMappingComponent::DesiredInputMapping' has a wrong offset!");
static_assert(offsetof(UJunoInputMappingComponent, DisplayTexts) == 0x0000B8, "Member 'UJunoInputMappingComponent::DisplayTexts' has a wrong offset!");

// Class JunoGameNative.JunoInputQueueComponent
// 0x0068 (0x0108 - 0x00A0)
class UJunoInputQueueComponent final : public UPawnComponent
{
public:
	uint8                                         Pad_A0[0x68];                                      // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireQueuedInputs(int32 MontageInstanceID);
	void OverrideBlockingTags(int32 MontageInstanceID, class UGameplayAbility* Ability, const struct FGameplayTagContainer& AbilityTagsToAdd, const struct FGameplayTagContainer& AbilityTagsToRemove);
	void ResetBlockingTags(int32 MontageInstanceID);
	void SetInterruptible(int32 MontageInstanceID, const struct FGameplayTagContainer& AbilityTagsToAdd, const struct FGameplayTagContainer& AbilityTagsToRemove);
	void StartQueueingInput(int32 MontageInstanecID, class UGameplayAbility* Ability, bool bQueueMantisInputs, const struct FGameplayTagContainer& EventTags);
	void StopQueueingInput(int32 MontageInstanceID, const struct FGameplayTagContainer& AbilityTagsToAdd, const struct FGameplayTagContainer& AbilityTagsToRemove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInputQueueComponent">();
	}
	static class UJunoInputQueueComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInputQueueComponent>();
	}
};
static_assert(alignof(UJunoInputQueueComponent) == 0x000008, "Wrong alignment on UJunoInputQueueComponent");
static_assert(sizeof(UJunoInputQueueComponent) == 0x000108, "Wrong size on UJunoInputQueueComponent");

// Class JunoGameNative.JunoInventoryPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoInventoryPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryPersistenceFeatureModule">();
	}
	static class UJunoInventoryPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInventoryPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoInventoryPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoInventoryPersistenceFeatureModule");
static_assert(sizeof(UJunoInventoryPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoInventoryPersistenceFeatureModule");

// Class JunoGameNative.JunoInventoryPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoInventoryPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryPersistenceFeatureData_Container">();
	}
	static class UJunoInventoryPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInventoryPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoInventoryPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoInventoryPersistenceFeatureData_Container");
static_assert(sizeof(UJunoInventoryPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoInventoryPersistenceFeatureData_Container");

// Class JunoGameNative.JunoInventoryUIPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoInventoryUIPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryUIPersistenceFeatureModule">();
	}
	static class UJunoInventoryUIPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInventoryUIPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoInventoryUIPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoInventoryUIPersistenceFeatureModule");
static_assert(sizeof(UJunoInventoryUIPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoInventoryUIPersistenceFeatureModule");

// Class JunoGameNative.JunoInventoryUIPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoInventoryUIPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryUIPersistenceFeatureData_Container">();
	}
	static class UJunoInventoryUIPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInventoryUIPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoInventoryUIPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoInventoryUIPersistenceFeatureData_Container");
static_assert(sizeof(UJunoInventoryUIPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoInventoryUIPersistenceFeatureData_Container");

// Class JunoGameNative.JunoKnowledgeBundle
// 0x0060 (0x0090 - 0x0030)
class UJunoKnowledgeBundle final : public UPrimaryDataAsset
{
public:
	class UDataTable*                             RecipeTable;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   BundleName;                                        // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   BundleDescription;                                 // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UObject>                 BundleImage;                                       // 0x0068(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BundleIdentifier;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgeBundle">();
	}
	static class UJunoKnowledgeBundle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoKnowledgeBundle>();
	}
};
static_assert(alignof(UJunoKnowledgeBundle) == 0x000008, "Wrong alignment on UJunoKnowledgeBundle");
static_assert(sizeof(UJunoKnowledgeBundle) == 0x000090, "Wrong size on UJunoKnowledgeBundle");
static_assert(offsetof(UJunoKnowledgeBundle, RecipeTable) == 0x000030, "Member 'UJunoKnowledgeBundle::RecipeTable' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeBundle, BundleName) == 0x000038, "Member 'UJunoKnowledgeBundle::BundleName' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeBundle, BundleDescription) == 0x000050, "Member 'UJunoKnowledgeBundle::BundleDescription' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeBundle, BundleImage) == 0x000068, "Member 'UJunoKnowledgeBundle::BundleImage' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeBundle, BundleIdentifier) == 0x000088, "Member 'UJunoKnowledgeBundle::BundleIdentifier' has a wrong offset!");

// Class JunoGameNative.JunoKnowledgeCraftingComponent
// 0x0008 (0x00A8 - 0x00A0)
class UJunoKnowledgeCraftingComponent final : public UGameFrameworkComponent
{
public:
	TWeakObjectPtr<class UCraftingObjectComponent> CachedCraftingObjectComponent;                     // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleCraftingStateChanged(const struct FCraftingObjectStateChangedEvent& Event);
	void OnCraftingSuccess(const struct FCraftingObjectSuccessEvent& Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgeCraftingComponent">();
	}
	static class UJunoKnowledgeCraftingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoKnowledgeCraftingComponent>();
	}
};
static_assert(alignof(UJunoKnowledgeCraftingComponent) == 0x000008, "Wrong alignment on UJunoKnowledgeCraftingComponent");
static_assert(sizeof(UJunoKnowledgeCraftingComponent) == 0x0000A8, "Wrong size on UJunoKnowledgeCraftingComponent");
static_assert(offsetof(UJunoKnowledgeCraftingComponent, CachedCraftingObjectComponent) == 0x0000A0, "Member 'UJunoKnowledgeCraftingComponent::CachedCraftingObjectComponent' has a wrong offset!");

// Class JunoGameNative.JunoKnowledgePersistenceFeatureDataActor
// 0x00F0 (0x03C0 - 0x02D0)
class AJunoKnowledgePersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoKnowledgeSaveData                 KnowledgeSaveData;                                 // 0x02D8(0x00E8)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgePersistenceFeatureDataActor">();
	}
	static class AJunoKnowledgePersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoKnowledgePersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoKnowledgePersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoKnowledgePersistenceFeatureDataActor");
static_assert(sizeof(AJunoKnowledgePersistenceFeatureDataActor) == 0x0003C0, "Wrong size on AJunoKnowledgePersistenceFeatureDataActor");
static_assert(offsetof(AJunoKnowledgePersistenceFeatureDataActor, KnowledgeSaveData) == 0x0002D8, "Member 'AJunoKnowledgePersistenceFeatureDataActor::KnowledgeSaveData' has a wrong offset!");

// Class JunoGameNative.JunoKnowledgePersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoKnowledgePersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgePersistenceFeatureModule">();
	}
	static class UJunoKnowledgePersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoKnowledgePersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoKnowledgePersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoKnowledgePersistenceFeatureModule");
static_assert(sizeof(UJunoKnowledgePersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoKnowledgePersistenceFeatureModule");

// Class JunoGameNative.JunoKnowledgePersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoKnowledgePersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgePersistenceFeatureData_Container">();
	}
	static class UJunoKnowledgePersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoKnowledgePersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoKnowledgePersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoKnowledgePersistenceFeatureData_Container");
static_assert(sizeof(UJunoKnowledgePersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoKnowledgePersistenceFeatureData_Container");

// Class JunoGameNative.JunoLevelProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoLevelProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLevelProviderInterface">();
	}
	static class IJunoLevelProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoLevelProviderInterface>();
	}
};
static_assert(alignof(IJunoLevelProviderInterface) == 0x000008, "Wrong alignment on IJunoLevelProviderInterface");
static_assert(sizeof(IJunoLevelProviderInterface) == 0x000028, "Wrong size on IJunoLevelProviderInterface");

// Class JunoGameNative.JunoLifeCycleInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoLifeCycleInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLifeCycleInterface">();
	}
	static class IJunoLifeCycleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoLifeCycleInterface>();
	}
};
static_assert(alignof(IJunoLifeCycleInterface) == 0x000008, "Wrong alignment on IJunoLifeCycleInterface");
static_assert(sizeof(IJunoLifeCycleInterface) == 0x000028, "Wrong size on IJunoLifeCycleInterface");

// Class JunoGameNative.JunoLocalEnvironmentComponentInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoLocalEnvironmentComponentInterface final : public IInterface
{
public:
	struct FJunoBiomeInfoQueryResult GetBiome() const;
	struct FGuid GetCaveId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLocalEnvironmentComponentInterface">();
	}
	static class IJunoLocalEnvironmentComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoLocalEnvironmentComponentInterface>();
	}
};
static_assert(alignof(IJunoLocalEnvironmentComponentInterface) == 0x000008, "Wrong alignment on IJunoLocalEnvironmentComponentInterface");
static_assert(sizeof(IJunoLocalEnvironmentComponentInterface) == 0x000028, "Wrong size on IJunoLocalEnvironmentComponentInterface");

// Class JunoGameNative.JunoLocalEnvironmentActorInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoLocalEnvironmentActorInterface final : public IInterface
{
public:
	bool GetBiome(EJunoBiome* OutBiome) const;
	bool GetBiomeInfo(struct FJunoBiomeInfoQueryResult* OutHabitat) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLocalEnvironmentActorInterface">();
	}
	static class IJunoLocalEnvironmentActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoLocalEnvironmentActorInterface>();
	}
};
static_assert(alignof(IJunoLocalEnvironmentActorInterface) == 0x000008, "Wrong alignment on IJunoLocalEnvironmentActorInterface");
static_assert(sizeof(IJunoLocalEnvironmentActorInterface) == 0x000028, "Wrong size on IJunoLocalEnvironmentActorInterface");

// Class JunoGameNative.JunoLWMCaveEventDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoLWMCaveEventDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLWMCaveEventDataInterface">();
	}
	static class IJunoLWMCaveEventDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoLWMCaveEventDataInterface>();
	}
};
static_assert(alignof(IJunoLWMCaveEventDataInterface) == 0x000008, "Wrong alignment on IJunoLWMCaveEventDataInterface");
static_assert(sizeof(IJunoLWMCaveEventDataInterface) == 0x000028, "Wrong size on IJunoLWMCaveEventDataInterface");

// Class JunoGameNative.DisplayableTile
// 0x0018 (0x0040 - 0x0028)
class UDisplayableTile final : public UObject
{
public:
	int32                                         TileId;                                            // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearedPixelCount;                                 // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FogMask;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayableTile">();
	}
	static class UDisplayableTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayableTile>();
	}
};
static_assert(alignof(UDisplayableTile) == 0x000008, "Wrong alignment on UDisplayableTile");
static_assert(sizeof(UDisplayableTile) == 0x000040, "Wrong size on UDisplayableTile");
static_assert(offsetof(UDisplayableTile, TileId) == 0x000028, "Member 'UDisplayableTile::TileId' has a wrong offset!");
static_assert(offsetof(UDisplayableTile, ClearedPixelCount) == 0x00002C, "Member 'UDisplayableTile::ClearedPixelCount' has a wrong offset!");
static_assert(offsetof(UDisplayableTile, FogMask) == 0x000030, "Member 'UDisplayableTile::FogMask' has a wrong offset!");

// Class JunoGameNative.JunoMarkersPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoMarkersPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMarkersPersistenceFeatureModule">();
	}
	static class UJunoMarkersPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMarkersPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoMarkersPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoMarkersPersistenceFeatureModule");
static_assert(sizeof(UJunoMarkersPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoMarkersPersistenceFeatureModule");

// Class JunoGameNative.JunoMarkersPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoMarkersPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMarkersPersistenceFeatureData_Container">();
	}
	static class UJunoMarkersPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMarkersPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoMarkersPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoMarkersPersistenceFeatureData_Container");
static_assert(sizeof(UJunoMarkersPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoMarkersPersistenceFeatureData_Container");

// Class JunoGameNative.JunoMerchantDatabase
// 0x0008 (0x0100 - 0x00F8)
class UJunoMerchantDatabase final : public UFortPlayspaceComponent
{
public:
	class UDataTable*                             MerchantSalesDataTable;                            // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMerchantDatabase">();
	}
	static class UJunoMerchantDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMerchantDatabase>();
	}
};
static_assert(alignof(UJunoMerchantDatabase) == 0x000008, "Wrong alignment on UJunoMerchantDatabase");
static_assert(sizeof(UJunoMerchantDatabase) == 0x000100, "Wrong size on UJunoMerchantDatabase");
static_assert(offsetof(UJunoMerchantDatabase, MerchantSalesDataTable) == 0x0000F8, "Member 'UJunoMerchantDatabase::MerchantSalesDataTable' has a wrong offset!");

// Class JunoGameNative.JunoMoodReactionConfigMappings
// 0x0050 (0x0080 - 0x0030)
class UJunoMoodReactionConfigMappings final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FDataTableRowHandle> MoodReactionConfigMap;                             // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMoodReactionConfigMappings">();
	}
	static class UJunoMoodReactionConfigMappings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMoodReactionConfigMappings>();
	}
};
static_assert(alignof(UJunoMoodReactionConfigMappings) == 0x000008, "Wrong alignment on UJunoMoodReactionConfigMappings");
static_assert(sizeof(UJunoMoodReactionConfigMappings) == 0x000080, "Wrong size on UJunoMoodReactionConfigMappings");
static_assert(offsetof(UJunoMoodReactionConfigMappings, MoodReactionConfigMap) == 0x000030, "Member 'UJunoMoodReactionConfigMappings::MoodReactionConfigMap' has a wrong offset!");

// Class JunoGameNative.JunoNPCMoodReactionDatabase
// 0x0008 (0x0100 - 0x00F8)
class UJunoNPCMoodReactionDatabase final : public UFortPlayspaceComponent
{
public:
	class UJunoMoodReactionConfigMappings*        MoodReactionConfigMappings;                        // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoNPCMoodReactionDatabase">();
	}
	static class UJunoNPCMoodReactionDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoNPCMoodReactionDatabase>();
	}
};
static_assert(alignof(UJunoNPCMoodReactionDatabase) == 0x000008, "Wrong alignment on UJunoNPCMoodReactionDatabase");
static_assert(sizeof(UJunoNPCMoodReactionDatabase) == 0x000100, "Wrong size on UJunoNPCMoodReactionDatabase");
static_assert(offsetof(UJunoNPCMoodReactionDatabase, MoodReactionConfigMappings) == 0x0000F8, "Member 'UJunoNPCMoodReactionDatabase::MoodReactionConfigMappings' has a wrong offset!");

// Class JunoGameNative.JunoPassiveCraftingComponent
// 0x0060 (0x0100 - 0x00A0)
class UJunoPassiveCraftingComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* PassiveCraftingObject, class FName& FormulaRowName, EPassiveCraftingDoneReason Reason)> OnPassiveCraftingDone;                             // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* PassiveCraftingObject, class FName& NewFormulaRowName)> OnAutoCraftingFormulaRowChanged;                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAutoSelectRecipeFromIngredients;                  // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UJunoInventoryComponent> CachedInventoryComponent;                          // 0x00CC(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UCraftingObjectComponent> CachedCraftingObjectComponent;                     // 0x00D4(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAutoCrafting;                                   // 0x00DC(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AutoCraftingFormulaRow;                            // 0x00E0(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              AutoCraftingStartDateTime;                         // 0x00E8(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableAutoCrafting();
	void EnableAutoCrafting();
	void HandleCraftingStateChanged(const struct FCraftingObjectStateChangedEvent& Event);
	void HandleInventoryDataRestored();
	void MulticastFireCraftingDone(EPassiveCraftingDoneReason Reason);
	void OnCraftingSuccess(const struct FCraftingObjectSuccessEvent& Event);
	void OnRep_AutoCraftingFormulaRow();
	void SetAutoCraftRecipe(class FName FormulaRow);

	int32 CalculateNumRemainingAutoCraft(class FName OptionalFormulaRow) const;
	class FName GetAutoCraftingFormulaRow() const;
	bool IsAutoCrafting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPassiveCraftingComponent">();
	}
	static class UJunoPassiveCraftingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPassiveCraftingComponent>();
	}
};
static_assert(alignof(UJunoPassiveCraftingComponent) == 0x000008, "Wrong alignment on UJunoPassiveCraftingComponent");
static_assert(sizeof(UJunoPassiveCraftingComponent) == 0x000100, "Wrong size on UJunoPassiveCraftingComponent");
static_assert(offsetof(UJunoPassiveCraftingComponent, OnPassiveCraftingDone) == 0x0000A8, "Member 'UJunoPassiveCraftingComponent::OnPassiveCraftingDone' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingComponent, OnAutoCraftingFormulaRowChanged) == 0x0000B8, "Member 'UJunoPassiveCraftingComponent::OnAutoCraftingFormulaRowChanged' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingComponent, bAutoSelectRecipeFromIngredients) == 0x0000C8, "Member 'UJunoPassiveCraftingComponent::bAutoSelectRecipeFromIngredients' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingComponent, CachedInventoryComponent) == 0x0000CC, "Member 'UJunoPassiveCraftingComponent::CachedInventoryComponent' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingComponent, CachedCraftingObjectComponent) == 0x0000D4, "Member 'UJunoPassiveCraftingComponent::CachedCraftingObjectComponent' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingComponent, bIsAutoCrafting) == 0x0000DC, "Member 'UJunoPassiveCraftingComponent::bIsAutoCrafting' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingComponent, AutoCraftingFormulaRow) == 0x0000E0, "Member 'UJunoPassiveCraftingComponent::AutoCraftingFormulaRow' has a wrong offset!");
static_assert(offsetof(UJunoPassiveCraftingComponent, AutoCraftingStartDateTime) == 0x0000E8, "Member 'UJunoPassiveCraftingComponent::AutoCraftingStartDateTime' has a wrong offset!");

// Class JunoGameNative.JunoPassiveResourcesGathererPawnComponent
// 0x0090 (0x0130 - 0x00A0)
class UJunoPassiveResourcesGathererPawnComponent final : public UPawnComponent
{
public:
	struct FScalableFloat                         JobEstimationTimeMultiplier;                       // 0x00A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             GathererTable;                                     // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class AActor* GeneratorActor, int32 GeneratedItemsCount, bool bIsRuntime)> OnPassiveResourceGeneratedOnPawnDelegate;          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x50];                                      // 0x00E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetEstimatedTotalJobCompletionTimeInJunoDays() const;
	float GetLastGeneratedPercentage() const;
	class FText GetLastUsedGatheringActorDisplayText() const;
	struct FPrimaryAssetId GetLastUsedGatheringActorItemId() const;
	float GetRemainingJobCompletionTimeInJunoHours() const;
	float GetTotalJobCompletionTimeInJunoHours() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPassiveResourcesGathererPawnComponent">();
	}
	static class UJunoPassiveResourcesGathererPawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPassiveResourcesGathererPawnComponent>();
	}
};
static_assert(alignof(UJunoPassiveResourcesGathererPawnComponent) == 0x000008, "Wrong alignment on UJunoPassiveResourcesGathererPawnComponent");
static_assert(sizeof(UJunoPassiveResourcesGathererPawnComponent) == 0x000130, "Wrong size on UJunoPassiveResourcesGathererPawnComponent");
static_assert(offsetof(UJunoPassiveResourcesGathererPawnComponent, JobEstimationTimeMultiplier) == 0x0000A0, "Member 'UJunoPassiveResourcesGathererPawnComponent::JobEstimationTimeMultiplier' has a wrong offset!");
static_assert(offsetof(UJunoPassiveResourcesGathererPawnComponent, GathererTable) == 0x0000C8, "Member 'UJunoPassiveResourcesGathererPawnComponent::GathererTable' has a wrong offset!");
static_assert(offsetof(UJunoPassiveResourcesGathererPawnComponent, OnPassiveResourceGeneratedOnPawnDelegate) == 0x0000D0, "Member 'UJunoPassiveResourcesGathererPawnComponent::OnPassiveResourceGeneratedOnPawnDelegate' has a wrong offset!");

// Class JunoGameNative.JunoPassiveResourcesGatheringWorldConditionSchema
// 0x0010 (0x0048 - 0x0038)
class UJunoPassiveResourcesGatheringWorldConditionSchema final : public UWorldConditionSchema
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPassiveResourcesGatheringWorldConditionSchema">();
	}
	static class UJunoPassiveResourcesGatheringWorldConditionSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPassiveResourcesGatheringWorldConditionSchema>();
	}
};
static_assert(alignof(UJunoPassiveResourcesGatheringWorldConditionSchema) == 0x000008, "Wrong alignment on UJunoPassiveResourcesGatheringWorldConditionSchema");
static_assert(sizeof(UJunoPassiveResourcesGatheringWorldConditionSchema) == 0x000048, "Wrong size on UJunoPassiveResourcesGatheringWorldConditionSchema");

// Class JunoGameNative.JunoPersistenceDeveloperSettings
// 0x0070 (0x00A0 - 0x0030)
class UJunoPersistenceDeveloperSettings final : public UDeveloperSettings
{
public:
	bool                                          bCreateNewWorldAlways;                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePersistence;                               // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WorldNameSuffix;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePersistenceFrameworkDeltas;                 // 0x0048(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewWorldAdventureSeed;                             // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            NewWorldDevProperties;                             // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPersistenceDeveloperSettings">();
	}
	static class UJunoPersistenceDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPersistenceDeveloperSettings>();
	}
};
static_assert(alignof(UJunoPersistenceDeveloperSettings) == 0x000008, "Wrong alignment on UJunoPersistenceDeveloperSettings");
static_assert(sizeof(UJunoPersistenceDeveloperSettings) == 0x0000A0, "Wrong size on UJunoPersistenceDeveloperSettings");
static_assert(offsetof(UJunoPersistenceDeveloperSettings, bCreateNewWorldAlways) == 0x000030, "Member 'UJunoPersistenceDeveloperSettings::bCreateNewWorldAlways' has a wrong offset!");
static_assert(offsetof(UJunoPersistenceDeveloperSettings, bDisablePersistence) == 0x000031, "Member 'UJunoPersistenceDeveloperSettings::bDisablePersistence' has a wrong offset!");
static_assert(offsetof(UJunoPersistenceDeveloperSettings, WorldNameSuffix) == 0x000038, "Member 'UJunoPersistenceDeveloperSettings::WorldNameSuffix' has a wrong offset!");
static_assert(offsetof(UJunoPersistenceDeveloperSettings, bEnablePersistenceFrameworkDeltas) == 0x000048, "Member 'UJunoPersistenceDeveloperSettings::bEnablePersistenceFrameworkDeltas' has a wrong offset!");
static_assert(offsetof(UJunoPersistenceDeveloperSettings, NewWorldAdventureSeed) == 0x00004C, "Member 'UJunoPersistenceDeveloperSettings::NewWorldAdventureSeed' has a wrong offset!");
static_assert(offsetof(UJunoPersistenceDeveloperSettings, NewWorldDevProperties) == 0x000050, "Member 'UJunoPersistenceDeveloperSettings::NewWorldDevProperties' has a wrong offset!");

// Class JunoGameNative.JunoPersistenceFeaturesReportHandler
// 0x0018 (0x0040 - 0x0028)
class UJunoPersistenceFeaturesReportHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPersistenceFeaturesReportHandler">();
	}
	static class UJunoPersistenceFeaturesReportHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPersistenceFeaturesReportHandler>();
	}
};
static_assert(alignof(UJunoPersistenceFeaturesReportHandler) == 0x000008, "Wrong alignment on UJunoPersistenceFeaturesReportHandler");
static_assert(sizeof(UJunoPersistenceFeaturesReportHandler) == 0x000040, "Wrong size on UJunoPersistenceFeaturesReportHandler");

// Class JunoGameNative.JunoPFWDefaultServiceWrapperSettings
// 0x0000 (0x0040 - 0x0040)
class UJunoPFWDefaultServiceWrapperSettings final : public UPersistenceFrameworkServiceSettingsBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPFWDefaultServiceWrapperSettings">();
	}
	static class UJunoPFWDefaultServiceWrapperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPFWDefaultServiceWrapperSettings>();
	}
};
static_assert(alignof(UJunoPFWDefaultServiceWrapperSettings) == 0x000008, "Wrong alignment on UJunoPFWDefaultServiceWrapperSettings");
static_assert(sizeof(UJunoPFWDefaultServiceWrapperSettings) == 0x000040, "Wrong size on UJunoPFWDefaultServiceWrapperSettings");

// Class JunoGameNative.JunoPlayerBuildingComponent
// 0x0500 (0x05A8 - 0x00A8)
class UJunoPlayerBuildingComponent final : public UFortControllerComponent
{
public:
	struct FJunoSelectedSlot                      ReplicatedSelectedSlot;                            // 0x00A8(0x0030)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x38];                                      // 0x00D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoBuildingSlotDataArray             BuildBars[0x2];                                    // 0x0110(0x0138)(Net, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AJunoGuidedBuildingActor> LastGuidedBuildingActor;                           // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AJunoGuidedBuildingActor> ReplicatedLastGuidedBuildingActor;                 // 0x0388(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicateLastGuidedActorTime;                      // 0x0390(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicateBuildingMetricSpatialPrecision;           // 0x0394(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoBuildingSessionInfo               BuildingSessionInfo;                               // 0x0398(0x0028)(Protected, NativeAccessSpecifierProtected)
	struct FJunoInputMapping                      BuildingMappingContext;                            // 0x03C0(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UInputAction*                           NextSlot;                                          // 0x03D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           PrevSlot;                                          // 0x03D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           ExitBuildMode;                                     // 0x03E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           PinItem;                                           // 0x03E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UInputAction*>                   BuildBarBindings;                                  // 0x03F0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            DefaultRecipes;                                    // 0x0400(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJunoBuildingMetricsClientPermissions> ClientSpatialMetricsBuildingPermissions;           // 0x0410(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FIntVector                             LastKnownPawnSpatialCell;                          // 0x0420(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FJunoTrackedActorKey>             DirtyCellLocations;                                // 0x0430(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRecentRecipes;                                  // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoMCPItemPlacementStatus            MCPItemPlacementStatus;                            // 0x0494(0x000C)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UObject>                 UINotificationIcon;                                // 0x04A0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJunoMCPItemPlacementStatusAlertData> AlertData;                                         // 0x04C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0xC0];                                     // 0x04D0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoAsyncAction_WaitForEventRouter*    WaitForEventRouterAction;                          // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x10];                                     // 0x0598(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttempEndGuidedBuild();
	void EnterBuildingModeAndSelectIndex(int32 Index_0, EJunoBuildModeType InType);
	void EnterGuidedBuilding(class AJunoGuidedBuildingActor* InLastGuidedBuildingActor);
	void HandleBuildingMetricsActorCountChange(const struct FInt32Vector& Location, int32 PreviousActorCount, int32 NewActorCount);
	void HandleBuildingMetricsThresholdChange(const struct FInt32Vector& Location);
	void OnGuidedBuildDone(const struct FGuidedBuildingUpdate& StageUpdate);
	void OnGuidedBuildingStageChanged(const struct FGuidedBuildingUpdate& StageUpdate);
	void OnRep_MCPItemPlacementStatus();
	void OnRep_ReplicatedLastGuidedBuildingActor();
	void OnRep_ReplicatedSelectedSlot();
	void OnRep_ReplicateLastGuidedActorTime();
	void ServerEndGuidedBuild();
	void ServerSelectSlot(const struct FJunoSelectedSlot& NewSlot);
	void ServerSetLastGuidedBuildingActor(class AJunoGuidedBuildingActor* InLastActor);
	void ServerSetRecipeAtIndex(const struct FJunoSlotIndex& NewSlot, class FName RecipeName);
	void SetLastGuidedBuildingActor(class AJunoGuidedBuildingActor* InLastGuidedBuildingActor);
	void SetRecipeAtIndex(int32 InIndex, class FName RecipeName, const EJunoBuildModeType ModeType);

	bool CanPlaceMCPItems() const;
	bool CanPlaceRecipe(class FName RecipeToPlace) const;
	EJunoBuildModeType GetBuildModeType() const;
	class FName GetCurrentRecipe() const;
	class FName GetForcedRecipe() const;
	bool GetIsInBuildMode() const;
	class FName GetLastFocusedRecipe() const;
	const class AJunoGuidedBuildingActor* GetLastGuidedBuildingActor() const;
	class FName GetLastLoadedRecipe() const;
	const struct FJunoLastLoadedRecipeData GetLastLoadedRecipeData() const;
	class FName GetLastSelectedRecipe() const;
	class FText GetMCPItemPlacedMessageDescription() const;
	class FText GetMCPItemPlacedMessageTitle() const;
	struct FJunoGuidedBuildRemainingPartsInfo GetRemainingPartsForSelectedRecipe() const;
	int32 GetRemainingWorldsForMCPItems() const;
	int32 GetSelectedSlotIndex(EJunoBuildModeType InType) const;
	struct FJunoBuildingSlotData GetSlotData(int32 Index_0, EJunoBuildModeType InType) const;
	int32 GetTotalAllowedMCPItemWorlds() const;
	bool HasSelectedMissingParts() const;
	bool HasSelectedRemainingParts() const;
	bool IsBuildModeEnabled() const;
	bool IsRecipePinned(class FName Recipe) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerBuildingComponent">();
	}
	static class UJunoPlayerBuildingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerBuildingComponent>();
	}
};
static_assert(alignof(UJunoPlayerBuildingComponent) == 0x000008, "Wrong alignment on UJunoPlayerBuildingComponent");
static_assert(sizeof(UJunoPlayerBuildingComponent) == 0x0005A8, "Wrong size on UJunoPlayerBuildingComponent");
static_assert(offsetof(UJunoPlayerBuildingComponent, ReplicatedSelectedSlot) == 0x0000A8, "Member 'UJunoPlayerBuildingComponent::ReplicatedSelectedSlot' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, BuildBars) == 0x000110, "Member 'UJunoPlayerBuildingComponent::BuildBars' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, LastGuidedBuildingActor) == 0x000380, "Member 'UJunoPlayerBuildingComponent::LastGuidedBuildingActor' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, ReplicatedLastGuidedBuildingActor) == 0x000388, "Member 'UJunoPlayerBuildingComponent::ReplicatedLastGuidedBuildingActor' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, ReplicateLastGuidedActorTime) == 0x000390, "Member 'UJunoPlayerBuildingComponent::ReplicateLastGuidedActorTime' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, ReplicateBuildingMetricSpatialPrecision) == 0x000394, "Member 'UJunoPlayerBuildingComponent::ReplicateBuildingMetricSpatialPrecision' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, BuildingSessionInfo) == 0x000398, "Member 'UJunoPlayerBuildingComponent::BuildingSessionInfo' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, BuildingMappingContext) == 0x0003C0, "Member 'UJunoPlayerBuildingComponent::BuildingMappingContext' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, NextSlot) == 0x0003D0, "Member 'UJunoPlayerBuildingComponent::NextSlot' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, PrevSlot) == 0x0003D8, "Member 'UJunoPlayerBuildingComponent::PrevSlot' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, ExitBuildMode) == 0x0003E0, "Member 'UJunoPlayerBuildingComponent::ExitBuildMode' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, PinItem) == 0x0003E8, "Member 'UJunoPlayerBuildingComponent::PinItem' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, BuildBarBindings) == 0x0003F0, "Member 'UJunoPlayerBuildingComponent::BuildBarBindings' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, DefaultRecipes) == 0x000400, "Member 'UJunoPlayerBuildingComponent::DefaultRecipes' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, ClientSpatialMetricsBuildingPermissions) == 0x000410, "Member 'UJunoPlayerBuildingComponent::ClientSpatialMetricsBuildingPermissions' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, LastKnownPawnSpatialCell) == 0x000420, "Member 'UJunoPlayerBuildingComponent::LastKnownPawnSpatialCell' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, DirtyCellLocations) == 0x000430, "Member 'UJunoPlayerBuildingComponent::DirtyCellLocations' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, MaxRecentRecipes) == 0x000490, "Member 'UJunoPlayerBuildingComponent::MaxRecentRecipes' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, MCPItemPlacementStatus) == 0x000494, "Member 'UJunoPlayerBuildingComponent::MCPItemPlacementStatus' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, UINotificationIcon) == 0x0004A0, "Member 'UJunoPlayerBuildingComponent::UINotificationIcon' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, AlertData) == 0x0004C0, "Member 'UJunoPlayerBuildingComponent::AlertData' has a wrong offset!");
static_assert(offsetof(UJunoPlayerBuildingComponent, WaitForEventRouterAction) == 0x000590, "Member 'UJunoPlayerBuildingComponent::WaitForEventRouterAction' has a wrong offset!");

// Class JunoGameNative.JunoPlayerControllerComponent_SessionAnalytics
// 0x0200 (0x02A0 - 0x00A0)
class UJunoPlayerControllerComponent_SessionAnalytics final : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        JunoPlaySessionStartedTime;                        // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  JunoPlaySessionID;                                 // 0x00B0(0x0010)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           RecipesUnlockedDuringSession;                      // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         AccumulatedDistanceTraveled;                       // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastPlayerPawnLocation;                            // 0x00D8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedDisconnectReason;                             // 0x0140(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayEventListenerHandle           GracefulShutdownInitiatedEventHandle;              // 0x0150(0x001C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGracefulShutdownStarted;                          // 0x016C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GracefulShutdownExitCode;                          // 0x0170(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GracefulShutdownMaxTime;                           // 0x0174(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x50];                                     // 0x0178(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEventListenerHandle           PawnEliminatedEventHandle;                         // 0x01C8(0x001C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E4[0xBC];                                     // 0x01E4(0x00BC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleGracefulShutdownInitiated(const struct FFortGracefulShutdownInitiatedEvent& Event);
	void HandleInventoryDataRestored();
	void OnHeartbeatTimer();
	void OnPlayerDisconnecting(const class AFortPlayerController* FortPlayerController, const class FString& DevReason, bool bGracefulDisconnect);
	void OnPlayerStatsUpdateTimer();
	void OnRep_JunoPlaySessionID();
	void ResetHeartbeatStats();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerControllerComponent_SessionAnalytics">();
	}
	static class UJunoPlayerControllerComponent_SessionAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerControllerComponent_SessionAnalytics>();
	}
};
static_assert(alignof(UJunoPlayerControllerComponent_SessionAnalytics) == 0x000008, "Wrong alignment on UJunoPlayerControllerComponent_SessionAnalytics");
static_assert(sizeof(UJunoPlayerControllerComponent_SessionAnalytics) == 0x0002A0, "Wrong size on UJunoPlayerControllerComponent_SessionAnalytics");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, JunoPlaySessionStartedTime) == 0x0000A8, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::JunoPlaySessionStartedTime' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, JunoPlaySessionID) == 0x0000B0, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::JunoPlaySessionID' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, RecipesUnlockedDuringSession) == 0x0000C0, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::RecipesUnlockedDuringSession' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, AccumulatedDistanceTraveled) == 0x0000D0, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::AccumulatedDistanceTraveled' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, LastPlayerPawnLocation) == 0x0000D8, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::LastPlayerPawnLocation' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, SavedDisconnectReason) == 0x000140, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::SavedDisconnectReason' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, GracefulShutdownInitiatedEventHandle) == 0x000150, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::GracefulShutdownInitiatedEventHandle' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, bGracefulShutdownStarted) == 0x00016C, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::bGracefulShutdownStarted' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, GracefulShutdownExitCode) == 0x000170, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::GracefulShutdownExitCode' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, GracefulShutdownMaxTime) == 0x000174, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::GracefulShutdownMaxTime' has a wrong offset!");
static_assert(offsetof(UJunoPlayerControllerComponent_SessionAnalytics, PawnEliminatedEventHandle) == 0x0001C8, "Member 'UJunoPlayerControllerComponent_SessionAnalytics::PawnEliminatedEventHandle' has a wrong offset!");

// Class JunoGameNative.JunoPlayerPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoPlayerPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerPersistenceFeatureModule">();
	}
	static class UJunoPlayerPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoPlayerPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoPlayerPersistenceFeatureModule");
static_assert(sizeof(UJunoPlayerPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoPlayerPersistenceFeatureModule");

// Class JunoGameNative.JunoPlayspaceAccountantFeatureData
// 0x0058 (0x0098 - 0x0040)
class UJunoPlayspaceAccountantFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoPlayspaceAccountantSaveData       JunoPlayspaceAccountantSaveData;                   // 0x0048(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceAccountantFeatureData">();
	}
	static class UJunoPlayspaceAccountantFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceAccountantFeatureData>();
	}
};
static_assert(alignof(UJunoPlayspaceAccountantFeatureData) == 0x000008, "Wrong alignment on UJunoPlayspaceAccountantFeatureData");
static_assert(sizeof(UJunoPlayspaceAccountantFeatureData) == 0x000098, "Wrong size on UJunoPlayspaceAccountantFeatureData");
static_assert(offsetof(UJunoPlayspaceAccountantFeatureData, JunoPlayspaceAccountantSaveData) == 0x000048, "Member 'UJunoPlayspaceAccountantFeatureData::JunoPlayspaceAccountantSaveData' has a wrong offset!");

// Class JunoGameNative.JunoPlayspaceAccountantPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoPlayspaceAccountantPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceAccountantPersistenceFeatureModule">();
	}
	static class UJunoPlayspaceAccountantPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceAccountantPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoPlayspaceAccountantPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoPlayspaceAccountantPersistenceFeatureModule");
static_assert(sizeof(UJunoPlayspaceAccountantPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoPlayspaceAccountantPersistenceFeatureModule");

// Class JunoGameNative.JunoPlayspaceControllerComponent_PlayerSpawning
// 0x0040 (0x0158 - 0x0118)
class UJunoPlayspaceControllerComponent_PlayerSpawning final : public UPlayspaceControllerComponent_PlayerSpawning
{
public:
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayspaceSearchBoxExtent;                          // 0x0130(0x0018)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnPosessed(class AFortPawn* NewPawn);
	void ServerQueuePlayerForRespawn();
	void StartRespawn();

	bool IsAllowedToShowRespawnUI() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceControllerComponent_PlayerSpawning">();
	}
	static class UJunoPlayspaceControllerComponent_PlayerSpawning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceControllerComponent_PlayerSpawning>();
	}
};
static_assert(alignof(UJunoPlayspaceControllerComponent_PlayerSpawning) == 0x000008, "Wrong alignment on UJunoPlayspaceControllerComponent_PlayerSpawning");
static_assert(sizeof(UJunoPlayspaceControllerComponent_PlayerSpawning) == 0x000158, "Wrong size on UJunoPlayspaceControllerComponent_PlayerSpawning");
static_assert(offsetof(UJunoPlayspaceControllerComponent_PlayerSpawning, PlayspaceSearchBoxExtent) == 0x000130, "Member 'UJunoPlayspaceControllerComponent_PlayerSpawning::PlayspaceSearchBoxExtent' has a wrong offset!");

// Class JunoGameNative.JunoPlayspaceIndexPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoPlayspaceIndexPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceIndexPersistenceFeatureModule">();
	}
	static class UJunoPlayspaceIndexPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceIndexPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoPlayspaceIndexPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoPlayspaceIndexPersistenceFeatureModule");
static_assert(sizeof(UJunoPlayspaceIndexPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoPlayspaceIndexPersistenceFeatureModule");

// Class JunoGameNative.JunoPlayspaceIndexPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoPlayspaceIndexPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceIndexPersistenceFeatureData_Container">();
	}
	static class UJunoPlayspaceIndexPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceIndexPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoPlayspaceIndexPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoPlayspaceIndexPersistenceFeatureData_Container");
static_assert(sizeof(UJunoPlayspaceIndexPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoPlayspaceIndexPersistenceFeatureData_Container");

// Class JunoGameNative.JunoPlayspacePersistenceFeatureHelper
// 0x0028 (0x0050 - 0x0028)
class UJunoPlayspacePersistenceFeatureHelper final : public UObject
{
public:
	TSubclassOf<class UObject>                    PersistenceFeatureDataClass;                       // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IJunoPersistenceFeatureData> PersistenceFeatureData;                            // 0x0030(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspacePersistenceFeatureHelper">();
	}
	static class UJunoPlayspacePersistenceFeatureHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspacePersistenceFeatureHelper>();
	}
};
static_assert(alignof(UJunoPlayspacePersistenceFeatureHelper) == 0x000008, "Wrong alignment on UJunoPlayspacePersistenceFeatureHelper");
static_assert(sizeof(UJunoPlayspacePersistenceFeatureHelper) == 0x000050, "Wrong size on UJunoPlayspacePersistenceFeatureHelper");
static_assert(offsetof(UJunoPlayspacePersistenceFeatureHelper, PersistenceFeatureDataClass) == 0x000028, "Member 'UJunoPlayspacePersistenceFeatureHelper::PersistenceFeatureDataClass' has a wrong offset!");
static_assert(offsetof(UJunoPlayspacePersistenceFeatureHelper, PersistenceFeatureData) == 0x000030, "Member 'UJunoPlayspacePersistenceFeatureHelper::PersistenceFeatureData' has a wrong offset!");

// Class JunoGameNative.JunoQueryContext_Camp_Center
// 0x0000 (0x0028 - 0x0028)
class UJunoQueryContext_Camp_Center final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoQueryContext_Camp_Center">();
	}
	static class UJunoQueryContext_Camp_Center* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoQueryContext_Camp_Center>();
	}
};
static_assert(alignof(UJunoQueryContext_Camp_Center) == 0x000008, "Wrong alignment on UJunoQueryContext_Camp_Center");
static_assert(sizeof(UJunoQueryContext_Camp_Center) == 0x000028, "Wrong size on UJunoQueryContext_Camp_Center");

// Class JunoGameNative.JunoQuickBuildSelectionData
// 0x0018 (0x0040 - 0x0028)
class UJunoQuickBuildSelectionData final : public UObject
{
public:
	int32                                         CurrentlySelectedIndex;                            // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           QuickBuildRecipes;                                 // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoQuickBuildSelectionData">();
	}
	static class UJunoQuickBuildSelectionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoQuickBuildSelectionData>();
	}
};
static_assert(alignof(UJunoQuickBuildSelectionData) == 0x000008, "Wrong alignment on UJunoQuickBuildSelectionData");
static_assert(sizeof(UJunoQuickBuildSelectionData) == 0x000040, "Wrong size on UJunoQuickBuildSelectionData");
static_assert(offsetof(UJunoQuickBuildSelectionData, CurrentlySelectedIndex) == 0x000028, "Member 'UJunoQuickBuildSelectionData::CurrentlySelectedIndex' has a wrong offset!");
static_assert(offsetof(UJunoQuickBuildSelectionData, QuickBuildRecipes) == 0x000030, "Member 'UJunoQuickBuildSelectionData::QuickBuildRecipes' has a wrong offset!");

// Class JunoGameNative.JunoRainCapture
// 0x0030 (0x02C0 - 0x0290)
class AJunoRainCapture final : public AActor
{
public:
	class USceneCaptureComponent2D*               SceneCaptureComponent2D;                           // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MaterialParameterCollection;                       // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RainOccluderSceneCaptureLocationName;              // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RainOccluderPositionOffset;                        // 0x02A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRainCapture">();
	}
	static class AJunoRainCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoRainCapture>();
	}
};
static_assert(alignof(AJunoRainCapture) == 0x000008, "Wrong alignment on AJunoRainCapture");
static_assert(sizeof(AJunoRainCapture) == 0x0002C0, "Wrong size on AJunoRainCapture");
static_assert(offsetof(AJunoRainCapture, SceneCaptureComponent2D) == 0x000290, "Member 'AJunoRainCapture::SceneCaptureComponent2D' has a wrong offset!");
static_assert(offsetof(AJunoRainCapture, MaterialParameterCollection) == 0x000298, "Member 'AJunoRainCapture::MaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(AJunoRainCapture, RainOccluderSceneCaptureLocationName) == 0x0002A0, "Member 'AJunoRainCapture::RainOccluderSceneCaptureLocationName' has a wrong offset!");
static_assert(offsetof(AJunoRainCapture, RainOccluderPositionOffset) == 0x0002A8, "Member 'AJunoRainCapture::RainOccluderPositionOffset' has a wrong offset!");

// Class JunoGameNative.JunoRainCaptureSubsystem
// 0x0050 (0x0090 - 0x0040)
class UJunoRainCaptureSubsystem final : public UTickableWorldSubsystem
{
public:
	struct FSoftObjectPath                        SubsystemDataAssetPath;                            // 0x0040(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoRainCaptureSubsystemData*          SubsystemData;                                     // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AJunoRainCapture*                       RainCaptureInstance;                               // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRainCaptureSubsystem">();
	}
	static class UJunoRainCaptureSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRainCaptureSubsystem>();
	}
};
static_assert(alignof(UJunoRainCaptureSubsystem) == 0x000008, "Wrong alignment on UJunoRainCaptureSubsystem");
static_assert(sizeof(UJunoRainCaptureSubsystem) == 0x000090, "Wrong size on UJunoRainCaptureSubsystem");
static_assert(offsetof(UJunoRainCaptureSubsystem, SubsystemDataAssetPath) == 0x000040, "Member 'UJunoRainCaptureSubsystem::SubsystemDataAssetPath' has a wrong offset!");
static_assert(offsetof(UJunoRainCaptureSubsystem, SubsystemData) == 0x000058, "Member 'UJunoRainCaptureSubsystem::SubsystemData' has a wrong offset!");
static_assert(offsetof(UJunoRainCaptureSubsystem, RainCaptureInstance) == 0x000080, "Member 'UJunoRainCaptureSubsystem::RainCaptureInstance' has a wrong offset!");

// Class JunoGameNative.JunoRainOccluderComponent
// 0x0000 (0x00A0 - 0x00A0)
class UJunoRainOccluderComponent final : public UGameFrameworkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRainOccluderComponent">();
	}
	static class UJunoRainOccluderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRainOccluderComponent>();
	}
};
static_assert(alignof(UJunoRainOccluderComponent) == 0x000008, "Wrong alignment on UJunoRainOccluderComponent");
static_assert(sizeof(UJunoRainOccluderComponent) == 0x0000A0, "Wrong size on UJunoRainOccluderComponent");

// Class JunoGameNative.JunoSmartObjectComponent
// 0x0010 (0x02E0 - 0x02D0)
class UJunoSmartObjectComponent final : public UFortSmartObjectComponent
{
public:
	class UCurveFloat*                            LootTierPercentageToSlotPickingModifier;           // 0x02D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoSmartObjectComponent">();
	}
	static class UJunoSmartObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoSmartObjectComponent>();
	}
};
static_assert(alignof(UJunoSmartObjectComponent) == 0x000010, "Wrong alignment on UJunoSmartObjectComponent");
static_assert(sizeof(UJunoSmartObjectComponent) == 0x0002E0, "Wrong size on UJunoSmartObjectComponent");
static_assert(offsetof(UJunoSmartObjectComponent, LootTierPercentageToSlotPickingModifier) == 0x0002D0, "Member 'UJunoSmartObjectComponent::LootTierPercentageToSlotPickingModifier' has a wrong offset!");

// Class JunoGameNative.JunoSyncWeatherComponent
// 0x0050 (0x00F0 - 0x00A0)
class UJunoSyncWeatherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoSyncWeatherComponent">();
	}
	static class UJunoSyncWeatherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoSyncWeatherComponent>();
	}
};
static_assert(alignof(UJunoSyncWeatherComponent) == 0x000008, "Wrong alignment on UJunoSyncWeatherComponent");
static_assert(sizeof(UJunoSyncWeatherComponent) == 0x0000F0, "Wrong size on UJunoSyncWeatherComponent");

// Class JunoGameNative.JunoTeleporter
// 0x0010 (0x0BD8 - 0x0BC8)
class AJunoTeleporter final : public ABuildingProp
{
public:
	TWeakObjectPtr<class AJunoTeleporter>         TargetTeleporter;                                  // 0x0BC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTeleporterEnabled;                              // 0x0BD0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD1[0x7];                                      // 0x0BD1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargetTeleporter(class AJunoTeleporter* TargetTeleportActor);

	class AJunoTeleporter* GetTargetTeleporter() const;
	bool IsTeleporterEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTeleporter">();
	}
	static class AJunoTeleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoTeleporter>();
	}
};
static_assert(alignof(AJunoTeleporter) == 0x000008, "Wrong alignment on AJunoTeleporter");
static_assert(sizeof(AJunoTeleporter) == 0x000BD8, "Wrong size on AJunoTeleporter");
static_assert(offsetof(AJunoTeleporter, TargetTeleporter) == 0x000BC8, "Member 'AJunoTeleporter::TargetTeleporter' has a wrong offset!");
static_assert(offsetof(AJunoTeleporter, bIsTeleporterEnabled) == 0x000BD0, "Member 'AJunoTeleporter::bIsTeleporterEnabled' has a wrong offset!");

// Class JunoGameNative.JunoTemperatureComponent
// 0x0008 (0x00A8 - 0x00A0)
class UJunoTemperatureComponent final : public UGameFrameworkComponent
{
public:
	TWeakObjectPtr<class UJunoTemperatureAttributeSet> TemperatureAttributeSet;                           // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleOwnerASCInitialized(class UFortAbilitySystemComponent* FortAbilitySystemComponent, class AFortPlayerPawn* AffectedPawn);
	void HandleOwnerASCInvalidated();

	class UJunoTemperatureAttributeSet* GetTemperatureAttributeSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTemperatureComponent">();
	}
	static class UJunoTemperatureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTemperatureComponent>();
	}
};
static_assert(alignof(UJunoTemperatureComponent) == 0x000008, "Wrong alignment on UJunoTemperatureComponent");
static_assert(sizeof(UJunoTemperatureComponent) == 0x0000A8, "Wrong size on UJunoTemperatureComponent");
static_assert(offsetof(UJunoTemperatureComponent, TemperatureAttributeSet) == 0x0000A0, "Member 'UJunoTemperatureComponent::TemperatureAttributeSet' has a wrong offset!");

// Class JunoGameNative.JunoToyAttachmentFixupComponent
// 0x0008 (0x00A8 - 0x00A0)
class UJunoToyAttachmentFixupComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleToyAttachementFixupTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoToyAttachmentFixupComponent">();
	}
	static class UJunoToyAttachmentFixupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoToyAttachmentFixupComponent>();
	}
};
static_assert(alignof(UJunoToyAttachmentFixupComponent) == 0x000008, "Wrong alignment on UJunoToyAttachmentFixupComponent");
static_assert(sizeof(UJunoToyAttachmentFixupComponent) == 0x0000A8, "Wrong size on UJunoToyAttachmentFixupComponent");

// Class JunoGameNative.JunoWeaponAbility
// 0x0000 (0x0B60 - 0x0B60)
class UJunoWeaponAbility final : public UFortGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeaponAbility">();
	}
	static class UJunoWeaponAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeaponAbility>();
	}
};
static_assert(alignof(UJunoWeaponAbility) == 0x000008, "Wrong alignment on UJunoWeaponAbility");
static_assert(sizeof(UJunoWeaponAbility) == 0x000B60, "Wrong size on UJunoWeaponAbility");

// Class JunoGameNative.JunoWeaponsBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoWeaponsBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<TSubclassOf<class UFortAthenaAISpawnerData>> GetCreaturesToSpawn(const class UGameplayAbility* GameplayAbility);
	static TArray<struct FDataTableRowHandle> GetSpawnEvents(const class UGameplayAbility* GameplayAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeaponsBlueprintLibrary">();
	}
	static class UJunoWeaponsBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeaponsBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoWeaponsBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoWeaponsBlueprintLibrary");
static_assert(sizeof(UJunoWeaponsBlueprintLibrary) == 0x000028, "Wrong size on UJunoWeaponsBlueprintLibrary");

// Class JunoGameNative.JunoWeatherLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoWeatherLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FJunoWeatherLocation CalculateLocation(const class AActor* Actor);
	static class FString DescribeLocation(const struct FJunoWeatherLocation& WeatherLocation);
	static class FString DescribePhase(const struct FJunoWeatherPhase& WeatherPhase);
	static bool EqualEqual_JunoWeatherLocation(const struct FJunoWeatherLocation& A, const struct FJunoWeatherLocation& B);
	static class UJunoGameStateWeatherComponent* FindGameStateWeatherComponent(const class UObject* WorldContextObject);
	static bool NotEqual_JunoWeatherLocation(const struct FJunoWeatherLocation& A, const struct FJunoWeatherLocation& B);
	static struct FJunoWeatherPhase RollWeatherFromForecast(const struct FJunoWeatherPhaseForecast& Forecast);
	static struct FJunoWeatherPhase RollWeatherFromSeason(const struct FJunoWeatherSeasonRow& Season, const struct FJunoWeatherLocation& Location, const struct FGameplayTag& OptionalWeatherType);
	static struct FJunoWeatherLocation StringToLocation(class FName LocationName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherLibrary">();
	}
	static class UJunoWeatherLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeatherLibrary>();
	}
};
static_assert(alignof(UJunoWeatherLibrary) == 0x000008, "Wrong alignment on UJunoWeatherLibrary");
static_assert(sizeof(UJunoWeatherLibrary) == 0x000028, "Wrong size on UJunoWeatherLibrary");

// Class JunoGameNative.JunoWeatherPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoWeatherPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherPersistenceFeatureModule">();
	}
	static class UJunoWeatherPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeatherPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoWeatherPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoWeatherPersistenceFeatureModule");
static_assert(sizeof(UJunoWeatherPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoWeatherPersistenceFeatureModule");

// Class JunoGameNative.JunoWeatherReactionComponent
// 0x0028 (0x00C8 - 0x00A0)
class UJunoWeatherReactionComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FJunoEvent_WeatherPhaseChanged& Payload)> OnWeatherPhaseChanged;                             // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FJunoEvent_TemperatureChanged& Payload)> OnTemperatureChanged;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleWeatherLocationChanged(const struct FJunoWeatherLocationChangedEvent& Payload);
	void ReceiveOnTemperatureChanged(const struct FJunoEvent_TemperatureChanged& Payload);
	void ReceiveOnWeatherPhaseChanged(const struct FJunoEvent_WeatherPhaseChanged& Payload);

	class UJunoWeatherStateComponent* FindWeatherState() const;
	struct FJunoWeatherLocation GetClosestStatefulLocationFor(const struct FJunoWeatherLocation& WeatherLocation) const;
	struct FGameplayTag GetCurrentTemperature() const;
	float GetCurrentTemperatureFloat() const;
	struct FJunoWeatherPhase GetCurrentWeatherPhase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherReactionComponent">();
	}
	static class UJunoWeatherReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeatherReactionComponent>();
	}
};
static_assert(alignof(UJunoWeatherReactionComponent) == 0x000008, "Wrong alignment on UJunoWeatherReactionComponent");
static_assert(sizeof(UJunoWeatherReactionComponent) == 0x0000C8, "Wrong size on UJunoWeatherReactionComponent");
static_assert(offsetof(UJunoWeatherReactionComponent, OnWeatherPhaseChanged) == 0x0000A0, "Member 'UJunoWeatherReactionComponent::OnWeatherPhaseChanged' has a wrong offset!");
static_assert(offsetof(UJunoWeatherReactionComponent, OnTemperatureChanged) == 0x0000B0, "Member 'UJunoWeatherReactionComponent::OnTemperatureChanged' has a wrong offset!");

// Class JunoGameNative.JunoWeatherStateComponent
// 0x00E8 (0x0188 - 0x00A0)
class UJunoWeatherStateComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoWeatherLocation                   Location;                                          // 0x00D0(0x0002)(Edit, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             SeasonTable;                                       // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoWeatherPhase                      CurrentWeatherPhase;                               // 0x00E8(0x0038)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoWeatherPhase                      NextWeatherPhase;                                  // 0x0120(0x0038)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FJunoWeatherPhase>              NextWeatherQueue;                                  // 0x0158(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x20];                                     // 0x0168(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearNextWeatherQueue();
	void ForceNextWeatherTo(const struct FJunoWeatherPhase& NewNextWeatherPhase);
	void OnRep_CurrentWeatherPhase();
	void QueueNextWeather(const struct FJunoWeatherPhase& QueuedWeather);
	void ReceiveTemperatureChanged(const struct FJunoEvent_TemperatureChanged& Payload);
	void ReceiveWeatherPhaseChanged(const struct FJunoEvent_WeatherPhaseChanged& Payload);
	void RerollNextWeatherWith(const struct FGameplayTag& WeatherTypeName);
	void SetAutoTransitioning(bool bAutoTransitionWeather);
	void TransitionWeatherNow();
	void TransitionWeatherNowTo(const struct FJunoWeatherPhase& NewWeatherPhase, const struct FJunoWeatherPhase& NewNextWeatherPhase);

	struct FGameplayTag GetCurrentSeason() const;
	struct FGameplayTag GetCurrentTemperature() const;
	float GetCurrentTemperatureFloat() const;
	const struct FJunoWeatherPhase GetCurrentWeatherPhase() const;
	const struct FJunoWeatherLocation GetLocation() const;
	const struct FJunoWeatherPhase GetNextWeatherPhase() const;
	TArray<struct FJunoWeatherPhase> GetNextWeatherQueue() const;
	float GetTransitionInAlpha() const;
	float GetTransitionOutAlpha() const;
	bool IsAutoTransitioning() const;
	struct FJunoWeatherPhase RollWeatherPhase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherStateComponent">();
	}
	static class UJunoWeatherStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWeatherStateComponent>();
	}
};
static_assert(alignof(UJunoWeatherStateComponent) == 0x000008, "Wrong alignment on UJunoWeatherStateComponent");
static_assert(sizeof(UJunoWeatherStateComponent) == 0x000188, "Wrong size on UJunoWeatherStateComponent");
static_assert(offsetof(UJunoWeatherStateComponent, Location) == 0x0000D0, "Member 'UJunoWeatherStateComponent::Location' has a wrong offset!");
static_assert(offsetof(UJunoWeatherStateComponent, SeasonTable) == 0x0000D8, "Member 'UJunoWeatherStateComponent::SeasonTable' has a wrong offset!");
static_assert(offsetof(UJunoWeatherStateComponent, CurrentWeatherPhase) == 0x0000E8, "Member 'UJunoWeatherStateComponent::CurrentWeatherPhase' has a wrong offset!");
static_assert(offsetof(UJunoWeatherStateComponent, NextWeatherPhase) == 0x000120, "Member 'UJunoWeatherStateComponent::NextWeatherPhase' has a wrong offset!");
static_assert(offsetof(UJunoWeatherStateComponent, NextWeatherQueue) == 0x000158, "Member 'UJunoWeatherStateComponent::NextWeatherQueue' has a wrong offset!");

// Class JunoGameNative.JunoWorldPersistenceCheckpointManager
// 0x0028 (0x0050 - 0x0028)
class UJunoWorldPersistenceCheckpointManager final : public UObject
{
public:
	int32                                         CheckpointIntervalSeconds;                         // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinCheckpointIntervalSeconds;                      // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxCheckpointCountWithinConfiguredInterval;        // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x1C];                                      // 0x0034(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceCheckpointManager">();
	}
	static class UJunoWorldPersistenceCheckpointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistenceCheckpointManager>();
	}
};
static_assert(alignof(UJunoWorldPersistenceCheckpointManager) == 0x000008, "Wrong alignment on UJunoWorldPersistenceCheckpointManager");
static_assert(sizeof(UJunoWorldPersistenceCheckpointManager) == 0x000050, "Wrong size on UJunoWorldPersistenceCheckpointManager");
static_assert(offsetof(UJunoWorldPersistenceCheckpointManager, CheckpointIntervalSeconds) == 0x000028, "Member 'UJunoWorldPersistenceCheckpointManager::CheckpointIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceCheckpointManager, MinCheckpointIntervalSeconds) == 0x00002C, "Member 'UJunoWorldPersistenceCheckpointManager::MinCheckpointIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceCheckpointManager, MaxCheckpointCountWithinConfiguredInterval) == 0x000030, "Member 'UJunoWorldPersistenceCheckpointManager::MaxCheckpointCountWithinConfiguredInterval' has a wrong offset!");

// Class JunoGameNative.JunoWorldPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoWorldPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceFeatureModule">();
	}
	static class UJunoWorldPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoWorldPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoWorldPersistenceFeatureModule");
static_assert(sizeof(UJunoWorldPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoWorldPersistenceFeatureModule");

// Class JunoGameNative.JunoWorldPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoWorldPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceFeatureData_Container">();
	}
	static class UJunoWorldPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoWorldPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoWorldPersistenceFeatureData_Container");
static_assert(sizeof(UJunoWorldPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoWorldPersistenceFeatureData_Container");

// Class JunoGameNative.JunoWorldPersistenceSubsystemData
// 0x0018 (0x0048 - 0x0030)
class UJunoWorldPersistenceSubsystemData final : public UPrimaryDataAsset
{
public:
	TArray<TSubclassOf<class UJunoWorldPersistenceHandler>> AvailableWorldPersistenceHandlerClasses;           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UJunoWorldPersistenceHandler> DefaultWorldPersistenceHandlerClass;               // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceSubsystemData">();
	}
	static class UJunoWorldPersistenceSubsystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistenceSubsystemData>();
	}
};
static_assert(alignof(UJunoWorldPersistenceSubsystemData) == 0x000008, "Wrong alignment on UJunoWorldPersistenceSubsystemData");
static_assert(sizeof(UJunoWorldPersistenceSubsystemData) == 0x000048, "Wrong size on UJunoWorldPersistenceSubsystemData");
static_assert(offsetof(UJunoWorldPersistenceSubsystemData, AvailableWorldPersistenceHandlerClasses) == 0x000030, "Member 'UJunoWorldPersistenceSubsystemData::AvailableWorldPersistenceHandlerClasses' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceSubsystemData, DefaultWorldPersistenceHandlerClass) == 0x000040, "Member 'UJunoWorldPersistenceSubsystemData::DefaultWorldPersistenceHandlerClass' has a wrong offset!");

// Class JunoGameNative.JunoWorldRegistryInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoWorldRegistryInterface final : public IInterface
{
public:
	void GetWorldAnalyticsInfo(const class UObject* WorldContextObject, const struct FVector& WorldLocation, struct FJunoWorldAnalyticsInfoResult* WorldAnalyticsInfo) const;
	void GetWorldDebugInfoText(const class AFortPlayerPawn* PlayerPawn, struct FJunoDebugWorldInfoResult* WorldDebugInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldRegistryInterface">();
	}
	static class IJunoWorldRegistryInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoWorldRegistryInterface>();
	}
};
static_assert(alignof(IJunoWorldRegistryInterface) == 0x000008, "Wrong alignment on IJunoWorldRegistryInterface");
static_assert(sizeof(IJunoWorldRegistryInterface) == 0x000028, "Wrong size on IJunoWorldRegistryInterface");

// Class JunoGameNative.JunoWorldSettingsBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoWorldSettingsBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FGameplayTag> GetAllWorldSettingNames(const class UObject* WorldContextObject);
	static bool IsWorldSettingOn(const class UObject* WorldContextObject, const struct FGameplayTag& SettingName);
	static bool IsWorldSettingSaved(const class UObject* WorldContextObject, const struct FGameplayTag& SettingName);
	static bool IsWorldSettingTainted(const class UObject* WorldContextObject, const struct FGameplayTag& SettingName);
	static void TurnWorldSettingOff(const class UObject* WorldContextObject, const struct FGameplayTag& SettingName);
	static void TurnWorldSettingOn(const class UObject* WorldContextObject, const struct FGameplayTag& SettingName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldSettingsBlueprintLibrary">();
	}
	static class UJunoWorldSettingsBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldSettingsBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoWorldSettingsBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoWorldSettingsBlueprintLibrary");
static_assert(sizeof(UJunoWorldSettingsBlueprintLibrary) == 0x000028, "Wrong size on UJunoWorldSettingsBlueprintLibrary");

// Class JunoGameNative.JunoWorldSettingsPersistenceFeatureData
// 0x0068 (0x00A8 - 0x0040)
class UJunoWorldSettingsPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       BoolWorldSettings;                                 // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FJunoWorldSettingsSaveData             WorldSettingsSaveData;                             // 0x0098(0x0010)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldSettingsPersistenceFeatureData">();
	}
	static class UJunoWorldSettingsPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldSettingsPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoWorldSettingsPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoWorldSettingsPersistenceFeatureData");
static_assert(sizeof(UJunoWorldSettingsPersistenceFeatureData) == 0x0000A8, "Wrong size on UJunoWorldSettingsPersistenceFeatureData");
static_assert(offsetof(UJunoWorldSettingsPersistenceFeatureData, BoolWorldSettings) == 0x000048, "Member 'UJunoWorldSettingsPersistenceFeatureData::BoolWorldSettings' has a wrong offset!");
static_assert(offsetof(UJunoWorldSettingsPersistenceFeatureData, WorldSettingsSaveData) == 0x000098, "Member 'UJunoWorldSettingsPersistenceFeatureData::WorldSettingsSaveData' has a wrong offset!");

// Class JunoGameNative.JunoWorldSettingsPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoWorldSettingsPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldSettingsPersistenceFeatureData_Container">();
	}
	static class UJunoWorldSettingsPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldSettingsPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoWorldSettingsPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoWorldSettingsPersistenceFeatureData_Container");
static_assert(sizeof(UJunoWorldSettingsPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoWorldSettingsPersistenceFeatureData_Container");

// Class JunoGameNative.PhysicalStrainHealthSubsystem
// 0x0018 (0x0058 - 0x0040)
class UPhysicalStrainHealthSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalStrainHealthSubsystem">();
	}
	static class UPhysicalStrainHealthSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalStrainHealthSubsystem>();
	}
};
static_assert(alignof(UPhysicalStrainHealthSubsystem) == 0x000008, "Wrong alignment on UPhysicalStrainHealthSubsystem");
static_assert(sizeof(UPhysicalStrainHealthSubsystem) == 0x000058, "Wrong size on UPhysicalStrainHealthSubsystem");

// Class JunoGameNative.JunoCampWorldConditionSchema
// 0x0008 (0x0040 - 0x0038)
class UJunoCampWorldConditionSchema : public UWorldConditionSchema
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampWorldConditionSchema">();
	}
	static class UJunoCampWorldConditionSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampWorldConditionSchema>();
	}
};
static_assert(alignof(UJunoCampWorldConditionSchema) == 0x000008, "Wrong alignment on UJunoCampWorldConditionSchema");
static_assert(sizeof(UJunoCampWorldConditionSchema) == 0x000040, "Wrong size on UJunoCampWorldConditionSchema");

// Class JunoGameNative.JunoAwesomeInteractionConfigMappings
// 0x0050 (0x0080 - 0x0030)
class UJunoAwesomeInteractionConfigMappings final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FDataTableRowHandle> InteractionConfigMap;                              // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAwesomeInteractionConfigMappings">();
	}
	static class UJunoAwesomeInteractionConfigMappings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAwesomeInteractionConfigMappings>();
	}
};
static_assert(alignof(UJunoAwesomeInteractionConfigMappings) == 0x000008, "Wrong alignment on UJunoAwesomeInteractionConfigMappings");
static_assert(sizeof(UJunoAwesomeInteractionConfigMappings) == 0x000080, "Wrong size on UJunoAwesomeInteractionConfigMappings");
static_assert(offsetof(UJunoAwesomeInteractionConfigMappings, InteractionConfigMap) == 0x000030, "Member 'UJunoAwesomeInteractionConfigMappings::InteractionConfigMap' has a wrong offset!");

// Class JunoGameNative.JunoAwesomePoiConfigMappings
// 0x0060 (0x0090 - 0x0030)
class UJunoAwesomePoiConfigMappings final : public UDataAsset
{
public:
	TMap<EJunoBiome, struct FDataTableRowHandle>  PoiConfigMap;                                      // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    DefaultConfig;                                     // 0x0080(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAwesomePoiConfigMappings">();
	}
	static class UJunoAwesomePoiConfigMappings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAwesomePoiConfigMappings>();
	}
};
static_assert(alignof(UJunoAwesomePoiConfigMappings) == 0x000008, "Wrong alignment on UJunoAwesomePoiConfigMappings");
static_assert(sizeof(UJunoAwesomePoiConfigMappings) == 0x000090, "Wrong size on UJunoAwesomePoiConfigMappings");
static_assert(offsetof(UJunoAwesomePoiConfigMappings, PoiConfigMap) == 0x000030, "Member 'UJunoAwesomePoiConfigMappings::PoiConfigMap' has a wrong offset!");
static_assert(offsetof(UJunoAwesomePoiConfigMappings, DefaultConfig) == 0x000080, "Member 'UJunoAwesomePoiConfigMappings::DefaultConfig' has a wrong offset!");

// Class JunoGameNative.JunoAwesomeThresholdsComponent
// 0x0038 (0x00D8 - 0x00A0)
class UJunoAwesomeThresholdsComponent final : public UGameFrameworkComponent
{
public:
	TMulticastInlineDelegate<void(int32 NewAwesomeLevel)> OnAwesomeLevelChanged;                             // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FJunoAwesomeThresholdMapping>   AwesomeThresholdToActionsMappings;                 // 0x00B0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleJunoAwesomeLevelChanged(const struct FJunoAwesomeLevelChangeData& ChangeData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAwesomeThresholdsComponent">();
	}
	static class UJunoAwesomeThresholdsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAwesomeThresholdsComponent>();
	}
};
static_assert(alignof(UJunoAwesomeThresholdsComponent) == 0x000008, "Wrong alignment on UJunoAwesomeThresholdsComponent");
static_assert(sizeof(UJunoAwesomeThresholdsComponent) == 0x0000D8, "Wrong size on UJunoAwesomeThresholdsComponent");
static_assert(offsetof(UJunoAwesomeThresholdsComponent, OnAwesomeLevelChanged) == 0x0000A0, "Member 'UJunoAwesomeThresholdsComponent::OnAwesomeLevelChanged' has a wrong offset!");
static_assert(offsetof(UJunoAwesomeThresholdsComponent, AwesomeThresholdToActionsMappings) == 0x0000B0, "Member 'UJunoAwesomeThresholdsComponent::AwesomeThresholdToActionsMappings' has a wrong offset!");

// Class JunoGameNative.JunoNamedPOIComponent
// 0x00D8 (0x0178 - 0x00A0)
class UJunoNamedPOIComponent final : public UJunoCampComponentBase
{
public:
	TMulticastInlineDelegate<void()>              OnJunoPOIMarkerChangedDelegate;                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   POIName;                                           // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FJunoMarker                            Marker;                                            // 0x00D8(0x0098)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnAwesomeLevelChangedCosmetic(const struct FJunoAwesomeLevelChangeData& ChangeData);
	void K2_OnAwesomePointsModifiedCosmetic(const struct FJunoAwesomePointModificationData& ModificationData);
	void K2_OnPlayerEnteredCampCosmetic(int32 CurrentAwesomeLevel, int32 AwesomePoints, const class AJunoCampActor* OwningCamp);
	void K2_OnPlayerExitedCampCosmetic(int32 CurrentAwesomeLevel, int32 AwesomePoints, const class AJunoCampActor* OwningCamp);
	void OnAwesomeLevelChangedCosmetic(const struct FJunoAwesomeLevelChangeData& ChangeData);
	void OnAwesomePointsModifiedCosmetic(const struct FJunoAwesomePointModificationData& ModificationData);
	void OnRep_Marker();
	void PrepareForCampReadyLogic();
	void ProcessCampReadyLogic(const struct FJunoCampAwesomeStatsData& ReadyData);
	void SetMarker(const struct FJunoMarker& NewMarker);
	void SetPOIName(const class FText& NewPOIName);

	const struct FJunoMarker GetMarker() const;
	const class FText GetPOIName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoNamedPOIComponent">();
	}
	static class UJunoNamedPOIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoNamedPOIComponent>();
	}
};
static_assert(alignof(UJunoNamedPOIComponent) == 0x000008, "Wrong alignment on UJunoNamedPOIComponent");
static_assert(sizeof(UJunoNamedPOIComponent) == 0x000178, "Wrong size on UJunoNamedPOIComponent");
static_assert(offsetof(UJunoNamedPOIComponent, OnJunoPOIMarkerChangedDelegate) == 0x0000A0, "Member 'UJunoNamedPOIComponent::OnJunoPOIMarkerChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoNamedPOIComponent, POIName) == 0x0000C0, "Member 'UJunoNamedPOIComponent::POIName' has a wrong offset!");
static_assert(offsetof(UJunoNamedPOIComponent, Marker) == 0x0000D8, "Member 'UJunoNamedPOIComponent::Marker' has a wrong offset!");

// Class JunoGameNative.JunoCampPersistenceFeatureData
// 0x0018 (0x0058 - 0x0040)
class UJunoCampPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoAllCampsSaveData                  SavedAllCamps;                                     // 0x0048(0x0010)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampPersistenceFeatureData">();
	}
	static class UJunoCampPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoCampPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoCampPersistenceFeatureData");
static_assert(sizeof(UJunoCampPersistenceFeatureData) == 0x000058, "Wrong size on UJunoCampPersistenceFeatureData");
static_assert(offsetof(UJunoCampPersistenceFeatureData, SavedAllCamps) == 0x000048, "Member 'UJunoCampPersistenceFeatureData::SavedAllCamps' has a wrong offset!");

// Class JunoGameNative.JunoCampPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoCampPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampPersistenceFeatureDataInterface">();
	}
	static class IJunoCampPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoCampPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoCampPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoCampPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoCampPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoCampPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoVerbProcessor_AwesomeLevelIncreased
// 0x0000 (0x00A0 - 0x00A0)
class UJunoVerbProcessor_AwesomeLevelIncreased final : public UFortObjectiveProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoVerbProcessor_AwesomeLevelIncreased">();
	}
	static class UJunoVerbProcessor_AwesomeLevelIncreased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoVerbProcessor_AwesomeLevelIncreased>();
	}
};
static_assert(alignof(UJunoVerbProcessor_AwesomeLevelIncreased) == 0x000008, "Wrong alignment on UJunoVerbProcessor_AwesomeLevelIncreased");
static_assert(sizeof(UJunoVerbProcessor_AwesomeLevelIncreased) == 0x0000A0, "Wrong size on UJunoVerbProcessor_AwesomeLevelIncreased");

// Class JunoGameNative.JunoVerbProcessor_GuidedBuildStageCompleted
// 0x0000 (0x00A0 - 0x00A0)
class UJunoVerbProcessor_GuidedBuildStageCompleted final : public UFortObjectiveProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoVerbProcessor_GuidedBuildStageCompleted">();
	}
	static class UJunoVerbProcessor_GuidedBuildStageCompleted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoVerbProcessor_GuidedBuildStageCompleted>();
	}
};
static_assert(alignof(UJunoVerbProcessor_GuidedBuildStageCompleted) == 0x000008, "Wrong alignment on UJunoVerbProcessor_GuidedBuildStageCompleted");
static_assert(sizeof(UJunoVerbProcessor_GuidedBuildStageCompleted) == 0x0000A0, "Wrong size on UJunoVerbProcessor_GuidedBuildStageCompleted");

// Class JunoGameNative.JunoVerbProcessor_TemperatureUpdated
// 0x0000 (0x00A0 - 0x00A0)
class UJunoVerbProcessor_TemperatureUpdated final : public UFortObjectiveProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoVerbProcessor_TemperatureUpdated">();
	}
	static class UJunoVerbProcessor_TemperatureUpdated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoVerbProcessor_TemperatureUpdated>();
	}
};
static_assert(alignof(UJunoVerbProcessor_TemperatureUpdated) == 0x000008, "Wrong alignment on UJunoVerbProcessor_TemperatureUpdated");
static_assert(sizeof(UJunoVerbProcessor_TemperatureUpdated) == 0x0000A0, "Wrong size on UJunoVerbProcessor_TemperatureUpdated");

// Class JunoGameNative.JunoAINavInvokerComponent
// 0x0000 (0x00B0 - 0x00B0)
class UJunoAINavInvokerComponent final : public UNavigationInvokerComponent
{
public:
	void OnNPCPossessed(class APawn* Pawn);
	void OnPlayerPossessed(class APawn* Pawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAINavInvokerComponent">();
	}
	static class UJunoAINavInvokerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAINavInvokerComponent>();
	}
};
static_assert(alignof(UJunoAINavInvokerComponent) == 0x000008, "Wrong alignment on UJunoAINavInvokerComponent");
static_assert(sizeof(UJunoAINavInvokerComponent) == 0x0000B0, "Wrong size on UJunoAINavInvokerComponent");

// Class JunoGameNative.JunoPhysicsObjectNavigationComponent
// 0x00A0 (0x0140 - 0x00A0)
class alignas(0x10) UJunoPhysicsObjectNavigationComponent final : public UActorComponent
{
public:
	float                                         LowSpeedThreshold;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowSpeedDistanceThreshold;                         // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowSpeedRotationThreshold;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowSpeedScaleThreshold;                            // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowSpeedDurationTrigger;                           // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x6C];                                      // 0x00B4(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    PrimitiveComponentAffectingNavMesh;                // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddedToClusterUnion(class UClusterUnionComponent* ClusterUnion, class UPrimitiveComponent* Component);
	void OnClusterUnionPhysicsObjectAwakeChanged(class UPrimitiveComponent* SimulatingComponent, bool bIsAwake);
	void OnRemovedFromClusterUnion(class UClusterUnionComponent* ClusterUnion, class UPrimitiveComponent* Component);
	void OnSleep(class UPrimitiveComponent* SimulatingComponent, class FName BoneName);
	void OnWake(class UPrimitiveComponent* SimulatingComponent, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsObjectNavigationComponent">();
	}
	static class UJunoPhysicsObjectNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPhysicsObjectNavigationComponent>();
	}
};
static_assert(alignof(UJunoPhysicsObjectNavigationComponent) == 0x000010, "Wrong alignment on UJunoPhysicsObjectNavigationComponent");
static_assert(sizeof(UJunoPhysicsObjectNavigationComponent) == 0x000140, "Wrong size on UJunoPhysicsObjectNavigationComponent");
static_assert(offsetof(UJunoPhysicsObjectNavigationComponent, LowSpeedThreshold) == 0x0000A0, "Member 'UJunoPhysicsObjectNavigationComponent::LowSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UJunoPhysicsObjectNavigationComponent, LowSpeedDistanceThreshold) == 0x0000A4, "Member 'UJunoPhysicsObjectNavigationComponent::LowSpeedDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UJunoPhysicsObjectNavigationComponent, LowSpeedRotationThreshold) == 0x0000A8, "Member 'UJunoPhysicsObjectNavigationComponent::LowSpeedRotationThreshold' has a wrong offset!");
static_assert(offsetof(UJunoPhysicsObjectNavigationComponent, LowSpeedScaleThreshold) == 0x0000AC, "Member 'UJunoPhysicsObjectNavigationComponent::LowSpeedScaleThreshold' has a wrong offset!");
static_assert(offsetof(UJunoPhysicsObjectNavigationComponent, LowSpeedDurationTrigger) == 0x0000B0, "Member 'UJunoPhysicsObjectNavigationComponent::LowSpeedDurationTrigger' has a wrong offset!");
static_assert(offsetof(UJunoPhysicsObjectNavigationComponent, PrimitiveComponentAffectingNavMesh) == 0x000120, "Member 'UJunoPhysicsObjectNavigationComponent::PrimitiveComponentAffectingNavMesh' has a wrong offset!");

// Class JunoGameNative.JunoAnimationBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoAnimationBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AbilityMontage_ReplicatePosition(const class AFortPawn* FortPawn, bool bReplicatePosition);
	static void AbilityMontage_SetNextSection(const class AFortPawn* FortPawn, class FName NextSection);
	static void GetCapsuleActorSpaceBounds(class UCapsuleComponent* Capsule, struct FVector* Origin, struct FVector* Extents);
	static void GetClampedWarpTargetLocation(const struct FVector& WarpStartLocation, const struct FVector& WarpTargetLocation, float WarpTargetRadius, float WarpDistanceMax, bool ConstrainToPawnForwardVector, const struct FVector& PawnForward, struct FVector* ClampedTargetLocation, struct FRotator* FaceTargetRotation);
	static struct FRotator GetFacingRotation(const struct FVector& SourceLocation, const struct FVector& TargetLocation);
	static struct FRotator GetFacingTargetRotation(const class USceneComponent* Source, const class USceneComponent* Target, bool bYawOnly);
	static bool HasMatchingImpactCue(const struct FGameplayTagContainer& DamageTags, const class AFortPawn* DamageInstigator, const class AActor* DamageSource);
	static void ImpactOrDamage(const struct FGameplayTagContainer& DamageTags, const class AFortPawn* DamageInstigator, const class AActor* DamageSource, EImpactOrDamage_ExecutionPin* ExecutionPin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAnimationBlueprintLibrary">();
	}
	static class UJunoAnimationBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAnimationBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoAnimationBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoAnimationBlueprintLibrary");
static_assert(sizeof(UJunoAnimationBlueprintLibrary) == 0x000028, "Wrong size on UJunoAnimationBlueprintLibrary");

// Class JunoGameNative.JunoPlayerState
// 0x0028 (0x18B0 - 0x1888)
class AJunoPlayerState final : public AFortPlayerStateAthena
{
public:
	struct FGuid                                  CaveId;                                            // 0x1888(0x0010)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLinearColor>                   PinColorForPlayer;                                 // 0x1898(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           GameplayTagPresentWhenTeleporting;                 // 0x18A8(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18AC[0x4];                                     // 0x18AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGuid GetCaveId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerState">();
	}
	static class AJunoPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPlayerState>();
	}
};
static_assert(alignof(AJunoPlayerState) == 0x000008, "Wrong alignment on AJunoPlayerState");
static_assert(sizeof(AJunoPlayerState) == 0x0018B0, "Wrong size on AJunoPlayerState");
static_assert(offsetof(AJunoPlayerState, CaveId) == 0x001888, "Member 'AJunoPlayerState::CaveId' has a wrong offset!");
static_assert(offsetof(AJunoPlayerState, PinColorForPlayer) == 0x001898, "Member 'AJunoPlayerState::PinColorForPlayer' has a wrong offset!");
static_assert(offsetof(AJunoPlayerState, GameplayTagPresentWhenTeleporting) == 0x0018A8, "Member 'AJunoPlayerState::GameplayTagPresentWhenTeleporting' has a wrong offset!");

// Class JunoGameNative.JunoAnimInstance
// 0x0010 (0x0470 - 0x0460)
class UJunoAnimInstance : public UFortBaseAnimInstance
{
public:
	uint8                                         Pad_458[0x18];                                     // 0x0458(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RandomizeAnimationTimer(float MinTime, float MaxTime, float& TimeRemaining, bool& bTimeIsExpired);
	void UpdateAnimationTimer(float& TimeRemaining, bool& bTimeIsExpired, EUpdateAnimationTimer_ExecutionPin* ExecutionPin);

	float BlendCurvesByName(class FName CurveA, class FName CurveB, float Alpha) const;
	class UJunoAnimInstance* GetMainAnimInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAnimInstance">();
	}
	static class UJunoAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAnimInstance>();
	}
};
static_assert(alignof(UJunoAnimInstance) == 0x000010, "Wrong alignment on UJunoAnimInstance");
static_assert(sizeof(UJunoAnimInstance) == 0x000470, "Wrong size on UJunoAnimInstance");

// Class JunoGameNative.JunoGliderAnimInstance
// 0x0010 (0x0840 - 0x0830)
class UJunoGliderAnimInstance final : public UFortGliderAnimInstance
{
public:
	uint8                                         bIsSkydiving : 1;                                  // 0x0828(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsParachuteOpen : 1;                              // 0x0828(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGliderUseFastDeploy : 1;                          // 0x0828(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_829[0x3];                                      // 0x0829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GliderPitch;                                       // 0x082C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderRoll;                                        // 0x0830(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_834[0x4];                                      // 0x0834(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoPlayerAnimInstance*                PlayerAnimInstance;                                // 0x0838(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGliderAnimInstance">();
	}
	static class UJunoGliderAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGliderAnimInstance>();
	}
};
static_assert(alignof(UJunoGliderAnimInstance) == 0x000010, "Wrong alignment on UJunoGliderAnimInstance");
static_assert(sizeof(UJunoGliderAnimInstance) == 0x000840, "Wrong size on UJunoGliderAnimInstance");
static_assert(offsetof(UJunoGliderAnimInstance, GliderPitch) == 0x00082C, "Member 'UJunoGliderAnimInstance::GliderPitch' has a wrong offset!");
static_assert(offsetof(UJunoGliderAnimInstance, GliderRoll) == 0x000830, "Member 'UJunoGliderAnimInstance::GliderRoll' has a wrong offset!");
static_assert(offsetof(UJunoGliderAnimInstance, PlayerAnimInstance) == 0x000838, "Member 'UJunoGliderAnimInstance::PlayerAnimInstance' has a wrong offset!");

// Class JunoGameNative.JunoPlayerPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoPlayerPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerPersistenceFeatureDataInterface">();
	}
	static class IJunoPlayerPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoPlayerPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoPlayerPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoPlayerPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoPlayerPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoPlayerPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoMinifigAnimationComponent
// 0x0018 (0x00B8 - 0x00A0)
class UJunoMinifigAnimationComponent final : public UPawnComponent
{
public:
	struct FRotator                               MinifigLookAtRotation;                             // 0x00A0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMinifigAnimationComponent">();
	}
	static class UJunoMinifigAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMinifigAnimationComponent>();
	}
};
static_assert(alignof(UJunoMinifigAnimationComponent) == 0x000008, "Wrong alignment on UJunoMinifigAnimationComponent");
static_assert(sizeof(UJunoMinifigAnimationComponent) == 0x0000B8, "Wrong size on UJunoMinifigAnimationComponent");
static_assert(offsetof(UJunoMinifigAnimationComponent, MinifigLookAtRotation) == 0x0000A0, "Member 'UJunoMinifigAnimationComponent::MinifigLookAtRotation' has a wrong offset!");

// Class JunoGameNative.JunoPawnAnimInstance
// 0x0110 (0x0580 - 0x0470)
class UJunoPawnAnimInstance : public UJunoAnimInstance
{
public:
	float                                         PawnMovingSpeedThreshold;                          // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x0474(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PawnSpeed2D;                                       // 0x0478(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PawnVelocity;                                      // 0x0480(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PawnRotationRate;                                  // 0x0498(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bPawnIsDying : 1;                                  // 0x04B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnIsFalling : 1;                                // 0x04B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnIsOnGround : 1;                               // 0x04B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnIsIdling : 1;                                 // 0x04B0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnIsJumping : 1;                                // 0x04B0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnIsMoving2D : 1;                               // 0x04B0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnIsMovingOnGround : 1;                         // 0x04B0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnWasMoving2D : 1;                              // 0x04B0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnHasAcceleration : 1;                          // 0x04B1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnHasRootMotion : 1;                            // 0x04B1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnHasVelocity : 1;                              // 0x04B1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnIdleBreakTimeIsExpired : 1;                   // 0x04B1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnMovingIdleBreakTimeIsExpired : 1;             // 0x04B1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4B2[0x6];                                      // 0x04B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PawnAcceleration;                                  // 0x04B8(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnAccelerationDirection;                         // 0x04D0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PawnRotation;                                      // 0x04D8(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PawnRotationDelta;                                 // 0x04F0(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PawnRotationRateNormalized;                        // 0x0508(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PawnRootRotation;                                  // 0x0520(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PawnVelocityDirection;                             // 0x0538(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PawnPreviousVelocity;                              // 0x0540(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnIdleBreakTime;                                 // 0x0558(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnMovingIdleBreakTime;                           // 0x055C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnCurrentLOD;                                    // 0x0560(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_564[0x4];                                      // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PawnLocation;                                      // 0x0568(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearPawnIdleBreakTimer();
	void ClearPawnMovingIdleBreakTimer();
	void StartPawnIdleBreakTimer(float MinTime, float MaxTime);
	void StartPawnMovingIdleBreakTimer(float MinTime, float MaxTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPawnAnimInstance">();
	}
	static class UJunoPawnAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPawnAnimInstance>();
	}
};
static_assert(alignof(UJunoPawnAnimInstance) == 0x000010, "Wrong alignment on UJunoPawnAnimInstance");
static_assert(sizeof(UJunoPawnAnimInstance) == 0x000580, "Wrong size on UJunoPawnAnimInstance");
static_assert(offsetof(UJunoPawnAnimInstance, PawnMovingSpeedThreshold) == 0x000470, "Member 'UJunoPawnAnimInstance::PawnMovingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, bIsFalling) == 0x000474, "Member 'UJunoPawnAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnSpeed2D) == 0x000478, "Member 'UJunoPawnAnimInstance::PawnSpeed2D' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnVelocity) == 0x000480, "Member 'UJunoPawnAnimInstance::PawnVelocity' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnRotationRate) == 0x000498, "Member 'UJunoPawnAnimInstance::PawnRotationRate' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnAcceleration) == 0x0004B8, "Member 'UJunoPawnAnimInstance::PawnAcceleration' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnAccelerationDirection) == 0x0004D0, "Member 'UJunoPawnAnimInstance::PawnAccelerationDirection' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnRotation) == 0x0004D8, "Member 'UJunoPawnAnimInstance::PawnRotation' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnRotationDelta) == 0x0004F0, "Member 'UJunoPawnAnimInstance::PawnRotationDelta' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnRotationRateNormalized) == 0x000508, "Member 'UJunoPawnAnimInstance::PawnRotationRateNormalized' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnRootRotation) == 0x000520, "Member 'UJunoPawnAnimInstance::PawnRootRotation' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnVelocityDirection) == 0x000538, "Member 'UJunoPawnAnimInstance::PawnVelocityDirection' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnPreviousVelocity) == 0x000540, "Member 'UJunoPawnAnimInstance::PawnPreviousVelocity' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnIdleBreakTime) == 0x000558, "Member 'UJunoPawnAnimInstance::PawnIdleBreakTime' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnMovingIdleBreakTime) == 0x00055C, "Member 'UJunoPawnAnimInstance::PawnMovingIdleBreakTime' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnCurrentLOD) == 0x000560, "Member 'UJunoPawnAnimInstance::PawnCurrentLOD' has a wrong offset!");
static_assert(offsetof(UJunoPawnAnimInstance, PawnLocation) == 0x000568, "Member 'UJunoPawnAnimInstance::PawnLocation' has a wrong offset!");

// Class JunoGameNative.PlayspaceComponent_JunoPerformance
// 0x0008 (0x00A8 - 0x00A0)
class UPlayspaceComponent_JunoPerformance final : public UPlayspaceComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceComponent_JunoPerformance">();
	}
	static class UPlayspaceComponent_JunoPerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceComponent_JunoPerformance>();
	}
};
static_assert(alignof(UPlayspaceComponent_JunoPerformance) == 0x000008, "Wrong alignment on UPlayspaceComponent_JunoPerformance");
static_assert(sizeof(UPlayspaceComponent_JunoPerformance) == 0x0000A8, "Wrong size on UPlayspaceComponent_JunoPerformance");

// Class JunoGameNative.JunoPlayerAnimInstance
// 0x0370 (0x08F0 - 0x0580)
class UJunoPlayerAnimInstance final : public UJunoPawnAnimInstance
{
public:
	float                                         PlayerLookAngleFromPawnMax;                        // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerLookAngleFromRootMax;                        // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerFaceVisibleAngle;                            // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRunningAccelerationThreshold;                // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerWalkingAccelerationThreshold;                // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PlayerStrafeCurve;                                 // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerPawn*                        FortPlayerPawn;                                    // 0x05A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsAccelerating2D : 1;                             // 0x05A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSurfaceSwimming : 1;                            // 0x05A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsMovingAndInMotionEmote : 1;                     // 0x05A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bIsSlopeSliding;                                   // 0x05A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsInVehicle : 1;                                  // 0x05AA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5AB[0x5];                                      // 0x05AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalAcceleration;                                 // 0x05B0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalAccelYawAngle;                                // 0x05C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalVelocity;                                     // 0x05D0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityYawAngle;                             // 0x05E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x05EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSwimSpeed;                                      // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityZ;                                         // 0x05F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldAcceleration;                                 // 0x05F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldVelocity;                                     // 0x0610(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ActorRotationLastTick;                             // 0x0628(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         YawDeltaCurrentTick;                               // 0x0640(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDeltaLastTick;                                  // 0x0644(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDeltaSmoothed;                                  // 0x0648(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsTacticalSprint : 1;                             // 0x064C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSkydiving : 1;                                  // 0x064C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsParachuteOpen : 1;                              // 0x064C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGliderUseFastDeploy : 1;                          // 0x064C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGliderIsOpen : 1;                                 // 0x064C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGliderWasOpen : 1;                                // 0x064C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerProp1Aim : 1;                               // 0x064C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerProp2Aim : 1;                               // 0x064C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsCold : 1;                                 // 0x064D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsMildCold : 1;                             // 0x064D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsVeryCold : 1;                             // 0x064D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsHot : 1;                                  // 0x064D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsMildHot : 1;                              // 0x064D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsVeryHot : 1;                              // 0x064D(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsHumanControlled : 1;                      // 0x064D(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsSneaking : 1;                             // 0x064D(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsFishing : 1;                              // 0x064E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerWasFishing : 1;                             // 0x064E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsFocusing : 1;                             // 0x064E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsFlying : 1;                               // 0x064E(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsFacingController : 1;                     // 0x064E(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsMovingBackwards : 1;                      // 0x064E(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsProp1AimTargetValid : 1;                  // 0x064E(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsPushing : 1;                              // 0x064E(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerWasPushing : 1;                             // 0x064F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsRunning : 1;                              // 0x064F(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsSprinting : 1;                            // 0x064F(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsWalking : 1;                              // 0x064F(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerIsWaterJumping : 1;                         // 0x064F(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerShouldMove : 1;                             // 0x064F(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerShouldTurnInPlace : 1;                      // 0x064F(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerFaceIsVisible : 1;                          // 0x064F(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerUpperBodyIsSwinging : 1;                    // 0x0650(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerProp1MontageActive : 1;                     // 0x0650(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerProp2MontageActive : 1;                     // 0x0650(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerHeadShouldFollowCamera : 1;                 // 0x0650(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EFortMovementStyle                            PlayerMovementStyle;                               // 0x0651(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_652[0x2];                                      // 0x0652(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerAccelerationAmount;                          // 0x0654(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerLookAtRotation;                              // 0x0658(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerRotationTarget;                              // 0x0670(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerPreviousRotationTarget;                      // 0x0688(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PlayerRotationTargetRate;                          // 0x06A0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerVelocityYawRate;                             // 0x06A4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerUseProceduralFaceAnim;                       // 0x06A8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJunoMinifigLayeringMask               LayeringMask;                                      // 0x06AC(0x00A0)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74C[0x4];                                      // 0x074C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputAlphaBoolBlend                   SecondaryMotionLODBlend;                           // 0x0750(0x0048)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SecondaryMotionLODThreshold;                       // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryMotionLODBlendTime;                       // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderPitch;                                       // 0x07A0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderRoll;                                        // 0x07A4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortWeapon*                            PlayerMainHandItem;                                // 0x07A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortWeapon*                            PlayerOffHandItem;                                 // 0x07B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayerAimOffset;                                   // 0x07B8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerAimOffsetTemp;                               // 0x07C8(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayerProp1AimOffset;                              // 0x07E0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerProp1AimTargetLocation;                      // 0x07F0(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerSlopeMatchingRotationOffset;                 // 0x0808(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PlayerSlopeMatchingWeight;                         // 0x0820(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_824[0x4];                                      // 0x0824(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PlayerPreviousRootRotation;                        // 0x0828(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EJunoMinifigRotationMode                      PlayerRotationMode;                                // 0x0840(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_841[0x7];                                      // 0x0841(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SmoothedRotationTarget;                            // 0x0848(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SuperSmoothedRotationTarget;                       // 0x0860(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerStartingRotation;                            // 0x0878(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PlayerStartingAngle;                               // 0x0890(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerEmotionHasChanged;                          // 0x0894(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_895[0x5B];                                     // 0x0895(0x005B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerEmotionChanged();
	void OnPlayerMainHandItemChanged(class AFortWeapon* CurrentItem);
	void OnPlayerOffHandItemChanged(class AFortWeapon* CurrentItem);
	void OnPlayerStoppedPushing();
	void SetPlayerRotationMode(EJunoMinifigRotationMode RotationMode);
	void UpdatePlayerAimOffset(float DeltaSeconds);
	void UpdatePlayerAimOffsetWithRootCompensation(const struct FRotator& LookAtRotation, float InterpSpeed, bool bCompensate, float DeltaSeconds);
	void UpdatePlayerContinuousRotateToTarget(float DeltaSeconds);
	void UpdatePlayerCurveRotateToMovingTarget(float DeltaSeconds);
	void UpdatePlayerCurveRotateToStaticTarget(float DeltaSeconds);
	void UpdatePlayerRootRotation(float DeltaSeconds);
	void UpdatePlayerRotationTarget(float DeltaSeconds);

	float GetPlayerLeanAmount() const;
	EJunoMinifigRotationMode GetPlayerRotationMode() const;
	void GetPlayerRotationTargetInterpolationSpeeds(float* SmoothedSpeed, float* SuperSmoothedSpeed) const;
	float GetPlayerStrideScale() const;
	bool ShouldForcePlayerToFacePawnRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerAnimInstance">();
	}
	static class UJunoPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerAnimInstance>();
	}
};
static_assert(alignof(UJunoPlayerAnimInstance) == 0x000010, "Wrong alignment on UJunoPlayerAnimInstance");
static_assert(sizeof(UJunoPlayerAnimInstance) == 0x0008F0, "Wrong size on UJunoPlayerAnimInstance");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerLookAngleFromPawnMax) == 0x000580, "Member 'UJunoPlayerAnimInstance::PlayerLookAngleFromPawnMax' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerLookAngleFromRootMax) == 0x000584, "Member 'UJunoPlayerAnimInstance::PlayerLookAngleFromRootMax' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerFaceVisibleAngle) == 0x000588, "Member 'UJunoPlayerAnimInstance::PlayerFaceVisibleAngle' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerRunningAccelerationThreshold) == 0x00058C, "Member 'UJunoPlayerAnimInstance::PlayerRunningAccelerationThreshold' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerWalkingAccelerationThreshold) == 0x000590, "Member 'UJunoPlayerAnimInstance::PlayerWalkingAccelerationThreshold' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerStrafeCurve) == 0x000598, "Member 'UJunoPlayerAnimInstance::PlayerStrafeCurve' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, FortPlayerPawn) == 0x0005A0, "Member 'UJunoPlayerAnimInstance::FortPlayerPawn' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, bIsSlopeSliding) == 0x0005A9, "Member 'UJunoPlayerAnimInstance::bIsSlopeSliding' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, LocalAcceleration) == 0x0005B0, "Member 'UJunoPlayerAnimInstance::LocalAcceleration' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, LocalAccelYawAngle) == 0x0005C8, "Member 'UJunoPlayerAnimInstance::LocalAccelYawAngle' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, LocalVelocity) == 0x0005D0, "Member 'UJunoPlayerAnimInstance::LocalVelocity' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, LocalVelocityYawAngle) == 0x0005E8, "Member 'UJunoPlayerAnimInstance::LocalVelocityYawAngle' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, MaxSpeed) == 0x0005EC, "Member 'UJunoPlayerAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, MaxSwimSpeed) == 0x0005F0, "Member 'UJunoPlayerAnimInstance::MaxSwimSpeed' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, VelocityZ) == 0x0005F4, "Member 'UJunoPlayerAnimInstance::VelocityZ' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, WorldAcceleration) == 0x0005F8, "Member 'UJunoPlayerAnimInstance::WorldAcceleration' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, WorldVelocity) == 0x000610, "Member 'UJunoPlayerAnimInstance::WorldVelocity' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, ActorRotationLastTick) == 0x000628, "Member 'UJunoPlayerAnimInstance::ActorRotationLastTick' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, YawDeltaCurrentTick) == 0x000640, "Member 'UJunoPlayerAnimInstance::YawDeltaCurrentTick' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, YawDeltaLastTick) == 0x000644, "Member 'UJunoPlayerAnimInstance::YawDeltaLastTick' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, YawDeltaSmoothed) == 0x000648, "Member 'UJunoPlayerAnimInstance::YawDeltaSmoothed' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerMovementStyle) == 0x000651, "Member 'UJunoPlayerAnimInstance::PlayerMovementStyle' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerAccelerationAmount) == 0x000654, "Member 'UJunoPlayerAnimInstance::PlayerAccelerationAmount' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerLookAtRotation) == 0x000658, "Member 'UJunoPlayerAnimInstance::PlayerLookAtRotation' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerRotationTarget) == 0x000670, "Member 'UJunoPlayerAnimInstance::PlayerRotationTarget' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerPreviousRotationTarget) == 0x000688, "Member 'UJunoPlayerAnimInstance::PlayerPreviousRotationTarget' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerRotationTargetRate) == 0x0006A0, "Member 'UJunoPlayerAnimInstance::PlayerRotationTargetRate' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerVelocityYawRate) == 0x0006A4, "Member 'UJunoPlayerAnimInstance::PlayerVelocityYawRate' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerUseProceduralFaceAnim) == 0x0006A8, "Member 'UJunoPlayerAnimInstance::PlayerUseProceduralFaceAnim' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, LayeringMask) == 0x0006AC, "Member 'UJunoPlayerAnimInstance::LayeringMask' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, SecondaryMotionLODBlend) == 0x000750, "Member 'UJunoPlayerAnimInstance::SecondaryMotionLODBlend' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, SecondaryMotionLODThreshold) == 0x000798, "Member 'UJunoPlayerAnimInstance::SecondaryMotionLODThreshold' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, SecondaryMotionLODBlendTime) == 0x00079C, "Member 'UJunoPlayerAnimInstance::SecondaryMotionLODBlendTime' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, GliderPitch) == 0x0007A0, "Member 'UJunoPlayerAnimInstance::GliderPitch' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, GliderRoll) == 0x0007A4, "Member 'UJunoPlayerAnimInstance::GliderRoll' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerMainHandItem) == 0x0007A8, "Member 'UJunoPlayerAnimInstance::PlayerMainHandItem' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerOffHandItem) == 0x0007B0, "Member 'UJunoPlayerAnimInstance::PlayerOffHandItem' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerAimOffset) == 0x0007B8, "Member 'UJunoPlayerAnimInstance::PlayerAimOffset' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerAimOffsetTemp) == 0x0007C8, "Member 'UJunoPlayerAnimInstance::PlayerAimOffsetTemp' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerProp1AimOffset) == 0x0007E0, "Member 'UJunoPlayerAnimInstance::PlayerProp1AimOffset' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerProp1AimTargetLocation) == 0x0007F0, "Member 'UJunoPlayerAnimInstance::PlayerProp1AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerSlopeMatchingRotationOffset) == 0x000808, "Member 'UJunoPlayerAnimInstance::PlayerSlopeMatchingRotationOffset' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerSlopeMatchingWeight) == 0x000820, "Member 'UJunoPlayerAnimInstance::PlayerSlopeMatchingWeight' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerPreviousRootRotation) == 0x000828, "Member 'UJunoPlayerAnimInstance::PlayerPreviousRootRotation' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerRotationMode) == 0x000840, "Member 'UJunoPlayerAnimInstance::PlayerRotationMode' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, SmoothedRotationTarget) == 0x000848, "Member 'UJunoPlayerAnimInstance::SmoothedRotationTarget' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, SuperSmoothedRotationTarget) == 0x000860, "Member 'UJunoPlayerAnimInstance::SuperSmoothedRotationTarget' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerStartingRotation) == 0x000878, "Member 'UJunoPlayerAnimInstance::PlayerStartingRotation' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, PlayerStartingAngle) == 0x000890, "Member 'UJunoPlayerAnimInstance::PlayerStartingAngle' has a wrong offset!");
static_assert(offsetof(UJunoPlayerAnimInstance, bPlayerEmotionHasChanged) == 0x000894, "Member 'UJunoPlayerAnimInstance::bPlayerEmotionHasChanged' has a wrong offset!");

// Class JunoGameNative.JunoPlayerAnimInstanceProxy
// 0x0000 (0x1620 - 0x1620)
class UJunoPlayerAnimInstanceProxy final : public UFortPlayerAnimInstanceProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerAnimInstanceProxy">();
	}
	static class UJunoPlayerAnimInstanceProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerAnimInstanceProxy>();
	}
};
static_assert(alignof(UJunoPlayerAnimInstanceProxy) == 0x000010, "Wrong alignment on UJunoPlayerAnimInstanceProxy");
static_assert(sizeof(UJunoPlayerAnimInstanceProxy) == 0x001620, "Wrong size on UJunoPlayerAnimInstanceProxy");

// Class JunoGameNative.AudioEventAggregatorSubsystem
// 0x0080 (0x00B0 - 0x0030)
class UAudioEventAggregatorSubsystem final : public UWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(TArray<struct FSoundBreakEvent>& OnSoundBreakEvents)> OnSoundBreakEvents;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FSoundCollisionEvent>& OnSoundCollisionEvents)> OnSoundCollisionEvents;                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FSoundBreakEvent>& OnActiveSoundBreakEventsUpdated)> OnActiveSoundBreakEventsUpdated;                   // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FSoundCollisionEvent>& OnActiveSoundCollisionEventsUpdated)> OnActiveSoundCollisionEventsUpdated;               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x38];                                      // 0x0078(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeinitChaosEventRelay();
	void FilterAndGroupBreakEvents(const TArray<struct FChaosBreakEvent>& BreakEvents);
	void FilterAndGroupCollisionEvents(const TArray<struct FCollisionChaosEvent>& CollisionEvents);
	void InitChaosEventRelay();
	bool IsAggregatingCollisionEvents();
	void RemoveActiveBreakEvent(const struct FGuid& EventId);
	void RemoveActiveCollisionEvent(const struct FGuid& EventId);
	void SetBreakEventLifetime(float Time);
	void SetCollisionDeltaVelocityMagnitudeThreshold(float Magnitude);
	void SetCollisionEventLifetime(float Time);
	void SetRadius(float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioEventAggregatorSubsystem">();
	}
	static class UAudioEventAggregatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioEventAggregatorSubsystem>();
	}
};
static_assert(alignof(UAudioEventAggregatorSubsystem) == 0x000008, "Wrong alignment on UAudioEventAggregatorSubsystem");
static_assert(sizeof(UAudioEventAggregatorSubsystem) == 0x0000B0, "Wrong size on UAudioEventAggregatorSubsystem");
static_assert(offsetof(UAudioEventAggregatorSubsystem, OnSoundBreakEvents) == 0x000030, "Member 'UAudioEventAggregatorSubsystem::OnSoundBreakEvents' has a wrong offset!");
static_assert(offsetof(UAudioEventAggregatorSubsystem, OnSoundCollisionEvents) == 0x000040, "Member 'UAudioEventAggregatorSubsystem::OnSoundCollisionEvents' has a wrong offset!");
static_assert(offsetof(UAudioEventAggregatorSubsystem, OnActiveSoundBreakEventsUpdated) == 0x000050, "Member 'UAudioEventAggregatorSubsystem::OnActiveSoundBreakEventsUpdated' has a wrong offset!");
static_assert(offsetof(UAudioEventAggregatorSubsystem, OnActiveSoundCollisionEventsUpdated) == 0x000060, "Member 'UAudioEventAggregatorSubsystem::OnActiveSoundCollisionEventsUpdated' has a wrong offset!");
static_assert(offsetof(UAudioEventAggregatorSubsystem, World) == 0x000070, "Member 'UAudioEventAggregatorSubsystem::World' has a wrong offset!");

// Class JunoGameNative.JunoFoleyContext
// 0x0008 (0x00E0 - 0x00D8)
class UJunoFoleyContext final : public UFortPlayerFoleyContext
{
public:
	float                                         PitchMultiplier;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFoleyContext">();
	}
	static class UJunoFoleyContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFoleyContext>();
	}
};
static_assert(alignof(UJunoFoleyContext) == 0x000008, "Wrong alignment on UJunoFoleyContext");
static_assert(sizeof(UJunoFoleyContext) == 0x0000E0, "Wrong size on UJunoFoleyContext");
static_assert(offsetof(UJunoFoleyContext, PitchMultiplier) == 0x0000D8, "Member 'UJunoFoleyContext::PitchMultiplier' has a wrong offset!");

// Class JunoGameNative.JunoAction
// 0x0000 (0x0028 - 0x0028)
class UJunoAction : public UObject
{
public:
	void K2_OnExecuteAction(const struct FJunoActionTargetPayload& ActionTargetPayload, const class UJunoActionConfig* Config) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAction">();
	}
	static class UJunoAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAction>();
	}
};
static_assert(alignof(UJunoAction) == 0x000008, "Wrong alignment on UJunoAction");
static_assert(sizeof(UJunoAction) == 0x000028, "Wrong size on UJunoAction");

// Class JunoGameNative.JunoAction_SetStaticMesh
// 0x0000 (0x0028 - 0x0028)
class UJunoAction_SetStaticMesh final : public UJunoAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAction_SetStaticMesh">();
	}
	static class UJunoAction_SetStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAction_SetStaticMesh>();
	}
};
static_assert(alignof(UJunoAction_SetStaticMesh) == 0x000008, "Wrong alignment on UJunoAction_SetStaticMesh");
static_assert(sizeof(UJunoAction_SetStaticMesh) == 0x000028, "Wrong size on UJunoAction_SetStaticMesh");

// Class JunoGameNative.JunoActiveItemAnimContext
// 0x0000 (0x0098 - 0x0098)
class UJunoActiveItemAnimContext final : public USoundLibraryAnimContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoActiveItemAnimContext">();
	}
	static class UJunoActiveItemAnimContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoActiveItemAnimContext>();
	}
};
static_assert(alignof(UJunoActiveItemAnimContext) == 0x000008, "Wrong alignment on UJunoActiveItemAnimContext");
static_assert(sizeof(UJunoActiveItemAnimContext) == 0x000098, "Wrong size on UJunoActiveItemAnimContext");

// Class JunoGameNative.JunoCameraMode_OrbitCam
// 0x00C0 (0x1C60 - 0x1BA0)
class UJunoCameraMode_OrbitCam final : public UFortCameraMode_ThirdPerson
{
public:
	bool                                          bIsBuildPreviewMode;                               // 0x1BA0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BA1[0xF];                                     // 0x1BA1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BuildPreviewActorTransform;                        // 0x1BB0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   BuildPreviewLocalBounds;                           // 0x1C10(0x0038)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideCameraOriginDuringBuildPreview;           // 0x1C48(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C49[0x7];                                     // 0x1C49(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BuildPreviewBoundsToForwardDistanceScale;          // 0x1C50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C58[0x8];                                     // 0x1C58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AJunoBuilderTool* GetBuildPreviewerFromViewTarget(const class AActor* ViewTarget);
	void OnBecomeActiveBP(class AActor* ViewTarget);
	void UpdateCameraBP(class AActor* ViewTarget, float DeltaTime, struct FTViewTarget& OutVT);

	bool CalculateCameraOriginForBuildPreview(const class AActor* ViewTarget, struct FVector& OutOrigin) const;
	bool IsCurrentlyInBuildPreviewMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCameraMode_OrbitCam">();
	}
	static class UJunoCameraMode_OrbitCam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCameraMode_OrbitCam>();
	}
};
static_assert(alignof(UJunoCameraMode_OrbitCam) == 0x000010, "Wrong alignment on UJunoCameraMode_OrbitCam");
static_assert(sizeof(UJunoCameraMode_OrbitCam) == 0x001C60, "Wrong size on UJunoCameraMode_OrbitCam");
static_assert(offsetof(UJunoCameraMode_OrbitCam, bIsBuildPreviewMode) == 0x001BA0, "Member 'UJunoCameraMode_OrbitCam::bIsBuildPreviewMode' has a wrong offset!");
static_assert(offsetof(UJunoCameraMode_OrbitCam, BuildPreviewActorTransform) == 0x001BB0, "Member 'UJunoCameraMode_OrbitCam::BuildPreviewActorTransform' has a wrong offset!");
static_assert(offsetof(UJunoCameraMode_OrbitCam, BuildPreviewLocalBounds) == 0x001C10, "Member 'UJunoCameraMode_OrbitCam::BuildPreviewLocalBounds' has a wrong offset!");
static_assert(offsetof(UJunoCameraMode_OrbitCam, bOverrideCameraOriginDuringBuildPreview) == 0x001C48, "Member 'UJunoCameraMode_OrbitCam::bOverrideCameraOriginDuringBuildPreview' has a wrong offset!");
static_assert(offsetof(UJunoCameraMode_OrbitCam, BuildPreviewBoundsToForwardDistanceScale) == 0x001C50, "Member 'UJunoCameraMode_OrbitCam::BuildPreviewBoundsToForwardDistanceScale' has a wrong offset!");

// Class JunoGameNative.JunoPawnComponent_EmotionalState
// 0x0090 (0x0138 - 0x00A8)
class UJunoPawnComponent_EmotionalState final : public UFortPawnComponent
{
public:
	TMulticastInlineDelegate<void(EJunoPawnEmotionalState NewEmotion)> OnJunoCurrentEmotionalStateChangedDelegate;        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EJunoPawnEmotionalState NewEmotion)> OnJunoCurrentEmotionalStateStartedChange;          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float NewEmotionPercent)> OnJunoCurrentEmotionChangeFinished;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(uint8 EmotionIndex)> OnCheatEmotionIndexChanged;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EJunoPawnEmotionalState                       CurrentEmotionalState;                             // 0x00E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoEmotionalStateData                TargetEmotionalState;                              // 0x00EC(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         CheatEmotionIndex;                                 // 0x00FC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoPawnEmotionalStateMappingFromAwesomeLevel> JunoPawnEmotionalStateMappingFromAwesomeLevel;     // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetToDefaultEmotionRate;                         // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeToStayAtEmotionInSeconds;                      // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DefaultEmotionHandle;                              // 0x0128(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleJunoAwesomeLevelChanged(const struct FJunoAwesomeLevelChangeData& ChangeData);
	void OnRep_CheatEmotionIndex();
	void OnRep_CurrentEmotionalState();
	void OnRep_TargetEmotionalState();
	void ResetToDefaultEmotionalState();
	void SetCurrentEmotionalState(const EJunoPawnEmotionalState NewEmotion);
	void SetEmotionalState(const struct FJunoEmotionalStateData& Emotion);

	EJunoPawnEmotionalState GetCurrentEmotionalState() const;
	float GetCurrentEmotionalStateValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPawnComponent_EmotionalState">();
	}
	static class UJunoPawnComponent_EmotionalState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPawnComponent_EmotionalState>();
	}
};
static_assert(alignof(UJunoPawnComponent_EmotionalState) == 0x000008, "Wrong alignment on UJunoPawnComponent_EmotionalState");
static_assert(sizeof(UJunoPawnComponent_EmotionalState) == 0x000138, "Wrong size on UJunoPawnComponent_EmotionalState");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, OnJunoCurrentEmotionalStateChangedDelegate) == 0x0000A8, "Member 'UJunoPawnComponent_EmotionalState::OnJunoCurrentEmotionalStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, OnJunoCurrentEmotionalStateStartedChange) == 0x0000B8, "Member 'UJunoPawnComponent_EmotionalState::OnJunoCurrentEmotionalStateStartedChange' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, OnJunoCurrentEmotionChangeFinished) == 0x0000C8, "Member 'UJunoPawnComponent_EmotionalState::OnJunoCurrentEmotionChangeFinished' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, OnCheatEmotionIndexChanged) == 0x0000D8, "Member 'UJunoPawnComponent_EmotionalState::OnCheatEmotionIndexChanged' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, CurrentEmotionalState) == 0x0000E8, "Member 'UJunoPawnComponent_EmotionalState::CurrentEmotionalState' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, TargetEmotionalState) == 0x0000EC, "Member 'UJunoPawnComponent_EmotionalState::TargetEmotionalState' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, CheatEmotionIndex) == 0x0000FC, "Member 'UJunoPawnComponent_EmotionalState::CheatEmotionIndex' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, JunoPawnEmotionalStateMappingFromAwesomeLevel) == 0x000100, "Member 'UJunoPawnComponent_EmotionalState::JunoPawnEmotionalStateMappingFromAwesomeLevel' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, ResetToDefaultEmotionRate) == 0x000118, "Member 'UJunoPawnComponent_EmotionalState::ResetToDefaultEmotionRate' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, TimeToStayAtEmotionInSeconds) == 0x00011C, "Member 'UJunoPawnComponent_EmotionalState::TimeToStayAtEmotionInSeconds' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_EmotionalState, DefaultEmotionHandle) == 0x000128, "Member 'UJunoPawnComponent_EmotionalState::DefaultEmotionHandle' has a wrong offset!");

// Class JunoGameNative.FortClientPilot_QuickSmokeJuno
// 0x0010 (0x0320 - 0x0310)
class UFortClientPilot_QuickSmokeJuno final : public UFortClientPilot_GameplayBase
{
public:
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientPilot_QuickSmokeJuno">();
	}
	static class UFortClientPilot_QuickSmokeJuno* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientPilot_QuickSmokeJuno>();
	}
};
static_assert(alignof(UFortClientPilot_QuickSmokeJuno) == 0x000010, "Wrong alignment on UFortClientPilot_QuickSmokeJuno");
static_assert(sizeof(UFortClientPilot_QuickSmokeJuno) == 0x000320, "Wrong size on UFortClientPilot_QuickSmokeJuno");

// Class JunoGameNative.FortPickupInteractOverrideComponent_Juno
// 0x0000 (0x00C0 - 0x00C0)
class UFortPickupInteractOverrideComponent_Juno final : public UFortPickupInteractOverrideComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickupInteractOverrideComponent_Juno">();
	}
	static class UFortPickupInteractOverrideComponent_Juno* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPickupInteractOverrideComponent_Juno>();
	}
};
static_assert(alignof(UFortPickupInteractOverrideComponent_Juno) == 0x000008, "Wrong alignment on UFortPickupInteractOverrideComponent_Juno");
static_assert(sizeof(UFortPickupInteractOverrideComponent_Juno) == 0x0000C0, "Wrong size on UFortPickupInteractOverrideComponent_Juno");

// Class JunoGameNative.JunoBuildingSpatialMetricComponent
// 0x0028 (0x00C8 - 0x00A0)
class UJunoBuildingSpatialMetricComponent final : public UGameStateComponent
{
public:
	TSoftClassPtr<class UClass>                   JunoBuildingMetricClass;                           // 0x00A0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJunoBuildingActorMetric> JunoBuildingMetric;                                // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingSpatialMetricComponent">();
	}
	static class UJunoBuildingSpatialMetricComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingSpatialMetricComponent>();
	}
};
static_assert(alignof(UJunoBuildingSpatialMetricComponent) == 0x000008, "Wrong alignment on UJunoBuildingSpatialMetricComponent");
static_assert(sizeof(UJunoBuildingSpatialMetricComponent) == 0x0000C8, "Wrong size on UJunoBuildingSpatialMetricComponent");
static_assert(offsetof(UJunoBuildingSpatialMetricComponent, JunoBuildingMetricClass) == 0x0000A0, "Member 'UJunoBuildingSpatialMetricComponent::JunoBuildingMetricClass' has a wrong offset!");
static_assert(offsetof(UJunoBuildingSpatialMetricComponent, JunoBuildingMetric) == 0x0000C0, "Member 'UJunoBuildingSpatialMetricComponent::JunoBuildingMetric' has a wrong offset!");

// Class JunoGameNative.JunoAIPersistenceComponent
// 0x0028 (0x00D0 - 0x00A8)
class UJunoAIPersistenceComponent final : public UFortPawnComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAIFullySpawned(const class AAIController* Controller, const class AFortPawn* Pawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIPersistenceComponent">();
	}
	static class UJunoAIPersistenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIPersistenceComponent>();
	}
};
static_assert(alignof(UJunoAIPersistenceComponent) == 0x000008, "Wrong alignment on UJunoAIPersistenceComponent");
static_assert(sizeof(UJunoAIPersistenceComponent) == 0x0000D0, "Wrong size on UJunoAIPersistenceComponent");

// Class JunoGameNative.JunoCameraModeOverrideComponent
// 0x0000 (0x00A8 - 0x00A8)
class UJunoCameraModeOverrideComponent final : public UFortCameraModeOverrideComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCameraModeOverrideComponent">();
	}
	static class UJunoCameraModeOverrideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCameraModeOverrideComponent>();
	}
};
static_assert(alignof(UJunoCameraModeOverrideComponent) == 0x000008, "Wrong alignment on UJunoCameraModeOverrideComponent");
static_assert(sizeof(UJunoCameraModeOverrideComponent) == 0x0000A8, "Wrong size on UJunoCameraModeOverrideComponent");

// Class JunoGameNative.JunoPhysicsPFWModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoPhysicsPFWModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsPFWModule">();
	}
	static class UJunoPhysicsPFWModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPhysicsPFWModule>();
	}
};
static_assert(alignof(UJunoPhysicsPFWModule) == 0x000008, "Wrong alignment on UJunoPhysicsPFWModule");
static_assert(sizeof(UJunoPhysicsPFWModule) == 0x0000E0, "Wrong size on UJunoPhysicsPFWModule");

// Class JunoGameNative.JunoControllerComponent_BedAssignmentNetworkEvents
// 0x0050 (0x00F8 - 0x00A8)
class UJunoControllerComponent_BedAssignmentNetworkEvents final : public UFortControllerComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoReplicatedCharacterData           ReplicatedCharacterData;                           // 0x00C0(0x0028)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyObjectInteracted(class AActor* ReceivingActor);
	const struct FJunoReplicatedCharacterData GetCharacterData();
	void HandleCampObjectInteracted(class AActor* ReceivingActor);
	void OnRep_CharacterData();
	void ServerAttemptAssignAICharacter(class AActor* ReceivingActor, const struct FGameplayTag& CharacterGameplayTag);
	void ServerAttemptAssignPlayerCharacter(class AActor* ReceivingActor);
	void ServerHandleEndInteraction();
	class FText TryFindCharacterDisplayName(const struct FGameplayTag& CharacterGameplayTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoControllerComponent_BedAssignmentNetworkEvents">();
	}
	static class UJunoControllerComponent_BedAssignmentNetworkEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoControllerComponent_BedAssignmentNetworkEvents>();
	}
};
static_assert(alignof(UJunoControllerComponent_BedAssignmentNetworkEvents) == 0x000008, "Wrong alignment on UJunoControllerComponent_BedAssignmentNetworkEvents");
static_assert(sizeof(UJunoControllerComponent_BedAssignmentNetworkEvents) == 0x0000F8, "Wrong size on UJunoControllerComponent_BedAssignmentNetworkEvents");
static_assert(offsetof(UJunoControllerComponent_BedAssignmentNetworkEvents, ReplicatedCharacterData) == 0x0000C0, "Member 'UJunoControllerComponent_BedAssignmentNetworkEvents::ReplicatedCharacterData' has a wrong offset!");

// Class JunoGameNative.JunoGameStateComponent_PickupManagement
// 0x0010 (0x0168 - 0x0158)
class UJunoGameStateComponent_PickupManagement final : public UFortGameStateComponent_PickupManagement
{
public:
	struct FDataTableRowHandle                    SettingsRow;                                       // 0x0158(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnPlaylistDataReady(class AFortGameStateAthena* GameState, const class UFortPlaylist* Playlist, const struct FGameplayTagContainer& PlaylistContextTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameStateComponent_PickupManagement">();
	}
	static class UJunoGameStateComponent_PickupManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameStateComponent_PickupManagement>();
	}
};
static_assert(alignof(UJunoGameStateComponent_PickupManagement) == 0x000008, "Wrong alignment on UJunoGameStateComponent_PickupManagement");
static_assert(sizeof(UJunoGameStateComponent_PickupManagement) == 0x000168, "Wrong size on UJunoGameStateComponent_PickupManagement");
static_assert(offsetof(UJunoGameStateComponent_PickupManagement, SettingsRow) == 0x000158, "Member 'UJunoGameStateComponent_PickupManagement::SettingsRow' has a wrong offset!");

// Class JunoGameNative.JunoPlayspaceAccountantComponent
// 0x0028 (0x0120 - 0x00F8)
class UJunoPlayspaceAccountantComponent final : public UFortPlayspaceComponent
{
public:
	uint8                                         Pad_F8[0x28];                                      // 0x00F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJunoPlayspaceAccountantComponent* GetJunoPlayspaceAccountantComponent(const class UObject* WorldContextObject, const struct FVector& Location);

	void DecrementValue(class FName ValueName, int32 Value);
	void IncrementValue(class FName ValueName, int32 Value);

	int32 GetValue(class FName ValueName) const;
	bool IsAccountantReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceAccountantComponent">();
	}
	static class UJunoPlayspaceAccountantComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceAccountantComponent>();
	}
};
static_assert(alignof(UJunoPlayspaceAccountantComponent) == 0x000008, "Wrong alignment on UJunoPlayspaceAccountantComponent");
static_assert(sizeof(UJunoPlayspaceAccountantComponent) == 0x000120, "Wrong size on UJunoPlayspaceAccountantComponent");

// Class JunoGameNative.JunoPlayspaceRandomStreamComponent
// 0x0008 (0x0100 - 0x00F8)
class UJunoPlayspaceRandomStreamComponent final : public UFortPlayspaceComponent
{
public:
	int32                                         PlayspaceRandomSeed;                               // 0x00F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJunoPlayspaceRandomStreamComponent* GetJunoPlayspaceRandomStreamComponent(const class UObject* WorldContextObject, const struct FVector& Location);
	static class UJunoPlayspaceRandomStreamComponent* GetJunoRootPlayspaceRandomStreamComponent(const class UObject* WorldContextObject);

	void OnVolumeBoundsChanged(class APlayspace* Playspace);
	void OnVolumeGuidChanged(class AActor* Actor, const struct FGuid& NewGuid);

	int32 GenerateRandomSeed(const class FString& Name_0, const struct FVector& OptionalLocation) const;
	struct FRandomStream GenerateRandomStream(const class FString& Name_0, const struct FVector& OptionalLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceRandomStreamComponent">();
	}
	static class UJunoPlayspaceRandomStreamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceRandomStreamComponent>();
	}
};
static_assert(alignof(UJunoPlayspaceRandomStreamComponent) == 0x000008, "Wrong alignment on UJunoPlayspaceRandomStreamComponent");
static_assert(sizeof(UJunoPlayspaceRandomStreamComponent) == 0x000100, "Wrong size on UJunoPlayspaceRandomStreamComponent");
static_assert(offsetof(UJunoPlayspaceRandomStreamComponent, PlayspaceRandomSeed) == 0x0000F8, "Member 'UJunoPlayspaceRandomStreamComponent::PlayspaceRandomSeed' has a wrong offset!");

// Class JunoGameNative.JunoClusterUnionCustomRepNode
// 0x0070 (0x00C0 - 0x0050)
class UJunoClusterUnionCustomRepNode final : public UFortReplicationGraphNode_Custom
{
public:
	TArray<class AJunoClusterUnionActor*>         AllClusterUnions;                                  // 0x0050(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class AJunoClusterUnionActor*>           FlushedClusterUnionsWhenIrrelevant;                // 0x0060(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClusterUnionCustomRepNode">();
	}
	static class UJunoClusterUnionCustomRepNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoClusterUnionCustomRepNode>();
	}
};
static_assert(alignof(UJunoClusterUnionCustomRepNode) == 0x000008, "Wrong alignment on UJunoClusterUnionCustomRepNode");
static_assert(sizeof(UJunoClusterUnionCustomRepNode) == 0x0000C0, "Wrong size on UJunoClusterUnionCustomRepNode");
static_assert(offsetof(UJunoClusterUnionCustomRepNode, AllClusterUnions) == 0x000050, "Member 'UJunoClusterUnionCustomRepNode::AllClusterUnions' has a wrong offset!");
static_assert(offsetof(UJunoClusterUnionCustomRepNode, FlushedClusterUnionsWhenIrrelevant) == 0x000060, "Member 'UJunoClusterUnionCustomRepNode::FlushedClusterUnionsWhenIrrelevant' has a wrong offset!");

// Class JunoGameNative.JunoHarvestingComponent
// 0x00A8 (0x0148 - 0x00A0)
class UJunoHarvestingComponent final : public UPlayspaceComponent
{
public:
	float                                         HeightOffset;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalConeRadius;                              // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalConeRadius;                                // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             BuildingTagToResourceDataTable;                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CraftingIngredientDataTable;                       // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ResourceIdentifierTags;                            // 0x00C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BuildingTagsToIgnoreForResourceSplitting;          // 0x00E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TimeToRegenHealth;                                 // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoBuildingHitData>           BuildingsHitList;                                  // 0x0108(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         ResourcePercentToReturn;                           // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PickupsPerResource;                                // 0x011C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PickupClassPtr;                                    // 0x0120(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TossSpeed;                                         // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConeHalfAngleDegrees;                              // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoHarvestingComponent">();
	}
	static class UJunoHarvestingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoHarvestingComponent>();
	}
};
static_assert(alignof(UJunoHarvestingComponent) == 0x000008, "Wrong alignment on UJunoHarvestingComponent");
static_assert(sizeof(UJunoHarvestingComponent) == 0x000148, "Wrong size on UJunoHarvestingComponent");
static_assert(offsetof(UJunoHarvestingComponent, HeightOffset) == 0x0000A0, "Member 'UJunoHarvestingComponent::HeightOffset' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, HorizontalConeRadius) == 0x0000A4, "Member 'UJunoHarvestingComponent::HorizontalConeRadius' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, VerticalConeRadius) == 0x0000A8, "Member 'UJunoHarvestingComponent::VerticalConeRadius' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, BuildingTagToResourceDataTable) == 0x0000B0, "Member 'UJunoHarvestingComponent::BuildingTagToResourceDataTable' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, CraftingIngredientDataTable) == 0x0000B8, "Member 'UJunoHarvestingComponent::CraftingIngredientDataTable' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, ResourceIdentifierTags) == 0x0000C0, "Member 'UJunoHarvestingComponent::ResourceIdentifierTags' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, BuildingTagsToIgnoreForResourceSplitting) == 0x0000E0, "Member 'UJunoHarvestingComponent::BuildingTagsToIgnoreForResourceSplitting' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, TimeToRegenHealth) == 0x000100, "Member 'UJunoHarvestingComponent::TimeToRegenHealth' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, BuildingsHitList) == 0x000108, "Member 'UJunoHarvestingComponent::BuildingsHitList' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, ResourcePercentToReturn) == 0x000118, "Member 'UJunoHarvestingComponent::ResourcePercentToReturn' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, PickupsPerResource) == 0x00011C, "Member 'UJunoHarvestingComponent::PickupsPerResource' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, PickupClassPtr) == 0x000120, "Member 'UJunoHarvestingComponent::PickupClassPtr' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, TossSpeed) == 0x000140, "Member 'UJunoHarvestingComponent::TossSpeed' has a wrong offset!");
static_assert(offsetof(UJunoHarvestingComponent, ConeHalfAngleDegrees) == 0x000144, "Member 'UJunoHarvestingComponent::ConeHalfAngleDegrees' has a wrong offset!");

// Class JunoGameNative.JunoPlayerSpawningComponent
// 0x0028 (0x00D8 - 0x00B0)
class UJunoPlayerSpawningComponent final : public UPlayspaceComponent_PlayerSpawning
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerSpawningComponent">();
	}
	static class UJunoPlayerSpawningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerSpawningComponent>();
	}
};
static_assert(alignof(UJunoPlayerSpawningComponent) == 0x000008, "Wrong alignment on UJunoPlayerSpawningComponent");
static_assert(sizeof(UJunoPlayerSpawningComponent) == 0x0000D8, "Wrong size on UJunoPlayerSpawningComponent");

// Class JunoGameNative.JunoCoreMutators
// 0x0048 (0x0380 - 0x0338)
class AJunoCoreMutators final : public AFortAthenaMutator
{
public:
	TMulticastInlineDelegate<void(class AFortPlayerPawnAthena* NewPawn)> OnPawnLoaded;                                      // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnClientInitialLoadingFinished;                    // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsJunoPlayspaceReady;                             // 0x0358(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_359[0x27];                                     // 0x0359(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCoreMutators">();
	}
	static class AJunoCoreMutators* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoCoreMutators>();
	}
};
static_assert(alignof(AJunoCoreMutators) == 0x000008, "Wrong alignment on AJunoCoreMutators");
static_assert(sizeof(AJunoCoreMutators) == 0x000380, "Wrong size on AJunoCoreMutators");
static_assert(offsetof(AJunoCoreMutators, OnPawnLoaded) == 0x000338, "Member 'AJunoCoreMutators::OnPawnLoaded' has a wrong offset!");
static_assert(offsetof(AJunoCoreMutators, OnClientInitialLoadingFinished) == 0x000348, "Member 'AJunoCoreMutators::OnClientInitialLoadingFinished' has a wrong offset!");
static_assert(offsetof(AJunoCoreMutators, bIsJunoPlayspaceReady) == 0x000358, "Member 'AJunoCoreMutators::bIsJunoPlayspaceReady' has a wrong offset!");

// Class JunoGameNative.JunoPersistentPlayspace
// 0x0120 (0x0808 - 0x06E8)
class AJunoPersistentPlayspace : public AFortPlayspace
{
public:
	uint8                                         Pad_6E8[0x40];                                     // 0x06E8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoPlayspacePersistenceComponent*     PersistenceComponent;                              // 0x0728(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpatialLoadingState                          SpatialLoadingState;                               // 0x0730(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_731[0x3];                                      // 0x0731(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PersistenceMainLevelUniquePackageName;             // 0x0734(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ULevel>                  PersistenceMainLevelWeakPtr;                       // 0x0738(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        PlayspaceRequestKey;                               // 0x0740(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_744[0xC4];                                     // 0x0744(0x00C4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void EnableSpawnedActorTracking(class AActor* Actor);
	static void SetShouldBeTrackedByPlayspace(class AActor* Actor, bool bShouldBeTracked);
	static bool ShouldBeTrackedByPlayspace(const class AActor* Actor);

	void RemoveActorWhenEndPlay(class AActor* Actor, const EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPersistentPlayspace">();
	}
	static class AJunoPersistentPlayspace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPersistentPlayspace>();
	}
};
static_assert(alignof(AJunoPersistentPlayspace) == 0x000008, "Wrong alignment on AJunoPersistentPlayspace");
static_assert(sizeof(AJunoPersistentPlayspace) == 0x000808, "Wrong size on AJunoPersistentPlayspace");
static_assert(offsetof(AJunoPersistentPlayspace, PersistenceComponent) == 0x000728, "Member 'AJunoPersistentPlayspace::PersistenceComponent' has a wrong offset!");
static_assert(offsetof(AJunoPersistentPlayspace, SpatialLoadingState) == 0x000730, "Member 'AJunoPersistentPlayspace::SpatialLoadingState' has a wrong offset!");
static_assert(offsetof(AJunoPersistentPlayspace, PersistenceMainLevelUniquePackageName) == 0x000734, "Member 'AJunoPersistentPlayspace::PersistenceMainLevelUniquePackageName' has a wrong offset!");
static_assert(offsetof(AJunoPersistentPlayspace, PersistenceMainLevelWeakPtr) == 0x000738, "Member 'AJunoPersistentPlayspace::PersistenceMainLevelWeakPtr' has a wrong offset!");
static_assert(offsetof(AJunoPersistentPlayspace, PlayspaceRequestKey) == 0x000740, "Member 'AJunoPersistentPlayspace::PlayspaceRequestKey' has a wrong offset!");

// Class JunoGameNative.JunoHealthComponent
// 0x0000 (0x00A0 - 0x00A0)
class UJunoHealthComponent final : public UGameFrameworkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoHealthComponent">();
	}
	static class UJunoHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoHealthComponent>();
	}
};
static_assert(alignof(UJunoHealthComponent) == 0x000008, "Wrong alignment on UJunoHealthComponent");
static_assert(sizeof(UJunoHealthComponent) == 0x0000A0, "Wrong size on UJunoHealthComponent");

// Class JunoGameNative.JunoRootPlayspace
// 0x0178 (0x0980 - 0x0808)
class AJunoRootPlayspace final : public AJunoPersistentPlayspace
{
public:
	uint8                                         Pad_808[0x20];                                     // 0x0808(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AFortPlayerControllerAthena> OwningController;                                  // 0x0828(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DefaultInventoryItemTag;                           // 0x0830(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_834[0x4];                                      // 0x0834(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayspaceComponent_JunoServerExpiration* JunoServerExpiration;                              // 0x0838(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_840[0x18];                                     // 0x0840(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProcessPlayerProgressionTime;                      // 0x0858(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_85C[0xC];                                      // 0x085C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayStateMachine>      JunoStateMachineClass;                             // 0x0868(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWorldDataAvailable                           WorldDataAvailable;                                // 0x0870(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRootPlayspaceReady;                               // 0x0871(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_872[0x6];                                      // 0x0872(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoWorld*                             CurrentJunoWorld;                                  // 0x0878(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_880[0x8];                                      // 0x0880(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoReplicatedWorldMetadata           MetadataForReplication;                            // 0x0888(0x00E0)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_968[0x10];                                     // 0x0968(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoPlayerPersistenceComponent*        JunoPlayerPersistenceComponent;                    // 0x0978(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_WorldMetadata();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRootPlayspace">();
	}
	static class AJunoRootPlayspace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoRootPlayspace>();
	}
};
static_assert(alignof(AJunoRootPlayspace) == 0x000008, "Wrong alignment on AJunoRootPlayspace");
static_assert(sizeof(AJunoRootPlayspace) == 0x000980, "Wrong size on AJunoRootPlayspace");
static_assert(offsetof(AJunoRootPlayspace, OwningController) == 0x000828, "Member 'AJunoRootPlayspace::OwningController' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, DefaultInventoryItemTag) == 0x000830, "Member 'AJunoRootPlayspace::DefaultInventoryItemTag' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, JunoServerExpiration) == 0x000838, "Member 'AJunoRootPlayspace::JunoServerExpiration' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, ProcessPlayerProgressionTime) == 0x000858, "Member 'AJunoRootPlayspace::ProcessPlayerProgressionTime' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, JunoStateMachineClass) == 0x000868, "Member 'AJunoRootPlayspace::JunoStateMachineClass' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, WorldDataAvailable) == 0x000870, "Member 'AJunoRootPlayspace::WorldDataAvailable' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, bRootPlayspaceReady) == 0x000871, "Member 'AJunoRootPlayspace::bRootPlayspaceReady' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, CurrentJunoWorld) == 0x000878, "Member 'AJunoRootPlayspace::CurrentJunoWorld' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, MetadataForReplication) == 0x000888, "Member 'AJunoRootPlayspace::MetadataForReplication' has a wrong offset!");
static_assert(offsetof(AJunoRootPlayspace, JunoPlayerPersistenceComponent) == 0x000978, "Member 'AJunoRootPlayspace::JunoPlayerPersistenceComponent' has a wrong offset!");

// Class JunoGameNative.JunoStateMachine
// 0x0000 (0x00C8 - 0x00C8)
class UJunoStateMachine final : public UGameplayStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoStateMachine">();
	}
	static class UJunoStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoStateMachine>();
	}
};
static_assert(alignof(UJunoStateMachine) == 0x000008, "Wrong alignment on UJunoStateMachine");
static_assert(sizeof(UJunoStateMachine) == 0x0000C8, "Wrong size on UJunoStateMachine");

// Class JunoGameNative.JunoState_Setup
// 0x0028 (0x00A0 - 0x0078)
class UJunoState_Setup final : public UGameplayState
{
public:
	TSoftObjectPtr<class UDataTable>              PossibleWorldsDataTable;                           // 0x0078(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldRandomSeed;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoState_Setup">();
	}
	static class UJunoState_Setup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoState_Setup>();
	}
};
static_assert(alignof(UJunoState_Setup) == 0x000008, "Wrong alignment on UJunoState_Setup");
static_assert(sizeof(UJunoState_Setup) == 0x0000A0, "Wrong size on UJunoState_Setup");
static_assert(offsetof(UJunoState_Setup, PossibleWorldsDataTable) == 0x000078, "Member 'UJunoState_Setup::PossibleWorldsDataTable' has a wrong offset!");
static_assert(offsetof(UJunoState_Setup, WorldRandomSeed) == 0x000098, "Member 'UJunoState_Setup::WorldRandomSeed' has a wrong offset!");

// Class JunoGameNative.JunoAIFaunaAnimInstance
// 0x0160 (0x0700 - 0x05A0)
class UJunoAIFaunaAnimInstance final : public UFortAIAnimInstance
{
public:
	float                                         AverageSpeed;                                      // 0x0598(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageSpeedTimeFrame;                             // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasValidAimTarget;                                // 0x05A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A1[0x3];                                      // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimTime;                                           // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTargetLocation;                                 // 0x05A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurfaceSwimming;                                // 0x05C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGround;                                 // 0x05C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTornado;                                      // 0x05C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C3[0x1];                                      // 0x05C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlpha;                                       // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToPlayerForLookAt;                      // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTooFarFromPlayerTimeOut;                     // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLookAtDuringMontage;                       // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableHeadTrackingCurveName;                      // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJunoRidingAnimationData               RidingAnimationData;                               // 0x05D8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSlopeSliding;                                   // 0x05EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5ED[0x3];                                      // 0x05ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeSlidingPitch;                                 // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeSlidingRoll;                                  // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RidingMovePlayRate;                                // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustGotPlayer;                                    // 0x05FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBoosting;                                       // 0x05FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurningInPlace;                                 // 0x05FE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FF[0x1];                                      // 0x05FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceRotationSpeed;                          // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngleDelta;                             // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingBackwards;                                // 0x0608(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RiderReferentialYaw;                               // 0x060C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostPlayRate;                                     // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnInPlaceAngleDeltaPositive;                  // 0x0614(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayLandAdditive;                                 // 0x0615(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_616[0x2];                                      // 0x0616(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackwardVelocity;                                  // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayStopBackwards;                          // 0x061C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61D[0x3];                                      // 0x061D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwimmingYaw;                                       // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardsPlayRate;                                 // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyRoll;                                          // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngleStored;                                   // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasTurningRight;                                  // 0x0630(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERidingFootPhase                              FootPhase;                                         // 0x0631(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_FeetInAir;                            // 0x0632(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_FrontFeetPlanted;                     // 0x0633(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_BackFeetPlanted;                      // 0x0634(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_LeftBackFeetForward;                  // 0x0635(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_RightBackFeetForward;                 // 0x0636(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_LeftPlantedRightPass;                 // 0x0637(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_RightPlantedLeftPass;                 // 0x0638(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SlipstreamTags;                                    // 0x0640(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsInSlipstream;                                   // 0x0660(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_661[0x7];                                      // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SkydivingTags;                                     // 0x0668(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bMovementMode_Skydiving;                           // 0x0688(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_689[0x7];                                      // 0x0689(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SkytubingTags;                                     // 0x0690(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bGameplay_Status_Skytubing;                        // 0x06B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAbducted;                                       // 0x06B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B2[0x6];                                      // 0x06B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TractorBeamTags;                                   // 0x06B8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x06D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x06D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6DA[0x2];                                      // 0x06DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JustGotPlayerInitialDelaySec;                      // 0x06DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x20];                                     // 0x06E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateLookAtAlpha(bool bForceDisableLookAt, float DeltaSeconds);
	void FinishFootPhaseStopUpdate();
	void UpdateBackwardsPlayRate();
	void UpdateBackwardVelocity();
	void UpdateBodyRoll();
	void UpdateBoostPlayRate();
	void UpdateFootPhaseStop();
	void UpdatePlayLandAdditive();
	void UpdateRidingMovePlayRate();
	void UpdateSwimmingYaw();
	void UpdateTurnAngleStored();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIFaunaAnimInstance">();
	}
	static class UJunoAIFaunaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIFaunaAnimInstance>();
	}
};
static_assert(alignof(UJunoAIFaunaAnimInstance) == 0x000010, "Wrong alignment on UJunoAIFaunaAnimInstance");
static_assert(sizeof(UJunoAIFaunaAnimInstance) == 0x000700, "Wrong size on UJunoAIFaunaAnimInstance");
static_assert(offsetof(UJunoAIFaunaAnimInstance, AverageSpeed) == 0x000598, "Member 'UJunoAIFaunaAnimInstance::AverageSpeed' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, AverageSpeedTimeFrame) == 0x00059C, "Member 'UJunoAIFaunaAnimInstance::AverageSpeedTimeFrame' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bHasValidAimTarget) == 0x0005A0, "Member 'UJunoAIFaunaAnimInstance::bHasValidAimTarget' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, AimTime) == 0x0005A4, "Member 'UJunoAIFaunaAnimInstance::AimTime' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, AimTargetLocation) == 0x0005A8, "Member 'UJunoAIFaunaAnimInstance::AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsSurfaceSwimming) == 0x0005C0, "Member 'UJunoAIFaunaAnimInstance::bIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsMovingOnGround) == 0x0005C1, "Member 'UJunoAIFaunaAnimInstance::bIsMovingOnGround' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsInTornado) == 0x0005C2, "Member 'UJunoAIFaunaAnimInstance::bIsInTornado' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, LookAtAlpha) == 0x0005C4, "Member 'UJunoAIFaunaAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, MaxDistanceToPlayerForLookAt) == 0x0005C8, "Member 'UJunoAIFaunaAnimInstance::MaxDistanceToPlayerForLookAt' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, LookAtTooFarFromPlayerTimeOut) == 0x0005CC, "Member 'UJunoAIFaunaAnimInstance::LookAtTooFarFromPlayerTimeOut' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bDisableLookAtDuringMontage) == 0x0005D0, "Member 'UJunoAIFaunaAnimInstance::bDisableLookAtDuringMontage' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, DisableHeadTrackingCurveName) == 0x0005D4, "Member 'UJunoAIFaunaAnimInstance::DisableHeadTrackingCurveName' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, RidingAnimationData) == 0x0005D8, "Member 'UJunoAIFaunaAnimInstance::RidingAnimationData' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsSlopeSliding) == 0x0005EC, "Member 'UJunoAIFaunaAnimInstance::bIsSlopeSliding' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, SlopeSlidingPitch) == 0x0005F0, "Member 'UJunoAIFaunaAnimInstance::SlopeSlidingPitch' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, SlopeSlidingRoll) == 0x0005F4, "Member 'UJunoAIFaunaAnimInstance::SlopeSlidingRoll' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, RidingMovePlayRate) == 0x0005F8, "Member 'UJunoAIFaunaAnimInstance::RidingMovePlayRate' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bJustGotPlayer) == 0x0005FC, "Member 'UJunoAIFaunaAnimInstance::bJustGotPlayer' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsBoosting) == 0x0005FD, "Member 'UJunoAIFaunaAnimInstance::bIsBoosting' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsTurningInPlace) == 0x0005FE, "Member 'UJunoAIFaunaAnimInstance::bIsTurningInPlace' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, TurnInPlaceRotationSpeed) == 0x000600, "Member 'UJunoAIFaunaAnimInstance::TurnInPlaceRotationSpeed' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, TurnInPlaceAngleDelta) == 0x000604, "Member 'UJunoAIFaunaAnimInstance::TurnInPlaceAngleDelta' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsMovingBackwards) == 0x000608, "Member 'UJunoAIFaunaAnimInstance::bIsMovingBackwards' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, RiderReferentialYaw) == 0x00060C, "Member 'UJunoAIFaunaAnimInstance::RiderReferentialYaw' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, BoostPlayRate) == 0x000610, "Member 'UJunoAIFaunaAnimInstance::BoostPlayRate' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsTurnInPlaceAngleDeltaPositive) == 0x000614, "Member 'UJunoAIFaunaAnimInstance::bIsTurnInPlaceAngleDeltaPositive' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bPlayLandAdditive) == 0x000615, "Member 'UJunoAIFaunaAnimInstance::bPlayLandAdditive' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, BackwardVelocity) == 0x000618, "Member 'UJunoAIFaunaAnimInstance::BackwardVelocity' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bShouldPlayStopBackwards) == 0x00061C, "Member 'UJunoAIFaunaAnimInstance::bShouldPlayStopBackwards' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, SwimmingYaw) == 0x000620, "Member 'UJunoAIFaunaAnimInstance::SwimmingYaw' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, BackwardsPlayRate) == 0x000624, "Member 'UJunoAIFaunaAnimInstance::BackwardsPlayRate' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, BodyRoll) == 0x000628, "Member 'UJunoAIFaunaAnimInstance::BodyRoll' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, TurnAngleStored) == 0x00062C, "Member 'UJunoAIFaunaAnimInstance::TurnAngleStored' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bWasTurningRight) == 0x000630, "Member 'UJunoAIFaunaAnimInstance::bWasTurningRight' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, FootPhase) == 0x000631, "Member 'UJunoAIFaunaAnimInstance::FootPhase' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsFootPhase_FeetInAir) == 0x000632, "Member 'UJunoAIFaunaAnimInstance::bIsFootPhase_FeetInAir' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsFootPhase_FrontFeetPlanted) == 0x000633, "Member 'UJunoAIFaunaAnimInstance::bIsFootPhase_FrontFeetPlanted' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsFootPhase_BackFeetPlanted) == 0x000634, "Member 'UJunoAIFaunaAnimInstance::bIsFootPhase_BackFeetPlanted' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsFootPhase_LeftBackFeetForward) == 0x000635, "Member 'UJunoAIFaunaAnimInstance::bIsFootPhase_LeftBackFeetForward' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsFootPhase_RightBackFeetForward) == 0x000636, "Member 'UJunoAIFaunaAnimInstance::bIsFootPhase_RightBackFeetForward' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsFootPhase_LeftPlantedRightPass) == 0x000637, "Member 'UJunoAIFaunaAnimInstance::bIsFootPhase_LeftPlantedRightPass' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsFootPhase_RightPlantedLeftPass) == 0x000638, "Member 'UJunoAIFaunaAnimInstance::bIsFootPhase_RightPlantedLeftPass' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, SlipstreamTags) == 0x000640, "Member 'UJunoAIFaunaAnimInstance::SlipstreamTags' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsInSlipstream) == 0x000660, "Member 'UJunoAIFaunaAnimInstance::bIsInSlipstream' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, SkydivingTags) == 0x000668, "Member 'UJunoAIFaunaAnimInstance::SkydivingTags' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bMovementMode_Skydiving) == 0x000688, "Member 'UJunoAIFaunaAnimInstance::bMovementMode_Skydiving' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, SkytubingTags) == 0x000690, "Member 'UJunoAIFaunaAnimInstance::SkytubingTags' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bGameplay_Status_Skytubing) == 0x0006B0, "Member 'UJunoAIFaunaAnimInstance::bGameplay_Status_Skytubing' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsAbducted) == 0x0006B1, "Member 'UJunoAIFaunaAnimInstance::bIsAbducted' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, TractorBeamTags) == 0x0006B8, "Member 'UJunoAIFaunaAnimInstance::TractorBeamTags' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsInTractorBeam) == 0x0006D8, "Member 'UJunoAIFaunaAnimInstance::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, bIsFloating) == 0x0006D9, "Member 'UJunoAIFaunaAnimInstance::bIsFloating' has a wrong offset!");
static_assert(offsetof(UJunoAIFaunaAnimInstance, JustGotPlayerInitialDelaySec) == 0x0006DC, "Member 'UJunoAIFaunaAnimInstance::JustGotPlayerInitialDelaySec' has a wrong offset!");

// Class JunoGameNative.JunoBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BreakHitResultThreadSafe(const struct FHitResult& Hit, bool* bBlockingHit, bool* bInitialOverlap, float* Time, float* Distance, struct FVector* Location, struct FVector* ImpactPoint, struct FVector* Normal, struct FVector* ImpactNormal, class UPhysicalMaterial** PhysMat, class AActor** HitActor, class UPrimitiveComponent** HitComponent, class FName* HitBoneName, class FName* BoneName, int32* HitItem, int32* ElementIndex, int32* FaceIndex, struct FVector* TraceStart, struct FVector* TraceEnd);
	static const class FText CostlyFindAIDisplayNameFromUniqueAIIdentifier(const class UObject* WorldContextObject, const struct FGameplayTag& UniqueAIIdentifier);
	static void ForEachComponentOfActorClassDefault(const TSubclassOf<class AActor>& ActorClass, const TSubclassOf<class UActorComponent>& ComponentClass, const TDelegate<void(class UActorComponent* Component)>& Func_0);
	static class AJunoPersistentPlayspace* GetActorPersistentPlayspace(class AActor* Actor);
	static bool GetAMSAnimDataAssets(const class AFortPlayerPawn* FortPlayerPawn, struct FAssembledMeshSchemaData_AnimDataAssets* AnimData);
	static bool GetAMSAnimDataAssetsFromActor(const class AActor* Actor, struct FAssembledMeshSchemaData_AnimDataAssets* AnimData);
	static class UCustomizableObjectInstance* GetAMSCustomizableObjectInstance(const class AActor* Actor);
	static void GetBiomeForActor(const class AActor* Actor, EJunoBiome* OutResult);
	static void GetBiomeInformationAtLocation(const class UObject* WorldContextObject, const struct FVector& Location, struct FJunoBiomeInfoQueryResult* OutResult);
	static void GetBiomeInformationForActor(const class AActor* Actor, struct FJunoBiomeInfoQueryResult* OutResult);
	static int32 GetBoneIndex(const class USkeletalMesh* SkeletalMesh, class FName BoneName);
	static int32 GetCountOfResourcesInAIResourcesInventory(const class AActor* AIActor);
	static double GetDistanceToWorldStartPosition(const class UObject* WorldContextObject, const struct FVector& Location, bool* bIsReady);
	static bool GetIsWorldKeyHolder(const class AFortPlayerController* PC);
	static bool GetIsWorldOwner(const class AFortPlayerController* PC);
	static void GetKnownCraftingRecipes(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class FName>* OutFormulas);
	static class UJunoMapManagerComponent* GetMapManagerComponent(const class UObject* WorldContextObject);
	static TArray<class UPrimitiveComponent*> GetMergedMeshComponents(class UObject* WorldContextObject);
	static const struct FJunoPlayerSaveData GetPlayerSaveData(const class AController* PlayerController, bool* bIsValid);
	static class UPlayspaceComponent* GetPlayspaceComponentByInterface(class AActor* Actor, TSubclassOf<class IInterface> InterfaceClass, TSubclassOf<class APlayspace> PlayspaceClass);
	static class UPlayspaceComponent* GetPlayspaceComponentFromPlayspace(class AActor* Actor, TSubclassOf<class UPlayspaceComponent> ComponentClass, TSubclassOf<class APlayspace> PlayspaceClass);
	static bool GetPreviewSmartObjectEntranceLocations(const struct FTransform& WorldTransform, const class USmartObjectDefinition* SmartObjectDefinition, TArray<struct FSmartObjectSlotEntranceLocationResult>* Results);
	static bool GetPreviewSmartObjectEntranceLocationsWithValidation(const class UObject* WorldContextObject, const struct FTransform& WorldTransform, const class USmartObjectDefinition* SmartObjectDefinition, const class AActor* SkipActor, const struct FSmartObjectSlotEntranceLocationRequest& Request, TArray<struct FSmartObjectSlotEntranceLocationResult>* Results);
	static void GetWorldStartPosition(const class UObject* WorldContextObject, struct FVector* Location, bool* bIsReady);
	static bool IsFirstPlayerSpawn(const class AFortPlayerPawn* PlayerPawn);
	static bool IsFreshWorld(const class UObject* WorldContextObject);
	static void SetGeometryCollectionISMPoolCustomInstanceData(class UGeometryCollectionComponent* GeometryCollectionComponent, int32 CustomDataIndex, float CustomDataValue);
	static class AActor* SpawnPersistentActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor>& ActorClass, const struct FTransform& SpawnTransform, class APawn* Instigator, class AJunoPersistentPlayspace* Playspace, const struct FGameplayTagQuery& PlayspaceTagQuery);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBlueprintLibrary">();
	}
	static class UJunoBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoBlueprintLibrary");
static_assert(sizeof(UJunoBlueprintLibrary) == 0x000028, "Wrong size on UJunoBlueprintLibrary");

// Class JunoGameNative.JunoCreatureAnimInstance
// 0x0280 (0x0800 - 0x0580)
#pragma pack(push, 0x1)
class alignas(0x10) UJunoCreatureAnimInstance : public UJunoPawnAnimInstance
{
public:
	bool                                          bIsTurning;                                        // 0x0580(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasTurning;                                       // 0x0581(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x0582(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_583[0x1];                                      // 0x0583(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShufflePlayRate;                               // 0x0584(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CreaturePosition;                                  // 0x0590(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CreaturePositionDelta;                             // 0x05A8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CreatureRootRotation;                              // 0x05C0(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CreatureRootRotationOffset;                        // 0x05D8(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CreatureRotation;                                  // 0x05F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CreatureRotationDelta;                             // 0x0608(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CreatureVelocity;                                  // 0x0620(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CreatureYaw;                                       // 0x0638(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CreatureYawDelta;                                  // 0x063C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RootSmoothing_Enabled;                             // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootSmoothing_Distance;                            // 0x0644(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeWarpingIsEnabled;                            // 0x0648(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_649[0x3];                                      // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeWarpingFloorCheckFrequency;                   // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeWarpingRollAlpha;                             // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartingInPlace;                                  // 0x0654(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_655[0x3];                                      // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartInPlace_RootTranslation;                      // 0x0658(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartInPlace_Sequence;                             // 0x0670(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartInPlace_SequenceTime;                         // 0x0678(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurningInPlace;                                   // 0x067C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnInPlace_UseAuthoredAngle;                     // 0x067D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67E[0x2];                                      // 0x067E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          TurnAnimation;                                     // 0x0680(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlace_AnimationAuthoredAngle;                // 0x0688(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnPlayRate;                                      // 0x068C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlace_RootRotationZ;                         // 0x0690(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlace_RotationAngle;                         // 0x0694(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlace_RotationAngle_Min;                     // 0x0698(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlace_RotationRate;                          // 0x069C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TurnInPlace_Sequence;                              // 0x06A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlace_SequenceTime;                          // 0x06A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x06AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AD[0x3];                                      // 0x06AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleTurnThreshold;                          // 0x06B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x06B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x06B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x06BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x06C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasValidAimTarget;                                // 0x06C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C9[0x7];                                      // 0x06C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimTargetLocation;                                 // 0x06D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimTime;                                           // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlpha;                                       // 0x06EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToPlayerForLookAt;                      // 0x06F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTooFarFromPlayerTimeOut;                     // 0x06F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLookAtDuringMontage;                       // 0x06F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartTurn;                                        // 0x06F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6FA[0x2];                                      // 0x06FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnAngle;                                         // 0x06FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnRate;                                          // 0x0700(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableHeadTrackingCurveName;                      // 0x0704(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0708(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayLandAdditive;                                 // 0x070C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x070D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurfaceSwimming;                                // 0x070E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurningInPlace;                                 // 0x070F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_710[0xE8];                                     // 0x0710(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartInPlace_Setup(const class UAnimSequence* StartAnimSequence);
	void StartInPlace_Started();
	void TurnInPlace_Ended();
	void TurnInPlace_Interrupted();
	void TurnInPlace_Setup(const class UAnimSequence* TurnAnimSequence);
	void TurnInPlace_SignalAnimationEnded();
	void TurnInPlace_Started();

	bool CreatureIsMovingLeft() const;
	bool CreatureIsMovingRight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCreatureAnimInstance">();
	}
	static class UJunoCreatureAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCreatureAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UJunoCreatureAnimInstance) == 0x000010, "Wrong alignment on UJunoCreatureAnimInstance");
static_assert(sizeof(UJunoCreatureAnimInstance) == 0x000800, "Wrong size on UJunoCreatureAnimInstance");
static_assert(offsetof(UJunoCreatureAnimInstance, bIsTurning) == 0x000580, "Member 'UJunoCreatureAnimInstance::bIsTurning' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bWasTurning) == 0x000581, "Member 'UJunoCreatureAnimInstance::bWasTurning' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bIdleShuffleTurnDirection) == 0x000582, "Member 'UJunoCreatureAnimInstance::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, IdleShufflePlayRate) == 0x000584, "Member 'UJunoCreatureAnimInstance::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bIsIdleShuffleTurn) == 0x000588, "Member 'UJunoCreatureAnimInstance::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreaturePosition) == 0x000590, "Member 'UJunoCreatureAnimInstance::CreaturePosition' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreaturePositionDelta) == 0x0005A8, "Member 'UJunoCreatureAnimInstance::CreaturePositionDelta' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreatureRootRotation) == 0x0005C0, "Member 'UJunoCreatureAnimInstance::CreatureRootRotation' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreatureRootRotationOffset) == 0x0005D8, "Member 'UJunoCreatureAnimInstance::CreatureRootRotationOffset' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreatureRotation) == 0x0005F0, "Member 'UJunoCreatureAnimInstance::CreatureRotation' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreatureRotationDelta) == 0x000608, "Member 'UJunoCreatureAnimInstance::CreatureRotationDelta' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreatureVelocity) == 0x000620, "Member 'UJunoCreatureAnimInstance::CreatureVelocity' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreatureYaw) == 0x000638, "Member 'UJunoCreatureAnimInstance::CreatureYaw' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, CreatureYawDelta) == 0x00063C, "Member 'UJunoCreatureAnimInstance::CreatureYawDelta' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, RootSmoothing_Enabled) == 0x000640, "Member 'UJunoCreatureAnimInstance::RootSmoothing_Enabled' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, RootSmoothing_Distance) == 0x000644, "Member 'UJunoCreatureAnimInstance::RootSmoothing_Distance' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bSlopeWarpingIsEnabled) == 0x000648, "Member 'UJunoCreatureAnimInstance::bSlopeWarpingIsEnabled' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, SlopeWarpingFloorCheckFrequency) == 0x00064C, "Member 'UJunoCreatureAnimInstance::SlopeWarpingFloorCheckFrequency' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, SlopeWarpingRollAlpha) == 0x000650, "Member 'UJunoCreatureAnimInstance::SlopeWarpingRollAlpha' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bStartingInPlace) == 0x000654, "Member 'UJunoCreatureAnimInstance::bStartingInPlace' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, StartInPlace_RootTranslation) == 0x000658, "Member 'UJunoCreatureAnimInstance::StartInPlace_RootTranslation' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, StartInPlace_Sequence) == 0x000670, "Member 'UJunoCreatureAnimInstance::StartInPlace_Sequence' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, StartInPlace_SequenceTime) == 0x000678, "Member 'UJunoCreatureAnimInstance::StartInPlace_SequenceTime' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bTurningInPlace) == 0x00067C, "Member 'UJunoCreatureAnimInstance::bTurningInPlace' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bTurnInPlace_UseAuthoredAngle) == 0x00067D, "Member 'UJunoCreatureAnimInstance::bTurnInPlace_UseAuthoredAngle' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnAnimation) == 0x000680, "Member 'UJunoCreatureAnimInstance::TurnAnimation' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnInPlace_AnimationAuthoredAngle) == 0x000688, "Member 'UJunoCreatureAnimInstance::TurnInPlace_AnimationAuthoredAngle' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnPlayRate) == 0x00068C, "Member 'UJunoCreatureAnimInstance::TurnPlayRate' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnInPlace_RootRotationZ) == 0x000690, "Member 'UJunoCreatureAnimInstance::TurnInPlace_RootRotationZ' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnInPlace_RotationAngle) == 0x000694, "Member 'UJunoCreatureAnimInstance::TurnInPlace_RotationAngle' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnInPlace_RotationAngle_Min) == 0x000698, "Member 'UJunoCreatureAnimInstance::TurnInPlace_RotationAngle_Min' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnInPlace_RotationRate) == 0x00069C, "Member 'UJunoCreatureAnimInstance::TurnInPlace_RotationRate' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnInPlace_Sequence) == 0x0006A0, "Member 'UJunoCreatureAnimInstance::TurnInPlace_Sequence' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnInPlace_SequenceTime) == 0x0006A8, "Member 'UJunoCreatureAnimInstance::TurnInPlace_SequenceTime' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bStateRule_Idle_Moving) == 0x0006AC, "Member 'UJunoCreatureAnimInstance::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, IdleShuffleTurnThreshold) == 0x0006B0, "Member 'UJunoCreatureAnimInstance::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, IdleShuffleTurnDirectionThreshold) == 0x0006B4, "Member 'UJunoCreatureAnimInstance::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, IdleShufflePlayRateInRangeA) == 0x0006B8, "Member 'UJunoCreatureAnimInstance::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, IdleShufflePlayRateInRangeB) == 0x0006BC, "Member 'UJunoCreatureAnimInstance::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, IdleShufflePlayRateOutRangeA) == 0x0006C0, "Member 'UJunoCreatureAnimInstance::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, IdleShufflePlayRateOutRangeB) == 0x0006C4, "Member 'UJunoCreatureAnimInstance::IdleShufflePlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bHasValidAimTarget) == 0x0006C8, "Member 'UJunoCreatureAnimInstance::bHasValidAimTarget' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, AimTargetLocation) == 0x0006D0, "Member 'UJunoCreatureAnimInstance::AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, AimTime) == 0x0006E8, "Member 'UJunoCreatureAnimInstance::AimTime' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, LookAtAlpha) == 0x0006EC, "Member 'UJunoCreatureAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, MaxDistanceToPlayerForLookAt) == 0x0006F0, "Member 'UJunoCreatureAnimInstance::MaxDistanceToPlayerForLookAt' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, LookAtTooFarFromPlayerTimeOut) == 0x0006F4, "Member 'UJunoCreatureAnimInstance::LookAtTooFarFromPlayerTimeOut' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bDisableLookAtDuringMontage) == 0x0006F8, "Member 'UJunoCreatureAnimInstance::bDisableLookAtDuringMontage' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bStartTurn) == 0x0006F9, "Member 'UJunoCreatureAnimInstance::bStartTurn' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnAngle) == 0x0006FC, "Member 'UJunoCreatureAnimInstance::TurnAngle' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, TurnRate) == 0x000700, "Member 'UJunoCreatureAnimInstance::TurnRate' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, DisableHeadTrackingCurveName) == 0x000704, "Member 'UJunoCreatureAnimInstance::DisableHeadTrackingCurveName' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, Speed) == 0x000708, "Member 'UJunoCreatureAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bPlayLandAdditive) == 0x00070C, "Member 'UJunoCreatureAnimInstance::bPlayLandAdditive' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bIsFloating) == 0x00070D, "Member 'UJunoCreatureAnimInstance::bIsFloating' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bIsSurfaceSwimming) == 0x00070E, "Member 'UJunoCreatureAnimInstance::bIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance, bIsTurningInPlace) == 0x00070F, "Member 'UJunoCreatureAnimInstance::bIsTurningInPlace' has a wrong offset!");

// Class JunoGameNative.JunoCreatureAnimInstance_LootLlama
// 0x0030 (0x0830 - 0x0800)
class UJunoCreatureAnimInstance_LootLlama final : public UJunoCreatureAnimInstance
{
public:
	bool                                          bHighVelocity;                                     // 0x07F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInterruptible;                                  // 0x07F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocoToIdle;                                       // 0x07FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleToLoco;                                       // 0x07FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpStartToJumpLoop;                              // 0x07FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpLandToMovement;                               // 0x07FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x07FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleToFalling;                                    // 0x07FF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToppledOnGround;                                  // 0x0800(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionToLand;                                 // 0x0801(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_802[0x2];                                      // 0x0802(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetDistance;                                    // 0x0804(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetIsClose;                                    // 0x0808(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsToppled;                                        // 0x0809(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeaking;                                        // 0x080A(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80B[0x1];                                      // 0x080B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHighVelocityMagnitude;                          // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInterruptibleCurveValue;                        // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocoIdleTransitionThreshold;                       // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedThreshold;                                 // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLandToMovementInterruptibleThreshold;          // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetIsCloseDistance;                          // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_Interruptible;                           // 0x0824(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCreatureAnimInstance_LootLlama">();
	}
	static class UJunoCreatureAnimInstance_LootLlama* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCreatureAnimInstance_LootLlama>();
	}
};
static_assert(alignof(UJunoCreatureAnimInstance_LootLlama) == 0x000010, "Wrong alignment on UJunoCreatureAnimInstance_LootLlama");
static_assert(sizeof(UJunoCreatureAnimInstance_LootLlama) == 0x000830, "Wrong size on UJunoCreatureAnimInstance_LootLlama");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bHighVelocity) == 0x0007F8, "Member 'UJunoCreatureAnimInstance_LootLlama::bHighVelocity' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bIsInterruptible) == 0x0007F9, "Member 'UJunoCreatureAnimInstance_LootLlama::bIsInterruptible' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bLocoToIdle) == 0x0007FA, "Member 'UJunoCreatureAnimInstance_LootLlama::bLocoToIdle' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bIdleToLoco) == 0x0007FB, "Member 'UJunoCreatureAnimInstance_LootLlama::bIdleToLoco' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bJumpStartToJumpLoop) == 0x0007FC, "Member 'UJunoCreatureAnimInstance_LootLlama::bJumpStartToJumpLoop' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bJumpLandToMovement) == 0x0007FD, "Member 'UJunoCreatureAnimInstance_LootLlama::bJumpLandToMovement' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bIsRunning) == 0x0007FE, "Member 'UJunoCreatureAnimInstance_LootLlama::bIsRunning' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bIdleToFalling) == 0x0007FF, "Member 'UJunoCreatureAnimInstance_LootLlama::bIdleToFalling' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bToppledOnGround) == 0x000800, "Member 'UJunoCreatureAnimInstance_LootLlama::bToppledOnGround' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bTransitionToLand) == 0x000801, "Member 'UJunoCreatureAnimInstance_LootLlama::bTransitionToLand' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, TargetDistance) == 0x000804, "Member 'UJunoCreatureAnimInstance_LootLlama::TargetDistance' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bTargetIsClose) == 0x000808, "Member 'UJunoCreatureAnimInstance_LootLlama::bTargetIsClose' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bIsToppled) == 0x000809, "Member 'UJunoCreatureAnimInstance_LootLlama::bIsToppled' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, bIsLeaking) == 0x00080A, "Member 'UJunoCreatureAnimInstance_LootLlama::bIsLeaking' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, MinHighVelocityMagnitude) == 0x00080C, "Member 'UJunoCreatureAnimInstance_LootLlama::MinHighVelocityMagnitude' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, MaxInterruptibleCurveValue) == 0x000810, "Member 'UJunoCreatureAnimInstance_LootLlama::MaxInterruptibleCurveValue' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, LocoIdleTransitionThreshold) == 0x000814, "Member 'UJunoCreatureAnimInstance_LootLlama::LocoIdleTransitionThreshold' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, RunSpeedThreshold) == 0x000818, "Member 'UJunoCreatureAnimInstance_LootLlama::RunSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, JumpLandToMovementInterruptibleThreshold) == 0x00081C, "Member 'UJunoCreatureAnimInstance_LootLlama::JumpLandToMovementInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, MinTargetIsCloseDistance) == 0x000820, "Member 'UJunoCreatureAnimInstance_LootLlama::MinTargetIsCloseDistance' has a wrong offset!");
static_assert(offsetof(UJunoCreatureAnimInstance_LootLlama, CurveName_Interruptible) == 0x000824, "Member 'UJunoCreatureAnimInstance_LootLlama::CurveName_Interruptible' has a wrong offset!");

// Class JunoGameNative.JunoFreeBuildPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoFreeBuildPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFreeBuildPersistenceFeatureDataInterface">();
	}
	static class IJunoFreeBuildPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoFreeBuildPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoFreeBuildPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoFreeBuildPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoFreeBuildPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoFreeBuildPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoDamageFormulaExecutionCalculation
// 0x0000 (0x0048 - 0x0048)
class UJunoDamageFormulaExecutionCalculation final : public UFortDamageFormulaExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDamageFormulaExecutionCalculation">();
	}
	static class UJunoDamageFormulaExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDamageFormulaExecutionCalculation>();
	}
};
static_assert(alignof(UJunoDamageFormulaExecutionCalculation) == 0x000008, "Wrong alignment on UJunoDamageFormulaExecutionCalculation");
static_assert(sizeof(UJunoDamageFormulaExecutionCalculation) == 0x000048, "Wrong size on UJunoDamageFormulaExecutionCalculation");

// Class JunoGameNative.JunoControllerComponent_StreamingSources
// 0x0050 (0x0160 - 0x0110)
class UJunoControllerComponent_StreamingSources final : public UFortControllerComponent_StreamingSources
{
public:
	uint8                                         Pad_110[0x50];                                     // 0x0110(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoControllerComponent_StreamingSources">();
	}
	static class UJunoControllerComponent_StreamingSources* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoControllerComponent_StreamingSources>();
	}
};
static_assert(alignof(UJunoControllerComponent_StreamingSources) == 0x000008, "Wrong alignment on UJunoControllerComponent_StreamingSources");
static_assert(sizeof(UJunoControllerComponent_StreamingSources) == 0x000160, "Wrong size on UJunoControllerComponent_StreamingSources");

// Class JunoGameNative.JunoInventory
// 0x0080 (0x0588 - 0x0508)
class AJunoInventory final : public AFortInventory
{
public:
	uint8                                         Pad_508[0x30];                                     // 0x0508(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SavedActorGuid;                                    // 0x0538(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x28];                                     // 0x0548(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InventoryCapacity;                                 // 0x0570(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  InventoryHandleGuid;                               // 0x0574(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPersistent;                                     // 0x0584(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasSpawnedByLevelSaveRecord;                      // 0x0585(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_586[0x2];                                      // 0x0586(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventory">();
	}
	static class AJunoInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoInventory>();
	}
};
static_assert(alignof(AJunoInventory) == 0x000008, "Wrong alignment on AJunoInventory");
static_assert(sizeof(AJunoInventory) == 0x000588, "Wrong size on AJunoInventory");
static_assert(offsetof(AJunoInventory, SavedActorGuid) == 0x000538, "Member 'AJunoInventory::SavedActorGuid' has a wrong offset!");
static_assert(offsetof(AJunoInventory, InventoryCapacity) == 0x000570, "Member 'AJunoInventory::InventoryCapacity' has a wrong offset!");
static_assert(offsetof(AJunoInventory, InventoryHandleGuid) == 0x000574, "Member 'AJunoInventory::InventoryHandleGuid' has a wrong offset!");
static_assert(offsetof(AJunoInventory, bIsPersistent) == 0x000584, "Member 'AJunoInventory::bIsPersistent' has a wrong offset!");
static_assert(offsetof(AJunoInventory, bWasSpawnedByLevelSaveRecord) == 0x000585, "Member 'AJunoInventory::bWasSpawnedByLevelSaveRecord' has a wrong offset!");

// Class JunoGameNative.JunoInventoryManagerComponent
// 0x0060 (0x0100 - 0x00A0)
class UJunoInventoryManagerComponent final : public UActorComponent
{
public:
	TArray<struct FJunoInventoryHandle>           InventoryHandles;                                  // 0x00A0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AJunoInventory>>  InventoryInstances;                                // 0x00B0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x40];                                      // 0x00C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_InventoryHandles();
	void OnRep_InventoryInstances();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryManagerComponent">();
	}
	static class UJunoInventoryManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInventoryManagerComponent>();
	}
};
static_assert(alignof(UJunoInventoryManagerComponent) == 0x000008, "Wrong alignment on UJunoInventoryManagerComponent");
static_assert(sizeof(UJunoInventoryManagerComponent) == 0x000100, "Wrong size on UJunoInventoryManagerComponent");
static_assert(offsetof(UJunoInventoryManagerComponent, InventoryHandles) == 0x0000A0, "Member 'UJunoInventoryManagerComponent::InventoryHandles' has a wrong offset!");
static_assert(offsetof(UJunoInventoryManagerComponent, InventoryInstances) == 0x0000B0, "Member 'UJunoInventoryManagerComponent::InventoryInstances' has a wrong offset!");

// Class JunoGameNative.JunoInventoryPersistenceFeatureData
// 0x0018 (0x0058 - 0x0040)
class UJunoInventoryPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoInventoriesSaveData               SavedInventories;                                  // 0x0048(0x0010)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryPersistenceFeatureData">();
	}
	static class UJunoInventoryPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInventoryPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoInventoryPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoInventoryPersistenceFeatureData");
static_assert(sizeof(UJunoInventoryPersistenceFeatureData) == 0x000058, "Wrong size on UJunoInventoryPersistenceFeatureData");
static_assert(offsetof(UJunoInventoryPersistenceFeatureData, SavedInventories) == 0x000048, "Member 'UJunoInventoryPersistenceFeatureData::SavedInventories' has a wrong offset!");

// Class JunoGameNative.JunoInventoryPersistenceFeatureDataActor
// 0x0018 (0x02E8 - 0x02D0)
class AJunoInventoryPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AJunoInventory*>                 SavedInventories;                                  // 0x02D8(0x0010)(ZeroConstructor, SaveGame, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryPersistenceFeatureDataActor">();
	}
	static class AJunoInventoryPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoInventoryPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoInventoryPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoInventoryPersistenceFeatureDataActor");
static_assert(sizeof(AJunoInventoryPersistenceFeatureDataActor) == 0x0002E8, "Wrong size on AJunoInventoryPersistenceFeatureDataActor");
static_assert(offsetof(AJunoInventoryPersistenceFeatureDataActor, SavedInventories) == 0x0002D8, "Member 'AJunoInventoryPersistenceFeatureDataActor::SavedInventories' has a wrong offset!");

// Class JunoGameNative.StressISMManager
// 0x0060 (0x02F0 - 0x0290)
class AStressISMManager final : public AInfo
{
public:
	bool                                          bPushUpdatesEveryTick;                             // 0x0290(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          ISMC;                                              // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInstancedStaticMeshComponent*>  ChildISMC;                                         // 0x02A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Positions;                                         // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       Rotations;                                         // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   Colors;                                            // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   RandomColors;                                      // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void PushUpdatesToISMC();
	void SetNumChildISMC(int32 Num);
	void Towers(int32 Rows, int32 Cols, int32 Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StressISMManager">();
	}
	static class AStressISMManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStressISMManager>();
	}
};
static_assert(alignof(AStressISMManager) == 0x000008, "Wrong alignment on AStressISMManager");
static_assert(sizeof(AStressISMManager) == 0x0002F0, "Wrong size on AStressISMManager");
static_assert(offsetof(AStressISMManager, bPushUpdatesEveryTick) == 0x000290, "Member 'AStressISMManager::bPushUpdatesEveryTick' has a wrong offset!");
static_assert(offsetof(AStressISMManager, ISMC) == 0x000298, "Member 'AStressISMManager::ISMC' has a wrong offset!");
static_assert(offsetof(AStressISMManager, ChildISMC) == 0x0002A0, "Member 'AStressISMManager::ChildISMC' has a wrong offset!");
static_assert(offsetof(AStressISMManager, Positions) == 0x0002B0, "Member 'AStressISMManager::Positions' has a wrong offset!");
static_assert(offsetof(AStressISMManager, Rotations) == 0x0002C0, "Member 'AStressISMManager::Rotations' has a wrong offset!");
static_assert(offsetof(AStressISMManager, Colors) == 0x0002D0, "Member 'AStressISMManager::Colors' has a wrong offset!");
static_assert(offsetof(AStressISMManager, RandomColors) == 0x0002E0, "Member 'AStressISMManager::RandomColors' has a wrong offset!");

// Class JunoGameNative.JunoInventoryPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoInventoryPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryPersistenceFeatureDataInterface">();
	}
	static class IJunoInventoryPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoInventoryPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoInventoryPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoInventoryPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoInventoryPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoInventoryPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoInventoryUIPersistenceFeatureData
// 0x0058 (0x0098 - 0x0040)
class UJunoInventoryUIPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoInventoryUISaveData               SavedInventoryUI;                                  // 0x0048(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryUIPersistenceFeatureData">();
	}
	static class UJunoInventoryUIPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInventoryUIPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoInventoryUIPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoInventoryUIPersistenceFeatureData");
static_assert(sizeof(UJunoInventoryUIPersistenceFeatureData) == 0x000098, "Wrong size on UJunoInventoryUIPersistenceFeatureData");
static_assert(offsetof(UJunoInventoryUIPersistenceFeatureData, SavedInventoryUI) == 0x000048, "Member 'UJunoInventoryUIPersistenceFeatureData::SavedInventoryUI' has a wrong offset!");

// Class JunoGameNative.JunoInventoryUIPersistenceFeatureDataActor
// 0x0058 (0x0328 - 0x02D0)
class AJunoInventoryUIPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FJunoSavedInventoryUIData> SavedInventoryUI;                                  // 0x02D8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryUIPersistenceFeatureDataActor">();
	}
	static class AJunoInventoryUIPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoInventoryUIPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoInventoryUIPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoInventoryUIPersistenceFeatureDataActor");
static_assert(sizeof(AJunoInventoryUIPersistenceFeatureDataActor) == 0x000328, "Wrong size on AJunoInventoryUIPersistenceFeatureDataActor");
static_assert(offsetof(AJunoInventoryUIPersistenceFeatureDataActor, SavedInventoryUI) == 0x0002D8, "Member 'AJunoInventoryUIPersistenceFeatureDataActor::SavedInventoryUI' has a wrong offset!");

// Class JunoGameNative.JunoInventoryUIPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoInventoryUIPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInventoryUIPersistenceFeatureDataInterface">();
	}
	static class IJunoInventoryUIPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoInventoryUIPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoInventoryUIPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoInventoryUIPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoInventoryUIPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoInventoryUIPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoPlayerInventoryComponent
// 0x0000 (0x0318 - 0x0318)
class UJunoPlayerInventoryComponent final : public UJunoInventoryComponent
{
public:
	void OnPlayerPawnPossessed(class APawn* PossessedPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerInventoryComponent">();
	}
	static class UJunoPlayerInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerInventoryComponent>();
	}
};
static_assert(alignof(UJunoPlayerInventoryComponent) == 0x000008, "Wrong alignment on UJunoPlayerInventoryComponent");
static_assert(sizeof(UJunoPlayerInventoryComponent) == 0x000318, "Wrong size on UJunoPlayerInventoryComponent");

// Class JunoGameNative.JunoBuilderTool
// 0x0070 (0x1588 - 0x1518)
class AJunoBuilderTool final : public AFortWeapon
{
public:
	TMulticastInlineDelegate<void(class AJunoBuilderTool* BuilderTool, class UJunoBuilderToolInteractionBehavior* Behavior)> OnBuilderToolInteractionStarted;                   // 0x1518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AJunoBuilderTool* BuilderTool, class UJunoBuilderToolInteractionBehavior* Behavior)> OnBuilderToolInteractionStopped;                   // 0x1528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FJunoInputMapping                      InputMapping;                                      // 0x1538(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UInputAction*                           UnEquipInputAction;                                // 0x1548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ActivatedTags;                                     // 0x1550(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UJunoBuilderToolInteractionBehavior*> InteractionBehaviors;                              // 0x1570(0x0010)(Edit, ExportObject, Net, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UJunoBuilderToolInteractionBehavior*    ActiveInteractionBehavior;                         // 0x1580(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClientStartInteraction(class UJunoBuilderToolInteractionBehavior* InteractionBehavior, const TArray<struct FJunoBuilderToolSelectedActor>& SelectedActors, const struct FGuid& SelectionGUID);
	void ClientStopInteraction(const bool bIsExiting);
	void MulticastClearInteractionOnRemoteClients();
	void MulticastStartInteractionOnRemoteClients(class UJunoBuilderToolInteractionBehavior* InteractionBehavior, const TArray<struct FJunoBuilderToolSelectedActor>& SelectedActors, const struct FGuid& SelectionGUID);
	void ReceiveInteractionEnded(class UJunoBuilderToolInteractionBehavior* InteractionBehavior);
	void ReceiveInteractionStarted(class UJunoBuilderToolInteractionBehavior* InteractionBehavior);
	void ServerClearInteraction(const bool bExited);
	void ServerStartInteraction(const TArray<struct FJunoBuilderToolSelectedActor>& SelectedActors, const struct FGuid& SelectionGUID);

	const class UJunoBuilderToolInteractionBehavior* GetActiveInteractionBehavior() const;
	TArray<struct FJunoBuilderToolSelectedActor> GetSelectedActors() const;
	struct FGuid GetSelectionGUID() const;
	bool IsEnabled() const;
	bool IsRunningOnOwningClient() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuilderTool">();
	}
	static class AJunoBuilderTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoBuilderTool>();
	}
};
static_assert(alignof(AJunoBuilderTool) == 0x000008, "Wrong alignment on AJunoBuilderTool");
static_assert(sizeof(AJunoBuilderTool) == 0x001588, "Wrong size on AJunoBuilderTool");
static_assert(offsetof(AJunoBuilderTool, OnBuilderToolInteractionStarted) == 0x001518, "Member 'AJunoBuilderTool::OnBuilderToolInteractionStarted' has a wrong offset!");
static_assert(offsetof(AJunoBuilderTool, OnBuilderToolInteractionStopped) == 0x001528, "Member 'AJunoBuilderTool::OnBuilderToolInteractionStopped' has a wrong offset!");
static_assert(offsetof(AJunoBuilderTool, InputMapping) == 0x001538, "Member 'AJunoBuilderTool::InputMapping' has a wrong offset!");
static_assert(offsetof(AJunoBuilderTool, UnEquipInputAction) == 0x001548, "Member 'AJunoBuilderTool::UnEquipInputAction' has a wrong offset!");
static_assert(offsetof(AJunoBuilderTool, ActivatedTags) == 0x001550, "Member 'AJunoBuilderTool::ActivatedTags' has a wrong offset!");
static_assert(offsetof(AJunoBuilderTool, InteractionBehaviors) == 0x001570, "Member 'AJunoBuilderTool::InteractionBehaviors' has a wrong offset!");
static_assert(offsetof(AJunoBuilderTool, ActiveInteractionBehavior) == 0x001580, "Member 'AJunoBuilderTool::ActiveInteractionBehavior' has a wrong offset!");

// Class JunoGameNative.JunoBuilderToolInteractionBehavior
// 0x01B0 (0x0250 - 0x00A0)
class UJunoBuilderToolInteractionBehavior : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class UJunoBuilderToolInteractionBehavior* Behavior)> OnInteractionStart;                                // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UJunoBuilderToolInteractionBehavior* Behavior)> OnInteractionTrigger;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UJunoBuilderToolInteractionBehavior* Behavior)> OnInteractionEnd;                                  // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UJunoBuilderToolInteractionBehavior* Behavior)> OnInteractionExit;                                 // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bShouldAddToParent;                                // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    ConfigData;                                        // 0x00E8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ActivatedTags;                                     // 0x00F8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputMappingContext*                   InputMappingContext;                               // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InputMappingPriority;                              // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           TriggerInputAction;                                // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ExitInputAction;                                   // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortGameplayAbility>       StartInteractionAbility;                           // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortGameplayAbility>       EndInteractionAbility;                             // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortGameplayAbility>       FailAbility;                                       // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortGameplayAbility>       ExitAbility;                                       // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJunoBuilderToolInteractionActorClassSet SupportedClasses;                                  // 0x0160(0x00A0)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FJunoBuilderToolSelectedActor>  SelectedActors;                                    // 0x0200(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FGuid                                  SelectionGUID;                                     // 0x0210(0x0010)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FJunoBuilderToolTimedActors>    ClientPredictedActors;                             // 0x0220(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FServerSpawnedActorPair>        ServerSpawnedActors;                               // 0x0230(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOnServerSpawnSelectedActorsFailed(const TArray<class FName>& FailedNames);
	void OnRep_ServerSpawnedActors();
	void PlayGameplayAbility(const TSubclassOf<class UFortGameplayAbility> AbilityClass);
	void ReceiveClearInteractionOnRemoteClient();
	void ReceiveEndInteraction();
	void ReceiveExitInteraction(const bool bClearInteractionBehavior);
	void ReceiveSpawnedActor(class AActor* SpawnedActor);
	void ReceiveStartInteractionOnClient(const TArray<struct FJunoBuilderToolSelectedActor>& Actors, const struct FGuid& Guid);
	void ReceiveStartInteractionOnRemoteClient(const TArray<struct FJunoBuilderToolSelectedActor>& Actors, const struct FGuid& Guid);
	void ReceiveStartInteractionOnServer(const TArray<struct FJunoBuilderToolSelectedActor>& Actors, const struct FGuid& Guid);
	void ReceiveTickInteraction();
	void ReceiveTriggerInteraction();
	void ServerOnSpawnedActorProcessedByClient(const class FName StableName);
	void ServerSpawnSelectedActors(const struct FJunoBuilderToolSelectionSpawnParams& SelectionSpawnParameters);

	class AJunoBuilderTool* GetBuilderTool() const;
	class AFortPlayerController* GetFortPlayerController() const;
	class APawn* GetInstigator() const;
	class APlayerController* GetPlayerController() const;
	const TArray<struct FJunoBuilderToolSelectedActor> GetSelectedActors() const;
	const struct FGuid GetSelectionGUID() const;
	bool IsRunningOnOwningClient() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuilderToolInteractionBehavior">();
	}
	static class UJunoBuilderToolInteractionBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuilderToolInteractionBehavior>();
	}
};
static_assert(alignof(UJunoBuilderToolInteractionBehavior) == 0x000008, "Wrong alignment on UJunoBuilderToolInteractionBehavior");
static_assert(sizeof(UJunoBuilderToolInteractionBehavior) == 0x000250, "Wrong size on UJunoBuilderToolInteractionBehavior");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, OnInteractionStart) == 0x0000A0, "Member 'UJunoBuilderToolInteractionBehavior::OnInteractionStart' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, OnInteractionTrigger) == 0x0000B0, "Member 'UJunoBuilderToolInteractionBehavior::OnInteractionTrigger' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, OnInteractionEnd) == 0x0000C0, "Member 'UJunoBuilderToolInteractionBehavior::OnInteractionEnd' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, OnInteractionExit) == 0x0000D0, "Member 'UJunoBuilderToolInteractionBehavior::OnInteractionExit' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, bShouldAddToParent) == 0x0000E0, "Member 'UJunoBuilderToolInteractionBehavior::bShouldAddToParent' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, Priority) == 0x0000E4, "Member 'UJunoBuilderToolInteractionBehavior::Priority' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, ConfigData) == 0x0000E8, "Member 'UJunoBuilderToolInteractionBehavior::ConfigData' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, ActivatedTags) == 0x0000F8, "Member 'UJunoBuilderToolInteractionBehavior::ActivatedTags' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, InputMappingContext) == 0x000120, "Member 'UJunoBuilderToolInteractionBehavior::InputMappingContext' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, InputMappingPriority) == 0x000128, "Member 'UJunoBuilderToolInteractionBehavior::InputMappingPriority' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, TriggerInputAction) == 0x000130, "Member 'UJunoBuilderToolInteractionBehavior::TriggerInputAction' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, ExitInputAction) == 0x000138, "Member 'UJunoBuilderToolInteractionBehavior::ExitInputAction' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, StartInteractionAbility) == 0x000140, "Member 'UJunoBuilderToolInteractionBehavior::StartInteractionAbility' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, EndInteractionAbility) == 0x000148, "Member 'UJunoBuilderToolInteractionBehavior::EndInteractionAbility' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, FailAbility) == 0x000150, "Member 'UJunoBuilderToolInteractionBehavior::FailAbility' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, ExitAbility) == 0x000158, "Member 'UJunoBuilderToolInteractionBehavior::ExitAbility' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, SupportedClasses) == 0x000160, "Member 'UJunoBuilderToolInteractionBehavior::SupportedClasses' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, SelectedActors) == 0x000200, "Member 'UJunoBuilderToolInteractionBehavior::SelectedActors' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, SelectionGUID) == 0x000210, "Member 'UJunoBuilderToolInteractionBehavior::SelectionGUID' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, ClientPredictedActors) == 0x000220, "Member 'UJunoBuilderToolInteractionBehavior::ClientPredictedActors' has a wrong offset!");
static_assert(offsetof(UJunoBuilderToolInteractionBehavior, ServerSpawnedActors) == 0x000230, "Member 'UJunoBuilderToolInteractionBehavior::ServerSpawnedActors' has a wrong offset!");

// Class JunoGameNative.JunoBuildingActor
// 0x0280 (0x0E90 - 0x0C10)
class AJunoBuildingActor : public AJunoBuildingProp
{
public:
	uint8                                         Pad_C10[0x20];                                     // 0x0C10(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GridSizeOverride;                                  // 0x0C30(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoBuildingBehaviorGridLimits        GridOffsetLimits;                                  // 0x0C48(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJunoBuilderToolInteractionActorClassSet OverlappableClasses;                               // 0x0C58(0x00A0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FJunoBuilderToolInteractionActorClassSet SupportableClasses;                                // 0x0CF8(0x00A0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UJunoConnectivityComponent*             Connectivity;                                      // 0x0D98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJunoGeometryCollectionAssemblerComponent* GeometryCollectionAssemblerComponent;              // 0x0DA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJunoGuidedBuildingLandscapeVisualModifierActor* TerrainVisualModifierActor;                        // 0x0DA8(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             BuildingPivotOffset;                               // 0x0DB0(0x0060)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BuildingGridSnapOffset;                            // 0x0E10(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FJunoBuildingSnapEntry>         SnapEntries;                                       // 0x0E28(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, TSubclassOf<class UJunoBuildingPreviewComponent>> PreviewComponentTemplates;                         // 0x0E38(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         bCanRegenHealth : 1;                               // 0x0E88(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	bool                                          bShouldPersist;                                    // 0x0E89(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceOverrideDestroyFoliageWhenPlaced;            // 0x0E8A(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8B[0x5];                                      // 0x0E8B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlacedInWorld(bool bFinalize, const TArray<struct FJunoBuilderToolSupportActorComponentPair>& SupportCandidates);
	void OnRep_bForceOverrideDestroyFoliageWhenPlaced();
	void SetCanEverAffectNavigation(bool bCanEverAffectNavigation, class UActorComponent* TargetActorComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingActor">();
	}
	static class AJunoBuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoBuildingActor>();
	}
};
static_assert(alignof(AJunoBuildingActor) == 0x000010, "Wrong alignment on AJunoBuildingActor");
static_assert(sizeof(AJunoBuildingActor) == 0x000E90, "Wrong size on AJunoBuildingActor");
static_assert(offsetof(AJunoBuildingActor, GridSizeOverride) == 0x000C30, "Member 'AJunoBuildingActor::GridSizeOverride' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, GridOffsetLimits) == 0x000C48, "Member 'AJunoBuildingActor::GridOffsetLimits' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, OverlappableClasses) == 0x000C58, "Member 'AJunoBuildingActor::OverlappableClasses' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, SupportableClasses) == 0x000CF8, "Member 'AJunoBuildingActor::SupportableClasses' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, Connectivity) == 0x000D98, "Member 'AJunoBuildingActor::Connectivity' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, GeometryCollectionAssemblerComponent) == 0x000DA0, "Member 'AJunoBuildingActor::GeometryCollectionAssemblerComponent' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, TerrainVisualModifierActor) == 0x000DA8, "Member 'AJunoBuildingActor::TerrainVisualModifierActor' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, BuildingPivotOffset) == 0x000DB0, "Member 'AJunoBuildingActor::BuildingPivotOffset' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, BuildingGridSnapOffset) == 0x000E10, "Member 'AJunoBuildingActor::BuildingGridSnapOffset' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, SnapEntries) == 0x000E28, "Member 'AJunoBuildingActor::SnapEntries' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, PreviewComponentTemplates) == 0x000E38, "Member 'AJunoBuildingActor::PreviewComponentTemplates' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, bShouldPersist) == 0x000E89, "Member 'AJunoBuildingActor::bShouldPersist' has a wrong offset!");
static_assert(offsetof(AJunoBuildingActor, bForceOverrideDestroyFoliageWhenPlaced) == 0x000E8A, "Member 'AJunoBuildingActor::bForceOverrideDestroyFoliageWhenPlaced' has a wrong offset!");

// Class JunoGameNative.JunoBuildingAssociatedItemInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoBuildingAssociatedItemInterface final : public IInterface
{
public:
	bool CanRemoveAssociatedItemFromInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingAssociatedItemInterface">();
	}
	static class IJunoBuildingAssociatedItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoBuildingAssociatedItemInterface>();
	}
};
static_assert(alignof(IJunoBuildingAssociatedItemInterface) == 0x000008, "Wrong alignment on IJunoBuildingAssociatedItemInterface");
static_assert(sizeof(IJunoBuildingAssociatedItemInterface) == 0x000028, "Wrong size on IJunoBuildingAssociatedItemInterface");

// Class JunoGameNative.JunoBuildingBehaviorBase
// 0x0340 (0x0590 - 0x0250)
#pragma pack(push, 0x1)
class alignas(0x10) UJunoBuildingBehaviorBase : public UJunoBuilderToolInteractionBehavior
{
public:
	uint8                                         Pad_250[0x30];                                     // 0x0250(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AJunoBuildingPreviewer>     PreviewerClass;                                    // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJunoBuildingPreviewParams             DefaultPreviewParams;                              // 0x0288(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class AJunoBuildingPreviewer*                 Previewer_Internal;                                // 0x02A0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJunoBuildingBehaviorState                    BuildingState;                                     // 0x02A8(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BuildingStateTags;                                 // 0x02B0(0x0020)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UJunoBuildingBehaviorBase* BuildingBehavior, EJunoBuildingBehaviorState PreviousState, EJunoBuildingBehaviorState NewState)> OnBuildingStateChanged;                            // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UJunoBuildingBehaviorBase* BuildingBehavior, struct FGameplayTagContainer& PreviousTags, struct FGameplayTagContainer& NewTags)> OnBuildingStateTagsChanged;                        // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FJunoEvent_EnterBuildModePreview& Payload)> OnEnterPreviewMode;                                // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FJunoEvent_ExitBuildModePreview& Payload)> OnExitPreviewMode;                                 // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FJunoInputMapping                      BuildPreviewModeInputMapping;                      // 0x0310(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UInputAction*                           BuildingPreviewModeCameraRotationAction;           // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SelectionToWorld;                                  // 0x0330(0x0060)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             TargetSelectionToWorld;                            // 0x0390(0x0060)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             SmoothedSelectionToWorld;                          // 0x03F0(0x0060)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             SelectionToBasis;                                  // 0x0450(0x0060)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             InterpolationBasis;                                // 0x04B0(0x0060)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LocationLerpAlpha;                                 // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationLerpAlpha;                                 // 0x0514(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_518[0x1];                                      // 0x0518(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCurrentlyInPreviewMode;                         // 0x0519(0x0001)(Edit, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJunoBuildModeType                            CurrentBuildMode;                                  // 0x051A(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51B[0x5];                                      // 0x051B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UJunoBuildingBehaviorBase* BuildingBehavior)> OnPositionInterpStart;                             // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UJunoBuildingBehaviorBase* BuildingBehavior)> OnPositionInterpEnd;                               // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      SpatialInterfaceSelectionQuery;                    // 0x0540(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void HandleBuildModeChanged(const struct FJunoEvent_BuildingModeChanged& Event);
	void MulticastUpdatePreviewOnRemoteClients(const struct FTransform& NewSelectionToWorld, const EJunoBuildingBehaviorState NewBuildingState);
	void ReceiveBuildingStateChanged(const EJunoBuildingBehaviorState PreviousState, const EJunoBuildingBehaviorState NewState);
	void ReceivePositionInterpEnd();
	void ReceivePositionInterpStart();
	void ServerUpdatePreview(const struct FTransform& NewSelectionToWorld, const EJunoBuildingBehaviorState NewBuildingState);
	void SetDisabled(const bool bShouldBeDisabled);
	void SetInterpolationBasis(const struct FTransform& NewInterpolationBasis);
	void SetSmoothedSelectionToWorld(const struct FTransform& NewSmoothedSelectionToWorld);
	void SetTargetSelectionLocation(const struct FVector& NewLocation);
	void SetTargetSelectionRotation(const struct FQuat& NewRotation);
	void SetTargetSelectionToWorld(const struct FTransform& NewSelectionToWorld);

	bool CanPlaceSelectedActors(struct FGameplayTagContainer* OutBuildingStateTags) const;
	bool CanSelectedActorsBePlaced(const TArray<struct FJunoBuilderToolSelectedActor>& InSelectedActors, const struct FTransform& InSelectionToWorld, struct FGameplayTagContainer* OutBuildingStateTags) const;
	EJunoBuildingBehaviorState GetBuildingState() const;
	struct FGameplayTagContainer GetBuildingStateTags() const;
	const struct FJunoBuildingPreviewParams GetDefaultPreviewParams() const;
	class AJunoBuildingPreviewer* GetPreviewer() const;
	struct FBox GetPreviewLocalBounds() const;
	struct FBox GetPreviewWorldBounds() const;
	const struct FTransform GetSelectionToWorld() const;
	const struct FTransform GetTargetSelectionToWorld() const;
	bool IsDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingBehaviorBase">();
	}
	static class UJunoBuildingBehaviorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingBehaviorBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UJunoBuildingBehaviorBase) == 0x000010, "Wrong alignment on UJunoBuildingBehaviorBase");
static_assert(sizeof(UJunoBuildingBehaviorBase) == 0x000590, "Wrong size on UJunoBuildingBehaviorBase");
static_assert(offsetof(UJunoBuildingBehaviorBase, PreviewerClass) == 0x000280, "Member 'UJunoBuildingBehaviorBase::PreviewerClass' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, DefaultPreviewParams) == 0x000288, "Member 'UJunoBuildingBehaviorBase::DefaultPreviewParams' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, Previewer_Internal) == 0x0002A0, "Member 'UJunoBuildingBehaviorBase::Previewer_Internal' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, BuildingState) == 0x0002A8, "Member 'UJunoBuildingBehaviorBase::BuildingState' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, BuildingStateTags) == 0x0002B0, "Member 'UJunoBuildingBehaviorBase::BuildingStateTags' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, OnBuildingStateChanged) == 0x0002D0, "Member 'UJunoBuildingBehaviorBase::OnBuildingStateChanged' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, OnBuildingStateTagsChanged) == 0x0002E0, "Member 'UJunoBuildingBehaviorBase::OnBuildingStateTagsChanged' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, OnEnterPreviewMode) == 0x0002F0, "Member 'UJunoBuildingBehaviorBase::OnEnterPreviewMode' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, OnExitPreviewMode) == 0x000300, "Member 'UJunoBuildingBehaviorBase::OnExitPreviewMode' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, BuildPreviewModeInputMapping) == 0x000310, "Member 'UJunoBuildingBehaviorBase::BuildPreviewModeInputMapping' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, BuildingPreviewModeCameraRotationAction) == 0x000320, "Member 'UJunoBuildingBehaviorBase::BuildingPreviewModeCameraRotationAction' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, SelectionToWorld) == 0x000330, "Member 'UJunoBuildingBehaviorBase::SelectionToWorld' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, TargetSelectionToWorld) == 0x000390, "Member 'UJunoBuildingBehaviorBase::TargetSelectionToWorld' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, SmoothedSelectionToWorld) == 0x0003F0, "Member 'UJunoBuildingBehaviorBase::SmoothedSelectionToWorld' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, SelectionToBasis) == 0x000450, "Member 'UJunoBuildingBehaviorBase::SelectionToBasis' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, InterpolationBasis) == 0x0004B0, "Member 'UJunoBuildingBehaviorBase::InterpolationBasis' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, LocationLerpAlpha) == 0x000510, "Member 'UJunoBuildingBehaviorBase::LocationLerpAlpha' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, RotationLerpAlpha) == 0x000514, "Member 'UJunoBuildingBehaviorBase::RotationLerpAlpha' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, bIsCurrentlyInPreviewMode) == 0x000519, "Member 'UJunoBuildingBehaviorBase::bIsCurrentlyInPreviewMode' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, CurrentBuildMode) == 0x00051A, "Member 'UJunoBuildingBehaviorBase::CurrentBuildMode' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, OnPositionInterpStart) == 0x000520, "Member 'UJunoBuildingBehaviorBase::OnPositionInterpStart' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, OnPositionInterpEnd) == 0x000530, "Member 'UJunoBuildingBehaviorBase::OnPositionInterpEnd' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehaviorBase, SpatialInterfaceSelectionQuery) == 0x000540, "Member 'UJunoBuildingBehaviorBase::SpatialInterfaceSelectionQuery' has a wrong offset!");

// Class JunoGameNative.JunoBuildingBehavior
// 0x0CD0 (0x1260 - 0x0590)
class UJunoBuildingBehavior final : public UJunoBuildingBehaviorBase
{
public:
	class UInputAction*                           RotateInputAction;                                 // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           NudgeInputAction;                                  // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ToggleNudgeInputAction;                            // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           AdjacencyInputAction;                              // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           SnapToggleInputAction;                             // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        RotationStep;                                      // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxSelectionDistance;                              // 0x05B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxSelectionDistanceZ;                             // 0x05BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                MaxConnectivityDistance;                           // 0x05C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJunoBuildingBehaviorGridLimits        DefaultGridOffsetLimit;                            // 0x05D8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                PenetrationTolerance;                              // 0x05E8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortGameplayAbility>       RotateAbility;                                     // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJunoBuildingBehaviorOverrides         Overrides;                                         // 0x0608(0x0260)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_868[0x518];                                    // 0x0868(0x0518)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  RotationOffset;                                    // 0x0D80(0x0020)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DA0[0x10];                                     // 0x0DA0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoBuildingSnapContext               SnapContext;                                       // 0x0DB0(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E00[0xD0];                                     // 0x0E00(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoBuildingConnectivityContext       ConnectivityContext;                               // 0x0ED0(0x02A0)(Edit, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bEnableAdjacency;                                  // 0x1170(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableSnapPlacement;                              // 0x1171(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1172[0x6];                                     // 0x1172(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UJunoBuildingBehavior* Behavior, bool bEnabled)> OnToggleSnapping;                                  // 0x1178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FIntPoint                              GridOffset;                                        // 0x1188(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQuat                                  GridOffsetControlRotation;                         // 0x1190(0x0020)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UJunoBuildingBehavior* Behavior, EJunoBuildingPlacementType NewPlacementType, EJunoBuildingPlacementType OldPlacementType)> OnPlacementTypeChanged;                            // 0x11B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FJunoBuildingBehaviorStateContext      CachedBuildingStateContext;                        // 0x11C0(0x0030)(Edit, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UJunoBuildingBehavior* Behavior, EJunoBuildingBehaviorState State, struct FJunoBuildingBehaviorStateContext& Context)> OnBuildingStateContextChanged;                     // 0x11F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	double                                        LastTriggerRequestedTimestamp;                     // 0x1200(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        LastTriggerTimestamp;                              // 0x1208(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAdhesionNeedsReset;                               // 0x1210(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1211[0x7];                                     // 0x1211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastPawnLocationForSmoothing;                      // 0x1218(0x0018)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               LastCameraRotationForSmoothing;                    // 0x1230(0x0018)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         PlayerMotionAmount;                                // 0x1248(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124C[0x14];                                    // 0x124C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCameraSpaceGridOffset(const struct FIntPoint& Delta);
	void AddGridOffset(const struct FIntPoint& OffsetDelta);
	bool HasAnySnapEntries();
	void ReceivedFailedInteraction();
	void ReceiveNudgeInputAction(bool bOffsetChanged);
	void ReceivePositionChangedGridCell(const struct FVector& GridCellLocation);
	void ReceiveRotateSelection();
	void ReceiveSnappingDisabled();
	void ReceiveSnappingEnabled();
	void RotateSelection(const double Delta);
	void SetGridOffset(const struct FIntPoint& NewOffset);
	void ToggleAdjacency();

	const struct FJunoBuildingBehaviorStateContext GetBuildingStateContext() const;
	const struct FJunoBuildingBehaviorInteractionRow GetConfigData() const;
	const struct FJunoBuildingConnectivityContext GetConnectivityContext() const;
	const struct FIntPoint GetGridOffset() const;
	const struct FJunoBuildingBehaviorGridLimits GetGridOffsetLimits() const;
	const struct FVector GetGridSize() const;
	struct FVector GetGridSnapOffset() const;
	const struct FJunoBuildingPlacementResult GetLastPlacementResult() const;
	const struct FVector GetPenetrationTolerance() const;
	struct FVector GetPivotOffset() const;
	const struct FJunoBuildingSnapContext GetSnapContext() const;
	const struct FHitResult GetTargetTraceResult() const;
	struct FVector2D GetWorldSpaceGridOffset() const;
	struct FVector2D GetWorldSpaceGridOffsetLimits(struct FVector2D* MinOffset, struct FVector2D* MaxOffset) const;
	struct FVector GetWorldSpacePivotOffset() const;
	bool IsAdjacencyEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingBehavior">();
	}
	static class UJunoBuildingBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingBehavior>();
	}
};
static_assert(alignof(UJunoBuildingBehavior) == 0x000010, "Wrong alignment on UJunoBuildingBehavior");
static_assert(sizeof(UJunoBuildingBehavior) == 0x001260, "Wrong size on UJunoBuildingBehavior");
static_assert(offsetof(UJunoBuildingBehavior, RotateInputAction) == 0x000588, "Member 'UJunoBuildingBehavior::RotateInputAction' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, NudgeInputAction) == 0x000590, "Member 'UJunoBuildingBehavior::NudgeInputAction' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, ToggleNudgeInputAction) == 0x000598, "Member 'UJunoBuildingBehavior::ToggleNudgeInputAction' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, AdjacencyInputAction) == 0x0005A0, "Member 'UJunoBuildingBehavior::AdjacencyInputAction' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, SnapToggleInputAction) == 0x0005A8, "Member 'UJunoBuildingBehavior::SnapToggleInputAction' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, RotationStep) == 0x0005B0, "Member 'UJunoBuildingBehavior::RotationStep' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, MaxSelectionDistance) == 0x0005B8, "Member 'UJunoBuildingBehavior::MaxSelectionDistance' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, MaxSelectionDistanceZ) == 0x0005BC, "Member 'UJunoBuildingBehavior::MaxSelectionDistanceZ' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, MaxConnectivityDistance) == 0x0005C0, "Member 'UJunoBuildingBehavior::MaxConnectivityDistance' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, DefaultGridOffsetLimit) == 0x0005D8, "Member 'UJunoBuildingBehavior::DefaultGridOffsetLimit' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, PenetrationTolerance) == 0x0005E8, "Member 'UJunoBuildingBehavior::PenetrationTolerance' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, RotateAbility) == 0x000600, "Member 'UJunoBuildingBehavior::RotateAbility' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, Overrides) == 0x000608, "Member 'UJunoBuildingBehavior::Overrides' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, RotationOffset) == 0x000D80, "Member 'UJunoBuildingBehavior::RotationOffset' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, SnapContext) == 0x000DB0, "Member 'UJunoBuildingBehavior::SnapContext' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, ConnectivityContext) == 0x000ED0, "Member 'UJunoBuildingBehavior::ConnectivityContext' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, bEnableAdjacency) == 0x001170, "Member 'UJunoBuildingBehavior::bEnableAdjacency' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, bEnableSnapPlacement) == 0x001171, "Member 'UJunoBuildingBehavior::bEnableSnapPlacement' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, OnToggleSnapping) == 0x001178, "Member 'UJunoBuildingBehavior::OnToggleSnapping' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, GridOffset) == 0x001188, "Member 'UJunoBuildingBehavior::GridOffset' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, GridOffsetControlRotation) == 0x001190, "Member 'UJunoBuildingBehavior::GridOffsetControlRotation' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, OnPlacementTypeChanged) == 0x0011B0, "Member 'UJunoBuildingBehavior::OnPlacementTypeChanged' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, CachedBuildingStateContext) == 0x0011C0, "Member 'UJunoBuildingBehavior::CachedBuildingStateContext' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, OnBuildingStateContextChanged) == 0x0011F0, "Member 'UJunoBuildingBehavior::OnBuildingStateContextChanged' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, LastTriggerRequestedTimestamp) == 0x001200, "Member 'UJunoBuildingBehavior::LastTriggerRequestedTimestamp' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, LastTriggerTimestamp) == 0x001208, "Member 'UJunoBuildingBehavior::LastTriggerTimestamp' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, bAdhesionNeedsReset) == 0x001210, "Member 'UJunoBuildingBehavior::bAdhesionNeedsReset' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, LastPawnLocationForSmoothing) == 0x001218, "Member 'UJunoBuildingBehavior::LastPawnLocationForSmoothing' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, LastCameraRotationForSmoothing) == 0x001230, "Member 'UJunoBuildingBehavior::LastCameraRotationForSmoothing' has a wrong offset!");
static_assert(offsetof(UJunoBuildingBehavior, PlayerMotionAmount) == 0x001248, "Member 'UJunoBuildingBehavior::PlayerMotionAmount' has a wrong offset!");

// Class JunoGameNative.JunoBuildingBehaviorSelectedActorInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoBuildingBehaviorSelectedActorInterface final : public IInterface
{
public:
	bool CanPlaceSelectedActor(const class UJunoBuildingBehavior* Behavior, const struct FTransform& ToWorld, struct FGameplayTagContainer* OutBuildingStateTags) const;
	bool CanSupport(TSubclassOf<class AActor> ActorClass) const;
	struct FTransform GetCoordinateBasis() const;
	TArray<EJunoContactDirection> GetFloatingValidationDirections() const;
	struct FJunoBuildingBehaviorGridLimits GetGridOffsetLimits() const;
	struct FVector GetGridSize() const;
	struct FVector GetGridSnapOffset() const;
	float GetMinDistance() const;
	struct FJunoBuilderToolInteractionActorClassSet GetOverlappableClasses() const;
	struct FVector GetPivotOffset() const;
	struct FRotator GetRotationOffset() const;
	bool ShouldBeGridAligned() const;
	bool ShouldIgnoreOverlaps(const class UPrimitiveComponent* PrimComp, const class AActor* OverlappingActor) const;
	bool ShouldMinDistanceIncludeBounds() const;
	void UpdateNoTargetPlacement(struct FTransform* NewSelectionToWorld, struct FTransform* NewUnsnappedSelectionToWorld, struct FTransform* NewBasis, const struct FTransform& ActorToSelection, const struct FJunoBuildingPlacementResult& PlacementResult, const class UJunoBuildingBehavior* Behavior) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingBehaviorSelectedActorInterface">();
	}
	static class IJunoBuildingBehaviorSelectedActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoBuildingBehaviorSelectedActorInterface>();
	}
};
static_assert(alignof(IJunoBuildingBehaviorSelectedActorInterface) == 0x000008, "Wrong alignment on IJunoBuildingBehaviorSelectedActorInterface");
static_assert(sizeof(IJunoBuildingBehaviorSelectedActorInterface) == 0x000028, "Wrong size on IJunoBuildingBehaviorSelectedActorInterface");

// Class JunoGameNative.JunoWeatherPersistenceFeatureDataActor
// 0x0010 (0x02E0 - 0x02D0)
class AJunoWeatherPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	TArray<struct FSavedWeather>                  SavedWeathers;                                     // 0x02D0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherPersistenceFeatureDataActor">();
	}
	static class AJunoWeatherPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoWeatherPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoWeatherPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoWeatherPersistenceFeatureDataActor");
static_assert(sizeof(AJunoWeatherPersistenceFeatureDataActor) == 0x0002E0, "Wrong size on AJunoWeatherPersistenceFeatureDataActor");
static_assert(offsetof(AJunoWeatherPersistenceFeatureDataActor, SavedWeathers) == 0x0002D0, "Member 'AJunoWeatherPersistenceFeatureDataActor::SavedWeathers' has a wrong offset!");

// Class JunoGameNative.JunoBuildingBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoBuildingBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static const struct FTransform GetCoordinateBasis(const struct FJunoBuildingPlacementResult& PlacementResult);
	static const EJunoBuildingPlacementType GetPlacementType(const struct FJunoBuildingPlacementResult& PlacementResult);
	static TArray<class AActor*> GetSupportCandidates(const struct FJunoBuilderToolSelectionSpawnParams& Params_0);
	static const struct FHitResult GetTargetTraceResult(const struct FJunoBuildingPlacementResult& PlacementResult);
	static const struct FTransform GetTargetTransform(const struct FJunoBuildingPlacementResult& PlacementResult);
	static struct FVector GetUnitGridSize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingBlueprintLibrary">();
	}
	static class UJunoBuildingBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoBuildingBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoBuildingBlueprintLibrary");
static_assert(sizeof(UJunoBuildingBlueprintLibrary) == 0x000028, "Wrong size on UJunoBuildingBlueprintLibrary");

// Class JunoGameNative.JunoBuildingGameplayActor
// 0x0200 (0x0B80 - 0x0980)
class AJunoBuildingGameplayActor : public ABuildingGameplayActor
{
public:
	uint8                                         Pad_980[0x40];                                     // 0x0980(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GridSizeOverride;                                  // 0x09C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D8[0x8];                                      // 0x09D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BuildingPivotOffset;                               // 0x09E0(0x0060)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BuildingGridSnapOffset;                            // 0x0A40(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJunoBuildingBehaviorGridLimits        GridOffsetLimits;                                  // 0x0A58(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoBuilderToolInteractionActorClassSet OverlappableClasses;                               // 0x0A68(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	class UItemDefinitionBase*                    AssociatedItem;                                    // 0x0B08(0x0008)(Net, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, TSubclassOf<class UJunoBuildingPreviewComponent>> PreviewComponentTemplates;                         // 0x0B10(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bShouldPersist;                                    // 0x0B60(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B61[0x1F];                                     // 0x0B61(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BlueprintCanDropResourceOnDeath();
	bool BlueprintCanDropResourceWithTagOnDeath(const struct FGameplayTag& ResourceTag);
	void OnPhysicsStateChanged(class UPrimitiveComponent* PrimitiveComponent, EComponentPhysicsStateChange StateChange);
	void SetAssociatedItem(const class UItemDefinitionBase* Item);

	bool BlueprintCanDropItemOnDestroy() const;
	const class UItemDefinitionBase* GetAssociatedItem() const;
	bool HasBeenMigrated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingGameplayActor">();
	}
	static class AJunoBuildingGameplayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoBuildingGameplayActor>();
	}
};
static_assert(alignof(AJunoBuildingGameplayActor) == 0x000010, "Wrong alignment on AJunoBuildingGameplayActor");
static_assert(sizeof(AJunoBuildingGameplayActor) == 0x000B80, "Wrong size on AJunoBuildingGameplayActor");
static_assert(offsetof(AJunoBuildingGameplayActor, GridSizeOverride) == 0x0009C0, "Member 'AJunoBuildingGameplayActor::GridSizeOverride' has a wrong offset!");
static_assert(offsetof(AJunoBuildingGameplayActor, BuildingPivotOffset) == 0x0009E0, "Member 'AJunoBuildingGameplayActor::BuildingPivotOffset' has a wrong offset!");
static_assert(offsetof(AJunoBuildingGameplayActor, BuildingGridSnapOffset) == 0x000A40, "Member 'AJunoBuildingGameplayActor::BuildingGridSnapOffset' has a wrong offset!");
static_assert(offsetof(AJunoBuildingGameplayActor, GridOffsetLimits) == 0x000A58, "Member 'AJunoBuildingGameplayActor::GridOffsetLimits' has a wrong offset!");
static_assert(offsetof(AJunoBuildingGameplayActor, OverlappableClasses) == 0x000A68, "Member 'AJunoBuildingGameplayActor::OverlappableClasses' has a wrong offset!");
static_assert(offsetof(AJunoBuildingGameplayActor, AssociatedItem) == 0x000B08, "Member 'AJunoBuildingGameplayActor::AssociatedItem' has a wrong offset!");
static_assert(offsetof(AJunoBuildingGameplayActor, PreviewComponentTemplates) == 0x000B10, "Member 'AJunoBuildingGameplayActor::PreviewComponentTemplates' has a wrong offset!");
static_assert(offsetof(AJunoBuildingGameplayActor, bShouldPersist) == 0x000B60, "Member 'AJunoBuildingGameplayActor::bShouldPersist' has a wrong offset!");

// Class JunoGameNative.JunoConnectivityGraphPFWPersistenceFeatureData
// 0x0110 (0x0150 - 0x0040)
class UJunoConnectivityGraphPFWPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSerializableConnectivityGraph         SavedConnectivityData;                             // 0x0048(0x0108)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivityGraphPFWPersistenceFeatureData">();
	}
	static class UJunoConnectivityGraphPFWPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoConnectivityGraphPFWPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoConnectivityGraphPFWPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoConnectivityGraphPFWPersistenceFeatureData");
static_assert(sizeof(UJunoConnectivityGraphPFWPersistenceFeatureData) == 0x000150, "Wrong size on UJunoConnectivityGraphPFWPersistenceFeatureData");
static_assert(offsetof(UJunoConnectivityGraphPFWPersistenceFeatureData, SavedConnectivityData) == 0x000048, "Member 'UJunoConnectivityGraphPFWPersistenceFeatureData::SavedConnectivityData' has a wrong offset!");

// Class JunoGameNative.JunoBuildingSnapEditorComponent
// 0x0018 (0x00B8 - 0x00A0)
class UJunoBuildingSnapEditorComponent final : public UActorComponent
{
public:
	TArray<struct FJunoBuildingSnapEntry>         SnapEntries;                                       // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bShowUnselectedTargetingAreas;                     // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingSnapEditorComponent">();
	}
	static class UJunoBuildingSnapEditorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingSnapEditorComponent>();
	}
};
static_assert(alignof(UJunoBuildingSnapEditorComponent) == 0x000008, "Wrong alignment on UJunoBuildingSnapEditorComponent");
static_assert(sizeof(UJunoBuildingSnapEditorComponent) == 0x0000B8, "Wrong size on UJunoBuildingSnapEditorComponent");
static_assert(offsetof(UJunoBuildingSnapEditorComponent, SnapEntries) == 0x0000A0, "Member 'UJunoBuildingSnapEditorComponent::SnapEntries' has a wrong offset!");
static_assert(offsetof(UJunoBuildingSnapEditorComponent, bShowUnselectedTargetingAreas) == 0x0000B0, "Member 'UJunoBuildingSnapEditorComponent::bShowUnselectedTargetingAreas' has a wrong offset!");

// Class JunoGameNative.JunoBuildingSnappingLocation
// 0x0030 (0x0250 - 0x0220)
class UJunoBuildingSnappingLocation final : public USceneComponent
{
public:
	struct FGameplayTagContainer                  LocationTags;                                      // 0x0220(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJunoBuildingSnapEntryBase>     SnapEntries;                                       // 0x0240(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingSnappingLocation">();
	}
	static class UJunoBuildingSnappingLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingSnappingLocation>();
	}
};
static_assert(alignof(UJunoBuildingSnappingLocation) == 0x000010, "Wrong alignment on UJunoBuildingSnappingLocation");
static_assert(sizeof(UJunoBuildingSnappingLocation) == 0x000250, "Wrong size on UJunoBuildingSnappingLocation");
static_assert(offsetof(UJunoBuildingSnappingLocation, LocationTags) == 0x000220, "Member 'UJunoBuildingSnappingLocation::LocationTags' has a wrong offset!");
static_assert(offsetof(UJunoBuildingSnappingLocation, SnapEntries) == 0x000240, "Member 'UJunoBuildingSnappingLocation::SnapEntries' has a wrong offset!");

// Class JunoGameNative.JunoDamageableBuildingInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoDamageableBuildingInterface final : public IInterface
{
public:
	void OnBuildingHandleDamage(class AActor* DamageCauser);
	void OnBuildingHandleOutOfHealth(const struct FGameplayEffectContextHandle& EffectContext, class AController* EventInstigator, class AActor* DamageCauser, const struct FGameplayTagContainer& InTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDamageableBuildingInterface">();
	}
	static class IJunoDamageableBuildingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoDamageableBuildingInterface>();
	}
};
static_assert(alignof(IJunoDamageableBuildingInterface) == 0x000008, "Wrong alignment on IJunoDamageableBuildingInterface");
static_assert(sizeof(IJunoDamageableBuildingInterface) == 0x000028, "Wrong size on IJunoDamageableBuildingInterface");

// Class JunoGameNative.JunoGuidedBuildingActor
// 0x0760 (0x1370 - 0x0C10)
class AJunoGuidedBuildingActor final : public AJunoBuildingProp
{
public:
	uint8                                         Pad_C10[0x20];                                     // 0x0C10(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(struct FGuidedBuildingUpdate& UpdateData)> OnCurrentStageUpdateDelegate;                      // 0x0C30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FGuidedBuildingUpdate& UpdateData)> OnStageUpdateDelegate;                             // 0x0C40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FGuidedBuildingUpdate& UpdateData)> OnStageCompleteDelegate;                           // 0x0C50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FGuidedBuildingUpdate& UpdateData)> OnSectionCompleteDelegate;                         // 0x0C60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FGuidedBuildingUpdate& UpdateData)> OnSetCompleteDelegate;                             // 0x0C70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FGuidedBuildingUpdate& UpdateData)> OnSetUnfinishedDelegate;                           // 0x0C80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FGuidedBuildingUpdate& UpdateData)> OnCurrentStageChange;                              // 0x0C90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<int32>& UpdateData)> OnSnapsUpdatedDelegate;                            // 0x0CA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB0[0x10];                                     // 0x0CB0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BuildingPivotOffset;                               // 0x0CC0(0x0060)(Edit, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BuildingGridSnapOffset;                            // 0x0D20(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoBuilderToolInteractionActorClassSet OverlappableClasses;                               // 0x0D38(0x00A0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FVector                                GridSizeOverride;                                  // 0x0DD8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoBuildingBehaviorGridLimits        GridOffsetLimits;                                  // 0x0DF0(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MinDistanceOverride;                               // 0x0E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E04[0x4];                                      // 0x0E04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, TSubclassOf<class UJunoBuildingPreviewComponent>> PreviewComponentTemplates;                         // 0x0E08(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DestroyOnPlacementTags;                            // 0x0E58(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJunoGuidedBuildingData>        DataArray;                                         // 0x0E78(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FJunoGuidedBuildingStateArray          StateArray;                                        // 0x0E88(0x0120)(Net, Protected, NativeAccessSpecifierProtected)
	struct FJunoStageKey                          CurrentStage;                                      // 0x0FA8(0x0008)(Net, SaveGame, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJunoGuidedBuildingSetCompleteState    SetCompleteState;                                  // 0x0FB0(0x0010)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDateTime                              TimeStarted;                                       // 0x0FC0(0x0008)(ZeroConstructor, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUniqueNetIdRepl                       OwningPlayerID;                                    // 0x0FC8(0x0030)(Net, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterial>               GuidedBuildingMaterial;                            // 0x0FF8(0x0020)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoGuidedBuildingSetData             SetData;                                           // 0x1018(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         LifespanAfterCompletion;                           // 0x1088(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifespanAfterUnfinished;                           // 0x108C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeDelayBeforeShowingNewStageGhostBrushes;        // 0x1090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1094[0x4];                                     // 0x1094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerController*                  LocalRegisteredController;                         // 0x1098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJunoGuidedBuildingLandscapeVisualModifierActor* TerrainVisualModifierActor;                        // 0x10A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A8[0x68];                                    // 0x10A8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoGuidedBuildingRegisteredPlayerArray RegisteredPlayers;                                 // 0x1110(0x0148)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class APawn>                   AutoCompleteInstigatingPawn;                       // 0x1258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJunoGuidedBuildingInteractionComponent> InteractionComponentClass;                         // 0x1260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         FoundationVerticalOffset;                          // 0x1268(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  BuildId;                                           // 0x1290(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          PendingInstantAutoCompleteActors;                  // 0x12A0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FJunoBuildingSnapEntry>         SnapEntries;                                       // 0x12B0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C0[0xB0];                                    // 0x12C0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideSparkleEffect();
	void OnFilledPieceDestroyed(class AActor* Actor);
	void OnFilledPieceDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnGhostBrushesHidden(bool bCanBlendVisibility);
	void OnGhostBrushesVisible(bool bIsFocused, bool bCanBlendVisibility);
	void OnRep_CurrentStage(const struct FJunoStageKey& OldKeyVal);
	void OnRep_RegisteredPlayers();
	void OnRep_SetCompleteState();
	void SetTerrainVisualModifierOptions(EJunoLandscapeVisualModifierType InModifierType, const struct FTransform& InTransform);
	void SetToAutoComplete(class APawn* InInstigator);
	void SetToAutoCompleteCurrentStage(class APawn* InInstigator);
	void SetToAutoCompleteToStage(class APawn* InInstigator, const struct FJunoStageKey& InAutoCompleteToStage);
	void SetupComponent(class UPrimitiveComponent* PrimComp);
	void ShowSparkleEffect();
	void UpdateBlueprintColor(const struct FJunoGuidedBuildingBrushState& BrushState);

	EJunoGuidedBuildingState GetEntryState(const int32 BuildingDataIndex) const;
	struct FGuidedBuildingUpdate GetLatestUpdate() const;
	void GetMissingParts(TArray<struct FJunoGuidedBuildRemainingPartsInfo>* OutArray) const;
	struct FJunoGuidedBuildRemainingPartsInfo GetMissingPartsForRecipe(const class FName& Recipe) const;
	bool GetPartsInCurrentStage(TArray<struct FJunoGuidedBuildRemainingPartsInfo>* OutArray) const;
	bool GetPartsInStage(const struct FJunoStageKey& InStageKey, TArray<struct FJunoGuidedBuildRemainingPartsInfo>* OutArray) const;
	struct FJunoGuidedBuildRemainingPartsInfo GetRemainingPartsInfoForRecipe(const struct FJunoStageKey& InStageKey, const class FName& Recipe) const;
	struct FJunoGuidedBuildRemainingPartsInfo GetRemainingPartsInfoForRecipeInCurrentStage(const class FName& Recipe) const;
	const struct FJunoGuidedBuildingSetCompleteState GetSetCompleteState() const;
	struct FGuidedBuildingUpdate GetStageUpdate(const struct FJunoStageKey& InKey) const;
	bool IsOwningPlayerController(const class APlayerController* Controller) const;
	bool IsRecipeInCurrentStage(const class FName& Recipe) const;
	bool IsRecipeInStage(const struct FJunoStageKey& InStageKey, const class FName& Recipe) const;
	bool IsSetComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGuidedBuildingActor">();
	}
	static class AJunoGuidedBuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoGuidedBuildingActor>();
	}
};
static_assert(alignof(AJunoGuidedBuildingActor) == 0x000010, "Wrong alignment on AJunoGuidedBuildingActor");
static_assert(sizeof(AJunoGuidedBuildingActor) == 0x001370, "Wrong size on AJunoGuidedBuildingActor");
static_assert(offsetof(AJunoGuidedBuildingActor, OnCurrentStageUpdateDelegate) == 0x000C30, "Member 'AJunoGuidedBuildingActor::OnCurrentStageUpdateDelegate' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OnStageUpdateDelegate) == 0x000C40, "Member 'AJunoGuidedBuildingActor::OnStageUpdateDelegate' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OnStageCompleteDelegate) == 0x000C50, "Member 'AJunoGuidedBuildingActor::OnStageCompleteDelegate' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OnSectionCompleteDelegate) == 0x000C60, "Member 'AJunoGuidedBuildingActor::OnSectionCompleteDelegate' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OnSetCompleteDelegate) == 0x000C70, "Member 'AJunoGuidedBuildingActor::OnSetCompleteDelegate' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OnSetUnfinishedDelegate) == 0x000C80, "Member 'AJunoGuidedBuildingActor::OnSetUnfinishedDelegate' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OnCurrentStageChange) == 0x000C90, "Member 'AJunoGuidedBuildingActor::OnCurrentStageChange' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OnSnapsUpdatedDelegate) == 0x000CA0, "Member 'AJunoGuidedBuildingActor::OnSnapsUpdatedDelegate' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, BuildingPivotOffset) == 0x000CC0, "Member 'AJunoGuidedBuildingActor::BuildingPivotOffset' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, BuildingGridSnapOffset) == 0x000D20, "Member 'AJunoGuidedBuildingActor::BuildingGridSnapOffset' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OverlappableClasses) == 0x000D38, "Member 'AJunoGuidedBuildingActor::OverlappableClasses' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, GridSizeOverride) == 0x000DD8, "Member 'AJunoGuidedBuildingActor::GridSizeOverride' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, GridOffsetLimits) == 0x000DF0, "Member 'AJunoGuidedBuildingActor::GridOffsetLimits' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, MinDistanceOverride) == 0x000E00, "Member 'AJunoGuidedBuildingActor::MinDistanceOverride' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, PreviewComponentTemplates) == 0x000E08, "Member 'AJunoGuidedBuildingActor::PreviewComponentTemplates' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, DestroyOnPlacementTags) == 0x000E58, "Member 'AJunoGuidedBuildingActor::DestroyOnPlacementTags' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, DataArray) == 0x000E78, "Member 'AJunoGuidedBuildingActor::DataArray' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, StateArray) == 0x000E88, "Member 'AJunoGuidedBuildingActor::StateArray' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, CurrentStage) == 0x000FA8, "Member 'AJunoGuidedBuildingActor::CurrentStage' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, SetCompleteState) == 0x000FB0, "Member 'AJunoGuidedBuildingActor::SetCompleteState' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, TimeStarted) == 0x000FC0, "Member 'AJunoGuidedBuildingActor::TimeStarted' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, OwningPlayerID) == 0x000FC8, "Member 'AJunoGuidedBuildingActor::OwningPlayerID' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, GuidedBuildingMaterial) == 0x000FF8, "Member 'AJunoGuidedBuildingActor::GuidedBuildingMaterial' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, SetData) == 0x001018, "Member 'AJunoGuidedBuildingActor::SetData' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, LifespanAfterCompletion) == 0x001088, "Member 'AJunoGuidedBuildingActor::LifespanAfterCompletion' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, LifespanAfterUnfinished) == 0x00108C, "Member 'AJunoGuidedBuildingActor::LifespanAfterUnfinished' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, TimeDelayBeforeShowingNewStageGhostBrushes) == 0x001090, "Member 'AJunoGuidedBuildingActor::TimeDelayBeforeShowingNewStageGhostBrushes' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, LocalRegisteredController) == 0x001098, "Member 'AJunoGuidedBuildingActor::LocalRegisteredController' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, TerrainVisualModifierActor) == 0x0010A0, "Member 'AJunoGuidedBuildingActor::TerrainVisualModifierActor' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, RegisteredPlayers) == 0x001110, "Member 'AJunoGuidedBuildingActor::RegisteredPlayers' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, AutoCompleteInstigatingPawn) == 0x001258, "Member 'AJunoGuidedBuildingActor::AutoCompleteInstigatingPawn' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, InteractionComponentClass) == 0x001260, "Member 'AJunoGuidedBuildingActor::InteractionComponentClass' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, FoundationVerticalOffset) == 0x001268, "Member 'AJunoGuidedBuildingActor::FoundationVerticalOffset' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, BuildId) == 0x001290, "Member 'AJunoGuidedBuildingActor::BuildId' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, PendingInstantAutoCompleteActors) == 0x0012A0, "Member 'AJunoGuidedBuildingActor::PendingInstantAutoCompleteActors' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingActor, SnapEntries) == 0x0012B0, "Member 'AJunoGuidedBuildingActor::SnapEntries' has a wrong offset!");

// Class JunoGameNative.JunoPhysicsToyPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoPhysicsToyPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsToyPersistenceFeatureData_Container">();
	}
	static class UJunoPhysicsToyPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPhysicsToyPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoPhysicsToyPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoPhysicsToyPersistenceFeatureData_Container");
static_assert(sizeof(UJunoPhysicsToyPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoPhysicsToyPersistenceFeatureData_Container");

// Class JunoGameNative.JunoGuidedBuildingBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoGuidedBuildingBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static const TArray<struct FJunoStageKey> GetAllStageKeys();
	static class AJunoGuidedBuildingSettings* GetJunoGuidedBuildingWorldSettings();
	static struct FJunoStageKey GetNextStage(const struct FJunoStageKey& StageKey);
	static struct FJunoStageKey GetPreviousStage(const struct FJunoStageKey& StageKey);
	static void HideAllStages();
	static void IsolateStage(const struct FJunoStageKey& InStageKey);
	static void MoveActorToNewStage(const class AActor* Actor, const struct FJunoStageKey& NewStage);
	static void MoveActorToNewStageByName(const class FName& ActorName, const struct FJunoStageKey& NewStage);
	static void SetActorToAutoComplete(const class AActor* Actor, bool bAutoComplete);
	static void SetStageHidden(const struct FJunoStageKey& StageKey, bool bHidden);
	static void ShowAllStages();
	static void ShowProgressUpTo(const struct FJunoStageKey& InStageKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGuidedBuildingBlueprintLibrary">();
	}
	static class UJunoGuidedBuildingBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGuidedBuildingBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoGuidedBuildingBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoGuidedBuildingBlueprintLibrary");
static_assert(sizeof(UJunoGuidedBuildingBlueprintLibrary) == 0x000028, "Wrong size on UJunoGuidedBuildingBlueprintLibrary");

// Class JunoGameNative.JunoGuidedBuildingInteractionComponent
// 0x0030 (0x00D0 - 0x00A0)
class UJunoGuidedBuildingInteractionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJunoGuidedBuildingActor> ParentBuilding;                                    // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   InteractionText;                                   // 0x00B0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         InteractRatingAdjustment;                          // 0x00C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetInteractionText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGuidedBuildingInteractionComponent">();
	}
	static class UJunoGuidedBuildingInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGuidedBuildingInteractionComponent>();
	}
};
static_assert(alignof(UJunoGuidedBuildingInteractionComponent) == 0x000008, "Wrong alignment on UJunoGuidedBuildingInteractionComponent");
static_assert(sizeof(UJunoGuidedBuildingInteractionComponent) == 0x0000D0, "Wrong size on UJunoGuidedBuildingInteractionComponent");
static_assert(offsetof(UJunoGuidedBuildingInteractionComponent, ParentBuilding) == 0x0000A8, "Member 'UJunoGuidedBuildingInteractionComponent::ParentBuilding' has a wrong offset!");
static_assert(offsetof(UJunoGuidedBuildingInteractionComponent, InteractionText) == 0x0000B0, "Member 'UJunoGuidedBuildingInteractionComponent::InteractionText' has a wrong offset!");
static_assert(offsetof(UJunoGuidedBuildingInteractionComponent, InteractRatingAdjustment) == 0x0000C8, "Member 'UJunoGuidedBuildingInteractionComponent::InteractRatingAdjustment' has a wrong offset!");

// Class JunoGameNative.JunoGuidedBuildingLandscapeVisualModifierActor
// 0x0048 (0x02D8 - 0x0290)
class AJunoGuidedBuildingLandscapeVisualModifierActor final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoLandscapeVisualModifierComponent*  VisualModifier;                                    // 0x0298(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x4];                                      // 0x02A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SavedActorGuid;                                    // 0x02A4(0x0010)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x24];                                     // 0x02B4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOwningPartRef(class AActor* InOwningPart);
	void RemoveOwningPartRef(class AActor* InOwningPart);
	void SetupVisualModifier(EJunoLandscapeVisualModifierType InModifierType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGuidedBuildingLandscapeVisualModifierActor">();
	}
	static class AJunoGuidedBuildingLandscapeVisualModifierActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoGuidedBuildingLandscapeVisualModifierActor>();
	}
};
static_assert(alignof(AJunoGuidedBuildingLandscapeVisualModifierActor) == 0x000008, "Wrong alignment on AJunoGuidedBuildingLandscapeVisualModifierActor");
static_assert(sizeof(AJunoGuidedBuildingLandscapeVisualModifierActor) == 0x0002D8, "Wrong size on AJunoGuidedBuildingLandscapeVisualModifierActor");
static_assert(offsetof(AJunoGuidedBuildingLandscapeVisualModifierActor, VisualModifier) == 0x000298, "Member 'AJunoGuidedBuildingLandscapeVisualModifierActor::VisualModifier' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingLandscapeVisualModifierActor, SavedActorGuid) == 0x0002A4, "Member 'AJunoGuidedBuildingLandscapeVisualModifierActor::SavedActorGuid' has a wrong offset!");

// Class JunoGameNative.JunoGuidedBuildingSettings
// 0x0210 (0x04A0 - 0x0290)
class AJunoGuidedBuildingSettings final : public AActor
{
public:
	float                                         ZLevelSize;                                        // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   SortRankTags;                                      // 0x0298(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             BaseActorClasses;                                  // 0x02A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class IInterface>>         AllowedInterfaces;                                 // 0x02B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             ExcludedBaseActorClasses;                          // 0x02C8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FJunoGuidedBuildingSetEditorData       GeneratedData;                                     // 0x02D8(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         DefaultPluginsToActivate;                          // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PrimaryPlaylist;                                   // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UObject>, class FName> ClassToRecipeMap;                                  // 0x0370(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FName                                   CraftingFormulaRegistryType;                       // 0x03C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuidedBuildingCachedEditorData        CurrentState;                                      // 0x03C8(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FJunoBuildingEditorActorEntry>  ActorList;                                         // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class FName GetActorIdentifier(const class AActor* ActorPtr);
	static void StartGeneratingGuidedBuildingAssets();

	void AddStage(const struct FJunoStageKey& NewStage);
	void GenerateNewStageData();
	void MoveActorToNewStage(const class AActor* Actor, const struct FJunoStageKey& NewStage);
	void MoveActorToNewStageByName(const class FName& ActorName, const struct FJunoStageKey& NewStage);
	void SetActorToAutoComplete(const class AActor* Actor, bool bAutoComplete);

	const TArray<struct FJunoStageKey> GetAllStageKeys() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGuidedBuildingSettings">();
	}
	static class AJunoGuidedBuildingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoGuidedBuildingSettings>();
	}
};
static_assert(alignof(AJunoGuidedBuildingSettings) == 0x000008, "Wrong alignment on AJunoGuidedBuildingSettings");
static_assert(sizeof(AJunoGuidedBuildingSettings) == 0x0004A0, "Wrong size on AJunoGuidedBuildingSettings");
static_assert(offsetof(AJunoGuidedBuildingSettings, ZLevelSize) == 0x000290, "Member 'AJunoGuidedBuildingSettings::ZLevelSize' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, SortRankTags) == 0x000298, "Member 'AJunoGuidedBuildingSettings::SortRankTags' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, BaseActorClasses) == 0x0002A8, "Member 'AJunoGuidedBuildingSettings::BaseActorClasses' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, AllowedInterfaces) == 0x0002B8, "Member 'AJunoGuidedBuildingSettings::AllowedInterfaces' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, ExcludedBaseActorClasses) == 0x0002C8, "Member 'AJunoGuidedBuildingSettings::ExcludedBaseActorClasses' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, GeneratedData) == 0x0002D8, "Member 'AJunoGuidedBuildingSettings::GeneratedData' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, DefaultPluginsToActivate) == 0x000358, "Member 'AJunoGuidedBuildingSettings::DefaultPluginsToActivate' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, PrimaryPlaylist) == 0x000368, "Member 'AJunoGuidedBuildingSettings::PrimaryPlaylist' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, ClassToRecipeMap) == 0x000370, "Member 'AJunoGuidedBuildingSettings::ClassToRecipeMap' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, CraftingFormulaRegistryType) == 0x0003C0, "Member 'AJunoGuidedBuildingSettings::CraftingFormulaRegistryType' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, CurrentState) == 0x0003C8, "Member 'AJunoGuidedBuildingSettings::CurrentState' has a wrong offset!");
static_assert(offsetof(AJunoGuidedBuildingSettings, ActorList) == 0x000490, "Member 'AJunoGuidedBuildingSettings::ActorList' has a wrong offset!");

// Class JunoGameNative.PFWSubsystemExtension_JunoGameNative
// 0x0008 (0x0040 - 0x0038)
class UPFWSubsystemExtension_JunoGameNative final : public UPersistenceFrameworkSubsystemExtension
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PFWSubsystemExtension_JunoGameNative">();
	}
	static class UPFWSubsystemExtension_JunoGameNative* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPFWSubsystemExtension_JunoGameNative>();
	}
};
static_assert(alignof(UPFWSubsystemExtension_JunoGameNative) == 0x000008, "Wrong alignment on UPFWSubsystemExtension_JunoGameNative");
static_assert(sizeof(UPFWSubsystemExtension_JunoGameNative) == 0x000040, "Wrong size on UPFWSubsystemExtension_JunoGameNative");

// Class JunoGameNative.JunoISMPoolRenderer
// 0x01D8 (0x0200 - 0x0028)
class alignas(0x10) UJunoISMPoolRenderer final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGeometryCollectionISMPoolActor*        ISMPoolActor;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGeometryCollectionISMPoolComponent*    ISMPoolComponentOverride;                          // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x1A0];                                     // 0x0040(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAtomModelAssetUserData*>        AtomUserDatas;                                     // 0x01E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F0[0x10];                                     // 0x01F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoISMPoolRenderer">();
	}
	static class UJunoISMPoolRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoISMPoolRenderer>();
	}
};
static_assert(alignof(UJunoISMPoolRenderer) == 0x000010, "Wrong alignment on UJunoISMPoolRenderer");
static_assert(sizeof(UJunoISMPoolRenderer) == 0x000200, "Wrong size on UJunoISMPoolRenderer");
static_assert(offsetof(UJunoISMPoolRenderer, ISMPoolActor) == 0x000030, "Member 'UJunoISMPoolRenderer::ISMPoolActor' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRenderer, ISMPoolComponentOverride) == 0x000038, "Member 'UJunoISMPoolRenderer::ISMPoolComponentOverride' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRenderer, AtomUserDatas) == 0x0001E0, "Member 'UJunoISMPoolRenderer::AtomUserDatas' has a wrong offset!");

// Class JunoGameNative.JunoBuildingRenderComponent
// 0x0000 (0x0220 - 0x0220)
class UJunoBuildingRenderComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingRenderComponent">();
	}
	static class UJunoBuildingRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingRenderComponent>();
	}
};
static_assert(alignof(UJunoBuildingRenderComponent) == 0x000010, "Wrong alignment on UJunoBuildingRenderComponent");
static_assert(sizeof(UJunoBuildingRenderComponent) == 0x000220, "Wrong size on UJunoBuildingRenderComponent");

// Class JunoGameNative.JunoISMPoolRendererSettings
// 0x0048 (0x0078 - 0x0030)
class UJunoISMPoolRendererSettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MergedMeshMinLod;                                  // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MergedMeshLodScale;                                // 0x0038(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MergedMeshPropMinLod;                              // 0x003C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MergedMeshCullDistance;                            // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MergedMeshPropCullDistance;                        // 0x0044(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergedMeshAffectDistanceFieldLighting;            // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergedMeshOverrideCastFarShadows;                 // 0x0049(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommonPartsEnable;                                // 0x004A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CommonPartsTypeMask;                               // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommonPartsEnableShadows;                         // 0x0050(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CommonPartsCullDistanceStart;                      // 0x0054(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommonPartsCullDistanceEnd;                        // 0x0058(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommonPartsCullDistanceBoost;                      // 0x005C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommonPartsCellSize;                               // 0x0060(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstancesEnable;                                  // 0x0064(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstancesMinLod;                                   // 0x0068(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstancesLodScale;                                 // 0x006C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstancesCullDistance;                             // 0x0070(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstancesEnableShadows;                           // 0x0074(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstancesPreallocateComponents;                   // 0x0075(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstancesAllowRemove;                             // 0x0076(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77[0x1];                                       // 0x0077(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoISMPoolRendererSettings">();
	}
	static class UJunoISMPoolRendererSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoISMPoolRendererSettings>();
	}
};
static_assert(alignof(UJunoISMPoolRendererSettings) == 0x000008, "Wrong alignment on UJunoISMPoolRendererSettings");
static_assert(sizeof(UJunoISMPoolRendererSettings) == 0x000078, "Wrong size on UJunoISMPoolRendererSettings");
static_assert(offsetof(UJunoISMPoolRendererSettings, MergedMeshMinLod) == 0x000034, "Member 'UJunoISMPoolRendererSettings::MergedMeshMinLod' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, MergedMeshLodScale) == 0x000038, "Member 'UJunoISMPoolRendererSettings::MergedMeshLodScale' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, MergedMeshPropMinLod) == 0x00003C, "Member 'UJunoISMPoolRendererSettings::MergedMeshPropMinLod' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, MergedMeshCullDistance) == 0x000040, "Member 'UJunoISMPoolRendererSettings::MergedMeshCullDistance' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, MergedMeshPropCullDistance) == 0x000044, "Member 'UJunoISMPoolRendererSettings::MergedMeshPropCullDistance' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, bMergedMeshAffectDistanceFieldLighting) == 0x000048, "Member 'UJunoISMPoolRendererSettings::bMergedMeshAffectDistanceFieldLighting' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, bMergedMeshOverrideCastFarShadows) == 0x000049, "Member 'UJunoISMPoolRendererSettings::bMergedMeshOverrideCastFarShadows' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, bCommonPartsEnable) == 0x00004A, "Member 'UJunoISMPoolRendererSettings::bCommonPartsEnable' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, CommonPartsTypeMask) == 0x00004C, "Member 'UJunoISMPoolRendererSettings::CommonPartsTypeMask' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, bCommonPartsEnableShadows) == 0x000050, "Member 'UJunoISMPoolRendererSettings::bCommonPartsEnableShadows' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, CommonPartsCullDistanceStart) == 0x000054, "Member 'UJunoISMPoolRendererSettings::CommonPartsCullDistanceStart' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, CommonPartsCullDistanceEnd) == 0x000058, "Member 'UJunoISMPoolRendererSettings::CommonPartsCullDistanceEnd' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, CommonPartsCullDistanceBoost) == 0x00005C, "Member 'UJunoISMPoolRendererSettings::CommonPartsCullDistanceBoost' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, CommonPartsCellSize) == 0x000060, "Member 'UJunoISMPoolRendererSettings::CommonPartsCellSize' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, bInstancesEnable) == 0x000064, "Member 'UJunoISMPoolRendererSettings::bInstancesEnable' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, InstancesMinLod) == 0x000068, "Member 'UJunoISMPoolRendererSettings::InstancesMinLod' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, InstancesLodScale) == 0x00006C, "Member 'UJunoISMPoolRendererSettings::InstancesLodScale' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, InstancesCullDistance) == 0x000070, "Member 'UJunoISMPoolRendererSettings::InstancesCullDistance' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, bInstancesEnableShadows) == 0x000074, "Member 'UJunoISMPoolRendererSettings::bInstancesEnableShadows' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, bInstancesPreallocateComponents) == 0x000075, "Member 'UJunoISMPoolRendererSettings::bInstancesPreallocateComponents' has a wrong offset!");
static_assert(offsetof(UJunoISMPoolRendererSettings, bInstancesAllowRemove) == 0x000076, "Member 'UJunoISMPoolRendererSettings::bInstancesAllowRemove' has a wrong offset!");

// Class JunoGameNative.JunoCommonPartsDataMappings
// 0x0050 (0x0080 - 0x0030)
class UJunoCommonPartsDataMappings final : public UPrimaryDataAsset
{
public:
	TMap<TSoftObjectPtr<class UStaticMesh>, struct FJunoCommonPartsSettings> Mapping;                                           // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCommonPartsDataMappings">();
	}
	static class UJunoCommonPartsDataMappings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCommonPartsDataMappings>();
	}
};
static_assert(alignof(UJunoCommonPartsDataMappings) == 0x000008, "Wrong alignment on UJunoCommonPartsDataMappings");
static_assert(sizeof(UJunoCommonPartsDataMappings) == 0x000080, "Wrong size on UJunoCommonPartsDataMappings");
static_assert(offsetof(UJunoCommonPartsDataMappings, Mapping) == 0x000030, "Member 'UJunoCommonPartsDataMappings::Mapping' has a wrong offset!");

// Class JunoGameNative.JunoLWITriggerComponent
// 0x0018 (0x00C0 - 0x00A8)
class UJunoLWITriggerComponent final : public UFortPawnComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLWITriggerComponent">();
	}
	static class UJunoLWITriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLWITriggerComponent>();
	}
};
static_assert(alignof(UJunoLWITriggerComponent) == 0x000008, "Wrong alignment on UJunoLWITriggerComponent");
static_assert(sizeof(UJunoLWITriggerComponent) == 0x0000C0, "Wrong size on UJunoLWITriggerComponent");

// Class JunoGameNative.JunoLandscapeVisualModifierComponent
// 0x0030 (0x0250 - 0x0220)
class UJunoLandscapeVisualModifierComponent final : public USceneComponent
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   DirtPlane;                                         // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJunoLandscapeVisualModifierType              VisualModifierType;                                // 0x0240(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0xF];                                      // 0x0241(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LandscapeModifierData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLandscapeVisualModifierComponent">();
	}
	static class UJunoLandscapeVisualModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLandscapeVisualModifierComponent>();
	}
};
static_assert(alignof(UJunoLandscapeVisualModifierComponent) == 0x000010, "Wrong alignment on UJunoLandscapeVisualModifierComponent");
static_assert(sizeof(UJunoLandscapeVisualModifierComponent) == 0x000250, "Wrong size on UJunoLandscapeVisualModifierComponent");
static_assert(offsetof(UJunoLandscapeVisualModifierComponent, DirtPlane) == 0x000238, "Member 'UJunoLandscapeVisualModifierComponent::DirtPlane' has a wrong offset!");
static_assert(offsetof(UJunoLandscapeVisualModifierComponent, VisualModifierType) == 0x000240, "Member 'UJunoLandscapeVisualModifierComponent::VisualModifierType' has a wrong offset!");

// Class JunoGameNative.JunoPhysicsToySpawnerActor
// 0x0020 (0x0EB0 - 0x0E90)
class AJunoPhysicsToySpawnerActor final : public AJunoBuildingActor
{
public:
	uint8                                         bUseOffsetOrientation : 1;                         // 0x0E90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_E91[0x7];                                      // 0x0E91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJunoContactDirection>                 FloatingValidationDirections;                      // 0x0E98(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EA8[0x8];                                      // 0x0EA8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsToySpawnerActor">();
	}
	static class AJunoPhysicsToySpawnerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPhysicsToySpawnerActor>();
	}
};
static_assert(alignof(AJunoPhysicsToySpawnerActor) == 0x000010, "Wrong alignment on AJunoPhysicsToySpawnerActor");
static_assert(sizeof(AJunoPhysicsToySpawnerActor) == 0x000EB0, "Wrong size on AJunoPhysicsToySpawnerActor");
static_assert(offsetof(AJunoPhysicsToySpawnerActor, FloatingValidationDirections) == 0x000E98, "Member 'AJunoPhysicsToySpawnerActor::FloatingValidationDirections' has a wrong offset!");

// Class JunoGameNative.JunoPickupComponent
// 0x0018 (0x00B8 - 0x00A0)
class UJunoPickupComponent final : public UGameFrameworkComponent
{
public:
	struct FDataTableRowHandle                    CraftingSourceTable;                               // 0x00A0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UDataTable*                             ResourceDataTable;                                 // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PickupBuildingctor(class AFortPlayerController* FPC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPickupComponent">();
	}
	static class UJunoPickupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPickupComponent>();
	}
};
static_assert(alignof(UJunoPickupComponent) == 0x000008, "Wrong alignment on UJunoPickupComponent");
static_assert(sizeof(UJunoPickupComponent) == 0x0000B8, "Wrong size on UJunoPickupComponent");
static_assert(offsetof(UJunoPickupComponent, CraftingSourceTable) == 0x0000A0, "Member 'UJunoPickupComponent::CraftingSourceTable' has a wrong offset!");
static_assert(offsetof(UJunoPickupComponent, ResourceDataTable) == 0x0000B0, "Member 'UJunoPickupComponent::ResourceDataTable' has a wrong offset!");

// Class JunoGameNative.JunoResourceComponent
// 0x0018 (0x00B8 - 0x00A0)
class UJunoResourceComponent final : public UGameFrameworkComponent
{
public:
	class UDataTable*                             BuildingTagDataTable;                              // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ResourceDataTable;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBuildingDamaged(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoResourceComponent">();
	}
	static class UJunoResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoResourceComponent>();
	}
};
static_assert(alignof(UJunoResourceComponent) == 0x000008, "Wrong alignment on UJunoResourceComponent");
static_assert(sizeof(UJunoResourceComponent) == 0x0000B8, "Wrong size on UJunoResourceComponent");
static_assert(offsetof(UJunoResourceComponent, BuildingTagDataTable) == 0x0000A0, "Member 'UJunoResourceComponent::BuildingTagDataTable' has a wrong offset!");
static_assert(offsetof(UJunoResourceComponent, ResourceDataTable) == 0x0000A8, "Member 'UJunoResourceComponent::ResourceDataTable' has a wrong offset!");

// Class JunoGameNative.JunoStorageChest
// 0x0230 (0x0E40 - 0x0C10)
class AJunoStorageChest final : public AJunoBuildingProp
{
public:
	uint8                                         Pad_C10[0x18];                                     // 0x0C10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGeometryCollectionComponent*           GeometryCollectionComponent;                       // 0x0C28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJunoInventoryComponent*                ChestInventoryComponent;                           // 0x0C30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJunoCampMembershipActorComponent*      CampMembershipComponent;                           // 0x0C38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTakeAllItemsOnInteract;                           // 0x0C40(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyOnInteract;                                // 0x0C41(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C42[0x6];                                      // 0x0C42(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GridSizeOverride;                                  // 0x0C48(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             BuildingPivotOffset;                               // 0x0C60(0x0060)(Edit, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BuildingGridSnapOffset;                            // 0x0CC0(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoBuildingBehaviorGridLimits        GridOffsetLimits;                                  // 0x0CD8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJunoBuilderToolInteractionActorClassSet OverlappableClasses;                               // 0x0CE8(0x00A0)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, TSubclassOf<class UJunoBuildingPreviewComponent>> PreviewComponentTemplates;                         // 0x0D88(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FUniqueNetIdRepl                       OwnerPlayerId;                                     // 0x0DD8(0x0030)(Net, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BaseLootTierGroup;                                 // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultInteractTime;                               // 0x0E0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerPlacedInteractTime;                          // 0x0E10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchedInteractTime;                              // 0x0E14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePlayerPlacedInteractionTime;                   // 0x0E18(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E19[0x7];                                      // 0x0E19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SearchedMesh;                                      // 0x0E20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LootTossSpeed;                                     // 0x0E28(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LootTossAngle;                                     // 0x0E2C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChestSearched;                                    // 0x0E30(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChestLooted;                                      // 0x0E31(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E32[0x2];                                      // 0x0E32(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  LastInteractor;                                    // 0x0E34(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E3C[0x4];                                      // 0x0E3C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BlueprintAllowSpawnLoot(const struct FInteractionType& InteractType);
	bool BlueprintCanShowInventoryUI(const struct FInteractionType& InteractType);
	class FName BlueprintGetLootTierGroup(const struct FJunoBiomeInfoQueryResult& BiomeInfo);
	void BlueprintOnChestLooted();
	void OnInventoryAcquired();
	void OnPersistentPlayspaceDataLoadEnd(class AJunoPersistentPlayspace* PersistentPlayspace, const bool bSuccess);
	void OnRep_ChestLooted();
	void OnRep_ChestSearched();
	void UpdateVisibilityOfLightBeamDeathChest(bool IsVisible);

	bool CanInteractWithChest(const class AFortPawn* FortPawn) const;
	struct FUniqueNetIdRepl GetOwningPlayerID() const;
	bool IsChestAlreadySearched() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoStorageChest">();
	}
	static class AJunoStorageChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoStorageChest>();
	}
};
static_assert(alignof(AJunoStorageChest) == 0x000010, "Wrong alignment on AJunoStorageChest");
static_assert(sizeof(AJunoStorageChest) == 0x000E40, "Wrong size on AJunoStorageChest");
static_assert(offsetof(AJunoStorageChest, GeometryCollectionComponent) == 0x000C28, "Member 'AJunoStorageChest::GeometryCollectionComponent' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, ChestInventoryComponent) == 0x000C30, "Member 'AJunoStorageChest::ChestInventoryComponent' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, CampMembershipComponent) == 0x000C38, "Member 'AJunoStorageChest::CampMembershipComponent' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, bTakeAllItemsOnInteract) == 0x000C40, "Member 'AJunoStorageChest::bTakeAllItemsOnInteract' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, bDestroyOnInteract) == 0x000C41, "Member 'AJunoStorageChest::bDestroyOnInteract' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, GridSizeOverride) == 0x000C48, "Member 'AJunoStorageChest::GridSizeOverride' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, BuildingPivotOffset) == 0x000C60, "Member 'AJunoStorageChest::BuildingPivotOffset' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, BuildingGridSnapOffset) == 0x000CC0, "Member 'AJunoStorageChest::BuildingGridSnapOffset' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, GridOffsetLimits) == 0x000CD8, "Member 'AJunoStorageChest::GridOffsetLimits' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, OverlappableClasses) == 0x000CE8, "Member 'AJunoStorageChest::OverlappableClasses' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, PreviewComponentTemplates) == 0x000D88, "Member 'AJunoStorageChest::PreviewComponentTemplates' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, OwnerPlayerId) == 0x000DD8, "Member 'AJunoStorageChest::OwnerPlayerId' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, BaseLootTierGroup) == 0x000E08, "Member 'AJunoStorageChest::BaseLootTierGroup' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, DefaultInteractTime) == 0x000E0C, "Member 'AJunoStorageChest::DefaultInteractTime' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, PlayerPlacedInteractTime) == 0x000E10, "Member 'AJunoStorageChest::PlayerPlacedInteractTime' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, SearchedInteractTime) == 0x000E14, "Member 'AJunoStorageChest::SearchedInteractTime' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, bUsePlayerPlacedInteractionTime) == 0x000E18, "Member 'AJunoStorageChest::bUsePlayerPlacedInteractionTime' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, SearchedMesh) == 0x000E20, "Member 'AJunoStorageChest::SearchedMesh' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, LootTossSpeed) == 0x000E28, "Member 'AJunoStorageChest::LootTossSpeed' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, LootTossAngle) == 0x000E2C, "Member 'AJunoStorageChest::LootTossAngle' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, bChestSearched) == 0x000E30, "Member 'AJunoStorageChest::bChestSearched' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, bChestLooted) == 0x000E31, "Member 'AJunoStorageChest::bChestLooted' has a wrong offset!");
static_assert(offsetof(AJunoStorageChest, LastInteractor) == 0x000E34, "Member 'AJunoStorageChest::LastInteractor' has a wrong offset!");

// Class JunoGameNative.JunoBuildingPreviewComponent
// 0x0010 (0x00B0 - 0x00A0)
class UJunoBuildingPreviewComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveCleared();
	void ReceiveCreated();
	void ReceiveDisabled();
	void ReceiveEnabled();
	void ReceivePlacementStarted();
	void ReceiveSet();

	const struct FJunoBuildingSelectionPreview GetOwningPreviewRef(bool* bSuccess) const;
	const class AJunoBuildingPreviewer* GetPreviewer() const;
	TSubclassOf<class AActor> GetSourceActorClass() const;
	bool IsSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingPreviewComponent">();
	}
	static class UJunoBuildingPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingPreviewComponent>();
	}
};
static_assert(alignof(UJunoBuildingPreviewComponent) == 0x000008, "Wrong alignment on UJunoBuildingPreviewComponent");
static_assert(sizeof(UJunoBuildingPreviewComponent) == 0x0000B0, "Wrong size on UJunoBuildingPreviewComponent");

// Class JunoGameNative.JunoBuildingPreviewer
// 0x0150 (0x03E0 - 0x0290)
class AJunoBuildingPreviewer final : public AActor
{
public:
	TWeakObjectPtr<class UJunoBuildingBehaviorBase> OwningBehavior;                                    // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnabled;                                          // 0x0298(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FJunoBuildingSelectionPreview> PreviewPool;                                       // 0x02A0(0x0050)(Edit, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          MostRecentlyUpdated;                               // 0x02F0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	struct FGuid                                  CurrentlySetPreviewGUID;                           // 0x0300(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasSetPreview;                                    // 0x0310(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0xF];                                      // 0x0311(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoBuildingPlacementPreview          PlacementPreview;                                  // 0x0320(0x00C0)(Edit, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void ClearPreview();
	bool CreatePreview(const TArray<struct FJunoBuilderToolSelectedActor>& SelectedActors, const struct FGuid& Guid, const struct FJunoBuildingPreviewParams& Params_0);
	void DestroyPlacementPreview();
	void DestroyPreview(const struct FGuid& Guid);
	void Disable();
	void Enable();
	void HidePlacementPreview();
	void InitializePlacementPreview();
	void NotifyPlacementStarted();
	void ReceiveClearSnapEntryPreviews(const TArray<struct FJunoBuildingSnapEntryPreview>& Previews);
	void ReceiveDestroyPlacementPreview(const struct FJunoBuildingPlacementPreview& Preview);
	void ReceiveDestroyPreview(const struct FJunoBuildingSelectionPreview& Preview);
	void ReceiveDisabled();
	void ReceiveEnabled();
	void ReceivePlacementPreviewHidden(const struct FJunoBuildingPlacementPreview& Preview);
	void ReceivePlacementPreviewInitialized(const struct FJunoBuildingPlacementPreview& Preview);
	void ReceivePlacementStarted();
	void ReceivePreviewCleared(const struct FJunoBuildingSelectionPreview& Preview);
	void ReceivePreviewCreated(const struct FJunoBuildingSelectionPreview& Preview);
	void ReceivePreviewSet(const struct FJunoBuildingSelectionPreview& Preview);
	void ReceiveUpdateSnapEntryPreviews(const TArray<struct FJunoBuildingSnapEntryPreview>& Previews);
	bool SetPreview(const struct FGuid& Guid);
	void SetPreviewVisibility(const bool bVisible);

	const struct FJunoBuildingSelectionPreview FindPreviewRef(const struct FGuid& Guid, bool* bSuccess) const;
	class UJunoBuildingBehaviorBase* GetOwningBuildingBehavior() const;
	const struct FJunoBuildingPlacementPreview GetPlacementPreview() const;
	const struct FJunoBuildingSelectionPreview GetPreviewRef(bool* bSuccess) const;
	bool HasSetPreview() const;
	bool IsPreviewerEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingPreviewer">();
	}
	static class AJunoBuildingPreviewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoBuildingPreviewer>();
	}
};
static_assert(alignof(AJunoBuildingPreviewer) == 0x000010, "Wrong alignment on AJunoBuildingPreviewer");
static_assert(sizeof(AJunoBuildingPreviewer) == 0x0003E0, "Wrong size on AJunoBuildingPreviewer");
static_assert(offsetof(AJunoBuildingPreviewer, OwningBehavior) == 0x000290, "Member 'AJunoBuildingPreviewer::OwningBehavior' has a wrong offset!");
static_assert(offsetof(AJunoBuildingPreviewer, bEnabled) == 0x000298, "Member 'AJunoBuildingPreviewer::bEnabled' has a wrong offset!");
static_assert(offsetof(AJunoBuildingPreviewer, PreviewPool) == 0x0002A0, "Member 'AJunoBuildingPreviewer::PreviewPool' has a wrong offset!");
static_assert(offsetof(AJunoBuildingPreviewer, MostRecentlyUpdated) == 0x0002F0, "Member 'AJunoBuildingPreviewer::MostRecentlyUpdated' has a wrong offset!");
static_assert(offsetof(AJunoBuildingPreviewer, CurrentlySetPreviewGUID) == 0x000300, "Member 'AJunoBuildingPreviewer::CurrentlySetPreviewGUID' has a wrong offset!");
static_assert(offsetof(AJunoBuildingPreviewer, bHasSetPreview) == 0x000310, "Member 'AJunoBuildingPreviewer::bHasSetPreview' has a wrong offset!");
static_assert(offsetof(AJunoBuildingPreviewer, PlacementPreview) == 0x000320, "Member 'AJunoBuildingPreviewer::PlacementPreview' has a wrong offset!");

// Class JunoGameNative.JunoBuildingPreviewerSubsystem
// 0x0010 (0x0050 - 0x0040)
class UJunoBuildingPreviewerSubsystem final : public UTickableWorldSubsystem
{
public:
	TArray<struct FJunoBuildingPreviewerWorkingDataAsync> AsyncPreviewsStack;                                // 0x0040(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingPreviewerSubsystem">();
	}
	static class UJunoBuildingPreviewerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingPreviewerSubsystem>();
	}
};
static_assert(alignof(UJunoBuildingPreviewerSubsystem) == 0x000008, "Wrong alignment on UJunoBuildingPreviewerSubsystem");
static_assert(sizeof(UJunoBuildingPreviewerSubsystem) == 0x000050, "Wrong size on UJunoBuildingPreviewerSubsystem");
static_assert(offsetof(UJunoBuildingPreviewerSubsystem, AsyncPreviewsStack) == 0x000040, "Member 'UJunoBuildingPreviewerSubsystem::AsyncPreviewsStack' has a wrong offset!");

// Class JunoGameNative.JunoBuildingPreviewInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoBuildingPreviewInterface final : public IInterface
{
public:
	TMap<class FName, TSubclassOf<class UJunoBuildingPreviewComponent>> GetPreviewComponentTemplates() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingPreviewInterface">();
	}
	static class IJunoBuildingPreviewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoBuildingPreviewInterface>();
	}
};
static_assert(alignof(IJunoBuildingPreviewInterface) == 0x000008, "Wrong alignment on IJunoBuildingPreviewInterface");
static_assert(sizeof(IJunoBuildingPreviewInterface) == 0x000028, "Wrong size on IJunoBuildingPreviewInterface");

// Class JunoGameNative.JunoGameStateComponent_Loot
// 0x0030 (0x00D0 - 0x00A0)
class UJunoGameStateComponent_Loot final : public UFortGameStateComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDataTable*>                     LootTierTables;                                    // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     LootPackageTables;                                 // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnPlaylistDataReady(class AFortGameStateAthena* GameState, const class UFortPlaylist* Playlist, const struct FGameplayTagContainer& PlaylistContextTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameStateComponent_Loot">();
	}
	static class UJunoGameStateComponent_Loot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameStateComponent_Loot>();
	}
};
static_assert(alignof(UJunoGameStateComponent_Loot) == 0x000008, "Wrong alignment on UJunoGameStateComponent_Loot");
static_assert(sizeof(UJunoGameStateComponent_Loot) == 0x0000D0, "Wrong size on UJunoGameStateComponent_Loot");
static_assert(offsetof(UJunoGameStateComponent_Loot, LootTierTables) == 0x0000B0, "Member 'UJunoGameStateComponent_Loot::LootTierTables' has a wrong offset!");
static_assert(offsetof(UJunoGameStateComponent_Loot, LootPackageTables) == 0x0000C0, "Member 'UJunoGameStateComponent_Loot::LootPackageTables' has a wrong offset!");

// Class JunoGameNative.JunoBuildInstructionsItemDefinition
// 0x0070 (0x08C0 - 0x0850)
class UJunoBuildInstructionsItemDefinition final : public UFortWorldItemDefinition
{
public:
	uint8                                         bGiveResourcesOnDestroy : 1;                       // 0x0848(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_849[0x3];                                      // 0x0849(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SelfCraftingFormulaName;                           // 0x084C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           PrerequisiteCraftingFormulaNames;                  // 0x0850(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ActorClassToBuild;                                 // 0x0860(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortPlaysetPropItemDefinition*         PlaysetPropToBuild;                                // 0x0880(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   SizeDescription;                                   // 0x0888(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   SetDescription;                                    // 0x08A0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B8[0x8];                                      // 0x08B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TSoftClassPtr<class UClass> GetActorClassToBuild() const;
	const TArray<class FName> GetPrerequisiteCraftingFormulaNames() const;
	const class FName GetSelfCraftingFormulaName() const;
	const class FText GetSetDescription() const;
	const class FText GetSizeDescription() const;
	bool ShouldGiveResourcesOnDestroy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildInstructionsItemDefinition">();
	}
	static class UJunoBuildInstructionsItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildInstructionsItemDefinition>();
	}
};
static_assert(alignof(UJunoBuildInstructionsItemDefinition) == 0x000010, "Wrong alignment on UJunoBuildInstructionsItemDefinition");
static_assert(sizeof(UJunoBuildInstructionsItemDefinition) == 0x0008C0, "Wrong size on UJunoBuildInstructionsItemDefinition");
static_assert(offsetof(UJunoBuildInstructionsItemDefinition, SelfCraftingFormulaName) == 0x00084C, "Member 'UJunoBuildInstructionsItemDefinition::SelfCraftingFormulaName' has a wrong offset!");
static_assert(offsetof(UJunoBuildInstructionsItemDefinition, PrerequisiteCraftingFormulaNames) == 0x000850, "Member 'UJunoBuildInstructionsItemDefinition::PrerequisiteCraftingFormulaNames' has a wrong offset!");
static_assert(offsetof(UJunoBuildInstructionsItemDefinition, ActorClassToBuild) == 0x000860, "Member 'UJunoBuildInstructionsItemDefinition::ActorClassToBuild' has a wrong offset!");
static_assert(offsetof(UJunoBuildInstructionsItemDefinition, PlaysetPropToBuild) == 0x000880, "Member 'UJunoBuildInstructionsItemDefinition::PlaysetPropToBuild' has a wrong offset!");
static_assert(offsetof(UJunoBuildInstructionsItemDefinition, SizeDescription) == 0x000888, "Member 'UJunoBuildInstructionsItemDefinition::SizeDescription' has a wrong offset!");
static_assert(offsetof(UJunoBuildInstructionsItemDefinition, SetDescription) == 0x0008A0, "Member 'UJunoBuildInstructionsItemDefinition::SetDescription' has a wrong offset!");

// Class JunoGameNative.JunoControllerComponent_CraftingNetworkEvents
// 0x0018 (0x00C0 - 0x00A8)
class UJunoControllerComponent_CraftingNetworkEvents final : public UFortControllerComponent
{
public:
	TArray<struct FActorUpgradeInfo>              ActorsToUpgrade;                                   // 0x00A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  LastUpgradedActor;                                 // 0x00B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCraftingChangedState(const struct FCraftingObjectStateChangedEvent& Event);
	void OnCraftingSuccess(const struct FCraftingObjectSuccessEvent& Event);
	void OnRep_LastUpgradedActor();
	void ServerAttemptCraftingUpgrage(class AActor* ActorToUpgrade, class FName RecipeName);
	void ServerDisableAutoPassiveCrafting(class AActor* PassiveCraftingObject);
	void ServerEnableAutoPassiveCrafting(class AActor* PassiveCraftingObject);
	void ServerHandleCraftingBGAContributor(class AActor* CraftingObject);
	void ServerSetAutoPassiveCraftingFormula(class AActor* PassiveCraftingObject, class FName FormulaName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoControllerComponent_CraftingNetworkEvents">();
	}
	static class UJunoControllerComponent_CraftingNetworkEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoControllerComponent_CraftingNetworkEvents>();
	}
};
static_assert(alignof(UJunoControllerComponent_CraftingNetworkEvents) == 0x000008, "Wrong alignment on UJunoControllerComponent_CraftingNetworkEvents");
static_assert(sizeof(UJunoControllerComponent_CraftingNetworkEvents) == 0x0000C0, "Wrong size on UJunoControllerComponent_CraftingNetworkEvents");
static_assert(offsetof(UJunoControllerComponent_CraftingNetworkEvents, ActorsToUpgrade) == 0x0000A8, "Member 'UJunoControllerComponent_CraftingNetworkEvents::ActorsToUpgrade' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent_CraftingNetworkEvents, LastUpgradedActor) == 0x0000B8, "Member 'UJunoControllerComponent_CraftingNetworkEvents::LastUpgradedActor' has a wrong offset!");

// Class JunoGameNative.JunoCraftingObjectBGA
// 0x01D8 (0x0BC0 - 0x09E8)
class AJunoCraftingObjectBGA final : public ACraftingObjectBGA
{
public:
	uint8                                         Pad_9E8[0x30];                                     // 0x09E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GridSizeOverride;                                  // 0x0A18(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             BuildingPivotOffset;                               // 0x0A30(0x0060)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BuildingGridSnapOffset;                            // 0x0A90(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJunoBuildingBehaviorGridLimits        GridOffsetLimits;                                  // 0x0AA8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoBuilderToolInteractionActorClassSet OverlappableClasses;                               // 0x0AB8(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	class UItemDefinitionBase*                    AssociatedItem;                                    // 0x0B58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, TSubclassOf<class UJunoBuildingPreviewComponent>> PreviewComponentTemplates;                         // 0x0B60(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   UpgradeRecipe;                                     // 0x0BB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldPersist;                                    // 0x0BB4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BB5[0xB];                                      // 0x0BB5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCraftingSuccess(const struct FCraftingObjectSuccessEvent& Event);

	const class UItemDefinitionBase* GetAssociatedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCraftingObjectBGA">();
	}
	static class AJunoCraftingObjectBGA* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoCraftingObjectBGA>();
	}
};
static_assert(alignof(AJunoCraftingObjectBGA) == 0x000010, "Wrong alignment on AJunoCraftingObjectBGA");
static_assert(sizeof(AJunoCraftingObjectBGA) == 0x000BC0, "Wrong size on AJunoCraftingObjectBGA");
static_assert(offsetof(AJunoCraftingObjectBGA, GridSizeOverride) == 0x000A18, "Member 'AJunoCraftingObjectBGA::GridSizeOverride' has a wrong offset!");
static_assert(offsetof(AJunoCraftingObjectBGA, BuildingPivotOffset) == 0x000A30, "Member 'AJunoCraftingObjectBGA::BuildingPivotOffset' has a wrong offset!");
static_assert(offsetof(AJunoCraftingObjectBGA, BuildingGridSnapOffset) == 0x000A90, "Member 'AJunoCraftingObjectBGA::BuildingGridSnapOffset' has a wrong offset!");
static_assert(offsetof(AJunoCraftingObjectBGA, GridOffsetLimits) == 0x000AA8, "Member 'AJunoCraftingObjectBGA::GridOffsetLimits' has a wrong offset!");
static_assert(offsetof(AJunoCraftingObjectBGA, OverlappableClasses) == 0x000AB8, "Member 'AJunoCraftingObjectBGA::OverlappableClasses' has a wrong offset!");
static_assert(offsetof(AJunoCraftingObjectBGA, AssociatedItem) == 0x000B58, "Member 'AJunoCraftingObjectBGA::AssociatedItem' has a wrong offset!");
static_assert(offsetof(AJunoCraftingObjectBGA, PreviewComponentTemplates) == 0x000B60, "Member 'AJunoCraftingObjectBGA::PreviewComponentTemplates' has a wrong offset!");
static_assert(offsetof(AJunoCraftingObjectBGA, UpgradeRecipe) == 0x000BB0, "Member 'AJunoCraftingObjectBGA::UpgradeRecipe' has a wrong offset!");
static_assert(offsetof(AJunoCraftingObjectBGA, bShouldPersist) == 0x000BB4, "Member 'AJunoCraftingObjectBGA::bShouldPersist' has a wrong offset!");

// Class JunoGameNative.JunoGameStateComponent_Crafting
// 0x0060 (0x02B0 - 0x0250)
class UJunoGameStateComponent_Crafting final : public UFortGameStateComponent_Crafting
{
public:
	uint8                                         Pad_250[0x60];                                     // 0x0250(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLootTablesLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameStateComponent_Crafting">();
	}
	static class UJunoGameStateComponent_Crafting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameStateComponent_Crafting>();
	}
};
static_assert(alignof(UJunoGameStateComponent_Crafting) == 0x000008, "Wrong alignment on UJunoGameStateComponent_Crafting");
static_assert(sizeof(UJunoGameStateComponent_Crafting) == 0x0002B0, "Wrong size on UJunoGameStateComponent_Crafting");

// Class JunoGameNative.JunoRecipeBundleItemDefinition
// 0x0010 (0x0860 - 0x0850)
class UJunoRecipeBundleItemDefinition final : public UFortWorldItemDefinition
{
public:
	TArray<struct FDataTableRowHandle>            CraftingFormulas;                                  // 0x0848(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRecipeBundleItemDefinition">();
	}
	static class UJunoRecipeBundleItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRecipeBundleItemDefinition>();
	}
};
static_assert(alignof(UJunoRecipeBundleItemDefinition) == 0x000010, "Wrong alignment on UJunoRecipeBundleItemDefinition");
static_assert(sizeof(UJunoRecipeBundleItemDefinition) == 0x000860, "Wrong size on UJunoRecipeBundleItemDefinition");
static_assert(offsetof(UJunoRecipeBundleItemDefinition, CraftingFormulas) == 0x000848, "Member 'UJunoRecipeBundleItemDefinition::CraftingFormulas' has a wrong offset!");

// Class JunoGameNative.JunoConnectivityDataComponent
// 0x0000 (0x00A0 - 0x00A0)
class UJunoConnectivityDataComponent : public UGameFrameworkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivityDataComponent">();
	}
	static class UJunoConnectivityDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoConnectivityDataComponent>();
	}
};
static_assert(alignof(UJunoConnectivityDataComponent) == 0x000008, "Wrong alignment on UJunoConnectivityDataComponent");
static_assert(sizeof(UJunoConnectivityDataComponent) == 0x0000A0, "Wrong size on UJunoConnectivityDataComponent");

// Class JunoGameNative.JunoConnectivitySupportDataComponent
// 0x0000 (0x00A0 - 0x00A0)
class UJunoConnectivitySupportDataComponent final : public UJunoConnectivityDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivitySupportDataComponent">();
	}
	static class UJunoConnectivitySupportDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoConnectivitySupportDataComponent>();
	}
};
static_assert(alignof(UJunoConnectivitySupportDataComponent) == 0x000008, "Wrong alignment on UJunoConnectivitySupportDataComponent");
static_assert(sizeof(UJunoConnectivitySupportDataComponent) == 0x0000A0, "Wrong size on UJunoConnectivitySupportDataComponent");

// Class JunoGameNative.JunoPhysicsToy
// 0x0000 (0x0028 - 0x0028)
class IJunoPhysicsToy final : public IInterface
{
public:
	void DestroyToy();
	void DisablePhysics();
	void EnablePhysics();
	void OnToyStartTrigger(bool bIsControlled);
	void OnToyStopTrigger();
	void StartAttachmentToActor(class AActor* Actor);
	void StopAttachment();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsToy">();
	}
	static class IJunoPhysicsToy* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoPhysicsToy>();
	}
};
static_assert(alignof(IJunoPhysicsToy) == 0x000008, "Wrong alignment on IJunoPhysicsToy");
static_assert(sizeof(IJunoPhysicsToy) == 0x000028, "Wrong size on IJunoPhysicsToy");

// Class JunoGameNative.JunoBasePlayspaceMigrationComponent
// 0x0000 (0x00A0 - 0x00A0)
class UJunoBasePlayspaceMigrationComponent : public UGameFrameworkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBasePlayspaceMigrationComponent">();
	}
	static class UJunoBasePlayspaceMigrationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBasePlayspaceMigrationComponent>();
	}
};
static_assert(alignof(UJunoBasePlayspaceMigrationComponent) == 0x000008, "Wrong alignment on UJunoBasePlayspaceMigrationComponent");
static_assert(sizeof(UJunoBasePlayspaceMigrationComponent) == 0x0000A0, "Wrong size on UJunoBasePlayspaceMigrationComponent");

// Class JunoGameNative.JunoClientAtomicReplacementComponent
// 0x0020 (0x00C0 - 0x00A0)
class UJunoClientAtomicReplacementComponent final : public UGameFrameworkComponent
{
public:
	struct FGuid                                  Guid;                                              // 0x00A0(0x0010)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJunoPersistentPlayspace*               TargetPlayspace;                                   // 0x00B0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerGuidChanged(class AActor* Owner, const struct FGuid& InGuid);
	void OnRep_Guid(const struct FGuid& OldGuid);
	void OnRep_PlayspsaceRenameRepData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClientAtomicReplacementComponent">();
	}
	static class UJunoClientAtomicReplacementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoClientAtomicReplacementComponent>();
	}
};
static_assert(alignof(UJunoClientAtomicReplacementComponent) == 0x000008, "Wrong alignment on UJunoClientAtomicReplacementComponent");
static_assert(sizeof(UJunoClientAtomicReplacementComponent) == 0x0000C0, "Wrong size on UJunoClientAtomicReplacementComponent");
static_assert(offsetof(UJunoClientAtomicReplacementComponent, Guid) == 0x0000A0, "Member 'UJunoClientAtomicReplacementComponent::Guid' has a wrong offset!");
static_assert(offsetof(UJunoClientAtomicReplacementComponent, TargetPlayspace) == 0x0000B0, "Member 'UJunoClientAtomicReplacementComponent::TargetPlayspace' has a wrong offset!");

// Class JunoGameNative.JunoClientAtomicReplacementWorldSubsystem
// 0x0050 (0x0080 - 0x0030)
class UJunoClientAtomicReplacementWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClientAtomicReplacementWorldSubsystem">();
	}
	static class UJunoClientAtomicReplacementWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoClientAtomicReplacementWorldSubsystem>();
	}
};
static_assert(alignof(UJunoClientAtomicReplacementWorldSubsystem) == 0x000008, "Wrong alignment on UJunoClientAtomicReplacementWorldSubsystem");
static_assert(sizeof(UJunoClientAtomicReplacementWorldSubsystem) == 0x000080, "Wrong size on UJunoClientAtomicReplacementWorldSubsystem");

// Class JunoGameNative.JunoClusterUnionActor
// 0x0070 (0x03A0 - 0x0330)
class AJunoClusterUnionActor final : public AFortClusterUnionActor
{
public:
	uint8                                         Pad_330[0x70];                                     // 0x0330(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentAddedToClusterUnion(class UPrimitiveComponent* Component, const TArray<struct FClusterUnionBoneData>& BonesData, const TArray<struct FClusterUnionBoneData>& RemovedBoneIDs, bool bIsNew);
	void OnComponentRemovedFromClusterUnion(class UPrimitiveComponent* Component, const TArray<struct FClusterUnionBoneData>& RemovedBonesData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClusterUnionActor">();
	}
	static class AJunoClusterUnionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoClusterUnionActor>();
	}
};
static_assert(alignof(AJunoClusterUnionActor) == 0x000008, "Wrong alignment on AJunoClusterUnionActor");
static_assert(sizeof(AJunoClusterUnionActor) == 0x0003A0, "Wrong size on AJunoClusterUnionActor");

// Class JunoGameNative.JunoConnectivityComponent
// 0x0100 (0x01A0 - 0x00A0)
class UJunoConnectivityComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UClusterUnionComponent* ClusterUnion, class UPrimitiveComponent* Component)> NotifyAddedIntoClusterUnion;                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UClusterUnionComponent* ClusterUnion, class UPrimitiveComponent* Component)> NotifyRemovedFromClusterUnion;                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ContactDistance;                                   // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInGraph;                                        // 0x00CC(0x0001)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FComponentReference>            GeometryCollectionsToIgnoreBreaksForConnectivity;  // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FComponentReference>            RootDoorComponentReferences;                       // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> DoorComponents;                                    // 0x00F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bAreDoorsEjected;                                  // 0x0100(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAreDoorsEjectedInternal;                          // 0x0101(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraphVertexHandle                     GraphHandle;                                       // 0x0104(0x001C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRootPlayspaceInitialized;                         // 0x0120(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDebris;                                         // 0x0121(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasBeenSaved;                                     // 0x0122(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJunoAutomaticConnectionMethod                AutomaticConnectionMethod;                         // 0x0123(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJunoContactDirection>                 CustomConnectionDirections;                        // 0x0128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bCanBeConnectedTo;                                 // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMustConnectToDynamic;                             // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceIndependentlySupported;                      // 0x013A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceWorldSupportWhenPotentialConnectionsAreNotFound; // 0x013B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAddToConnectivityGraphOnBeginPlay;                // 0x013C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeWorldSupported;                              // 0x013D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             ClassesThatAreAlwaysValidForWorldSupport;          // 0x0140(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FVector                                OverlapMargin;                                     // 0x0150(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinimumIslandSize;                                 // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          AttachedToys;                                      // 0x0170(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x20];                                     // 0x0180(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ShouldUsePartialDestruction();

	void GetAutomaticallyConnectedComponents(TArray<class UJunoConnectivityComponent*>* Results);
	void NotifyRemovedFromGraph();
	void OnAddedIntoClusterUnion(class UClusterUnionComponent* ClusterUnion, class UPrimitiveComponent* Component);
	void OnAttachedToyDetached(class AActor* ToyActor);
	void OnGeometryCollectionBreak(const struct FChaosBreakEvent& BreakEvent);
	void OnGeometryCollectionDecayed();
	void OnParentActorDeath(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnParentClusterUnionAwake(class UPrimitiveComponent* WakingComponent, class FName BoneName);
	void OnRemovedFromClusterUnion(class UClusterUnionComponent* ClusterUnion, class UPrimitiveComponent* Component);
	void OnRemovedFromGraph();
	void OnRep_AreDoorsEjected();
	void OnRep_IsDebris();
	void OnToyAttached(class AActor* ToyActor);
	void OnVertexRemovedFromGraph();
	void OverrideMinimumIslandSize(int32 NewSize);

	class AActor* GetBaseAttachParentActor() const;
	float GetContactDistance() const;
	class UClusterUnionComponent* GetCurrentClusterUnion() const;
	TArray<class UPrimitiveComponent*> GetRelevantSimulatingComponents() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivityComponent">();
	}
	static class UJunoConnectivityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoConnectivityComponent>();
	}
};
static_assert(alignof(UJunoConnectivityComponent) == 0x000008, "Wrong alignment on UJunoConnectivityComponent");
static_assert(sizeof(UJunoConnectivityComponent) == 0x0001A0, "Wrong size on UJunoConnectivityComponent");
static_assert(offsetof(UJunoConnectivityComponent, NotifyAddedIntoClusterUnion) == 0x0000A8, "Member 'UJunoConnectivityComponent::NotifyAddedIntoClusterUnion' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, NotifyRemovedFromClusterUnion) == 0x0000B8, "Member 'UJunoConnectivityComponent::NotifyRemovedFromClusterUnion' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, ContactDistance) == 0x0000C8, "Member 'UJunoConnectivityComponent::ContactDistance' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bIsInGraph) == 0x0000CC, "Member 'UJunoConnectivityComponent::bIsInGraph' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, GeometryCollectionsToIgnoreBreaksForConnectivity) == 0x0000D0, "Member 'UJunoConnectivityComponent::GeometryCollectionsToIgnoreBreaksForConnectivity' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, RootDoorComponentReferences) == 0x0000E0, "Member 'UJunoConnectivityComponent::RootDoorComponentReferences' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, DoorComponents) == 0x0000F0, "Member 'UJunoConnectivityComponent::DoorComponents' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bAreDoorsEjected) == 0x000100, "Member 'UJunoConnectivityComponent::bAreDoorsEjected' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bAreDoorsEjectedInternal) == 0x000101, "Member 'UJunoConnectivityComponent::bAreDoorsEjectedInternal' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, GraphHandle) == 0x000104, "Member 'UJunoConnectivityComponent::GraphHandle' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bRootPlayspaceInitialized) == 0x000120, "Member 'UJunoConnectivityComponent::bRootPlayspaceInitialized' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bIsDebris) == 0x000121, "Member 'UJunoConnectivityComponent::bIsDebris' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bHasBeenSaved) == 0x000122, "Member 'UJunoConnectivityComponent::bHasBeenSaved' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, AutomaticConnectionMethod) == 0x000123, "Member 'UJunoConnectivityComponent::AutomaticConnectionMethod' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, CustomConnectionDirections) == 0x000128, "Member 'UJunoConnectivityComponent::CustomConnectionDirections' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bCanBeConnectedTo) == 0x000138, "Member 'UJunoConnectivityComponent::bCanBeConnectedTo' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bMustConnectToDynamic) == 0x000139, "Member 'UJunoConnectivityComponent::bMustConnectToDynamic' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bForceIndependentlySupported) == 0x00013A, "Member 'UJunoConnectivityComponent::bForceIndependentlySupported' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bForceWorldSupportWhenPotentialConnectionsAreNotFound) == 0x00013B, "Member 'UJunoConnectivityComponent::bForceWorldSupportWhenPotentialConnectionsAreNotFound' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bAddToConnectivityGraphOnBeginPlay) == 0x00013C, "Member 'UJunoConnectivityComponent::bAddToConnectivityGraphOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, bCanBeWorldSupported) == 0x00013D, "Member 'UJunoConnectivityComponent::bCanBeWorldSupported' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, ClassesThatAreAlwaysValidForWorldSupport) == 0x000140, "Member 'UJunoConnectivityComponent::ClassesThatAreAlwaysValidForWorldSupport' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, OverlapMargin) == 0x000150, "Member 'UJunoConnectivityComponent::OverlapMargin' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, MinimumIslandSize) == 0x000168, "Member 'UJunoConnectivityComponent::MinimumIslandSize' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityComponent, AttachedToys) == 0x000170, "Member 'UJunoConnectivityComponent::AttachedToys' has a wrong offset!");

// Class JunoGameNative.JunoConnectivityGraphWorldSubsystem
// 0x01E8 (0x0228 - 0x0040)
class UJunoConnectivityGraphWorldSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x1E8];                                     // 0x0040(0x01E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivityGraphWorldSubsystem">();
	}
	static class UJunoConnectivityGraphWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoConnectivityGraphWorldSubsystem>();
	}
};
static_assert(alignof(UJunoConnectivityGraphWorldSubsystem) == 0x000008, "Wrong alignment on UJunoConnectivityGraphWorldSubsystem");
static_assert(sizeof(UJunoConnectivityGraphWorldSubsystem) == 0x000228, "Wrong size on UJunoConnectivityGraphWorldSubsystem");

// Class JunoGameNative.JunoConnectivityManagerComponent
// 0x0178 (0x0218 - 0x00A0)
class UJunoConnectivityManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReady;                                          // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsNewPlayspace;                                   // 0x00B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortConnectivityGraph*                 Graph;                                             // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsGraphDirty;                                     // 0x00C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGraphVertexHandle, class UJunoConnectivityComponent*> VertexToConnectivityComponents;                    // 0x00D0(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<struct FGraphIslandHandle, class AJunoClusterUnionActor*> IslandToClusterUnionActors;                        // 0x0120(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FJunoConnectivityDebugData             DebugDrawData;                                     // 0x0170(0x0038)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x70];                                     // 0x01A8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnGeometryCollectionBreaks(const TArray<struct FChaosBreakEvent>& BreakEvents);
	void OnGraphIslandConnectivityChanged(const struct FGraphIslandHandle& IslandHandle);
	void OnGraphIslandCreated(const struct FGraphIslandHandle& IslandHandle);
	void OnGraphIslandDestroyed(const struct FGraphIslandHandle& IslandHandle);
	void OnGraphVertexAddedToIsland(const struct FGraphIslandHandle& IslandHandle, const struct FGraphVertexHandle& VertexHandle);
	void OnGraphVertexRemovedFromIsland(const struct FGraphIslandHandle& IslandHandle, const struct FGraphVertexHandle& VertexHandle);
	void RequestAddActorsToConnectivityGraph(const TArray<class AActor*>& Actors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivityManagerComponent">();
	}
	static class UJunoConnectivityManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoConnectivityManagerComponent>();
	}
};
static_assert(alignof(UJunoConnectivityManagerComponent) == 0x000008, "Wrong alignment on UJunoConnectivityManagerComponent");
static_assert(sizeof(UJunoConnectivityManagerComponent) == 0x000218, "Wrong size on UJunoConnectivityManagerComponent");
static_assert(offsetof(UJunoConnectivityManagerComponent, bIsReady) == 0x0000B8, "Member 'UJunoConnectivityManagerComponent::bIsReady' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityManagerComponent, bIsNewPlayspace) == 0x0000B9, "Member 'UJunoConnectivityManagerComponent::bIsNewPlayspace' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityManagerComponent, Graph) == 0x0000C0, "Member 'UJunoConnectivityManagerComponent::Graph' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityManagerComponent, bIsGraphDirty) == 0x0000C8, "Member 'UJunoConnectivityManagerComponent::bIsGraphDirty' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityManagerComponent, VertexToConnectivityComponents) == 0x0000D0, "Member 'UJunoConnectivityManagerComponent::VertexToConnectivityComponents' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityManagerComponent, IslandToClusterUnionActors) == 0x000120, "Member 'UJunoConnectivityManagerComponent::IslandToClusterUnionActors' has a wrong offset!");
static_assert(offsetof(UJunoConnectivityManagerComponent, DebugDrawData) == 0x000170, "Member 'UJunoConnectivityManagerComponent::DebugDrawData' has a wrong offset!");

// Class JunoGameNative.JunoPhysicsToyActor
// 0x0000 (0x0B80 - 0x0B80)
class AJunoPhysicsToyActor final : public AJunoBuildingGameplayActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsToyActor">();
	}
	static class AJunoPhysicsToyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPhysicsToyActor>();
	}
};
static_assert(alignof(AJunoPhysicsToyActor) == 0x000010, "Wrong alignment on AJunoPhysicsToyActor");
static_assert(sizeof(AJunoPhysicsToyActor) == 0x000B80, "Wrong size on AJunoPhysicsToyActor");

// Class JunoGameNative.JunoPhysicsToyConnectivityComponent
// 0x0020 (0x00C0 - 0x00A0)
class UJunoPhysicsToyConnectivityComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayspaceInitialized;                             // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachToConnectivity(class AActor* Other);
	void DetachFromConnectivity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsToyConnectivityComponent">();
	}
	static class UJunoPhysicsToyConnectivityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPhysicsToyConnectivityComponent>();
	}
};
static_assert(alignof(UJunoPhysicsToyConnectivityComponent) == 0x000008, "Wrong alignment on UJunoPhysicsToyConnectivityComponent");
static_assert(sizeof(UJunoPhysicsToyConnectivityComponent) == 0x0000C0, "Wrong size on UJunoPhysicsToyConnectivityComponent");
static_assert(offsetof(UJunoPhysicsToyConnectivityComponent, bPlayspaceInitialized) == 0x0000B0, "Member 'UJunoPhysicsToyConnectivityComponent::bPlayspaceInitialized' has a wrong offset!");

// Class JunoGameNative.JunoConnectivityGraphPersistenceFeatureData
// 0x0118 (0x03E8 - 0x02D0)
class AJunoConnectivityGraphPersistenceFeatureData final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSerializableConnectivityGraph         SavedConnectivityData;                             // 0x02E0(0x0108)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivityGraphPersistenceFeatureData">();
	}
	static class AJunoConnectivityGraphPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoConnectivityGraphPersistenceFeatureData>();
	}
};
static_assert(alignof(AJunoConnectivityGraphPersistenceFeatureData) == 0x000008, "Wrong alignment on AJunoConnectivityGraphPersistenceFeatureData");
static_assert(sizeof(AJunoConnectivityGraphPersistenceFeatureData) == 0x0003E8, "Wrong size on AJunoConnectivityGraphPersistenceFeatureData");
static_assert(offsetof(AJunoConnectivityGraphPersistenceFeatureData, SavedConnectivityData) == 0x0002E0, "Member 'AJunoConnectivityGraphPersistenceFeatureData::SavedConnectivityData' has a wrong offset!");

// Class JunoGameNative.JunoPhysicsPersistenceComponent
// 0x0060 (0x0100 - 0x00A0)
class UJunoPhysicsPersistenceComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsPersistenceComponent">();
	}
	static class UJunoPhysicsPersistenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPhysicsPersistenceComponent>();
	}
};
static_assert(alignof(UJunoPhysicsPersistenceComponent) == 0x000008, "Wrong alignment on UJunoPhysicsPersistenceComponent");
static_assert(sizeof(UJunoPhysicsPersistenceComponent) == 0x000100, "Wrong size on UJunoPhysicsPersistenceComponent");

// Class JunoGameNative.JunoPhysicsPersistenceWorldSubsystem
// 0x0058 (0x0098 - 0x0040)
class UJunoPhysicsPersistenceWorldSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x58];                                      // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsPersistenceWorldSubsystem">();
	}
	static class UJunoPhysicsPersistenceWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPhysicsPersistenceWorldSubsystem>();
	}
};
static_assert(alignof(UJunoPhysicsPersistenceWorldSubsystem) == 0x000008, "Wrong alignment on UJunoPhysicsPersistenceWorldSubsystem");
static_assert(sizeof(UJunoPhysicsPersistenceWorldSubsystem) == 0x000098, "Wrong size on UJunoPhysicsPersistenceWorldSubsystem");

// Class JunoGameNative.JunoGlobalKnowledgeComponent
// 0x0168 (0x0208 - 0x00A0)
class UJunoGlobalKnowledgeComponent final : public UFortGameStateComponent
{
public:
	uint8                                         Pad_A0[0x78];                                      // 0x00A0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoKnowledgeSaveRecord               CurrentWorldKnowledge;                             // 0x0118(0x00E8)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGlobalKnowledgeComponent">();
	}
	static class UJunoGlobalKnowledgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGlobalKnowledgeComponent>();
	}
};
static_assert(alignof(UJunoGlobalKnowledgeComponent) == 0x000008, "Wrong alignment on UJunoGlobalKnowledgeComponent");
static_assert(sizeof(UJunoGlobalKnowledgeComponent) == 0x000208, "Wrong size on UJunoGlobalKnowledgeComponent");
static_assert(offsetof(UJunoGlobalKnowledgeComponent, CurrentWorldKnowledge) == 0x000118, "Member 'UJunoGlobalKnowledgeComponent::CurrentWorldKnowledge' has a wrong offset!");

// Class JunoGameNative.JunoKnowledgeComponent
// 0x05F8 (0x06A0 - 0x00A8)
class UJunoKnowledgeComponent final : public UFortControllerComponent
{
public:
	uint8                                         Pad_A8[0x78];                                      // 0x00A8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableKnowledgeComponent;                         // 0x0120(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableKnowledgePersistence;                       // 0x0121(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableKnowledgeFiltering;                         // 0x0122(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_123[0x1];                                      // 0x0123(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUnownedMCPRecipesKnowledgeBlockedWhenUnfiltered;  // 0x0124(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortItemDefinition*>            DefaultKnownItems;                                 // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DefaultCraftingObjects;                            // 0x0138(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           UnblockMCPRecipesWorldStateTag;                    // 0x0158(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  FoundCraftingObjects;                              // 0x0160(0x0020)(Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ClaimedKnowlegeBundles;                            // 0x0180(0x0020)(Net, Protected, NativeAccessSpecifierProtected)
	struct FJunoKnowledgeRecipeStateFastArray     RecipeStateArray;                                  // 0x01A0(0x0120)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FJunoKnowledgeItemStateFastArray       ItemStateStateArray;                               // 0x02C0(0x0120)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  McpProfileOwnershipTagsCached;                     // 0x03E0(0x0020)(Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0xA0];                                     // 0x0400(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMCPRecipesBlocked;                                // 0x04A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bComponentReady;                                   // 0x04A1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A2[0x6];                                      // 0x04A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UItemDefinitionBase*>              ItemQuickLookup;                                   // 0x04A8(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0xE8];                                     // 0x04F8(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEventListenerHandle           CraftingObjectPlacedHandle;                        // 0x05E0(0x001C)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0xA4];                                     // 0x05FC(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AcquireItemForPlayer(class AFortPlayerController* PC, const class UItemDefinitionBase* NewItemDef);
	static void AddCraftingObjectTagsToPlayer(class AFortPlayerController* PC, const struct FGameplayTagContainer& CraftingObjectTags);
	static struct FGuid GetGuidFromRecipeForPlayer(const class AFortPlayerController* PC, const class FName RecipeName);
	static EJunoKnowledgeState GetPlayerRecipeKnowledgeState(class AFortPlayerController* PC, class FName RowName);
	static class FName GetRecipeFromGuidForPlayer(const class AFortPlayerController* PC, const struct FGuid& InGuid);
	static void RevealRecipeCategoryForPlayer(class AFortPlayerController* PC, const struct FGameplayTag& CraftingObjectTag, const struct FGameplayTag& CategoryTag, const struct FGameplayTag& SubCategoryTag);
	static void SetPlayerRecipeKnowledgeState(class AFortPlayerController* PC, class FName RowName, EJunoKnowledgeState NewState);

	void AcquireItem(const class UItemDefinitionBase* NewItemDef);
	void AddCraftingObjectTags(const struct FGameplayTagContainer& CraftingObjectTags);
	void HandleWorldStateChanged();
	void OnCraftingObjectInteraction(const struct FCraftingMessage& CraftingMessage);
	void OnMcpInventoryChanged(const TSet<class FString>& ItemChangeFlags, int64 ProfileRevision);
	void RevealRecipeCategory(const struct FGameplayTag& CraftingObjectTag, const struct FGameplayTag& CategoryTag, const struct FGameplayTag& SubCategoryTag);
	void ServerViewItem(const class UFortItemDefinition* InItemDef);
	void ServerViewRecipe(const class FName InRecipeName);
	void SetRecipeKnowledgeState(class FName RowName, EJunoKnowledgeState NewState);
	bool UnblockMCPRecipes();
	void ViewItem(const class UFortItemDefinition* InItemDef);
	void ViewRecipe(const class FName InRecipeName);

	bool AreMCPRecipesBlocked() const;
	bool DoesRecipeRequireMCPOwnership(class FName RowName) const;
	struct FGuid GetGuidFromRecipe(const class FName RecipeName) const;
	class FName GetRecipeFromGuid(const struct FGuid& InGuid) const;
	EJunoKnowledgeState GetRecipeKnowledgeState(class FName RowName) const;
	bool HasClaimedKnowledgeBundle(const struct FGameplayTag& BundleIdentifier) const;
	bool HasViewedItem(const class UFortItemDefinition* InItemDef) const;
	bool HasViewedRecipe(const class FName InRecipeName) const;
	bool IsRecipeMissingMCPOwnership(class FName RowName) const;
	bool OwnsAnyMCPRecipe() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgeComponent">();
	}
	static class UJunoKnowledgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoKnowledgeComponent>();
	}
};
static_assert(alignof(UJunoKnowledgeComponent) == 0x000008, "Wrong alignment on UJunoKnowledgeComponent");
static_assert(sizeof(UJunoKnowledgeComponent) == 0x0006A0, "Wrong size on UJunoKnowledgeComponent");
static_assert(offsetof(UJunoKnowledgeComponent, bEnableKnowledgeComponent) == 0x000120, "Member 'UJunoKnowledgeComponent::bEnableKnowledgeComponent' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, bEnableKnowledgePersistence) == 0x000121, "Member 'UJunoKnowledgeComponent::bEnableKnowledgePersistence' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, bEnableKnowledgeFiltering) == 0x000122, "Member 'UJunoKnowledgeComponent::bEnableKnowledgeFiltering' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, bUnownedMCPRecipesKnowledgeBlockedWhenUnfiltered) == 0x000124, "Member 'UJunoKnowledgeComponent::bUnownedMCPRecipesKnowledgeBlockedWhenUnfiltered' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, DefaultKnownItems) == 0x000128, "Member 'UJunoKnowledgeComponent::DefaultKnownItems' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, DefaultCraftingObjects) == 0x000138, "Member 'UJunoKnowledgeComponent::DefaultCraftingObjects' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, UnblockMCPRecipesWorldStateTag) == 0x000158, "Member 'UJunoKnowledgeComponent::UnblockMCPRecipesWorldStateTag' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, FoundCraftingObjects) == 0x000160, "Member 'UJunoKnowledgeComponent::FoundCraftingObjects' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, ClaimedKnowlegeBundles) == 0x000180, "Member 'UJunoKnowledgeComponent::ClaimedKnowlegeBundles' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, RecipeStateArray) == 0x0001A0, "Member 'UJunoKnowledgeComponent::RecipeStateArray' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, ItemStateStateArray) == 0x0002C0, "Member 'UJunoKnowledgeComponent::ItemStateStateArray' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, McpProfileOwnershipTagsCached) == 0x0003E0, "Member 'UJunoKnowledgeComponent::McpProfileOwnershipTagsCached' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, bMCPRecipesBlocked) == 0x0004A0, "Member 'UJunoKnowledgeComponent::bMCPRecipesBlocked' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, bComponentReady) == 0x0004A1, "Member 'UJunoKnowledgeComponent::bComponentReady' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, ItemQuickLookup) == 0x0004A8, "Member 'UJunoKnowledgeComponent::ItemQuickLookup' has a wrong offset!");
static_assert(offsetof(UJunoKnowledgeComponent, CraftingObjectPlacedHandle) == 0x0005E0, "Member 'UJunoKnowledgeComponent::CraftingObjectPlacedHandle' has a wrong offset!");

// Class JunoGameNative.JunoKnowledgeDebugMenu
// 0x0400 (0x08C0 - 0x04C0)
class AJunoKnowledgeDebugMenu final : public AImGuiDebugMenuBase
{
public:
	uint8                                         Pad_4B8[0x408];                                    // 0x04B8(0x0408)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgeDebugMenu">();
	}
	static class AJunoKnowledgeDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoKnowledgeDebugMenu>();
	}
};
static_assert(alignof(AJunoKnowledgeDebugMenu) == 0x000010, "Wrong alignment on AJunoKnowledgeDebugMenu");
static_assert(sizeof(AJunoKnowledgeDebugMenu) == 0x0008C0, "Wrong size on AJunoKnowledgeDebugMenu");

// Class JunoGameNative.JunoKnowledgePersistenceFeatureData
// 0x00F0 (0x0130 - 0x0040)
class UJunoKnowledgePersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoKnowledgeSaveData                 KnowledgeSaveData;                                 // 0x0048(0x00E8)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgePersistenceFeatureData">();
	}
	static class UJunoKnowledgePersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoKnowledgePersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoKnowledgePersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoKnowledgePersistenceFeatureData");
static_assert(sizeof(UJunoKnowledgePersistenceFeatureData) == 0x000130, "Wrong size on UJunoKnowledgePersistenceFeatureData");
static_assert(offsetof(UJunoKnowledgePersistenceFeatureData, KnowledgeSaveData) == 0x000048, "Member 'UJunoKnowledgePersistenceFeatureData::KnowledgeSaveData' has a wrong offset!");

// Class JunoGameNative.JunoKnowledgePersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoKnowledgePersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoKnowledgePersistenceFeatureDataInterface">();
	}
	static class IJunoKnowledgePersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoKnowledgePersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoKnowledgePersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoKnowledgePersistenceFeatureDataInterface");
static_assert(sizeof(IJunoKnowledgePersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoKnowledgePersistenceFeatureDataInterface");

// Class JunoGameNative.JunoFogOfWarPersistenceFeatureData
// 0x0018 (0x0058 - 0x0040)
class UJunoFogOfWarPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoFogOfWarSaveData                  FogOfWarSaveDatas;                                 // 0x0048(0x0010)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFogOfWarPersistenceFeatureData">();
	}
	static class UJunoFogOfWarPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoFogOfWarPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoFogOfWarPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoFogOfWarPersistenceFeatureData");
static_assert(sizeof(UJunoFogOfWarPersistenceFeatureData) == 0x000058, "Wrong size on UJunoFogOfWarPersistenceFeatureData");
static_assert(offsetof(UJunoFogOfWarPersistenceFeatureData, FogOfWarSaveDatas) == 0x000048, "Member 'UJunoFogOfWarPersistenceFeatureData::FogOfWarSaveDatas' has a wrong offset!");

// Class JunoGameNative.JunoFogOfWarPersistenceFeatureDataActor
// 0x0018 (0x02E8 - 0x02D0)
class AJunoFogOfWarPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoFogOfWar>                  FogOfWarData;                                      // 0x02D8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFogOfWarPersistenceFeatureDataActor">();
	}
	static class AJunoFogOfWarPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoFogOfWarPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoFogOfWarPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoFogOfWarPersistenceFeatureDataActor");
static_assert(sizeof(AJunoFogOfWarPersistenceFeatureDataActor) == 0x0002E8, "Wrong size on AJunoFogOfWarPersistenceFeatureDataActor");
static_assert(offsetof(AJunoFogOfWarPersistenceFeatureDataActor, FogOfWarData) == 0x0002D8, "Member 'AJunoFogOfWarPersistenceFeatureDataActor::FogOfWarData' has a wrong offset!");

// Class JunoGameNative.JunoFogOfWarPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoFogOfWarPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoFogOfWarPersistenceFeatureDataInterface">();
	}
	static class IJunoFogOfWarPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoFogOfWarPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoFogOfWarPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoFogOfWarPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoFogOfWarPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoFogOfWarPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoMarkerManagerPlayspaceComponent
// 0x0090 (0x0188 - 0x00F8)
class UJunoMarkerManagerPlayspaceComponent final : public UFortPlayspaceComponent
{
public:
	uint8                                         Pad_F8[0x38];                                      // 0x00F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoMarker>                    Markers;                                           // 0x0130(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          MarkersIds;                                        // 0x0140(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	class UDataTable*                             MarkerConfigData;                                  // 0x0150(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FUniqueMarkerSettings>          UniqueMarkers;                                     // 0x0158(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        LoadedIconTextures;                                // 0x0168(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJunoMarkerManagerPlayspaceComponent* GetJunoMarkerManagerComponent(const class UObject* WorldContextObject);

	bool CreateMarker(class AActor* Actor, const struct FJunoMarker& Marker);
	void OnRep_Markers();
	void OnRep_MarkersIds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMarkerManagerPlayspaceComponent">();
	}
	static class UJunoMarkerManagerPlayspaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMarkerManagerPlayspaceComponent>();
	}
};
static_assert(alignof(UJunoMarkerManagerPlayspaceComponent) == 0x000008, "Wrong alignment on UJunoMarkerManagerPlayspaceComponent");
static_assert(sizeof(UJunoMarkerManagerPlayspaceComponent) == 0x000188, "Wrong size on UJunoMarkerManagerPlayspaceComponent");
static_assert(offsetof(UJunoMarkerManagerPlayspaceComponent, Markers) == 0x000130, "Member 'UJunoMarkerManagerPlayspaceComponent::Markers' has a wrong offset!");
static_assert(offsetof(UJunoMarkerManagerPlayspaceComponent, MarkersIds) == 0x000140, "Member 'UJunoMarkerManagerPlayspaceComponent::MarkersIds' has a wrong offset!");
static_assert(offsetof(UJunoMarkerManagerPlayspaceComponent, MarkerConfigData) == 0x000150, "Member 'UJunoMarkerManagerPlayspaceComponent::MarkerConfigData' has a wrong offset!");
static_assert(offsetof(UJunoMarkerManagerPlayspaceComponent, UniqueMarkers) == 0x000158, "Member 'UJunoMarkerManagerPlayspaceComponent::UniqueMarkers' has a wrong offset!");
static_assert(offsetof(UJunoMarkerManagerPlayspaceComponent, LoadedIconTextures) == 0x000168, "Member 'UJunoMarkerManagerPlayspaceComponent::LoadedIconTextures' has a wrong offset!");

// Class JunoGameNative.JunoMarkersPersistenceFeatureData
// 0x0028 (0x0068 - 0x0040)
class UJunoMarkersPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoMarkersSaveData                   MarkersSaveData;                                   // 0x0048(0x0020)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMarkersPersistenceFeatureData">();
	}
	static class UJunoMarkersPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMarkersPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoMarkersPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoMarkersPersistenceFeatureData");
static_assert(sizeof(UJunoMarkersPersistenceFeatureData) == 0x000068, "Wrong size on UJunoMarkersPersistenceFeatureData");
static_assert(offsetof(UJunoMarkersPersistenceFeatureData, MarkersSaveData) == 0x000048, "Member 'UJunoMarkersPersistenceFeatureData::MarkersSaveData' has a wrong offset!");

// Class JunoGameNative.JunoMarkersPersistenceFeatureDataActor
// 0x0028 (0x02F8 - 0x02D0)
class AJunoMarkersPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoMarker>                    MarkersData;                                       // 0x02D8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          MarkersIds;                                        // 0x02E8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMarkersPersistenceFeatureDataActor">();
	}
	static class AJunoMarkersPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoMarkersPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoMarkersPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoMarkersPersistenceFeatureDataActor");
static_assert(sizeof(AJunoMarkersPersistenceFeatureDataActor) == 0x0002F8, "Wrong size on AJunoMarkersPersistenceFeatureDataActor");
static_assert(offsetof(AJunoMarkersPersistenceFeatureDataActor, MarkersData) == 0x0002D8, "Member 'AJunoMarkersPersistenceFeatureDataActor::MarkersData' has a wrong offset!");
static_assert(offsetof(AJunoMarkersPersistenceFeatureDataActor, MarkersIds) == 0x0002E8, "Member 'AJunoMarkersPersistenceFeatureDataActor::MarkersIds' has a wrong offset!");

// Class JunoGameNative.JunoMarkersPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoMarkersPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMarkersPersistenceFeatureDataInterface">();
	}
	static class IJunoMarkersPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoMarkersPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoMarkersPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoMarkersPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoMarkersPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoMarkersPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoBuildingActorCountMetricComponent
// 0x0010 (0x00B0 - 0x00A0)
class UJunoBuildingActorCountMetricComponent final : public UGameStateComponent
{
public:
	TSubclassOf<class UJunoBuildingActorCountMetric> JunoBuildingMetricClass;                           // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJunoBuildingActorCountMetric*          JunoBuildingMetric;                                // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingActorCountMetricComponent">();
	}
	static class UJunoBuildingActorCountMetricComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingActorCountMetricComponent>();
	}
};
static_assert(alignof(UJunoBuildingActorCountMetricComponent) == 0x000008, "Wrong alignment on UJunoBuildingActorCountMetricComponent");
static_assert(sizeof(UJunoBuildingActorCountMetricComponent) == 0x0000B0, "Wrong size on UJunoBuildingActorCountMetricComponent");
static_assert(offsetof(UJunoBuildingActorCountMetricComponent, JunoBuildingMetricClass) == 0x0000A0, "Member 'UJunoBuildingActorCountMetricComponent::JunoBuildingMetricClass' has a wrong offset!");
static_assert(offsetof(UJunoBuildingActorCountMetricComponent, JunoBuildingMetric) == 0x0000A8, "Member 'UJunoBuildingActorCountMetricComponent::JunoBuildingMetric' has a wrong offset!");

// Class JunoGameNative.JunoModeratorModeBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoModeratorModeBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsModeratorModeEnabled(const class UObject* WorldContextObject);
	static bool IsPlayerAllowedToFly(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoModeratorModeBlueprintLibrary">();
	}
	static class UJunoModeratorModeBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoModeratorModeBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoModeratorModeBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoModeratorModeBlueprintLibrary");
static_assert(sizeof(UJunoModeratorModeBlueprintLibrary) == 0x000028, "Wrong size on UJunoModeratorModeBlueprintLibrary");

// Class JunoGameNative.JunoModeratorModeComponent
// 0x0010 (0x00B0 - 0x00A0)
class UJunoModeratorModeComponent final : public UGameFrameworkComponent
{
public:
	class UInputAction*                           InputAction_TeleportPlayer_ModeratorMode;          // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsModeratorModeEnabled;                           // 0x00A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPlayerAllowedToFly;                             // 0x00A9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bModeratorConfirmed;                               // 0x00AA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheatModeratorConfirm();
	void DisableModeratorMode();
	void EnableModeratorMode();
	void HandleOnCreativeFlyChangedDelegate(bool bIsFlying);
	void HandlePlayerPossesedPawn(class APawn* PlayerPawn);
	void HandleTeleportPlayer();
	void OnPawnDestroyed(class AActor* DestroyedActor);
	void OnRep_IsModeratorModeEnabled();
	void OnRootPlayspaceOwnerSet(class AFortPlayerControllerAthena* PlayerControllerAthena);

	bool IsModeratorModeEnabled() const;
	bool IsPlayerAllowedToFly() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoModeratorModeComponent">();
	}
	static class UJunoModeratorModeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoModeratorModeComponent>();
	}
};
static_assert(alignof(UJunoModeratorModeComponent) == 0x000008, "Wrong alignment on UJunoModeratorModeComponent");
static_assert(sizeof(UJunoModeratorModeComponent) == 0x0000B0, "Wrong size on UJunoModeratorModeComponent");
static_assert(offsetof(UJunoModeratorModeComponent, InputAction_TeleportPlayer_ModeratorMode) == 0x0000A0, "Member 'UJunoModeratorModeComponent::InputAction_TeleportPlayer_ModeratorMode' has a wrong offset!");
static_assert(offsetof(UJunoModeratorModeComponent, bIsModeratorModeEnabled) == 0x0000A8, "Member 'UJunoModeratorModeComponent::bIsModeratorModeEnabled' has a wrong offset!");
static_assert(offsetof(UJunoModeratorModeComponent, bIsPlayerAllowedToFly) == 0x0000A9, "Member 'UJunoModeratorModeComponent::bIsPlayerAllowedToFly' has a wrong offset!");
static_assert(offsetof(UJunoModeratorModeComponent, bModeratorConfirmed) == 0x0000AA, "Member 'UJunoModeratorModeComponent::bModeratorConfirmed' has a wrong offset!");

// Class JunoGameNative.JunoDoorMetaNavArea
// 0x0008 (0x0050 - 0x0048)
class UJunoDoorMetaNavArea final : public UNavAreaMeta
{
public:
	struct FNavAgentSelector                      DoorAwareAgents;                                   // 0x0048(0x0004)(Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDoorMetaNavArea">();
	}
	static class UJunoDoorMetaNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDoorMetaNavArea>();
	}
};
static_assert(alignof(UJunoDoorMetaNavArea) == 0x000008, "Wrong alignment on UJunoDoorMetaNavArea");
static_assert(sizeof(UJunoDoorMetaNavArea) == 0x000050, "Wrong size on UJunoDoorMetaNavArea");
static_assert(offsetof(UJunoDoorMetaNavArea, DoorAwareAgents) == 0x000048, "Member 'UJunoDoorMetaNavArea::DoorAwareAgents' has a wrong offset!");

// Class JunoGameNative.JunoMetaNavArea
// 0x0008 (0x0050 - 0x0048)
class UJunoMetaNavArea final : public UNavAreaMeta
{
public:
	int32                                         HealthThreshold;                                   // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMetaNavArea">();
	}
	static class UJunoMetaNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMetaNavArea>();
	}
};
static_assert(alignof(UJunoMetaNavArea) == 0x000008, "Wrong alignment on UJunoMetaNavArea");
static_assert(sizeof(UJunoMetaNavArea) == 0x000050, "Wrong size on UJunoMetaNavArea");
static_assert(offsetof(UJunoMetaNavArea, HealthThreshold) == 0x000048, "Member 'UJunoMetaNavArea::HealthThreshold' has a wrong offset!");

// Class JunoGameNative.JunoPawnComponentMood
// 0x00B8 (0x0160 - 0x00A8)
class UJunoPawnComponentMood final : public UFortPawnComponent
{
public:
	TMulticastInlineDelegate<void(struct FJunoMoodStateData& NewMood)> OnJunoMoodChangedDelegate;                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(struct FJunoMoodReactionPayload& MoodReactionPayload)> OnJunoMoodReactionTriggeredDelegate;               // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnJunoMoodReactionFinishedDelegate;                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnJunoMoodReactionCanceledDelegate;                // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoMoodStateData                     CurrentMoodState;                                  // 0x0148(0x0004)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProxyTable*                            MoodAnimProxyTable;                                // 0x0150(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMoodReactionActive;                             // 0x0158(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMoodReactionSupported(const struct FGameplayTag& MoodReactionTag);
	bool IsMoodReactionSupported_Internal(const struct FGameplayTag& MoodReactionTag);
	void MulticastOnCancelCurrentMoodReaction();
	void MulticastOnMoodReactionComplete();
	void MulticastTriggerMoodReaction(const struct FGameplayTag& MoodReactionTag);
	void NotifyMoodReactionComplete();
	void OnRep_CurrentMoodState();

	const struct FJunoMoodStateData GetCurrentMoodState() const;
	class UProxyTable* GetMoodAnimProxyTable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPawnComponentMood">();
	}
	static class UJunoPawnComponentMood* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPawnComponentMood>();
	}
};
static_assert(alignof(UJunoPawnComponentMood) == 0x000008, "Wrong alignment on UJunoPawnComponentMood");
static_assert(sizeof(UJunoPawnComponentMood) == 0x000160, "Wrong size on UJunoPawnComponentMood");
static_assert(offsetof(UJunoPawnComponentMood, OnJunoMoodChangedDelegate) == 0x0000A8, "Member 'UJunoPawnComponentMood::OnJunoMoodChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponentMood, OnJunoMoodReactionTriggeredDelegate) == 0x0000D0, "Member 'UJunoPawnComponentMood::OnJunoMoodReactionTriggeredDelegate' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponentMood, OnJunoMoodReactionFinishedDelegate) == 0x0000F8, "Member 'UJunoPawnComponentMood::OnJunoMoodReactionFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponentMood, OnJunoMoodReactionCanceledDelegate) == 0x000120, "Member 'UJunoPawnComponentMood::OnJunoMoodReactionCanceledDelegate' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponentMood, CurrentMoodState) == 0x000148, "Member 'UJunoPawnComponentMood::CurrentMoodState' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponentMood, MoodAnimProxyTable) == 0x000150, "Member 'UJunoPawnComponentMood::MoodAnimProxyTable' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponentMood, bIsMoodReactionActive) == 0x000158, "Member 'UJunoPawnComponentMood::bIsMoodReactionActive' has a wrong offset!");

// Class JunoGameNative.JunoPawnComponentSpeechBubble
// 0x0000 (0x01D8 - 0x01D8)
class UJunoPawnComponentSpeechBubble final : public UFortPawnComponent_SpeechBubble
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPawnComponentSpeechBubble">();
	}
	static class UJunoPawnComponentSpeechBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPawnComponentSpeechBubble>();
	}
};
static_assert(alignof(UJunoPawnComponentSpeechBubble) == 0x000008, "Wrong alignment on UJunoPawnComponentSpeechBubble");
static_assert(sizeof(UJunoPawnComponentSpeechBubble) == 0x0001D8, "Wrong size on UJunoPawnComponentSpeechBubble");

// Class JunoGameNative.JunoDeltaFile
// 0x0068 (0x07D0 - 0x0768)
class UJunoDeltaFile final : public ULevelSaveRecord
{
public:
	class FName                                   UniquePackageName;                                 // 0x0768(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_76C[0x4];                                      // 0x076C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FJunoUpdateAction>  UpdateActions;                                     // 0x0770(0x0050)(NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AJunoPersistentPlayspace> WeakPersistentPlayspaceToApplyTo;                  // 0x07C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDirty;                                            // 0x07C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C9[0x7];                                      // 0x07C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDeltaFile">();
	}
	static class UJunoDeltaFile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDeltaFile>();
	}
};
static_assert(alignof(UJunoDeltaFile) == 0x000008, "Wrong alignment on UJunoDeltaFile");
static_assert(sizeof(UJunoDeltaFile) == 0x0007D0, "Wrong size on UJunoDeltaFile");
static_assert(offsetof(UJunoDeltaFile, UniquePackageName) == 0x000768, "Member 'UJunoDeltaFile::UniquePackageName' has a wrong offset!");
static_assert(offsetof(UJunoDeltaFile, UpdateActions) == 0x000770, "Member 'UJunoDeltaFile::UpdateActions' has a wrong offset!");
static_assert(offsetof(UJunoDeltaFile, WeakPersistentPlayspaceToApplyTo) == 0x0007C0, "Member 'UJunoDeltaFile::WeakPersistentPlayspaceToApplyTo' has a wrong offset!");
static_assert(offsetof(UJunoDeltaFile, bDirty) == 0x0007C8, "Member 'UJunoDeltaFile::bDirty' has a wrong offset!");

// Class JunoGameNative.JunoDeltaFileApplier
// 0x00A0 (0x0590 - 0x04F0)
class UJunoDeltaFileApplier final : public ULevelRecordSpawner
{
public:
	TMap<struct FGuid, struct FJunoUpdateAction>  UpdateActionMap;                                   // 0x04F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FDeleteAction>      DeleteActionMap;                                   // 0x0540(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDeltaFileApplier">();
	}
	static class UJunoDeltaFileApplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDeltaFileApplier>();
	}
};
static_assert(alignof(UJunoDeltaFileApplier) == 0x000010, "Wrong alignment on UJunoDeltaFileApplier");
static_assert(sizeof(UJunoDeltaFileApplier) == 0x000590, "Wrong size on UJunoDeltaFileApplier");
static_assert(offsetof(UJunoDeltaFileApplier, UpdateActionMap) == 0x0004F0, "Member 'UJunoDeltaFileApplier::UpdateActionMap' has a wrong offset!");
static_assert(offsetof(UJunoDeltaFileApplier, DeleteActionMap) == 0x000540, "Member 'UJunoDeltaFileApplier::DeleteActionMap' has a wrong offset!");

// Class JunoGameNative.JunoDeltasLevelSaveComponent
// 0x0000 (0x08F0 - 0x08F0)
class UJunoDeltasLevelSaveComponent final : public UFortLevelSaveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDeltasLevelSaveComponent">();
	}
	static class UJunoDeltasLevelSaveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDeltasLevelSaveComponent>();
	}
};
static_assert(alignof(UJunoDeltasLevelSaveComponent) == 0x000008, "Wrong alignment on UJunoDeltasLevelSaveComponent");
static_assert(sizeof(UJunoDeltasLevelSaveComponent) == 0x0008F0, "Wrong size on UJunoDeltasLevelSaveComponent");

// Class JunoGameNative.JunoPFWModule_LevelDeltas
// 0x0000 (0x00E0 - 0x00E0)
class UJunoPFWModule_LevelDeltas final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPFWModule_LevelDeltas">();
	}
	static class UJunoPFWModule_LevelDeltas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPFWModule_LevelDeltas>();
	}
};
static_assert(alignof(UJunoPFWModule_LevelDeltas) == 0x000008, "Wrong alignment on UJunoPFWModule_LevelDeltas");
static_assert(sizeof(UJunoPFWModule_LevelDeltas) == 0x0000E0, "Wrong size on UJunoPFWModule_LevelDeltas");

// Class JunoGameNative.JunoPFWContainer_LevelDelta
// 0x0038 (0x0178 - 0x0140)
class UJunoPFWContainer_LevelDelta final : public UPersistenceFrameworkContainer
{
public:
	uint8                                         Pad_140[0x38];                                     // 0x0140(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPFWContainer_LevelDelta">();
	}
	static class UJunoPFWContainer_LevelDelta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPFWContainer_LevelDelta>();
	}
};
static_assert(alignof(UJunoPFWContainer_LevelDelta) == 0x000008, "Wrong alignment on UJunoPFWContainer_LevelDelta");
static_assert(sizeof(UJunoPFWContainer_LevelDelta) == 0x000178, "Wrong size on UJunoPFWContainer_LevelDelta");

// Class JunoGameNative.JunoPFWContainer_LevelDeltaIndex
// 0x0020 (0x0200 - 0x01E0)
class UJunoPFWContainer_LevelDeltaIndex final : public UJunoBasePFWContainer
{
public:
	uint8                                         Pad_1E0[0x20];                                     // 0x01E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPFWContainer_LevelDeltaIndex">();
	}
	static class UJunoPFWContainer_LevelDeltaIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPFWContainer_LevelDeltaIndex>();
	}
};
static_assert(alignof(UJunoPFWContainer_LevelDeltaIndex) == 0x000008, "Wrong alignment on UJunoPFWContainer_LevelDeltaIndex");
static_assert(sizeof(UJunoPFWContainer_LevelDeltaIndex) == 0x000200, "Wrong size on UJunoPFWContainer_LevelDeltaIndex");

// Class JunoGameNative.JunoPlayspaceTrackableInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoPlayspaceTrackableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceTrackableInterface">();
	}
	static class IJunoPlayspaceTrackableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoPlayspaceTrackableInterface>();
	}
};
static_assert(alignof(IJunoPlayspaceTrackableInterface) == 0x000008, "Wrong alignment on IJunoPlayspaceTrackableInterface");
static_assert(sizeof(IJunoPlayspaceTrackableInterface) == 0x000028, "Wrong size on IJunoPlayspaceTrackableInterface");

// Class JunoGameNative.JunoPersistentPlayspaceLevelRegistry
// 0x0050 (0x0080 - 0x0030)
class UJunoPersistentPlayspaceLevelRegistry final : public UEngineSubsystem
{
public:
	TMap<class FName, struct FJunoPersistentPlayspaceLevelRegistryEntry> PersistentPlayspaceLevelMap;                       // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPersistentPlayspaceLevelRegistry">();
	}
	static class UJunoPersistentPlayspaceLevelRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPersistentPlayspaceLevelRegistry>();
	}
};
static_assert(alignof(UJunoPersistentPlayspaceLevelRegistry) == 0x000008, "Wrong alignment on UJunoPersistentPlayspaceLevelRegistry");
static_assert(sizeof(UJunoPersistentPlayspaceLevelRegistry) == 0x000080, "Wrong size on UJunoPersistentPlayspaceLevelRegistry");
static_assert(offsetof(UJunoPersistentPlayspaceLevelRegistry, PersistentPlayspaceLevelMap) == 0x000030, "Member 'UJunoPersistentPlayspaceLevelRegistry::PersistentPlayspaceLevelMap' has a wrong offset!");

// Class JunoGameNative.JunoPlayerPersistenceComponent
// 0x01A0 (0x0298 - 0x00F8)
class UJunoPlayerPersistenceComponent final : public UFortPlayspaceComponent
{
public:
	uint8                                         Pad_F8[0x40];                                      // 0x00F8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FUniqueNetIdRepl, int32>          PlayerSaveDataRefCount;                            // 0x0138(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, struct FJunoPlayerSaveData> PlayerSaveData;                                    // 0x0188(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, TWeakObjectPtr<class UJunoPlayerSaveData_Container>> PlayerSaveDataContainers;                          // 0x01D8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<struct FUniqueNetIdRepl>                 InFlightPlayerSaves;                               // 0x0228(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x20];                                     // 0x0278(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnyPlayerLoggedIn(class APlayerController* PlayerController);
	void OnAnyPlayerLoggedOut(class AGameModeBase* GameModeBase, class AController* Controller);
	void OnControllerBeginDestroy(class AFortPlayerControllerAthena* FortPCAthena);
	void OnRemovePlayer(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerPersistenceComponent">();
	}
	static class UJunoPlayerPersistenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayerPersistenceComponent>();
	}
};
static_assert(alignof(UJunoPlayerPersistenceComponent) == 0x000008, "Wrong alignment on UJunoPlayerPersistenceComponent");
static_assert(sizeof(UJunoPlayerPersistenceComponent) == 0x000298, "Wrong size on UJunoPlayerPersistenceComponent");
static_assert(offsetof(UJunoPlayerPersistenceComponent, PlayerSaveDataRefCount) == 0x000138, "Member 'UJunoPlayerPersistenceComponent::PlayerSaveDataRefCount' has a wrong offset!");
static_assert(offsetof(UJunoPlayerPersistenceComponent, PlayerSaveData) == 0x000188, "Member 'UJunoPlayerPersistenceComponent::PlayerSaveData' has a wrong offset!");
static_assert(offsetof(UJunoPlayerPersistenceComponent, PlayerSaveDataContainers) == 0x0001D8, "Member 'UJunoPlayerPersistenceComponent::PlayerSaveDataContainers' has a wrong offset!");
static_assert(offsetof(UJunoPlayerPersistenceComponent, InFlightPlayerSaves) == 0x000228, "Member 'UJunoPlayerPersistenceComponent::InFlightPlayerSaves' has a wrong offset!");

// Class JunoGameNative.JunoWorldPersistenceHandler
// 0x0008 (0x0030 - 0x0028)
class UJunoWorldPersistenceHandler : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceHandler">();
	}
	static class UJunoWorldPersistenceHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistenceHandler>();
	}
};
static_assert(alignof(UJunoWorldPersistenceHandler) == 0x000008, "Wrong alignment on UJunoWorldPersistenceHandler");
static_assert(sizeof(UJunoWorldPersistenceHandler) == 0x000030, "Wrong size on UJunoWorldPersistenceHandler");

// Class JunoGameNative.JunoWorldPersistenceHandler_Deltas
// 0x0140 (0x0170 - 0x0030)
class alignas(0x10) UJunoWorldPersistenceHandler_Deltas final : public UJunoWorldPersistenceHandler
{
public:
	int32                                         DeltasPeriodicSaveIntervalSeconds_Default;         // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DeltasPeriodicSaveIntervalSeconds_PIEOverride;     // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0xF0];                                      // 0x0038(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoDeltasSaveHandler*                 DeltasSaveHandler;                                 // 0x0128(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         DefaultDeltaFileClass;                             // 0x0140(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FJunoRollbackBadCheckpointRange> RollbackBadCheckpointRanges;                       // 0x0158(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceHandler_Deltas">();
	}
	static class UJunoWorldPersistenceHandler_Deltas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistenceHandler_Deltas>();
	}
};
static_assert(alignof(UJunoWorldPersistenceHandler_Deltas) == 0x000010, "Wrong alignment on UJunoWorldPersistenceHandler_Deltas");
static_assert(sizeof(UJunoWorldPersistenceHandler_Deltas) == 0x000170, "Wrong size on UJunoWorldPersistenceHandler_Deltas");
static_assert(offsetof(UJunoWorldPersistenceHandler_Deltas, DeltasPeriodicSaveIntervalSeconds_Default) == 0x000030, "Member 'UJunoWorldPersistenceHandler_Deltas::DeltasPeriodicSaveIntervalSeconds_Default' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceHandler_Deltas, DeltasPeriodicSaveIntervalSeconds_PIEOverride) == 0x000034, "Member 'UJunoWorldPersistenceHandler_Deltas::DeltasPeriodicSaveIntervalSeconds_PIEOverride' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceHandler_Deltas, DeltasSaveHandler) == 0x000128, "Member 'UJunoWorldPersistenceHandler_Deltas::DeltasSaveHandler' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceHandler_Deltas, DefaultDeltaFileClass) == 0x000140, "Member 'UJunoWorldPersistenceHandler_Deltas::DefaultDeltaFileClass' has a wrong offset!");
static_assert(offsetof(UJunoWorldPersistenceHandler_Deltas, RollbackBadCheckpointRanges) == 0x000158, "Member 'UJunoWorldPersistenceHandler_Deltas::RollbackBadCheckpointRanges' has a wrong offset!");

// Class JunoGameNative.JunoWorldPersistencePlayerManager
// 0x0098 (0x00C0 - 0x0028)
class UJunoWorldPersistencePlayerManager final : public UObject
{
public:
	uint8                                         Pad_28[0x98];                                      // 0x0028(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnyPlayerLoggedIn(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistencePlayerManager">();
	}
	static class UJunoWorldPersistencePlayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistencePlayerManager>();
	}
};
static_assert(alignof(UJunoWorldPersistencePlayerManager) == 0x000008, "Wrong alignment on UJunoWorldPersistencePlayerManager");
static_assert(sizeof(UJunoWorldPersistencePlayerManager) == 0x0000C0, "Wrong size on UJunoWorldPersistencePlayerManager");

// Class JunoGameNative.JunoAIPersistenceFeatureData
// 0x0130 (0x0170 - 0x0040)
class UJunoAIPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedAIDataManager                    SavedAIData;                                       // 0x0050(0x0120)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIPersistenceFeatureData">();
	}
	static class UJunoAIPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoAIPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoAIPersistenceFeatureData");
static_assert(sizeof(UJunoAIPersistenceFeatureData) == 0x000170, "Wrong size on UJunoAIPersistenceFeatureData");
static_assert(offsetof(UJunoAIPersistenceFeatureData, SavedAIData) == 0x000050, "Member 'UJunoAIPersistenceFeatureData::SavedAIData' has a wrong offset!");

// Class JunoGameNative.JunoPlayspaceAccountantPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoPlayspaceAccountantPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceAccountantPersistenceFeatureDataInterface">();
	}
	static class IJunoPlayspaceAccountantPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoPlayspaceAccountantPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoPlayspaceAccountantPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoPlayspaceAccountantPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoPlayspaceAccountantPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoPlayspaceAccountantPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoPlayspaceIndexPersistenceFeatureData
// 0x0050 (0x0090 - 0x0040)
class UJunoPlayspaceIndexPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	struct FJunoPlayspaceIndexSaveData            PlayspaceIndexSaveData;                            // 0x0040(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayspaceIndexPersistenceFeatureData">();
	}
	static class UJunoPlayspaceIndexPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPlayspaceIndexPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoPlayspaceIndexPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoPlayspaceIndexPersistenceFeatureData");
static_assert(sizeof(UJunoPlayspaceIndexPersistenceFeatureData) == 0x000090, "Wrong size on UJunoPlayspaceIndexPersistenceFeatureData");
static_assert(offsetof(UJunoPlayspaceIndexPersistenceFeatureData, PlayspaceIndexSaveData) == 0x000040, "Member 'UJunoPlayspaceIndexPersistenceFeatureData::PlayspaceIndexSaveData' has a wrong offset!");

// Class JunoGameNative.JunoWorldPersistenceFeatureData
// 0x0058 (0x0098 - 0x0040)
class UJunoWorldPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoWorldSaveData                     WorldSaveData;                                     // 0x0048(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceFeatureData">();
	}
	static class UJunoWorldPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoWorldPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoWorldPersistenceFeatureData");
static_assert(sizeof(UJunoWorldPersistenceFeatureData) == 0x000098, "Wrong size on UJunoWorldPersistenceFeatureData");
static_assert(offsetof(UJunoWorldPersistenceFeatureData, WorldSaveData) == 0x000048, "Member 'UJunoWorldPersistenceFeatureData::WorldSaveData' has a wrong offset!");

// Class JunoGameNative.JunoWorldPersistenceFeatureDataActor
// 0x0058 (0x0328 - 0x02D0)
class AJunoWorldPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoWorldSaveData                     WorldSaveData;                                     // 0x02D8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceFeatureDataActor">();
	}
	static class AJunoWorldPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoWorldPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoWorldPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoWorldPersistenceFeatureDataActor");
static_assert(sizeof(AJunoWorldPersistenceFeatureDataActor) == 0x000328, "Wrong size on AJunoWorldPersistenceFeatureDataActor");
static_assert(offsetof(AJunoWorldPersistenceFeatureDataActor, WorldSaveData) == 0x0002D8, "Member 'AJunoWorldPersistenceFeatureDataActor::WorldSaveData' has a wrong offset!");

// Class JunoGameNative.JunoWorldPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoWorldPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldPersistenceFeatureDataInterface">();
	}
	static class IJunoWorldPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoWorldPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoWorldPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoWorldPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoWorldPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoWorldPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoClusterUnionPersistenceFeatureData
// 0x0050 (0x0090 - 0x0040)
class UJunoClusterUnionPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	struct FJunoClusterUnionSaveData              SaveData;                                          // 0x0040(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClusterUnionPersistenceFeatureData">();
	}
	static class UJunoClusterUnionPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoClusterUnionPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoClusterUnionPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoClusterUnionPersistenceFeatureData");
static_assert(sizeof(UJunoClusterUnionPersistenceFeatureData) == 0x000090, "Wrong size on UJunoClusterUnionPersistenceFeatureData");
static_assert(offsetof(UJunoClusterUnionPersistenceFeatureData, SaveData) == 0x000040, "Member 'UJunoClusterUnionPersistenceFeatureData::SaveData' has a wrong offset!");

// Class JunoGameNative.JunoClusterUnionPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoClusterUnionPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClusterUnionPersistenceFeatureData_Container">();
	}
	static class UJunoClusterUnionPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoClusterUnionPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoClusterUnionPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoClusterUnionPersistenceFeatureData_Container");
static_assert(sizeof(UJunoClusterUnionPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoClusterUnionPersistenceFeatureData_Container");

// Class JunoGameNative.JunoConnectivityGraphPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoConnectivityGraphPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivityGraphPersistenceFeatureDataInterface">();
	}
	static class IJunoConnectivityGraphPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoConnectivityGraphPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoConnectivityGraphPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoConnectivityGraphPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoConnectivityGraphPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoConnectivityGraphPersistenceFeatureDataInterface");

// Class JunoGameNative.JunoConnectivityGraphPFW_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoConnectivityGraphPFW_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoConnectivityGraphPFW_Container">();
	}
	static class UJunoConnectivityGraphPFW_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoConnectivityGraphPFW_Container>();
	}
};
static_assert(alignof(UJunoConnectivityGraphPFW_Container) == 0x000008, "Wrong alignment on UJunoConnectivityGraphPFW_Container");
static_assert(sizeof(UJunoConnectivityGraphPFW_Container) == 0x0001E0, "Wrong size on UJunoConnectivityGraphPFW_Container");

// Class JunoGameNative.JunoPhysicsToyPersistenceFeatureData
// 0x0050 (0x0090 - 0x0040)
class UJunoPhysicsToyPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	struct FJunoPhysicsToySaveData                Container;                                         // 0x0040(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPhysicsToyPersistenceFeatureData">();
	}
	static class UJunoPhysicsToyPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPhysicsToyPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoPhysicsToyPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoPhysicsToyPersistenceFeatureData");
static_assert(sizeof(UJunoPhysicsToyPersistenceFeatureData) == 0x000090, "Wrong size on UJunoPhysicsToyPersistenceFeatureData");
static_assert(offsetof(UJunoPhysicsToyPersistenceFeatureData, Container) == 0x000040, "Member 'UJunoPhysicsToyPersistenceFeatureData::Container' has a wrong offset!");

// Class JunoGameNative.JunoPlayerPersistenceFeatureDataActor
// 0x0070 (0x0340 - 0x02D0)
class AJunoPlayerPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FUniqueNetIdRepl, struct FJunoPlayerSaveData> PlayerSaveData;                                    // 0x02D8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x18];                                     // 0x0328(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPlayerPersistenceFeatureDataActor">();
	}
	static class AJunoPlayerPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPlayerPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoPlayerPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoPlayerPersistenceFeatureDataActor");
static_assert(sizeof(AJunoPlayerPersistenceFeatureDataActor) == 0x000340, "Wrong size on AJunoPlayerPersistenceFeatureDataActor");
static_assert(offsetof(AJunoPlayerPersistenceFeatureDataActor, PlayerSaveData) == 0x0002D8, "Member 'AJunoPlayerPersistenceFeatureDataActor::PlayerSaveData' has a wrong offset!");

// Class JunoGameNative.JunoPersistenceFeaturePFWState
// 0x0008 (0x0030 - 0x0028)
class UJunoPersistenceFeaturePFWState final : public UObject
{
public:
	TWeakObjectPtr<class UJunoBasePFWPersistenceFeatureDataContainer> ContainerWeakPtr;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPersistenceFeaturePFWState">();
	}
	static class UJunoPersistenceFeaturePFWState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPersistenceFeaturePFWState>();
	}
};
static_assert(alignof(UJunoPersistenceFeaturePFWState) == 0x000008, "Wrong alignment on UJunoPersistenceFeaturePFWState");
static_assert(sizeof(UJunoPersistenceFeaturePFWState) == 0x000030, "Wrong size on UJunoPersistenceFeaturePFWState");
static_assert(offsetof(UJunoPersistenceFeaturePFWState, ContainerWeakPtr) == 0x000028, "Member 'UJunoPersistenceFeaturePFWState::ContainerWeakPtr' has a wrong offset!");

// Class JunoGameNative.JunoControllerComponent
// 0x0410 (0x04B8 - 0x00A8)
class UJunoControllerComponent final : public UFortControllerComponent
{
public:
	TMulticastInlineDelegate<void(class AFortPlayerController* InstigatorPC, class AActor* SpawnedActor)> OnPlayerSpawnedActorWithBuilderTool;               // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortItem* OffhandItem)> OnOffhandInputPressed;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortItem* OffhandItem)> OnOffhandInputReleased;                            // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFortWorldItemDefinition*               EmptyHandItemDefinition;                           // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InteractionDistanceFromCamera;                     // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InteractionDistanceFromPlayer;                     // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPrimaryAssetId                        BuilderToolPrimaryAsset;                           // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     DeathChestActorClass;                              // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     DeathChestNavFilterClass;                          // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DeathChestNavQuestyExtents;                        // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeathChestZDistanceToCheck;                        // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoMarker                            CheckpointMarker;                                  // 0x0120(0x0098)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGuid                                  ItemToBuildGUID;                                   // 0x01B8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ItemSelectedGuid;                                  // 0x01D8(0x0010)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpawnedBackpack;                                  // 0x01E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E9[0x17];                                     // 0x01E9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        InputComponent;                                    // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x90];                                     // 0x0208(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortItem*                              CachedQuickBuildItem;                              // 0x0298(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x190];                                    // 0x02A0(0x0190)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortOffhandComponent*                  OffhandComponent;                                  // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayEventListenerHandle           CheckpointActorDestroyedHandle;                    // 0x0438(0x001C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_454[0x5C];                                     // 0x0454(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsModeratorModeEnabled;                           // 0x04B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItemToBuilderTool(const class UFortItem* Item);
	void AddItemToBuilderToolOnEquip(class AFortWeapon* NewWeapon, class AFortWeapon* PrevWeapon);
	void AddRecipeToBuilderTool(const class FName RecipeName);
	void ClientNotifyInventoryClosed(class AActor* ReceivingActor);
	void ClientNotifyInventoryFull();
	void ClientNotifyInventoryInvoked(class AActor* ReceivingActor);
	bool GetIsModeratorModeEnabled();
	void HandleBuilderToolInteractionStarted(const class AJunoBuilderTool* BuilderTool, const class UJunoBuilderToolInteractionBehavior* Behavior);
	void HandleBuilderToolInteractionStopped(const class AJunoBuilderTool* BuilderTool, const class UJunoBuilderToolInteractionBehavior* Behavior);
	void HandleBuilderToolUnEquip(class AFortWeapon* Weapon);
	void HandleFortPawnChanged(class AFortPawn* NewPawn);
	void OnAnimToggle();
	void OnCameraToggle();
	void OnRep_ItemSelectedGuid();
	void ServerFreeBuildAddInventoryItem(const struct FFortItemEntry& InItemEntry);
	void ServerReplicateMapData();
	void ServerSetCraftingContextItem(const struct FGuid& InItemGuid);
	void ServerSetSelectedItem(const struct FGuid& ItemGuid, const struct FGameplayTag& SlotGroupTag, const int32 SlotRow, const int32 SlotColumn);
	void ServerTeleportToCave();
	void ServerTeleportToLocation(const struct FVector& TeleportLocation, const struct FRotator& TeleportRotation);
	void ServerTeleportToPOI();
	void SetIsModeratorModeEnabled(bool bEnable);
	void SetPlayerCheckpoint(class AActor* CheckpointActor, const struct FVector& CheckpointLocation);
	void SetPlayerLastCaveTeleporterLocation(const struct FVector& TeleporterLocation);
	void SwitchToEmptyHands(bool bTriggerSelection, const struct FGameplayTag& OptionalSlotGroupTag, int32 OptionalSlotRow, int32 OptionalSlotColumn);

	void ClientPrintPersistenceDataReport(const TArray<class FString>& Logs) const;
	class AJunoBuilderTool* GetBuilderTool() const;
	struct FVector GetLastCaveTeleporterLocation() const;
	struct FJunoPlayerCheckpoint GetPlayerCheckpoint() const;
	void ServerRequestPersistenceDataReport(const EJunoPersistenceReportOptions ReportOptions) const;
	bool ShouldSpawnDeathChest() const;
	bool SpawnedBackpack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoControllerComponent">();
	}
	static class UJunoControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoControllerComponent>();
	}
};
static_assert(alignof(UJunoControllerComponent) == 0x000008, "Wrong alignment on UJunoControllerComponent");
static_assert(sizeof(UJunoControllerComponent) == 0x0004B8, "Wrong size on UJunoControllerComponent");
static_assert(offsetof(UJunoControllerComponent, OnPlayerSpawnedActorWithBuilderTool) == 0x0000A8, "Member 'UJunoControllerComponent::OnPlayerSpawnedActorWithBuilderTool' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, OnOffhandInputPressed) == 0x0000B8, "Member 'UJunoControllerComponent::OnOffhandInputPressed' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, OnOffhandInputReleased) == 0x0000C8, "Member 'UJunoControllerComponent::OnOffhandInputReleased' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, EmptyHandItemDefinition) == 0x0000D8, "Member 'UJunoControllerComponent::EmptyHandItemDefinition' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, InteractionDistanceFromCamera) == 0x0000E0, "Member 'UJunoControllerComponent::InteractionDistanceFromCamera' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, InteractionDistanceFromPlayer) == 0x0000E4, "Member 'UJunoControllerComponent::InteractionDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, BuilderToolPrimaryAsset) == 0x0000E8, "Member 'UJunoControllerComponent::BuilderToolPrimaryAsset' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, DeathChestActorClass) == 0x0000F0, "Member 'UJunoControllerComponent::DeathChestActorClass' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, DeathChestNavFilterClass) == 0x0000F8, "Member 'UJunoControllerComponent::DeathChestNavFilterClass' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, DeathChestNavQuestyExtents) == 0x000100, "Member 'UJunoControllerComponent::DeathChestNavQuestyExtents' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, DeathChestZDistanceToCheck) == 0x000118, "Member 'UJunoControllerComponent::DeathChestZDistanceToCheck' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, CheckpointMarker) == 0x000120, "Member 'UJunoControllerComponent::CheckpointMarker' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, ItemToBuildGUID) == 0x0001B8, "Member 'UJunoControllerComponent::ItemToBuildGUID' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, ItemSelectedGuid) == 0x0001D8, "Member 'UJunoControllerComponent::ItemSelectedGuid' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, bSpawnedBackpack) == 0x0001E8, "Member 'UJunoControllerComponent::bSpawnedBackpack' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, InputComponent) == 0x000200, "Member 'UJunoControllerComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, CachedQuickBuildItem) == 0x000298, "Member 'UJunoControllerComponent::CachedQuickBuildItem' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, OffhandComponent) == 0x000430, "Member 'UJunoControllerComponent::OffhandComponent' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, CheckpointActorDestroyedHandle) == 0x000438, "Member 'UJunoControllerComponent::CheckpointActorDestroyedHandle' has a wrong offset!");
static_assert(offsetof(UJunoControllerComponent, bIsModeratorModeEnabled) == 0x0004B0, "Member 'UJunoControllerComponent::bIsModeratorModeEnabled' has a wrong offset!");

// Class JunoGameNative.JunoInputControllerComponent
// 0x0148 (0x01F0 - 0x00A8)
class UJunoInputControllerComponent final : public UFortControllerComponent
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCachedEnableClientSettingsRestoreInputPresets : 1; // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoInputMapping                      DefaultInputMapping;                               // 0x00F0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoInputMapping                      BasicGameplayInputMapping;                         // 0x0100(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleCameraToggle;                    // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleAnimToggle;                      // 0x0118(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleCyclePOI;                        // 0x0120(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleTeleportToCave;                  // 0x0128(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_NextQuickbarSlot;                      // 0x0130(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_NextQuickbarSlot_Delayed;              // 0x0138(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_PrevQuickbarSlot;                      // 0x0140(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_PrevQuickbarSlot_Delayed;              // 0x0148(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleOpenHudMenu;                     // 0x0150(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleOpenBuildingMenu;                // 0x0158(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleOpenMapMenu;                     // 0x0160(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleOpenInventoryMenu;               // 0x0168(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleOpenShopMenu;                    // 0x0170(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleOpenEngagementMenu;              // 0x0178(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_HandleOpenEscapeMenu;                  // 0x0180(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_JunoBuildingStartPlacement;            // 0x0188(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_ToggleBuildMode;                       // 0x0190(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_TeleportPlayer;                        // 0x0198(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_OffhandUse;                            // 0x01A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_FlyDown;                               // 0x01A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           InputAction_FlyUp;                                 // 0x01B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInputAction*>                   QuickbarBindings;                                  // 0x01B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FJunoEnhancedInputActionToGameplayEvent> InputActionsToGameplayEvents;                      // 0x01C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bJunoIsFlying;                                     // 0x01D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D9[0x17];                                     // 0x01D9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnCreativeFlyChangedDelegate(bool bIsFlying);

	void AddInputMappingContext(const struct FJunoInputMapping& InputMapping) const;
	void RemoveInputMappingContext(const class UInputMappingContext* InputMappingContext) const;
	void ReplaceInputMappingContext(const struct FJunoInputMapping& InputMapping) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInputControllerComponent">();
	}
	static class UJunoInputControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInputControllerComponent>();
	}
};
static_assert(alignof(UJunoInputControllerComponent) == 0x000008, "Wrong alignment on UJunoInputControllerComponent");
static_assert(sizeof(UJunoInputControllerComponent) == 0x0001F0, "Wrong size on UJunoInputControllerComponent");
static_assert(offsetof(UJunoInputControllerComponent, DefaultInputMapping) == 0x0000F0, "Member 'UJunoInputControllerComponent::DefaultInputMapping' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, BasicGameplayInputMapping) == 0x000100, "Member 'UJunoInputControllerComponent::BasicGameplayInputMapping' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleCameraToggle) == 0x000110, "Member 'UJunoInputControllerComponent::InputAction_HandleCameraToggle' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleAnimToggle) == 0x000118, "Member 'UJunoInputControllerComponent::InputAction_HandleAnimToggle' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleCyclePOI) == 0x000120, "Member 'UJunoInputControllerComponent::InputAction_HandleCyclePOI' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleTeleportToCave) == 0x000128, "Member 'UJunoInputControllerComponent::InputAction_HandleTeleportToCave' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_NextQuickbarSlot) == 0x000130, "Member 'UJunoInputControllerComponent::InputAction_NextQuickbarSlot' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_NextQuickbarSlot_Delayed) == 0x000138, "Member 'UJunoInputControllerComponent::InputAction_NextQuickbarSlot_Delayed' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_PrevQuickbarSlot) == 0x000140, "Member 'UJunoInputControllerComponent::InputAction_PrevQuickbarSlot' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_PrevQuickbarSlot_Delayed) == 0x000148, "Member 'UJunoInputControllerComponent::InputAction_PrevQuickbarSlot_Delayed' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleOpenHudMenu) == 0x000150, "Member 'UJunoInputControllerComponent::InputAction_HandleOpenHudMenu' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleOpenBuildingMenu) == 0x000158, "Member 'UJunoInputControllerComponent::InputAction_HandleOpenBuildingMenu' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleOpenMapMenu) == 0x000160, "Member 'UJunoInputControllerComponent::InputAction_HandleOpenMapMenu' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleOpenInventoryMenu) == 0x000168, "Member 'UJunoInputControllerComponent::InputAction_HandleOpenInventoryMenu' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleOpenShopMenu) == 0x000170, "Member 'UJunoInputControllerComponent::InputAction_HandleOpenShopMenu' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleOpenEngagementMenu) == 0x000178, "Member 'UJunoInputControllerComponent::InputAction_HandleOpenEngagementMenu' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_HandleOpenEscapeMenu) == 0x000180, "Member 'UJunoInputControllerComponent::InputAction_HandleOpenEscapeMenu' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_JunoBuildingStartPlacement) == 0x000188, "Member 'UJunoInputControllerComponent::InputAction_JunoBuildingStartPlacement' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_ToggleBuildMode) == 0x000190, "Member 'UJunoInputControllerComponent::InputAction_ToggleBuildMode' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_TeleportPlayer) == 0x000198, "Member 'UJunoInputControllerComponent::InputAction_TeleportPlayer' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_OffhandUse) == 0x0001A0, "Member 'UJunoInputControllerComponent::InputAction_OffhandUse' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_FlyDown) == 0x0001A8, "Member 'UJunoInputControllerComponent::InputAction_FlyDown' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputAction_FlyUp) == 0x0001B0, "Member 'UJunoInputControllerComponent::InputAction_FlyUp' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, QuickbarBindings) == 0x0001B8, "Member 'UJunoInputControllerComponent::QuickbarBindings' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, InputActionsToGameplayEvents) == 0x0001C8, "Member 'UJunoInputControllerComponent::InputActionsToGameplayEvents' has a wrong offset!");
static_assert(offsetof(UJunoInputControllerComponent, bJunoIsFlying) == 0x0001D8, "Member 'UJunoInputControllerComponent::bJunoIsFlying' has a wrong offset!");

// Class JunoGameNative.JunoPawnComponent
// 0x0008 (0x00B0 - 0x00A8)
class UJunoPawnComponent : public UFortPawnComponent
{
public:
	bool                                          bShouldSpawnDeathChest;                            // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPlayerInCave() const;
	bool ShouldPawnSpawnDeathChest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPawnComponent">();
	}
	static class UJunoPawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPawnComponent>();
	}
};
static_assert(alignof(UJunoPawnComponent) == 0x000008, "Wrong alignment on UJunoPawnComponent");
static_assert(sizeof(UJunoPawnComponent) == 0x0000B0, "Wrong size on UJunoPawnComponent");
static_assert(offsetof(UJunoPawnComponent, bShouldSpawnDeathChest) == 0x0000A8, "Member 'UJunoPawnComponent::bShouldSpawnDeathChest' has a wrong offset!");

// Class JunoGameNative.JunoPawnPhysicsRepulsionComponent
// 0x0030 (0x00D0 - 0x00A0)
class UJunoPawnPhysicsRepulsionComponent final : public UActorComponent
{
public:
	float                                         PushOutMaxDistance;                                // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x2C];                                      // 0x00A4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void HandleComponentPhysicsStateChange(class UPrimitiveComponent* ChangedComponent, EComponentPhysicsStateChange StateChange);
	void HandleHeldObjectChanged(class AActor* HeldObject);
	void HandleMovementBaseChanged(class UPrimitiveComponent* NewBaseComponent, const class FName BoneName);
	void HandleMovementModeChanged(EMovementMode MovementMode, uint8 CustomMode);
	void SetCapsuleMass(const float InBaseForce);

	float GetCapsuleMass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPawnPhysicsRepulsionComponent">();
	}
	static class UJunoPawnPhysicsRepulsionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPawnPhysicsRepulsionComponent>();
	}
};
static_assert(alignof(UJunoPawnPhysicsRepulsionComponent) == 0x000008, "Wrong alignment on UJunoPawnPhysicsRepulsionComponent");
static_assert(sizeof(UJunoPawnPhysicsRepulsionComponent) == 0x0000D0, "Wrong size on UJunoPawnPhysicsRepulsionComponent");
static_assert(offsetof(UJunoPawnPhysicsRepulsionComponent, PushOutMaxDistance) == 0x0000A0, "Member 'UJunoPawnPhysicsRepulsionComponent::PushOutMaxDistance' has a wrong offset!");

// Class JunoGameNative.JunoWorldStreamingSourceProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoWorldStreamingSourceProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldStreamingSourceProviderInterface">();
	}
	static class IJunoWorldStreamingSourceProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoWorldStreamingSourceProviderInterface>();
	}
};
static_assert(alignof(IJunoWorldStreamingSourceProviderInterface) == 0x000008, "Wrong alignment on IJunoWorldStreamingSourceProviderInterface");
static_assert(sizeof(IJunoWorldStreamingSourceProviderInterface) == 0x000028, "Wrong size on IJunoWorldStreamingSourceProviderInterface");

// Class JunoGameNative.PlayspaceComponent_JunoAIPersistence
// 0x0120 (0x0218 - 0x00F8)
class UPlayspaceComponent_JunoAIPersistence final : public UFortPlayspaceComponent
{
public:
	uint8                                         Pad_F8[0x120];                                     // 0x00F8(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceComponent_JunoAIPersistence">();
	}
	static class UPlayspaceComponent_JunoAIPersistence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceComponent_JunoAIPersistence>();
	}
};
static_assert(alignof(UPlayspaceComponent_JunoAIPersistence) == 0x000008, "Wrong alignment on UPlayspaceComponent_JunoAIPersistence");
static_assert(sizeof(UPlayspaceComponent_JunoAIPersistence) == 0x000218, "Wrong size on UPlayspaceComponent_JunoAIPersistence");

// Class JunoGameNative.PlayspaceComponent_JunoServerExpiration
// 0x0018 (0x01D0 - 0x01B8)
class UPlayspaceComponent_JunoServerExpiration final : public UPlayspaceComponent_ServerExpiration
{
public:
	bool                                          bUseConfigAlertDataList;                           // 0x01B8(0x0001)(ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FServerExpirationAlertData>     ConfigAlertDataList;                               // 0x01C0(0x0010)(ZeroConstructor, Transient, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceComponent_JunoServerExpiration">();
	}
	static class UPlayspaceComponent_JunoServerExpiration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceComponent_JunoServerExpiration>();
	}
};
static_assert(alignof(UPlayspaceComponent_JunoServerExpiration) == 0x000008, "Wrong alignment on UPlayspaceComponent_JunoServerExpiration");
static_assert(sizeof(UPlayspaceComponent_JunoServerExpiration) == 0x0001D0, "Wrong size on UPlayspaceComponent_JunoServerExpiration");
static_assert(offsetof(UPlayspaceComponent_JunoServerExpiration, bUseConfigAlertDataList) == 0x0001B8, "Member 'UPlayspaceComponent_JunoServerExpiration::bUseConfigAlertDataList' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoServerExpiration, ConfigAlertDataList) == 0x0001C0, "Member 'UPlayspaceComponent_JunoServerExpiration::ConfigAlertDataList' has a wrong offset!");

// Class JunoGameNative.JunoBuildingActorCountMetric
// 0x0008 (0x0030 - 0x0028)
class UJunoBuildingActorCountMetric final : public UObject
{
public:
	class UDataTable*                             BuildLimitPools;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingActorCountMetric">();
	}
	static class UJunoBuildingActorCountMetric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingActorCountMetric>();
	}
};
static_assert(alignof(UJunoBuildingActorCountMetric) == 0x000008, "Wrong alignment on UJunoBuildingActorCountMetric");
static_assert(sizeof(UJunoBuildingActorCountMetric) == 0x000030, "Wrong size on UJunoBuildingActorCountMetric");
static_assert(offsetof(UJunoBuildingActorCountMetric, BuildLimitPools) == 0x000028, "Member 'UJunoBuildingActorCountMetric::BuildLimitPools' has a wrong offset!");

// Class JunoGameNative.JunoBuildingActorMetric
// 0x01D8 (0x0230 - 0x0058)
class UJunoBuildingActorMetric final : public USpatialMetricInterface
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         MinValue;                                          // 0x0068(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         NetworkRelevantActorCountThreshold;                // 0x0090(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SpatialPrecision;                                  // 0x00B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FJunoTrackedActorKey, struct FJunoRelevantActorTrackingData> ActorCounts;                                       // 0x00E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<struct FJunoTrackedActor>                TrackedActors;                                     // 0x0130(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             TrackedClasses;                                    // 0x0180(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSet<struct FJunoTrackedActorRefreshmentOptions> PendingRefreshments;                               // 0x0190(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<TWeakObjectPtr<class AActor>>            ActorsPendingAdd;                                  // 0x01E0(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBuildingActorMetric">();
	}
	static class UJunoBuildingActorMetric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBuildingActorMetric>();
	}
};
static_assert(alignof(UJunoBuildingActorMetric) == 0x000008, "Wrong alignment on UJunoBuildingActorMetric");
static_assert(sizeof(UJunoBuildingActorMetric) == 0x000230, "Wrong size on UJunoBuildingActorMetric");
static_assert(offsetof(UJunoBuildingActorMetric, MinValue) == 0x000068, "Member 'UJunoBuildingActorMetric::MinValue' has a wrong offset!");
static_assert(offsetof(UJunoBuildingActorMetric, NetworkRelevantActorCountThreshold) == 0x000090, "Member 'UJunoBuildingActorMetric::NetworkRelevantActorCountThreshold' has a wrong offset!");
static_assert(offsetof(UJunoBuildingActorMetric, SpatialPrecision) == 0x0000B8, "Member 'UJunoBuildingActorMetric::SpatialPrecision' has a wrong offset!");
static_assert(offsetof(UJunoBuildingActorMetric, ActorCounts) == 0x0000E0, "Member 'UJunoBuildingActorMetric::ActorCounts' has a wrong offset!");
static_assert(offsetof(UJunoBuildingActorMetric, TrackedActors) == 0x000130, "Member 'UJunoBuildingActorMetric::TrackedActors' has a wrong offset!");
static_assert(offsetof(UJunoBuildingActorMetric, TrackedClasses) == 0x000180, "Member 'UJunoBuildingActorMetric::TrackedClasses' has a wrong offset!");
static_assert(offsetof(UJunoBuildingActorMetric, PendingRefreshments) == 0x000190, "Member 'UJunoBuildingActorMetric::PendingRefreshments' has a wrong offset!");
static_assert(offsetof(UJunoBuildingActorMetric, ActorsPendingAdd) == 0x0001E0, "Member 'UJunoBuildingActorMetric::ActorsPendingAdd' has a wrong offset!");

// Class JunoGameNative.JunoAssetList
// 0x0010 (0x0038 - 0x0028)
class UJunoAssetList final : public UObject
{
public:
	TArray<struct FSoftObjectPath>                Assets;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAssetList">();
	}
	static class UJunoAssetList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAssetList>();
	}
};
static_assert(alignof(UJunoAssetList) == 0x000008, "Wrong alignment on UJunoAssetList");
static_assert(sizeof(UJunoAssetList) == 0x000038, "Wrong size on UJunoAssetList");
static_assert(offsetof(UJunoAssetList, Assets) == 0x000028, "Member 'UJunoAssetList::Assets' has a wrong offset!");

// Class JunoGameNative.JunoCheatManager
// 0x0000 (0x0028 - 0x0028)
class UJunoCheatManager final : public UChildCheatManager
{
public:
	void JunoAdjustAreaAwesomePoints(int32 AwesomePointsDelta);
	void JunoApplyDamageToRadius(const float Radius, const float DamageToApply);
	void JunoCheckInWorldSaveDataAndExitPIE();
	void JunoClearClientFOW(bool bForCurrentTile);
	void JunoClearFOW(bool bForCurrentTile);
	void JunoClearKnowledgeCloudSave();
	void JunoCompleteCurrentGuidedBuildStage();
	void JunoCompleteGuidedBuild();
	void JunoCompleteGuidedBuildToStage(int32 SectionIndex, int32 StageIndex);
	void JunoCreateCurrentWorldCheckpoint();
	void JunoCreateNewWorld(const class FString& Title, int32 AdventureSeed, const class FString& WorldDevMetadata);
	void JunoDeleteAllWorlds();
	void JunoDeleteWorld(const class FString& JunoWorldId);
	void JunoDestroyAllSupportStructures();
	void JunoDestroyCurrentVillage();
	void JunoDisableFreeBuild();
	void JunoDisableModeratorMode();
	void JunoDisableSandbox();
	void JunoDumpAllDeltasAssetReferences();
	void JunoDumpWorldPersistentContents();
	void JunoEnableFreeBuild();
	void JunoEnableModeratorMode();
	void JunoEnableSandbox();
	void JunoEnableSpawnedActorPersistentPlayspaceTracking(const class FName ActorName);
	void JunoForcePlayerTemperature(class FName NewTemperatureTag);
	void JunoForceWeatherState(class FName NewWeatherType, class FName OptionalLocation);
	void JunoListWorlds();
	void JunoLogPersistenceDebugInfo();
	void JunoPrintAreaAwesomeLevelInfo();
	void JunoPrintConnectivityGraphSummary();
	void JunoPrintPersistenceDataReport(bool bShowTemplateData, bool bShowActorInstanceData, bool bShowJunoUpdateActions, bool bShowJunoDeleteActions);
	void JunoPrintWorldSettings();
	void JunoProcessPlayerProgression();
	void JunoProfiler_BuildingActor();
	void JunoProfiler_BuildingJunkyard(int32 NumBuildings, bool bSpawnRandom);
	void JunoProfiler_BuildingPropBundle(const class FString& PropBundleTemplateId);
	void JunoProfiler_BuildingSuburb(int32 NumBuildings);
	void JunoProfiler_Creature();
	void JunoProfiler_Item();
	void JunoResaveAllPersistentPlayspacesActors();
	void JunoResaveAllPersistentPlayspacesActorsAroundPlayer(float Max2DDistance);
	void JunoRevealBuildingTestRecipes();
	void JunoRevealRecipe(class FName RecipeName);
	void JunoRevealRecipesOfCategory(class FName CraftingObjectTag, class FName CategoryTag, class FName SubCategoryTag);
	void JunoSavePersistenceDataCsvReport();
	void JunoSetEmotion(int32 EmotionIndex);
	void JunoShowDualLocalPlayerInventory();
	void JunoTeleportToPersistenceLocationOfInterest();
	void JunoToggleBlockUnownedMCPRecipesKnowledgeWhenUnfiltered();
	void JunoToggleFreeCrafting();
	void JunoToggleKnowledgeDebugMenu();
	void JunoToggleKnowledgeFiltering();
	void JunoTransitionWeatherNow(class FName OptionalLocation);
	void JunoTurnOffWorldSetting(class FName WorldSetting);
	void JunoTurnOnWorldSetting(class FName WorldSetting);
	void JunoUpdateWorldLastAccessTime(const class FString& JunoWorldId);

	void JunoAddEssence(const class FString& EssencePath) const;
	void JunoGiveWeapon(const class FString& WeaponPath) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCheatManager">();
	}
	static class UJunoCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCheatManager>();
	}
};
static_assert(alignof(UJunoCheatManager) == 0x000008, "Wrong alignment on UJunoCheatManager");
static_assert(sizeof(UJunoCheatManager) == 0x000028, "Wrong size on UJunoCheatManager");

// Class JunoGameNative.JunoWeatherPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoWeatherPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWeatherPersistenceFeatureDataInterface">();
	}
	static class IJunoWeatherPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoWeatherPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoWeatherPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoWeatherPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoWeatherPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoWeatherPersistenceFeatureDataInterface");

}

