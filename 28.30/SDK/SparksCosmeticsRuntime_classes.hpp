#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SparksCosmeticsRuntime

#include "Basic.hpp"

#include "SparksCoreRuntime_structs.hpp"
#include "FMJamCoreRuntime_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "ModularGameplay_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_classes.hpp"
#include "SparksCosmeticsRuntime_structs.hpp"


namespace SDK
{

// Class SparksCosmeticsRuntime.FortAnimNotifyState_SpawnSparksProp
// 0x0050 (0x0210 - 0x01C0)
class UFortAnimNotifyState_SpawnSparksProp final : public UFortAnimNotifyState_SpawnProp
{
public:
	ESparksInstrumentType                         InstrumentType;                                    // 0x01C0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldUseLeftHandMesh;                             // 0x01C1(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldUseAuxiliaryMesh;                            // 0x01C2(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C3[0x5];                                      // 0x01C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      SkipActorsWithTag;                                 // 0x01C8(0x0048)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void InitNewNotify(ESparksInstrumentType InType, bool InLeftHand, bool InAuxMesh, class FName InSocketName, const struct FGameplayTagQuery& InSkipActorsWithTag, int32 InPropId, class USkeletalMesh* InDefaultMesh) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotifyState_SpawnSparksProp">();
	}
	static class UFortAnimNotifyState_SpawnSparksProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotifyState_SpawnSparksProp>();
	}
};
static_assert(alignof(UFortAnimNotifyState_SpawnSparksProp) == 0x000010, "Wrong alignment on UFortAnimNotifyState_SpawnSparksProp");
static_assert(sizeof(UFortAnimNotifyState_SpawnSparksProp) == 0x000210, "Wrong size on UFortAnimNotifyState_SpawnSparksProp");
static_assert(offsetof(UFortAnimNotifyState_SpawnSparksProp, InstrumentType) == 0x0001C0, "Member 'UFortAnimNotifyState_SpawnSparksProp::InstrumentType' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_SpawnSparksProp, ShouldUseLeftHandMesh) == 0x0001C1, "Member 'UFortAnimNotifyState_SpawnSparksProp::ShouldUseLeftHandMesh' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_SpawnSparksProp, ShouldUseAuxiliaryMesh) == 0x0001C2, "Member 'UFortAnimNotifyState_SpawnSparksProp::ShouldUseAuxiliaryMesh' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_SpawnSparksProp, SkipActorsWithTag) == 0x0001C8, "Member 'UFortAnimNotifyState_SpawnSparksProp::SkipActorsWithTag' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksAccountItemDefinition
// 0x0010 (0x0750 - 0x0740)
class USparksAccountItemDefinition : public UAthenaCosmeticItemDefinition
{
public:
	uint8                                         Pad_740[0x8];                                      // 0x0740(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESparksAccountItemSubtype                     Subtype;                                           // 0x0748(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_749[0x3];                                      // 0x0749(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Slot;                                              // 0x074C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ESparksInstrumentType GetInstrumentType() const;
	ESparksAccountItemSubtype GetItemSubtype() const;
	void GetVariantChannelOptionNames(const struct FGameplayTag& ChannelTag, class FText* OutChannelName, TArray<class FString>* OutNames) const;
	void GetVariantChannelTags(TArray<struct FGameplayTag>* OutChannelTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksAccountItemDefinition">();
	}
	static class USparksAccountItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksAccountItemDefinition>();
	}
};
static_assert(alignof(USparksAccountItemDefinition) == 0x000008, "Wrong alignment on USparksAccountItemDefinition");
static_assert(sizeof(USparksAccountItemDefinition) == 0x000750, "Wrong size on USparksAccountItemDefinition");
static_assert(offsetof(USparksAccountItemDefinition, Subtype) == 0x000748, "Member 'USparksAccountItemDefinition::Subtype' has a wrong offset!");
static_assert(offsetof(USparksAccountItemDefinition, Slot) == 0x00074C, "Member 'USparksAccountItemDefinition::Slot' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksAuraItemDefinition
// 0x0078 (0x07C8 - 0x0750)
class USparksAuraItemDefinition final : public USparksAccountItemDefinition
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          StartSystem;                                       // 0x0750(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSystemAttachPoint;                            // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_774[0x4];                                      // 0x0774(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          SustainSystem;                                     // 0x0778(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SustainSystemAttachPoint;                          // 0x0798(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79C[0x4];                                      // 0x079C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          StopSystem;                                        // 0x07A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StopSystemAttachPoint;                             // 0x07C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C4[0x4];                                      // 0x07C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksAuraItemDefinition">();
	}
	static class USparksAuraItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksAuraItemDefinition>();
	}
};
static_assert(alignof(USparksAuraItemDefinition) == 0x000008, "Wrong alignment on USparksAuraItemDefinition");
static_assert(sizeof(USparksAuraItemDefinition) == 0x0007C8, "Wrong size on USparksAuraItemDefinition");
static_assert(offsetof(USparksAuraItemDefinition, StartSystem) == 0x000750, "Member 'USparksAuraItemDefinition::StartSystem' has a wrong offset!");
static_assert(offsetof(USparksAuraItemDefinition, StartSystemAttachPoint) == 0x000770, "Member 'USparksAuraItemDefinition::StartSystemAttachPoint' has a wrong offset!");
static_assert(offsetof(USparksAuraItemDefinition, SustainSystem) == 0x000778, "Member 'USparksAuraItemDefinition::SustainSystem' has a wrong offset!");
static_assert(offsetof(USparksAuraItemDefinition, SustainSystemAttachPoint) == 0x000798, "Member 'USparksAuraItemDefinition::SustainSystemAttachPoint' has a wrong offset!");
static_assert(offsetof(USparksAuraItemDefinition, StopSystem) == 0x0007A0, "Member 'USparksAuraItemDefinition::StopSystem' has a wrong offset!");
static_assert(offsetof(USparksAuraItemDefinition, StopSystemAttachPoint) == 0x0007C0, "Member 'USparksAuraItemDefinition::StopSystemAttachPoint' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksCosmeticCatalog
// 0x00F8 (0x0198 - 0x00A0)
class USparksCosmeticCatalog final : public UGameStateComponent
{
public:
	bool                                          bDefsAreInitialized;                               // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class USparksAccountItemDefinition*> ItemDefinitionMap;                                 // 0x00A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FPrimaryAssetId, class USparksAccountItemDefinition*> AssetIDMap;                                        // 0x00F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x50];                                     // 0x0148(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USparksCosmeticCatalog* GetSparksCosmeticCatalog(const class UObject* WorldContextObject);

	class USparksAccountItemDefinition* GetItemDefFromAssetID(const struct FPrimaryAssetId& AssetId);

	const TArray<class FName> GetActiveItemDefNamesForSubtype(ESparksAccountItemSubtype Subtype) const;
	const TArray<class FName> GetActiveItemDefNamesForSubtypeAndInstrument(ESparksAccountItemSubtype Subtype, ESparksInstrumentType Instrument) const;
	class USparksAccountItemDefinition* GetItemDef(class FName InItemName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCosmeticCatalog">();
	}
	static class USparksCosmeticCatalog* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCosmeticCatalog>();
	}
};
static_assert(alignof(USparksCosmeticCatalog) == 0x000008, "Wrong alignment on USparksCosmeticCatalog");
static_assert(sizeof(USparksCosmeticCatalog) == 0x000198, "Wrong size on USparksCosmeticCatalog");
static_assert(offsetof(USparksCosmeticCatalog, bDefsAreInitialized) == 0x0000A0, "Member 'USparksCosmeticCatalog::bDefsAreInitialized' has a wrong offset!");
static_assert(offsetof(USparksCosmeticCatalog, ItemDefinitionMap) == 0x0000A8, "Member 'USparksCosmeticCatalog::ItemDefinitionMap' has a wrong offset!");
static_assert(offsetof(USparksCosmeticCatalog, AssetIDMap) == 0x0000F8, "Member 'USparksCosmeticCatalog::AssetIDMap' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksCosmeticComponent
// 0x03C0 (0x0460 - 0x00A0)
class USparksCosmeticComponent : public UPawnComponent
{
public:
	TMulticastInlineDelegate<void(class USparksAccountItemDefinition* ItemDef)> CosmeticItemChanged;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ESparksAccountItemSubtype Subtype, ESparksInstrumentType InstrumentType)> CosmeticChoiceChanged;                             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadoutFilled;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsLoadoutFilled;                                  // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x57];                                      // 0x00D1(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSparksCosmeticLoadoutData             CurrentLoadout;                                    // 0x0128(0x00F0)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ActiveAura;                                        // 0x0220(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        DefaultAuraItemDefID;                              // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USparksAuraItemDefinition*              AuraItemDef;                                       // 0x0230(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ESparksInstrumentType, struct FPrimaryAssetId> DefaultInstrumentDefIDs;                           // 0x0238(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ESparksInstrumentType, class USparksInstrumentItemDefBase*> InstrumentDefs;                                    // 0x0288(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x80];                                     // 0x02D8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESparksInstrumentType, struct FPrimaryAssetId> DefaultSpotlightAnimDefIDs;                        // 0x0358(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ESparksInstrumentType, class USparksSpotlightAnimDefinition*> SpotlightAnimDefs;                                 // 0x03A8(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x50];                                     // 0x03F8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AllValidJamTracksShortNameCache;                   // 0x0448(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          HasCachedValidJamTracks;                           // 0x0458(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AuraStart();
	void AuraStop();
	void Debug_BP_ShowCosmeticPicker(bool bShow);
	void DebugForceAuraState(bool bShouldBeActive);
	void DoCacheValidJamTracks();
	void GetCosmeticItems(TArray<class USparksAccountItemDefinition*>* ItemDefs);
	class FName GetEquippedJamSongShortnameForIndex(int32 Index_0);
	class FName GetOwnedJamSongShortnameForIndex(int32 Index_0);
	int32 GetOwnedJamTracksCount();
	void OnMaterialOverridesCleared(class AFortPlayerPawn* Pawn);
	void OnWeaponChanged(class AFortWeapon* NewWeapon, class AFortWeapon* PrevWeapon);
	void RefreshMCP();
	void SetActiveAuraItemDef(class USparksAuraItemDefinition* NewAuraItemDef);
	void SetActiveInstrumentItemDef(class USparksInstrumentItemDefBase* InstrumentItemDef);
	void SetActiveItemDef(class USparksAccountItemDefinition* NewItemDef);
	void SetActiveSpotlightAnimDef(class USparksSpotlightAnimDefinition* NewSpotlightDef);
	void SetAuraState(bool bShouldBeActive);
	void SetVariantChoice(ESparksAccountItemSubtype Subtype, ESparksInstrumentType InstrumentType, const struct FGameplayTag& VariantChannel, const class FString& Value);

	ESparksAccountItemSubtype GetAccountItemTypeFromInstrumentType(ESparksInstrumentType Instrument) const;
	bool GetChoice(struct FSparksVariantChoice* OutChoice, ESparksAccountItemSubtype Subtype, ESparksInstrumentType InstrumentType, const struct FGameplayTag& VariantChannel) const;
	const class USparksAccountItemDefinition* GetCosmeticItem(ESparksAccountItemSubtype Subtype, ESparksInstrumentType Instrument) const;
	int32 GetEquippedJamTracksCount() const;
	bool GetInstrumentAuxiliaryCosmetics(ESparksInstrumentType InstrumentType, class USkeletalMesh** OutMesh, class UMaterialInstance** OutMaterial, class UMaterialInstance** OutMaterial2) const;
	bool GetInstrumentCosmetics(ESparksInstrumentType InstrumentType, class USkeletalMesh** OutMesh, class UMaterialInstance** OutMaterial, class USkeletalMesh** OutLHMesh, class UMaterialInstance** OutLHMaterial) const;
	class ULevelSequence* GetSpotlightAnim(ESparksInstrumentType InstrumentType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCosmeticComponent">();
	}
	static class USparksCosmeticComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCosmeticComponent>();
	}
};
static_assert(alignof(USparksCosmeticComponent) == 0x000008, "Wrong alignment on USparksCosmeticComponent");
static_assert(sizeof(USparksCosmeticComponent) == 0x000460, "Wrong size on USparksCosmeticComponent");
static_assert(offsetof(USparksCosmeticComponent, CosmeticItemChanged) == 0x0000A0, "Member 'USparksCosmeticComponent::CosmeticItemChanged' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, CosmeticChoiceChanged) == 0x0000B0, "Member 'USparksCosmeticComponent::CosmeticChoiceChanged' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, OnLoadoutFilled) == 0x0000C0, "Member 'USparksCosmeticComponent::OnLoadoutFilled' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, bIsLoadoutFilled) == 0x0000D0, "Member 'USparksCosmeticComponent::bIsLoadoutFilled' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, CurrentLoadout) == 0x000128, "Member 'USparksCosmeticComponent::CurrentLoadout' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, ActiveAura) == 0x000220, "Member 'USparksCosmeticComponent::ActiveAura' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, DefaultAuraItemDefID) == 0x000228, "Member 'USparksCosmeticComponent::DefaultAuraItemDefID' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, AuraItemDef) == 0x000230, "Member 'USparksCosmeticComponent::AuraItemDef' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, DefaultInstrumentDefIDs) == 0x000238, "Member 'USparksCosmeticComponent::DefaultInstrumentDefIDs' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, InstrumentDefs) == 0x000288, "Member 'USparksCosmeticComponent::InstrumentDefs' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, DefaultSpotlightAnimDefIDs) == 0x000358, "Member 'USparksCosmeticComponent::DefaultSpotlightAnimDefIDs' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, SpotlightAnimDefs) == 0x0003A8, "Member 'USparksCosmeticComponent::SpotlightAnimDefs' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, AllValidJamTracksShortNameCache) == 0x000448, "Member 'USparksCosmeticComponent::AllValidJamTracksShortNameCache' has a wrong offset!");
static_assert(offsetof(USparksCosmeticComponent, HasCachedValidJamTracks) == 0x000458, "Member 'USparksCosmeticComponent::HasCachedValidJamTracks' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksCosmeticsCheatManager
// 0x0000 (0x0028 - 0x0028)
class USparksCosmeticsCheatManager final : public UChildCheatManager
{
public:
	void GrantSparksCosmeticsLoadedAssets() const;
	void GrantSparksSongsLoadedAssets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCosmeticsCheatManager">();
	}
	static class USparksCosmeticsCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCosmeticsCheatManager>();
	}
};
static_assert(alignof(USparksCosmeticsCheatManager) == 0x000008, "Wrong alignment on USparksCosmeticsCheatManager");
static_assert(sizeof(USparksCosmeticsCheatManager) == 0x000028, "Wrong size on USparksCosmeticsCheatManager");

// Class SparksCosmeticsRuntime.SparksCosmeticsSettings
// 0x00D0 (0x0100 - 0x0030)
class USparksCosmeticsSettings final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortItemPreviewActor>      SparksCosmeticPreviewActorClass;                   // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortItemPreviewActor>      SparksPreviewCameraActorClass;                     // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortItemPreviewActor>      SparksAuraPreviewActorClass;                       // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortItemPreviewActor>      SparksAuraDisplayActorClass;                       // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortItemPreviewActor>      SparksSongPreviewActorClass;                       // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     SparksSongPrefabActorClass;                        // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCosmeticLoadoutSchema*                 SparksLoadoutSchema;                               // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortUICameraFrameTargetBounds         GuitarCameraFramingBounds;                         // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFortUICameraFrameTargetBounds         BassCameraFramingBounds;                           // 0x0090(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFortUICameraFrameTargetBounds         DrumCameraFramingBounds;                           // 0x00B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFortUICameraFrameTargetBounds         MicCameraFramingBounds;                            // 0x00D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                RandomCharacters;                                  // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCosmeticsSettings">();
	}
	static class USparksCosmeticsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCosmeticsSettings>();
	}
};
static_assert(alignof(USparksCosmeticsSettings) == 0x000008, "Wrong alignment on USparksCosmeticsSettings");
static_assert(sizeof(USparksCosmeticsSettings) == 0x000100, "Wrong size on USparksCosmeticsSettings");
static_assert(offsetof(USparksCosmeticsSettings, SparksCosmeticPreviewActorClass) == 0x000038, "Member 'USparksCosmeticsSettings::SparksCosmeticPreviewActorClass' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, SparksPreviewCameraActorClass) == 0x000040, "Member 'USparksCosmeticsSettings::SparksPreviewCameraActorClass' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, SparksAuraPreviewActorClass) == 0x000048, "Member 'USparksCosmeticsSettings::SparksAuraPreviewActorClass' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, SparksAuraDisplayActorClass) == 0x000050, "Member 'USparksCosmeticsSettings::SparksAuraDisplayActorClass' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, SparksSongPreviewActorClass) == 0x000058, "Member 'USparksCosmeticsSettings::SparksSongPreviewActorClass' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, SparksSongPrefabActorClass) == 0x000060, "Member 'USparksCosmeticsSettings::SparksSongPrefabActorClass' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, SparksLoadoutSchema) == 0x000068, "Member 'USparksCosmeticsSettings::SparksLoadoutSchema' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, GuitarCameraFramingBounds) == 0x000070, "Member 'USparksCosmeticsSettings::GuitarCameraFramingBounds' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, BassCameraFramingBounds) == 0x000090, "Member 'USparksCosmeticsSettings::BassCameraFramingBounds' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, DrumCameraFramingBounds) == 0x0000B0, "Member 'USparksCosmeticsSettings::DrumCameraFramingBounds' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, MicCameraFramingBounds) == 0x0000D0, "Member 'USparksCosmeticsSettings::MicCameraFramingBounds' has a wrong offset!");
static_assert(offsetof(USparksCosmeticsSettings, RandomCharacters) == 0x0000F0, "Member 'USparksCosmeticsSettings::RandomCharacters' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksCosmetics_BPFL
// 0x0000 (0x0028 - 0x0028)
class USparksCosmetics_BPFL final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCosmetics_BPFL">();
	}
	static class USparksCosmetics_BPFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCosmetics_BPFL>();
	}
};
static_assert(alignof(USparksCosmetics_BPFL) == 0x000008, "Wrong alignment on USparksCosmetics_BPFL");
static_assert(sizeof(USparksCosmetics_BPFL) == 0x000028, "Wrong size on USparksCosmetics_BPFL");

// Class SparksCosmeticsRuntime.SparksInstrumentComponentBase
// 0x0000 (0x00A0 - 0x00A0)
class USparksInstrumentComponentBase final : public UActorComponent
{
public:
	ESparksInstrumentType GetInstrumentType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksInstrumentComponentBase">();
	}
	static class USparksInstrumentComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksInstrumentComponentBase>();
	}
};
static_assert(alignof(USparksInstrumentComponentBase) == 0x000008, "Wrong alignment on USparksInstrumentComponentBase");
static_assert(sizeof(USparksInstrumentComponentBase) == 0x0000A0, "Wrong size on USparksInstrumentComponentBase");

// Class SparksCosmeticsRuntime.SparksInstrumentItemDefBase
// 0x0140 (0x0890 - 0x0750)
class USparksInstrumentItemDefBase : public USparksAccountItemDefinition
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0750(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           LeftHandMesh;                                      // 0x0770(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           AuxiliaryMesh;                                     // 0x0790(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x07B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       LeftHandMaterial;                                  // 0x07D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       AuxiliaryMaterial;                                 // 0x07F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       AuxiliaryMaterial2;                                // 0x0810(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFXSystemAsset>          MainFXSystem;                                      // 0x0830(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFXSystemAsset>          LHFXSystem;                                        // 0x0850(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFXSystemAsset>          AuxFXSystem;                                       // 0x0870(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UFXSystemAsset* GetAuxFXSystem(const struct FSparksVariantChoices& Choices) const;
	class UMaterialInstance* GetAuxiliaryMaterial(const struct FSparksVariantChoices& Choices) const;
	class UMaterialInstance* GetAuxiliaryMaterial2(const struct FSparksVariantChoices& Choices) const;
	class USkeletalMesh* GetAuxiliaryMesh(const struct FSparksVariantChoices& Choices) const;
	class UMaterialInstance* GetLeftHandMaterial(const struct FSparksVariantChoices& Choices) const;
	class USkeletalMesh* GetLeftHandMesh(const struct FSparksVariantChoices& Choices) const;
	class UFXSystemAsset* GetLHFXSystem(const struct FSparksVariantChoices& Choices) const;
	class UFXSystemAsset* GetMainFXSystem(const struct FSparksVariantChoices& Choices) const;
	class UMaterialInstance* GetMaterial(const struct FSparksVariantChoices& Choices) const;
	class USkeletalMesh* GetMesh(const struct FSparksVariantChoices& Choices) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksInstrumentItemDefBase">();
	}
	static class USparksInstrumentItemDefBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksInstrumentItemDefBase>();
	}
};
static_assert(alignof(USparksInstrumentItemDefBase) == 0x000008, "Wrong alignment on USparksInstrumentItemDefBase");
static_assert(sizeof(USparksInstrumentItemDefBase) == 0x000890, "Wrong size on USparksInstrumentItemDefBase");
static_assert(offsetof(USparksInstrumentItemDefBase, Mesh) == 0x000750, "Member 'USparksInstrumentItemDefBase::Mesh' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, LeftHandMesh) == 0x000770, "Member 'USparksInstrumentItemDefBase::LeftHandMesh' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, AuxiliaryMesh) == 0x000790, "Member 'USparksInstrumentItemDefBase::AuxiliaryMesh' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, Material) == 0x0007B0, "Member 'USparksInstrumentItemDefBase::Material' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, LeftHandMaterial) == 0x0007D0, "Member 'USparksInstrumentItemDefBase::LeftHandMaterial' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, AuxiliaryMaterial) == 0x0007F0, "Member 'USparksInstrumentItemDefBase::AuxiliaryMaterial' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, AuxiliaryMaterial2) == 0x000810, "Member 'USparksInstrumentItemDefBase::AuxiliaryMaterial2' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, MainFXSystem) == 0x000830, "Member 'USparksInstrumentItemDefBase::MainFXSystem' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, LHFXSystem) == 0x000850, "Member 'USparksInstrumentItemDefBase::LHFXSystem' has a wrong offset!");
static_assert(offsetof(USparksInstrumentItemDefBase, AuxFXSystem) == 0x000870, "Member 'USparksInstrumentItemDefBase::AuxFXSystem' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksGuitarItemDefinition
// 0x0000 (0x0890 - 0x0890)
class USparksGuitarItemDefinition final : public USparksInstrumentItemDefBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksGuitarItemDefinition">();
	}
	static class USparksGuitarItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksGuitarItemDefinition>();
	}
};
static_assert(alignof(USparksGuitarItemDefinition) == 0x000008, "Wrong alignment on USparksGuitarItemDefinition");
static_assert(sizeof(USparksGuitarItemDefinition) == 0x000890, "Wrong size on USparksGuitarItemDefinition");

// Class SparksCosmeticsRuntime.SparksBassItemDefinition
// 0x0000 (0x0890 - 0x0890)
class USparksBassItemDefinition final : public USparksInstrumentItemDefBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksBassItemDefinition">();
	}
	static class USparksBassItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksBassItemDefinition>();
	}
};
static_assert(alignof(USparksBassItemDefinition) == 0x000008, "Wrong alignment on USparksBassItemDefinition");
static_assert(sizeof(USparksBassItemDefinition) == 0x000890, "Wrong size on USparksBassItemDefinition");

// Class SparksCosmeticsRuntime.SparksDrumItemDefinition
// 0x0000 (0x0890 - 0x0890)
class USparksDrumItemDefinition final : public USparksInstrumentItemDefBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksDrumItemDefinition">();
	}
	static class USparksDrumItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksDrumItemDefinition>();
	}
};
static_assert(alignof(USparksDrumItemDefinition) == 0x000008, "Wrong alignment on USparksDrumItemDefinition");
static_assert(sizeof(USparksDrumItemDefinition) == 0x000890, "Wrong size on USparksDrumItemDefinition");

// Class SparksCosmeticsRuntime.SparksMicItemDefinition
// 0x0000 (0x0890 - 0x0890)
class USparksMicItemDefinition final : public USparksInstrumentItemDefBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksMicItemDefinition">();
	}
	static class USparksMicItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksMicItemDefinition>();
	}
};
static_assert(alignof(USparksMicItemDefinition) == 0x000008, "Wrong alignment on USparksMicItemDefinition");
static_assert(sizeof(USparksMicItemDefinition) == 0x000890, "Wrong size on USparksMicItemDefinition");

// Class SparksCosmeticsRuntime.SparksKeyboardItemDefinition
// 0x0000 (0x0890 - 0x0890)
class USparksKeyboardItemDefinition final : public USparksInstrumentItemDefBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksKeyboardItemDefinition">();
	}
	static class USparksKeyboardItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksKeyboardItemDefinition>();
	}
};
static_assert(alignof(USparksKeyboardItemDefinition) == 0x000008, "Wrong alignment on USparksKeyboardItemDefinition");
static_assert(sizeof(USparksKeyboardItemDefinition) == 0x000890, "Wrong size on USparksKeyboardItemDefinition");

// Class SparksCosmeticsRuntime.SparksInstrumentPreviewActor
// 0x0040 (0x0470 - 0x0430)
class ASparksInstrumentPreviewActor : public AFortItemPreviewActor
{
public:
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USparksInstrumentItemDefBase> ItemDef;                                           // 0x0440(0x0020)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(TScriptInterface<class IFortUICameraFrameTargetInterface> Object)> OnSettingsChangedDelegate;                         // 0x0460(0x000C)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FSparksVariantChoices GetCurrentChoices() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksInstrumentPreviewActor">();
	}
	static class ASparksInstrumentPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASparksInstrumentPreviewActor>();
	}
};
static_assert(alignof(ASparksInstrumentPreviewActor) == 0x000008, "Wrong alignment on ASparksInstrumentPreviewActor");
static_assert(sizeof(ASparksInstrumentPreviewActor) == 0x000470, "Wrong size on ASparksInstrumentPreviewActor");
static_assert(offsetof(ASparksInstrumentPreviewActor, ItemDef) == 0x000440, "Member 'ASparksInstrumentPreviewActor::ItemDef' has a wrong offset!");
static_assert(offsetof(ASparksInstrumentPreviewActor, OnSettingsChangedDelegate) == 0x000460, "Member 'ASparksInstrumentPreviewActor::OnSettingsChangedDelegate' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksItemPreviewOffPawnActor
// 0x0000 (0x0488 - 0x0488)
class ASparksItemPreviewOffPawnActor : public AFortItemPreviewOffPawnActor
{
public:
	ESparksInstrumentType GetInstrumentType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksItemPreviewOffPawnActor">();
	}
	static class ASparksItemPreviewOffPawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASparksItemPreviewOffPawnActor>();
	}
};
static_assert(alignof(ASparksItemPreviewOffPawnActor) == 0x000008, "Wrong alignment on ASparksItemPreviewOffPawnActor");
static_assert(sizeof(ASparksItemPreviewOffPawnActor) == 0x000488, "Wrong size on ASparksItemPreviewOffPawnActor");

// Class SparksCosmeticsRuntime.SparksItemPreviewOnPawnActor
// 0x0000 (0x0700 - 0x0700)
class ASparksItemPreviewOnPawnActor : public AFortItemPreviewOnPawnActor
{
public:
	class UNiagaraComponent*                      ActiveAura;                                        // 0x06F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksItemPreviewOnPawnActor">();
	}
	static class ASparksItemPreviewOnPawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASparksItemPreviewOnPawnActor>();
	}
};
static_assert(alignof(ASparksItemPreviewOnPawnActor) == 0x000010, "Wrong alignment on ASparksItemPreviewOnPawnActor");
static_assert(sizeof(ASparksItemPreviewOnPawnActor) == 0x000700, "Wrong size on ASparksItemPreviewOnPawnActor");
static_assert(offsetof(ASparksItemPreviewOnPawnActor, ActiveAura) == 0x0006F8, "Member 'ASparksItemPreviewOnPawnActor::ActiveAura' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksJamEmoteItemDefinition
// 0x0010 (0x0978 - 0x0968)
class USparksJamEmoteItemDefinition final : public UAthenaDanceItemDefinition
{
public:
	class USparksSongItemDefinition*              SongItemDef;                                       // 0x0968(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFMJamLoopType                                LoopType;                                          // 0x0970(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_971[0x7];                                      // 0x0971(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EFMJamLoopType GetJamLoopType() const;
	const class UCatalogData* GetJamSongMetaData(const class UObject* WorldContextObject) const;
	class FName GetJamSongShortName(const class UObject* WorldContextObject) const;
	class USparksSongItemDefinition* GetSongItemDef() const;
	bool IsJamLoopEnabled(const class AFortPlayerController* PlayerController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksJamEmoteItemDefinition">();
	}
	static class USparksJamEmoteItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksJamEmoteItemDefinition>();
	}
};
static_assert(alignof(USparksJamEmoteItemDefinition) == 0x000008, "Wrong alignment on USparksJamEmoteItemDefinition");
static_assert(sizeof(USparksJamEmoteItemDefinition) == 0x000978, "Wrong size on USparksJamEmoteItemDefinition");
static_assert(offsetof(USparksJamEmoteItemDefinition, SongItemDef) == 0x000968, "Member 'USparksJamEmoteItemDefinition::SongItemDef' has a wrong offset!");
static_assert(offsetof(USparksJamEmoteItemDefinition, LoopType) == 0x000970, "Member 'USparksJamEmoteItemDefinition::LoopType' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksPlayerStateComponent
// 0x0008 (0x00A8 - 0x00A0)
class USparksPlayerStateComponent : public UPlayerStateComponent
{
public:
	ESparksInstrumentType                         SparksInstrumentChoice;                            // 0x00A0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSparksInstrumentChoice(ESparksInstrumentType Instrument);

	ESparksInstrumentType GetSparksInstrumentChoice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksPlayerStateComponent">();
	}
	static class USparksPlayerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksPlayerStateComponent>();
	}
};
static_assert(alignof(USparksPlayerStateComponent) == 0x000008, "Wrong alignment on USparksPlayerStateComponent");
static_assert(sizeof(USparksPlayerStateComponent) == 0x0000A8, "Wrong size on USparksPlayerStateComponent");
static_assert(offsetof(USparksPlayerStateComponent, SparksInstrumentChoice) == 0x0000A0, "Member 'USparksPlayerStateComponent::SparksInstrumentChoice' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksSongItemDefinition
// 0x0020 (0x0770 - 0x0750)
class USparksSongItemDefinition final : public USparksAccountItemDefinition
{
public:
	class USparksJamEmoteItemDefinition*          JamEmote_Vox;                                      // 0x0750(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USparksJamEmoteItemDefinition*          JamEmote_Lead;                                     // 0x0758(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USparksJamEmoteItemDefinition*          JamEmote_Bass;                                     // 0x0760(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USparksJamEmoteItemDefinition*          JamEmote_Drum;                                     // 0x0768(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksSongItemDefinition">();
	}
	static class USparksSongItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksSongItemDefinition>();
	}
};
static_assert(alignof(USparksSongItemDefinition) == 0x000008, "Wrong alignment on USparksSongItemDefinition");
static_assert(sizeof(USparksSongItemDefinition) == 0x000770, "Wrong size on USparksSongItemDefinition");
static_assert(offsetof(USparksSongItemDefinition, JamEmote_Vox) == 0x000750, "Member 'USparksSongItemDefinition::JamEmote_Vox' has a wrong offset!");
static_assert(offsetof(USparksSongItemDefinition, JamEmote_Lead) == 0x000758, "Member 'USparksSongItemDefinition::JamEmote_Lead' has a wrong offset!");
static_assert(offsetof(USparksSongItemDefinition, JamEmote_Bass) == 0x000760, "Member 'USparksSongItemDefinition::JamEmote_Bass' has a wrong offset!");
static_assert(offsetof(USparksSongItemDefinition, JamEmote_Drum) == 0x000768, "Member 'USparksSongItemDefinition::JamEmote_Drum' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksSongPreviewActor
// 0x0018 (0x02A8 - 0x0290)
class ASparksSongPreviewActor : public AActor
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SongShortName;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoundsScale;                                       // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSongTextureLoaded(class UTexture2D* CoverArt);
	void StartSongPreview();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksSongPreviewActor">();
	}
	static class ASparksSongPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASparksSongPreviewActor>();
	}
};
static_assert(alignof(ASparksSongPreviewActor) == 0x000008, "Wrong alignment on ASparksSongPreviewActor");
static_assert(sizeof(ASparksSongPreviewActor) == 0x0002A8, "Wrong size on ASparksSongPreviewActor");
static_assert(offsetof(ASparksSongPreviewActor, SongShortName) == 0x0002A0, "Member 'ASparksSongPreviewActor::SongShortName' has a wrong offset!");
static_assert(offsetof(ASparksSongPreviewActor, BoundsScale) == 0x0002A4, "Member 'ASparksSongPreviewActor::BoundsScale' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksSpotlightAnimDefinition
// 0x0028 (0x0778 - 0x0750)
class USparksSpotlightAnimDefinition : public USparksAccountItemDefinition
{
public:
	TSoftObjectPtr<class ULevelSequence>          SpotlightSequence;                                 // 0x0750(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESparksInstrumentType                         InstrumentType;                                    // 0x0770(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_771[0x7];                                      // 0x0771(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksSpotlightAnimDefinition">();
	}
	static class USparksSpotlightAnimDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksSpotlightAnimDefinition>();
	}
};
static_assert(alignof(USparksSpotlightAnimDefinition) == 0x000008, "Wrong alignment on USparksSpotlightAnimDefinition");
static_assert(sizeof(USparksSpotlightAnimDefinition) == 0x000778, "Wrong size on USparksSpotlightAnimDefinition");
static_assert(offsetof(USparksSpotlightAnimDefinition, SpotlightSequence) == 0x000750, "Member 'USparksSpotlightAnimDefinition::SpotlightSequence' has a wrong offset!");
static_assert(offsetof(USparksSpotlightAnimDefinition, InstrumentType) == 0x000770, "Member 'USparksSpotlightAnimDefinition::InstrumentType' has a wrong offset!");

// Class SparksCosmeticsRuntime.SparksGuitarSpotlightDefinition
// 0x0000 (0x0778 - 0x0778)
class USparksGuitarSpotlightDefinition final : public USparksSpotlightAnimDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksGuitarSpotlightDefinition">();
	}
	static class USparksGuitarSpotlightDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksGuitarSpotlightDefinition>();
	}
};
static_assert(alignof(USparksGuitarSpotlightDefinition) == 0x000008, "Wrong alignment on USparksGuitarSpotlightDefinition");
static_assert(sizeof(USparksGuitarSpotlightDefinition) == 0x000778, "Wrong size on USparksGuitarSpotlightDefinition");

// Class SparksCosmeticsRuntime.SparksDrumSpotlightDefinition
// 0x0000 (0x0778 - 0x0778)
class USparksDrumSpotlightDefinition final : public USparksSpotlightAnimDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksDrumSpotlightDefinition">();
	}
	static class USparksDrumSpotlightDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksDrumSpotlightDefinition>();
	}
};
static_assert(alignof(USparksDrumSpotlightDefinition) == 0x000008, "Wrong alignment on USparksDrumSpotlightDefinition");
static_assert(sizeof(USparksDrumSpotlightDefinition) == 0x000778, "Wrong size on USparksDrumSpotlightDefinition");

// Class SparksCosmeticsRuntime.SparksBassSpotlightDefinition
// 0x0000 (0x0778 - 0x0778)
class USparksBassSpotlightDefinition final : public USparksSpotlightAnimDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksBassSpotlightDefinition">();
	}
	static class USparksBassSpotlightDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksBassSpotlightDefinition>();
	}
};
static_assert(alignof(USparksBassSpotlightDefinition) == 0x000008, "Wrong alignment on USparksBassSpotlightDefinition");
static_assert(sizeof(USparksBassSpotlightDefinition) == 0x000778, "Wrong size on USparksBassSpotlightDefinition");

// Class SparksCosmeticsRuntime.SparksMicSpotlightDefinition
// 0x0000 (0x0778 - 0x0778)
class USparksMicSpotlightDefinition final : public USparksSpotlightAnimDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksMicSpotlightDefinition">();
	}
	static class USparksMicSpotlightDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksMicSpotlightDefinition>();
	}
};
static_assert(alignof(USparksMicSpotlightDefinition) == 0x000008, "Wrong alignment on USparksMicSpotlightDefinition");
static_assert(sizeof(USparksMicSpotlightDefinition) == 0x000778, "Wrong size on USparksMicSpotlightDefinition");

// Class SparksCosmeticsRuntime.SparksKeyboardSpotlightDefinition
// 0x0000 (0x0778 - 0x0778)
class USparksKeyboardSpotlightDefinition final : public USparksSpotlightAnimDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksKeyboardSpotlightDefinition">();
	}
	static class USparksKeyboardSpotlightDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksKeyboardSpotlightDefinition>();
	}
};
static_assert(alignof(USparksKeyboardSpotlightDefinition) == 0x000008, "Wrong alignment on USparksKeyboardSpotlightDefinition");
static_assert(sizeof(USparksKeyboardSpotlightDefinition) == 0x000778, "Wrong size on USparksKeyboardSpotlightDefinition");

}

