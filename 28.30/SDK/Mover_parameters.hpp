#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mover

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Mover_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function Mover.TurnGeneratorInterface.GetTurn
// 0x0200 (0x0200 - 0x0000)
struct TurnGeneratorInterface_GetTurn final
{
public:
	struct FRotator                               TargetOrientation;                                 // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMoverTickStartData                    FullStartState;                                    // 0x0018(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FMoverDefaultSyncState                 MoverState;                                        // 0x0050(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMoverTimeStep                         TimeStep;                                          // 0x0140(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FProposedMove                          ProposedMove;                                      // 0x0150(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UMoverBlackboard*                       SimBlackboard;                                     // 0x01D8(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x01E0(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TurnGeneratorInterface_GetTurn) == 0x000010, "Wrong alignment on TurnGeneratorInterface_GetTurn");
static_assert(sizeof(TurnGeneratorInterface_GetTurn) == 0x000200, "Wrong size on TurnGeneratorInterface_GetTurn");
static_assert(offsetof(TurnGeneratorInterface_GetTurn, TargetOrientation) == 0x000000, "Member 'TurnGeneratorInterface_GetTurn::TargetOrientation' has a wrong offset!");
static_assert(offsetof(TurnGeneratorInterface_GetTurn, FullStartState) == 0x000018, "Member 'TurnGeneratorInterface_GetTurn::FullStartState' has a wrong offset!");
static_assert(offsetof(TurnGeneratorInterface_GetTurn, MoverState) == 0x000050, "Member 'TurnGeneratorInterface_GetTurn::MoverState' has a wrong offset!");
static_assert(offsetof(TurnGeneratorInterface_GetTurn, TimeStep) == 0x000140, "Member 'TurnGeneratorInterface_GetTurn::TimeStep' has a wrong offset!");
static_assert(offsetof(TurnGeneratorInterface_GetTurn, ProposedMove) == 0x000150, "Member 'TurnGeneratorInterface_GetTurn::ProposedMove' has a wrong offset!");
static_assert(offsetof(TurnGeneratorInterface_GetTurn, SimBlackboard) == 0x0001D8, "Member 'TurnGeneratorInterface_GetTurn::SimBlackboard' has a wrong offset!");
static_assert(offsetof(TurnGeneratorInterface_GetTurn, ReturnValue) == 0x0001E0, "Member 'TurnGeneratorInterface_GetTurn::ReturnValue' has a wrong offset!");

// Function Mover.MoverBasePawn.GetMoverComponent
// 0x0008 (0x0008 - 0x0000)
struct MoverBasePawn_GetMoverComponent final
{
public:
	class UMoverComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverBasePawn_GetMoverComponent) == 0x000008, "Wrong alignment on MoverBasePawn_GetMoverComponent");
static_assert(sizeof(MoverBasePawn_GetMoverComponent) == 0x000008, "Wrong size on MoverBasePawn_GetMoverComponent");
static_assert(offsetof(MoverBasePawn_GetMoverComponent, ReturnValue) == 0x000000, "Member 'MoverBasePawn_GetMoverComponent::ReturnValue' has a wrong offset!");

// Function Mover.MoverDataModelBlueprintLibrary.GetLocationFromSyncState
// 0x0110 (0x0110 - 0x0000)
struct MoverDataModelBlueprintLibrary_GetLocationFromSyncState final
{
public:
	struct FMoverDefaultSyncState                 SyncState;                                         // 0x0000(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x00F0(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoverDataModelBlueprintLibrary_GetLocationFromSyncState) == 0x000010, "Wrong alignment on MoverDataModelBlueprintLibrary_GetLocationFromSyncState");
static_assert(sizeof(MoverDataModelBlueprintLibrary_GetLocationFromSyncState) == 0x000110, "Wrong size on MoverDataModelBlueprintLibrary_GetLocationFromSyncState");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetLocationFromSyncState, SyncState) == 0x000000, "Member 'MoverDataModelBlueprintLibrary_GetLocationFromSyncState::SyncState' has a wrong offset!");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetLocationFromSyncState, ReturnValue) == 0x0000F0, "Member 'MoverDataModelBlueprintLibrary_GetLocationFromSyncState::ReturnValue' has a wrong offset!");

// Function Mover.MoverDataModelBlueprintLibrary.GetMoveDirectionIntentFromInputs
// 0x0088 (0x0088 - 0x0000)
struct MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs final
{
public:
	struct FKinematicDefaultInputs                Inputs;                                            // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0070(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs) == 0x000008, "Wrong alignment on MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs");
static_assert(sizeof(MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs) == 0x000088, "Wrong size on MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs, Inputs) == 0x000000, "Member 'MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs::Inputs' has a wrong offset!");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs, ReturnValue) == 0x000070, "Member 'MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs::ReturnValue' has a wrong offset!");

// Function Mover.MoverDataModelBlueprintLibrary.GetMoveDirectionIntentFromSyncState
// 0x0110 (0x0110 - 0x0000)
struct MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState final
{
public:
	struct FMoverDefaultSyncState                 SyncState;                                         // 0x0000(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x00F0(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState) == 0x000010, "Wrong alignment on MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState");
static_assert(sizeof(MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState) == 0x000110, "Wrong size on MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState, SyncState) == 0x000000, "Member 'MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState::SyncState' has a wrong offset!");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState, ReturnValue) == 0x0000F0, "Member 'MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState::ReturnValue' has a wrong offset!");

// Function Mover.MoverDataModelBlueprintLibrary.GetOrientationFromSyncState
// 0x0110 (0x0110 - 0x0000)
struct MoverDataModelBlueprintLibrary_GetOrientationFromSyncState final
{
public:
	struct FMoverDefaultSyncState                 SyncState;                                         // 0x0000(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x00F0(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoverDataModelBlueprintLibrary_GetOrientationFromSyncState) == 0x000010, "Wrong alignment on MoverDataModelBlueprintLibrary_GetOrientationFromSyncState");
static_assert(sizeof(MoverDataModelBlueprintLibrary_GetOrientationFromSyncState) == 0x000110, "Wrong size on MoverDataModelBlueprintLibrary_GetOrientationFromSyncState");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetOrientationFromSyncState, SyncState) == 0x000000, "Member 'MoverDataModelBlueprintLibrary_GetOrientationFromSyncState::SyncState' has a wrong offset!");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetOrientationFromSyncState, ReturnValue) == 0x0000F0, "Member 'MoverDataModelBlueprintLibrary_GetOrientationFromSyncState::ReturnValue' has a wrong offset!");

// Function Mover.MoverDataModelBlueprintLibrary.GetVelocityFromSyncState
// 0x0110 (0x0110 - 0x0000)
struct MoverDataModelBlueprintLibrary_GetVelocityFromSyncState final
{
public:
	struct FMoverDefaultSyncState                 SyncState;                                         // 0x0000(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x00F0(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoverDataModelBlueprintLibrary_GetVelocityFromSyncState) == 0x000010, "Wrong alignment on MoverDataModelBlueprintLibrary_GetVelocityFromSyncState");
static_assert(sizeof(MoverDataModelBlueprintLibrary_GetVelocityFromSyncState) == 0x000110, "Wrong size on MoverDataModelBlueprintLibrary_GetVelocityFromSyncState");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetVelocityFromSyncState, SyncState) == 0x000000, "Member 'MoverDataModelBlueprintLibrary_GetVelocityFromSyncState::SyncState' has a wrong offset!");
static_assert(offsetof(MoverDataModelBlueprintLibrary_GetVelocityFromSyncState, ReturnValue) == 0x0000F0, "Member 'MoverDataModelBlueprintLibrary_GetVelocityFromSyncState::ReturnValue' has a wrong offset!");

// Function Mover.MoverDebugComponent.OnHistoryTrackingRollback
// 0x0020 (0x0020 - 0x0000)
struct MoverDebugComponent_OnHistoryTrackingRollback final
{
public:
	struct FMoverTimeStep                         NewTimeStep;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMoverTimeStep                         InvalidatedTimeStep;                               // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverDebugComponent_OnHistoryTrackingRollback) == 0x000004, "Wrong alignment on MoverDebugComponent_OnHistoryTrackingRollback");
static_assert(sizeof(MoverDebugComponent_OnHistoryTrackingRollback) == 0x000020, "Wrong size on MoverDebugComponent_OnHistoryTrackingRollback");
static_assert(offsetof(MoverDebugComponent_OnHistoryTrackingRollback, NewTimeStep) == 0x000000, "Member 'MoverDebugComponent_OnHistoryTrackingRollback::NewTimeStep' has a wrong offset!");
static_assert(offsetof(MoverDebugComponent_OnHistoryTrackingRollback, InvalidatedTimeStep) == 0x000010, "Member 'MoverDebugComponent_OnHistoryTrackingRollback::InvalidatedTimeStep' has a wrong offset!");

// Function Mover.MoverDebugComponent.OnMovementSimRollback
// 0x0020 (0x0020 - 0x0000)
struct MoverDebugComponent_OnMovementSimRollback final
{
public:
	struct FMoverTimeStep                         NewTimeStep;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMoverTimeStep                         InvalidatedTimeStep;                               // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverDebugComponent_OnMovementSimRollback) == 0x000004, "Wrong alignment on MoverDebugComponent_OnMovementSimRollback");
static_assert(sizeof(MoverDebugComponent_OnMovementSimRollback) == 0x000020, "Wrong size on MoverDebugComponent_OnMovementSimRollback");
static_assert(offsetof(MoverDebugComponent_OnMovementSimRollback, NewTimeStep) == 0x000000, "Member 'MoverDebugComponent_OnMovementSimRollback::NewTimeStep' has a wrong offset!");
static_assert(offsetof(MoverDebugComponent_OnMovementSimRollback, InvalidatedTimeStep) == 0x000010, "Member 'MoverDebugComponent_OnMovementSimRollback::InvalidatedTimeStep' has a wrong offset!");

// Function Mover.MoverDebugComponent.OnMovementSimTick
// 0x0010 (0x0010 - 0x0000)
struct MoverDebugComponent_OnMovementSimTick final
{
public:
	struct FMoverTimeStep                         TimeStep;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverDebugComponent_OnMovementSimTick) == 0x000004, "Wrong alignment on MoverDebugComponent_OnMovementSimTick");
static_assert(sizeof(MoverDebugComponent_OnMovementSimTick) == 0x000010, "Wrong size on MoverDebugComponent_OnMovementSimTick");
static_assert(offsetof(MoverDebugComponent_OnMovementSimTick, TimeStep) == 0x000000, "Member 'MoverDebugComponent_OnMovementSimTick::TimeStep' has a wrong offset!");

// Function Mover.MoverDebugComponent.SetHistoryTracking
// 0x0008 (0x0008 - 0x0000)
struct MoverDebugComponent_SetHistoryTracking final
{
public:
	float                                         SecondsToTrack;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SamplesPerSecond;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverDebugComponent_SetHistoryTracking) == 0x000004, "Wrong alignment on MoverDebugComponent_SetHistoryTracking");
static_assert(sizeof(MoverDebugComponent_SetHistoryTracking) == 0x000008, "Wrong size on MoverDebugComponent_SetHistoryTracking");
static_assert(offsetof(MoverDebugComponent_SetHistoryTracking, SecondsToTrack) == 0x000000, "Member 'MoverDebugComponent_SetHistoryTracking::SecondsToTrack' has a wrong offset!");
static_assert(offsetof(MoverDebugComponent_SetHistoryTracking, SamplesPerSecond) == 0x000004, "Member 'MoverDebugComponent_SetHistoryTracking::SamplesPerSecond' has a wrong offset!");

// Function Mover.MoverDebugComponent.GetFutureTrajectory
// 0x0018 (0x0018 - 0x0000)
struct MoverDebugComponent_GetFutureTrajectory final
{
public:
	float                                         FutureSeconds;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SamplesPerSecond;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTrajectorySampleInfo>          ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverDebugComponent_GetFutureTrajectory) == 0x000008, "Wrong alignment on MoverDebugComponent_GetFutureTrajectory");
static_assert(sizeof(MoverDebugComponent_GetFutureTrajectory) == 0x000018, "Wrong size on MoverDebugComponent_GetFutureTrajectory");
static_assert(offsetof(MoverDebugComponent_GetFutureTrajectory, FutureSeconds) == 0x000000, "Member 'MoverDebugComponent_GetFutureTrajectory::FutureSeconds' has a wrong offset!");
static_assert(offsetof(MoverDebugComponent_GetFutureTrajectory, SamplesPerSecond) == 0x000004, "Member 'MoverDebugComponent_GetFutureTrajectory::SamplesPerSecond' has a wrong offset!");
static_assert(offsetof(MoverDebugComponent_GetFutureTrajectory, ReturnValue) == 0x000008, "Member 'MoverDebugComponent_GetFutureTrajectory::ReturnValue' has a wrong offset!");

// Function Mover.MoverDebugComponent.GetPastTrajectory
// 0x0010 (0x0010 - 0x0000)
struct MoverDebugComponent_GetPastTrajectory final
{
public:
	TArray<struct FTrajectorySampleInfo>          ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverDebugComponent_GetPastTrajectory) == 0x000008, "Wrong alignment on MoverDebugComponent_GetPastTrajectory");
static_assert(sizeof(MoverDebugComponent_GetPastTrajectory) == 0x000010, "Wrong size on MoverDebugComponent_GetPastTrajectory");
static_assert(offsetof(MoverDebugComponent_GetPastTrajectory, ReturnValue) == 0x000000, "Member 'MoverDebugComponent_GetPastTrajectory::ReturnValue' has a wrong offset!");

// Function Mover.MoverInputProducerInterface.ProduceInput
// 0x0020 (0x0020 - 0x0000)
struct MoverInputProducerInterface_ProduceInput final
{
public:
	int32                                         SimTimeMs;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMoverInputCmdContext                  InputCmdResult;                                    // 0x0008(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverInputProducerInterface_ProduceInput) == 0x000008, "Wrong alignment on MoverInputProducerInterface_ProduceInput");
static_assert(sizeof(MoverInputProducerInterface_ProduceInput) == 0x000020, "Wrong size on MoverInputProducerInterface_ProduceInput");
static_assert(offsetof(MoverInputProducerInterface_ProduceInput, SimTimeMs) == 0x000000, "Member 'MoverInputProducerInterface_ProduceInput::SimTimeMs' has a wrong offset!");
static_assert(offsetof(MoverInputProducerInterface_ProduceInput, InputCmdResult) == 0x000008, "Member 'MoverInputProducerInterface_ProduceInput::InputCmdResult' has a wrong offset!");

// Function Mover.MoverDataCollectionLibrary.K2_AddDataToCollection
// 0x0020 (0x0020 - 0x0000)
struct MoverDataCollectionLibrary_K2_AddDataToCollection final
{
public:
	struct FMoverDataCollection                   Collection;                                        // 0x0000(0x0018)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         SourceAsRawBytes;                                  // 0x0018(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoverDataCollectionLibrary_K2_AddDataToCollection) == 0x000008, "Wrong alignment on MoverDataCollectionLibrary_K2_AddDataToCollection");
static_assert(sizeof(MoverDataCollectionLibrary_K2_AddDataToCollection) == 0x000020, "Wrong size on MoverDataCollectionLibrary_K2_AddDataToCollection");
static_assert(offsetof(MoverDataCollectionLibrary_K2_AddDataToCollection, Collection) == 0x000000, "Member 'MoverDataCollectionLibrary_K2_AddDataToCollection::Collection' has a wrong offset!");
static_assert(offsetof(MoverDataCollectionLibrary_K2_AddDataToCollection, SourceAsRawBytes) == 0x000018, "Member 'MoverDataCollectionLibrary_K2_AddDataToCollection::SourceAsRawBytes' has a wrong offset!");

// Function Mover.MoverDataCollectionLibrary.K2_GetDataFromCollection
// 0x0028 (0x0028 - 0x0000)
struct MoverDataCollectionLibrary_K2_GetDataFromCollection final
{
public:
	bool                                          DidSucceed;                                        // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMoverDataCollection                   Collection;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TargetAsRawBytes;                                  // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoverDataCollectionLibrary_K2_GetDataFromCollection) == 0x000008, "Wrong alignment on MoverDataCollectionLibrary_K2_GetDataFromCollection");
static_assert(sizeof(MoverDataCollectionLibrary_K2_GetDataFromCollection) == 0x000028, "Wrong size on MoverDataCollectionLibrary_K2_GetDataFromCollection");
static_assert(offsetof(MoverDataCollectionLibrary_K2_GetDataFromCollection, DidSucceed) == 0x000000, "Member 'MoverDataCollectionLibrary_K2_GetDataFromCollection::DidSucceed' has a wrong offset!");
static_assert(offsetof(MoverDataCollectionLibrary_K2_GetDataFromCollection, Collection) == 0x000008, "Member 'MoverDataCollectionLibrary_K2_GetDataFromCollection::Collection' has a wrong offset!");
static_assert(offsetof(MoverDataCollectionLibrary_K2_GetDataFromCollection, TargetAsRawBytes) == 0x000020, "Member 'MoverDataCollectionLibrary_K2_GetDataFromCollection::TargetAsRawBytes' has a wrong offset!");

// Function Mover.BaseMovementMode.K2_OnRegistered
// 0x0004 (0x0004 - 0x0000)
struct BaseMovementMode_K2_OnRegistered final
{
public:
	class FName                                   ModeName;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMovementMode_K2_OnRegistered) == 0x000004, "Wrong alignment on BaseMovementMode_K2_OnRegistered");
static_assert(sizeof(BaseMovementMode_K2_OnRegistered) == 0x000004, "Wrong size on BaseMovementMode_K2_OnRegistered");
static_assert(offsetof(BaseMovementMode_K2_OnRegistered, ModeName) == 0x000000, "Member 'BaseMovementMode_K2_OnRegistered::ModeName' has a wrong offset!");

// Function Mover.BaseMovementMode.K2_OnSimulationTick
// 0x0150 (0x0150 - 0x0000)
struct BaseMovementMode_K2_OnSimulationTick final
{
public:
	struct FSimulationTickParams                  Params_0;                                          // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMoverTickEndData                      ReturnValue;                                       // 0x00E0(0x0070)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMovementMode_K2_OnSimulationTick) == 0x000008, "Wrong alignment on BaseMovementMode_K2_OnSimulationTick");
static_assert(sizeof(BaseMovementMode_K2_OnSimulationTick) == 0x000150, "Wrong size on BaseMovementMode_K2_OnSimulationTick");
static_assert(offsetof(BaseMovementMode_K2_OnSimulationTick, Params_0) == 0x000000, "Member 'BaseMovementMode_K2_OnSimulationTick::Params_0' has a wrong offset!");
static_assert(offsetof(BaseMovementMode_K2_OnSimulationTick, ReturnValue) == 0x0000E0, "Member 'BaseMovementMode_K2_OnSimulationTick::ReturnValue' has a wrong offset!");

// Function Mover.BaseMovementMode.GetBlackboard
// 0x0008 (0x0008 - 0x0000)
struct BaseMovementMode_GetBlackboard final
{
public:
	const class UMoverBlackboard*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMovementMode_GetBlackboard) == 0x000008, "Wrong alignment on BaseMovementMode_GetBlackboard");
static_assert(sizeof(BaseMovementMode_GetBlackboard) == 0x000008, "Wrong size on BaseMovementMode_GetBlackboard");
static_assert(offsetof(BaseMovementMode_GetBlackboard, ReturnValue) == 0x000000, "Member 'BaseMovementMode_GetBlackboard::ReturnValue' has a wrong offset!");

// Function Mover.BaseMovementMode.GetBlackboard_Mutable
// 0x0008 (0x0008 - 0x0000)
struct BaseMovementMode_GetBlackboard_Mutable final
{
public:
	class UMoverBlackboard*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMovementMode_GetBlackboard_Mutable) == 0x000008, "Wrong alignment on BaseMovementMode_GetBlackboard_Mutable");
static_assert(sizeof(BaseMovementMode_GetBlackboard_Mutable) == 0x000008, "Wrong size on BaseMovementMode_GetBlackboard_Mutable");
static_assert(offsetof(BaseMovementMode_GetBlackboard_Mutable, ReturnValue) == 0x000000, "Member 'BaseMovementMode_GetBlackboard_Mutable::ReturnValue' has a wrong offset!");

// Function Mover.BaseMovementMode.GetMoverComponent
// 0x0008 (0x0008 - 0x0000)
struct BaseMovementMode_GetMoverComponent final
{
public:
	class UMoverComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMovementMode_GetMoverComponent) == 0x000008, "Wrong alignment on BaseMovementMode_GetMoverComponent");
static_assert(sizeof(BaseMovementMode_GetMoverComponent) == 0x000008, "Wrong size on BaseMovementMode_GetMoverComponent");
static_assert(offsetof(BaseMovementMode_GetMoverComponent, ReturnValue) == 0x000000, "Member 'BaseMovementMode_GetMoverComponent::ReturnValue' has a wrong offset!");

// Function Mover.BaseMovementMode.K2_OnGenerateMove
// 0x00D0 (0x00D0 - 0x0000)
struct BaseMovementMode_K2_OnGenerateMove final
{
public:
	struct FMoverTickStartData                    StartState;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FMoverTimeStep                         TimeStep;                                          // 0x0038(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FProposedMove                          ReturnValue;                                       // 0x0048(0x0088)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMovementMode_K2_OnGenerateMove) == 0x000008, "Wrong alignment on BaseMovementMode_K2_OnGenerateMove");
static_assert(sizeof(BaseMovementMode_K2_OnGenerateMove) == 0x0000D0, "Wrong size on BaseMovementMode_K2_OnGenerateMove");
static_assert(offsetof(BaseMovementMode_K2_OnGenerateMove, StartState) == 0x000000, "Member 'BaseMovementMode_K2_OnGenerateMove::StartState' has a wrong offset!");
static_assert(offsetof(BaseMovementMode_K2_OnGenerateMove, TimeStep) == 0x000038, "Member 'BaseMovementMode_K2_OnGenerateMove::TimeStep' has a wrong offset!");
static_assert(offsetof(BaseMovementMode_K2_OnGenerateMove, ReturnValue) == 0x000048, "Member 'BaseMovementMode_K2_OnGenerateMove::ReturnValue' has a wrong offset!");

// Function Mover.FallingMode.OnSimulationTick
// 0x0150 (0x0150 - 0x0000)
struct FallingMode_OnSimulationTick final
{
public:
	struct FSimulationTickParams                  Params_0;                                          // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMoverTickEndData                      OutputState;                                       // 0x00E0(0x0070)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FallingMode_OnSimulationTick) == 0x000008, "Wrong alignment on FallingMode_OnSimulationTick");
static_assert(sizeof(FallingMode_OnSimulationTick) == 0x000150, "Wrong size on FallingMode_OnSimulationTick");
static_assert(offsetof(FallingMode_OnSimulationTick, Params_0) == 0x000000, "Member 'FallingMode_OnSimulationTick::Params_0' has a wrong offset!");
static_assert(offsetof(FallingMode_OnSimulationTick, OutputState) == 0x0000E0, "Member 'FallingMode_OnSimulationTick::OutputState' has a wrong offset!");

// Function Mover.FallingMode.OnGenerateMove
// 0x00D0 (0x00D0 - 0x0000)
struct FallingMode_OnGenerateMove final
{
public:
	struct FMoverTickStartData                    StartState;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FMoverTimeStep                         TimeStep;                                          // 0x0038(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FProposedMove                          OutProposedMove;                                   // 0x0048(0x0088)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FallingMode_OnGenerateMove) == 0x000008, "Wrong alignment on FallingMode_OnGenerateMove");
static_assert(sizeof(FallingMode_OnGenerateMove) == 0x0000D0, "Wrong size on FallingMode_OnGenerateMove");
static_assert(offsetof(FallingMode_OnGenerateMove, StartState) == 0x000000, "Member 'FallingMode_OnGenerateMove::StartState' has a wrong offset!");
static_assert(offsetof(FallingMode_OnGenerateMove, TimeStep) == 0x000038, "Member 'FallingMode_OnGenerateMove::TimeStep' has a wrong offset!");
static_assert(offsetof(FallingMode_OnGenerateMove, OutProposedMove) == 0x000048, "Member 'FallingMode_OnGenerateMove::OutProposedMove' has a wrong offset!");

// Function Mover.FallingMode.ProcessLanded
// 0x01F0 (0x01F0 - 0x0000)
struct FallingMode_ProcessLanded final
{
public:
	struct FFloorCheckResult                      FloorResult;                                       // 0x0000(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x00F8(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRelativeBaseInfo                      BaseInfo;                                          // 0x0110(0x0070)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMoverTickEndData                      TickEndData;                                       // 0x0180(0x0070)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FallingMode_ProcessLanded) == 0x000010, "Wrong alignment on FallingMode_ProcessLanded");
static_assert(sizeof(FallingMode_ProcessLanded) == 0x0001F0, "Wrong size on FallingMode_ProcessLanded");
static_assert(offsetof(FallingMode_ProcessLanded, FloorResult) == 0x000000, "Member 'FallingMode_ProcessLanded::FloorResult' has a wrong offset!");
static_assert(offsetof(FallingMode_ProcessLanded, Velocity) == 0x0000F8, "Member 'FallingMode_ProcessLanded::Velocity' has a wrong offset!");
static_assert(offsetof(FallingMode_ProcessLanded, BaseInfo) == 0x000110, "Member 'FallingMode_ProcessLanded::BaseInfo' has a wrong offset!");
static_assert(offsetof(FallingMode_ProcessLanded, TickEndData) == 0x000180, "Member 'FallingMode_ProcessLanded::TickEndData' has a wrong offset!");

// Function Mover.FlyingMode.OnSimulationTick
// 0x0150 (0x0150 - 0x0000)
struct FlyingMode_OnSimulationTick final
{
public:
	struct FSimulationTickParams                  Params_0;                                          // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMoverTickEndData                      OutputState;                                       // 0x00E0(0x0070)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlyingMode_OnSimulationTick) == 0x000008, "Wrong alignment on FlyingMode_OnSimulationTick");
static_assert(sizeof(FlyingMode_OnSimulationTick) == 0x000150, "Wrong size on FlyingMode_OnSimulationTick");
static_assert(offsetof(FlyingMode_OnSimulationTick, Params_0) == 0x000000, "Member 'FlyingMode_OnSimulationTick::Params_0' has a wrong offset!");
static_assert(offsetof(FlyingMode_OnSimulationTick, OutputState) == 0x0000E0, "Member 'FlyingMode_OnSimulationTick::OutputState' has a wrong offset!");

// Function Mover.FlyingMode.OnGenerateMove
// 0x00D0 (0x00D0 - 0x0000)
struct FlyingMode_OnGenerateMove final
{
public:
	struct FMoverTickStartData                    StartState;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FMoverTimeStep                         TimeStep;                                          // 0x0038(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FProposedMove                          OutProposedMove;                                   // 0x0048(0x0088)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlyingMode_OnGenerateMove) == 0x000008, "Wrong alignment on FlyingMode_OnGenerateMove");
static_assert(sizeof(FlyingMode_OnGenerateMove) == 0x0000D0, "Wrong size on FlyingMode_OnGenerateMove");
static_assert(offsetof(FlyingMode_OnGenerateMove, StartState) == 0x000000, "Member 'FlyingMode_OnGenerateMove::StartState' has a wrong offset!");
static_assert(offsetof(FlyingMode_OnGenerateMove, TimeStep) == 0x000038, "Member 'FlyingMode_OnGenerateMove::TimeStep' has a wrong offset!");
static_assert(offsetof(FlyingMode_OnGenerateMove, OutProposedMove) == 0x000048, "Member 'FlyingMode_OnGenerateMove::OutProposedMove' has a wrong offset!");

// Function Mover.SwimmingMode.OnSimulationTick
// 0x0150 (0x0150 - 0x0000)
struct SwimmingMode_OnSimulationTick final
{
public:
	struct FSimulationTickParams                  Params_0;                                          // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMoverTickEndData                      OutputState;                                       // 0x00E0(0x0070)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SwimmingMode_OnSimulationTick) == 0x000008, "Wrong alignment on SwimmingMode_OnSimulationTick");
static_assert(sizeof(SwimmingMode_OnSimulationTick) == 0x000150, "Wrong size on SwimmingMode_OnSimulationTick");
static_assert(offsetof(SwimmingMode_OnSimulationTick, Params_0) == 0x000000, "Member 'SwimmingMode_OnSimulationTick::Params_0' has a wrong offset!");
static_assert(offsetof(SwimmingMode_OnSimulationTick, OutputState) == 0x0000E0, "Member 'SwimmingMode_OnSimulationTick::OutputState' has a wrong offset!");

// Function Mover.SwimmingMode.OnGenerateMove
// 0x00D0 (0x00D0 - 0x0000)
struct SwimmingMode_OnGenerateMove final
{
public:
	struct FMoverTickStartData                    StartState;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FMoverTimeStep                         TimeStep;                                          // 0x0038(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FProposedMove                          OutProposedMove;                                   // 0x0048(0x0088)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SwimmingMode_OnGenerateMove) == 0x000008, "Wrong alignment on SwimmingMode_OnGenerateMove");
static_assert(sizeof(SwimmingMode_OnGenerateMove) == 0x0000D0, "Wrong size on SwimmingMode_OnGenerateMove");
static_assert(offsetof(SwimmingMode_OnGenerateMove, StartState) == 0x000000, "Member 'SwimmingMode_OnGenerateMove::StartState' has a wrong offset!");
static_assert(offsetof(SwimmingMode_OnGenerateMove, TimeStep) == 0x000038, "Member 'SwimmingMode_OnGenerateMove::TimeStep' has a wrong offset!");
static_assert(offsetof(SwimmingMode_OnGenerateMove, OutProposedMove) == 0x000048, "Member 'SwimmingMode_OnGenerateMove::OutProposedMove' has a wrong offset!");

// Function Mover.WalkingMode.OnSimulationTick
// 0x0150 (0x0150 - 0x0000)
struct WalkingMode_OnSimulationTick final
{
public:
	struct FSimulationTickParams                  Params_0;                                          // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMoverTickEndData                      OutputState;                                       // 0x00E0(0x0070)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WalkingMode_OnSimulationTick) == 0x000008, "Wrong alignment on WalkingMode_OnSimulationTick");
static_assert(sizeof(WalkingMode_OnSimulationTick) == 0x000150, "Wrong size on WalkingMode_OnSimulationTick");
static_assert(offsetof(WalkingMode_OnSimulationTick, Params_0) == 0x000000, "Member 'WalkingMode_OnSimulationTick::Params_0' has a wrong offset!");
static_assert(offsetof(WalkingMode_OnSimulationTick, OutputState) == 0x0000E0, "Member 'WalkingMode_OnSimulationTick::OutputState' has a wrong offset!");

// Function Mover.WalkingMode.OnGenerateMove
// 0x00D0 (0x00D0 - 0x0000)
struct WalkingMode_OnGenerateMove final
{
public:
	struct FMoverTickStartData                    StartState;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FMoverTimeStep                         TimeStep;                                          // 0x0038(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FProposedMove                          OutProposedMove;                                   // 0x0048(0x0088)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(WalkingMode_OnGenerateMove) == 0x000008, "Wrong alignment on WalkingMode_OnGenerateMove");
static_assert(sizeof(WalkingMode_OnGenerateMove) == 0x0000D0, "Wrong size on WalkingMode_OnGenerateMove");
static_assert(offsetof(WalkingMode_OnGenerateMove, StartState) == 0x000000, "Member 'WalkingMode_OnGenerateMove::StartState' has a wrong offset!");
static_assert(offsetof(WalkingMode_OnGenerateMove, TimeStep) == 0x000038, "Member 'WalkingMode_OnGenerateMove::TimeStep' has a wrong offset!");
static_assert(offsetof(WalkingMode_OnGenerateMove, OutProposedMove) == 0x000048, "Member 'WalkingMode_OnGenerateMove::OutProposedMove' has a wrong offset!");

// Function Mover.MovementBaseUtils.GetMovementBaseTransform
// 0x0060 (0x0060 - 0x0000)
struct MovementBaseUtils_GetMovementBaseTransform final
{
public:
	const class UPrimitiveComponent*              MovementBase;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutLocation;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  OutQuat;                                           // 0x0030(0x0020)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementBaseUtils_GetMovementBaseTransform) == 0x000010, "Wrong alignment on MovementBaseUtils_GetMovementBaseTransform");
static_assert(sizeof(MovementBaseUtils_GetMovementBaseTransform) == 0x000060, "Wrong size on MovementBaseUtils_GetMovementBaseTransform");
static_assert(offsetof(MovementBaseUtils_GetMovementBaseTransform, MovementBase) == 0x000000, "Member 'MovementBaseUtils_GetMovementBaseTransform::MovementBase' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_GetMovementBaseTransform, BoneName) == 0x000008, "Member 'MovementBaseUtils_GetMovementBaseTransform::BoneName' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_GetMovementBaseTransform, OutLocation) == 0x000010, "Member 'MovementBaseUtils_GetMovementBaseTransform::OutLocation' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_GetMovementBaseTransform, OutQuat) == 0x000030, "Member 'MovementBaseUtils_GetMovementBaseTransform::OutQuat' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_GetMovementBaseTransform, ReturnValue) == 0x000050, "Member 'MovementBaseUtils_GetMovementBaseTransform::ReturnValue' has a wrong offset!");

// Function Mover.MovementBaseUtils.IsADynamicBase
// 0x0010 (0x0010 - 0x0000)
struct MovementBaseUtils_IsADynamicBase final
{
public:
	const class UPrimitiveComponent*              MovementBase;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementBaseUtils_IsADynamicBase) == 0x000008, "Wrong alignment on MovementBaseUtils_IsADynamicBase");
static_assert(sizeof(MovementBaseUtils_IsADynamicBase) == 0x000010, "Wrong size on MovementBaseUtils_IsADynamicBase");
static_assert(offsetof(MovementBaseUtils_IsADynamicBase, MovementBase) == 0x000000, "Member 'MovementBaseUtils_IsADynamicBase::MovementBase' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_IsADynamicBase, ReturnValue) == 0x000008, "Member 'MovementBaseUtils_IsADynamicBase::ReturnValue' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformBasedDirectionToWorld
// 0x0048 (0x0048 - 0x0000)
struct MovementBaseUtils_TransformBasedDirectionToWorld final
{
public:
	const class UPrimitiveComponent*              MovementBase;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalDirection;                                    // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutDirectionWorldSpace;                            // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementBaseUtils_TransformBasedDirectionToWorld) == 0x000008, "Wrong alignment on MovementBaseUtils_TransformBasedDirectionToWorld");
static_assert(sizeof(MovementBaseUtils_TransformBasedDirectionToWorld) == 0x000048, "Wrong size on MovementBaseUtils_TransformBasedDirectionToWorld");
static_assert(offsetof(MovementBaseUtils_TransformBasedDirectionToWorld, MovementBase) == 0x000000, "Member 'MovementBaseUtils_TransformBasedDirectionToWorld::MovementBase' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedDirectionToWorld, BoneName) == 0x000008, "Member 'MovementBaseUtils_TransformBasedDirectionToWorld::BoneName' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedDirectionToWorld, LocalDirection) == 0x000010, "Member 'MovementBaseUtils_TransformBasedDirectionToWorld::LocalDirection' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedDirectionToWorld, OutDirectionWorldSpace) == 0x000028, "Member 'MovementBaseUtils_TransformBasedDirectionToWorld::OutDirectionWorldSpace' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedDirectionToWorld, ReturnValue) == 0x000040, "Member 'MovementBaseUtils_TransformBasedDirectionToWorld::ReturnValue' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformBasedLocationToWorld
// 0x0048 (0x0048 - 0x0000)
struct MovementBaseUtils_TransformBasedLocationToWorld final
{
public:
	const class UPrimitiveComponent*              MovementBase;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalLocation;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocationWorldSpace;                             // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementBaseUtils_TransformBasedLocationToWorld) == 0x000008, "Wrong alignment on MovementBaseUtils_TransformBasedLocationToWorld");
static_assert(sizeof(MovementBaseUtils_TransformBasedLocationToWorld) == 0x000048, "Wrong size on MovementBaseUtils_TransformBasedLocationToWorld");
static_assert(offsetof(MovementBaseUtils_TransformBasedLocationToWorld, MovementBase) == 0x000000, "Member 'MovementBaseUtils_TransformBasedLocationToWorld::MovementBase' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedLocationToWorld, BoneName) == 0x000008, "Member 'MovementBaseUtils_TransformBasedLocationToWorld::BoneName' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedLocationToWorld, LocalLocation) == 0x000010, "Member 'MovementBaseUtils_TransformBasedLocationToWorld::LocalLocation' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedLocationToWorld, OutLocationWorldSpace) == 0x000028, "Member 'MovementBaseUtils_TransformBasedLocationToWorld::OutLocationWorldSpace' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedLocationToWorld, ReturnValue) == 0x000040, "Member 'MovementBaseUtils_TransformBasedLocationToWorld::ReturnValue' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformBasedRotatorToWorld
// 0x0048 (0x0048 - 0x0000)
struct MovementBaseUtils_TransformBasedRotatorToWorld final
{
public:
	const class UPrimitiveComponent*              MovementBase;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LocalRotator;                                      // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               OutWorldSpaceRotator;                              // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementBaseUtils_TransformBasedRotatorToWorld) == 0x000008, "Wrong alignment on MovementBaseUtils_TransformBasedRotatorToWorld");
static_assert(sizeof(MovementBaseUtils_TransformBasedRotatorToWorld) == 0x000048, "Wrong size on MovementBaseUtils_TransformBasedRotatorToWorld");
static_assert(offsetof(MovementBaseUtils_TransformBasedRotatorToWorld, MovementBase) == 0x000000, "Member 'MovementBaseUtils_TransformBasedRotatorToWorld::MovementBase' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedRotatorToWorld, BoneName) == 0x000008, "Member 'MovementBaseUtils_TransformBasedRotatorToWorld::BoneName' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedRotatorToWorld, LocalRotator) == 0x000010, "Member 'MovementBaseUtils_TransformBasedRotatorToWorld::LocalRotator' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedRotatorToWorld, OutWorldSpaceRotator) == 0x000028, "Member 'MovementBaseUtils_TransformBasedRotatorToWorld::OutWorldSpaceRotator' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformBasedRotatorToWorld, ReturnValue) == 0x000040, "Member 'MovementBaseUtils_TransformBasedRotatorToWorld::ReturnValue' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformDirectionToLocal
// 0x0050 (0x0050 - 0x0000)
struct MovementBaseUtils_TransformDirectionToLocal final
{
public:
	struct FQuat                                  BaseQuat;                                          // 0x0000(0x0020)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldSpaceDirection;                               // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocalDirection;                                 // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementBaseUtils_TransformDirectionToLocal) == 0x000010, "Wrong alignment on MovementBaseUtils_TransformDirectionToLocal");
static_assert(sizeof(MovementBaseUtils_TransformDirectionToLocal) == 0x000050, "Wrong size on MovementBaseUtils_TransformDirectionToLocal");
static_assert(offsetof(MovementBaseUtils_TransformDirectionToLocal, BaseQuat) == 0x000000, "Member 'MovementBaseUtils_TransformDirectionToLocal::BaseQuat' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformDirectionToLocal, WorldSpaceDirection) == 0x000020, "Member 'MovementBaseUtils_TransformDirectionToLocal::WorldSpaceDirection' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformDirectionToLocal, OutLocalDirection) == 0x000038, "Member 'MovementBaseUtils_TransformDirectionToLocal::OutLocalDirection' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformDirectionToWorld
// 0x0050 (0x0050 - 0x0000)
struct MovementBaseUtils_TransformDirectionToWorld final
{
public:
	struct FQuat                                  BaseQuat;                                          // 0x0000(0x0020)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalDirection;                                    // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutDirectionWorldSpace;                            // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementBaseUtils_TransformDirectionToWorld) == 0x000010, "Wrong alignment on MovementBaseUtils_TransformDirectionToWorld");
static_assert(sizeof(MovementBaseUtils_TransformDirectionToWorld) == 0x000050, "Wrong size on MovementBaseUtils_TransformDirectionToWorld");
static_assert(offsetof(MovementBaseUtils_TransformDirectionToWorld, BaseQuat) == 0x000000, "Member 'MovementBaseUtils_TransformDirectionToWorld::BaseQuat' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformDirectionToWorld, LocalDirection) == 0x000020, "Member 'MovementBaseUtils_TransformDirectionToWorld::LocalDirection' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformDirectionToWorld, OutDirectionWorldSpace) == 0x000038, "Member 'MovementBaseUtils_TransformDirectionToWorld::OutDirectionWorldSpace' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformLocationToLocal
// 0x0070 (0x0070 - 0x0000)
struct MovementBaseUtils_TransformLocationToLocal final
{
public:
	struct FVector                                BasePos;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  BaseQuat;                                          // 0x0020(0x0020)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldSpaceLocation;                                // 0x0040(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocalLocation;                                  // 0x0058(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementBaseUtils_TransformLocationToLocal) == 0x000010, "Wrong alignment on MovementBaseUtils_TransformLocationToLocal");
static_assert(sizeof(MovementBaseUtils_TransformLocationToLocal) == 0x000070, "Wrong size on MovementBaseUtils_TransformLocationToLocal");
static_assert(offsetof(MovementBaseUtils_TransformLocationToLocal, BasePos) == 0x000000, "Member 'MovementBaseUtils_TransformLocationToLocal::BasePos' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformLocationToLocal, BaseQuat) == 0x000020, "Member 'MovementBaseUtils_TransformLocationToLocal::BaseQuat' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformLocationToLocal, WorldSpaceLocation) == 0x000040, "Member 'MovementBaseUtils_TransformLocationToLocal::WorldSpaceLocation' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformLocationToLocal, OutLocalLocation) == 0x000058, "Member 'MovementBaseUtils_TransformLocationToLocal::OutLocalLocation' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformLocationToWorld
// 0x0070 (0x0070 - 0x0000)
struct MovementBaseUtils_TransformLocationToWorld final
{
public:
	struct FVector                                BasePos;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  BaseQuat;                                          // 0x0020(0x0020)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalLocation;                                     // 0x0040(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocationWorldSpace;                             // 0x0058(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementBaseUtils_TransformLocationToWorld) == 0x000010, "Wrong alignment on MovementBaseUtils_TransformLocationToWorld");
static_assert(sizeof(MovementBaseUtils_TransformLocationToWorld) == 0x000070, "Wrong size on MovementBaseUtils_TransformLocationToWorld");
static_assert(offsetof(MovementBaseUtils_TransformLocationToWorld, BasePos) == 0x000000, "Member 'MovementBaseUtils_TransformLocationToWorld::BasePos' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformLocationToWorld, BaseQuat) == 0x000020, "Member 'MovementBaseUtils_TransformLocationToWorld::BaseQuat' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformLocationToWorld, LocalLocation) == 0x000040, "Member 'MovementBaseUtils_TransformLocationToWorld::LocalLocation' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformLocationToWorld, OutLocationWorldSpace) == 0x000058, "Member 'MovementBaseUtils_TransformLocationToWorld::OutLocationWorldSpace' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformRotatorToLocal
// 0x0050 (0x0050 - 0x0000)
struct MovementBaseUtils_TransformRotatorToLocal final
{
public:
	struct FQuat                                  BaseQuat;                                          // 0x0000(0x0020)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WorldSpaceRotator;                                 // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               OutLocalRotator;                                   // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementBaseUtils_TransformRotatorToLocal) == 0x000010, "Wrong alignment on MovementBaseUtils_TransformRotatorToLocal");
static_assert(sizeof(MovementBaseUtils_TransformRotatorToLocal) == 0x000050, "Wrong size on MovementBaseUtils_TransformRotatorToLocal");
static_assert(offsetof(MovementBaseUtils_TransformRotatorToLocal, BaseQuat) == 0x000000, "Member 'MovementBaseUtils_TransformRotatorToLocal::BaseQuat' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformRotatorToLocal, WorldSpaceRotator) == 0x000020, "Member 'MovementBaseUtils_TransformRotatorToLocal::WorldSpaceRotator' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformRotatorToLocal, OutLocalRotator) == 0x000038, "Member 'MovementBaseUtils_TransformRotatorToLocal::OutLocalRotator' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformRotatorToWorld
// 0x0050 (0x0050 - 0x0000)
struct MovementBaseUtils_TransformRotatorToWorld final
{
public:
	struct FQuat                                  BaseQuat;                                          // 0x0000(0x0020)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LocalRotator;                                      // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               OutWorldSpaceRotator;                              // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementBaseUtils_TransformRotatorToWorld) == 0x000010, "Wrong alignment on MovementBaseUtils_TransformRotatorToWorld");
static_assert(sizeof(MovementBaseUtils_TransformRotatorToWorld) == 0x000050, "Wrong size on MovementBaseUtils_TransformRotatorToWorld");
static_assert(offsetof(MovementBaseUtils_TransformRotatorToWorld, BaseQuat) == 0x000000, "Member 'MovementBaseUtils_TransformRotatorToWorld::BaseQuat' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformRotatorToWorld, LocalRotator) == 0x000020, "Member 'MovementBaseUtils_TransformRotatorToWorld::LocalRotator' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformRotatorToWorld, OutWorldSpaceRotator) == 0x000038, "Member 'MovementBaseUtils_TransformRotatorToWorld::OutWorldSpaceRotator' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformWorldDirectionToBased
// 0x0048 (0x0048 - 0x0000)
struct MovementBaseUtils_TransformWorldDirectionToBased final
{
public:
	const class UPrimitiveComponent*              MovementBase;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldSpaceDirection;                               // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocalDirection;                                 // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementBaseUtils_TransformWorldDirectionToBased) == 0x000008, "Wrong alignment on MovementBaseUtils_TransformWorldDirectionToBased");
static_assert(sizeof(MovementBaseUtils_TransformWorldDirectionToBased) == 0x000048, "Wrong size on MovementBaseUtils_TransformWorldDirectionToBased");
static_assert(offsetof(MovementBaseUtils_TransformWorldDirectionToBased, MovementBase) == 0x000000, "Member 'MovementBaseUtils_TransformWorldDirectionToBased::MovementBase' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldDirectionToBased, BoneName) == 0x000008, "Member 'MovementBaseUtils_TransformWorldDirectionToBased::BoneName' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldDirectionToBased, WorldSpaceDirection) == 0x000010, "Member 'MovementBaseUtils_TransformWorldDirectionToBased::WorldSpaceDirection' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldDirectionToBased, OutLocalDirection) == 0x000028, "Member 'MovementBaseUtils_TransformWorldDirectionToBased::OutLocalDirection' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldDirectionToBased, ReturnValue) == 0x000040, "Member 'MovementBaseUtils_TransformWorldDirectionToBased::ReturnValue' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformWorldLocationToBased
// 0x0048 (0x0048 - 0x0000)
struct MovementBaseUtils_TransformWorldLocationToBased final
{
public:
	const class UPrimitiveComponent*              MovementBase;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldSpaceLocation;                                // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocalLocation;                                  // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementBaseUtils_TransformWorldLocationToBased) == 0x000008, "Wrong alignment on MovementBaseUtils_TransformWorldLocationToBased");
static_assert(sizeof(MovementBaseUtils_TransformWorldLocationToBased) == 0x000048, "Wrong size on MovementBaseUtils_TransformWorldLocationToBased");
static_assert(offsetof(MovementBaseUtils_TransformWorldLocationToBased, MovementBase) == 0x000000, "Member 'MovementBaseUtils_TransformWorldLocationToBased::MovementBase' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldLocationToBased, BoneName) == 0x000008, "Member 'MovementBaseUtils_TransformWorldLocationToBased::BoneName' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldLocationToBased, WorldSpaceLocation) == 0x000010, "Member 'MovementBaseUtils_TransformWorldLocationToBased::WorldSpaceLocation' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldLocationToBased, OutLocalLocation) == 0x000028, "Member 'MovementBaseUtils_TransformWorldLocationToBased::OutLocalLocation' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldLocationToBased, ReturnValue) == 0x000040, "Member 'MovementBaseUtils_TransformWorldLocationToBased::ReturnValue' has a wrong offset!");

// Function Mover.MovementBaseUtils.TransformWorldRotatorToBased
// 0x0048 (0x0048 - 0x0000)
struct MovementBaseUtils_TransformWorldRotatorToBased final
{
public:
	const class UPrimitiveComponent*              MovementBase;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               WorldSpaceRotator;                                 // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               OutLocalRotator;                                   // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementBaseUtils_TransformWorldRotatorToBased) == 0x000008, "Wrong alignment on MovementBaseUtils_TransformWorldRotatorToBased");
static_assert(sizeof(MovementBaseUtils_TransformWorldRotatorToBased) == 0x000048, "Wrong size on MovementBaseUtils_TransformWorldRotatorToBased");
static_assert(offsetof(MovementBaseUtils_TransformWorldRotatorToBased, MovementBase) == 0x000000, "Member 'MovementBaseUtils_TransformWorldRotatorToBased::MovementBase' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldRotatorToBased, BoneName) == 0x000008, "Member 'MovementBaseUtils_TransformWorldRotatorToBased::BoneName' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldRotatorToBased, WorldSpaceRotator) == 0x000010, "Member 'MovementBaseUtils_TransformWorldRotatorToBased::WorldSpaceRotator' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldRotatorToBased, OutLocalRotator) == 0x000028, "Member 'MovementBaseUtils_TransformWorldRotatorToBased::OutLocalRotator' has a wrong offset!");
static_assert(offsetof(MovementBaseUtils_TransformWorldRotatorToBased, ReturnValue) == 0x000040, "Member 'MovementBaseUtils_TransformWorldRotatorToBased::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.CanEscapeGravity
// 0x0050 (0x0050 - 0x0000)
struct MovementUtils_CanEscapeGravity final
{
public:
	struct FVector                                PriorVelocity;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewVelocity;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GravityAccel;                                      // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x004C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_CanEscapeGravity) == 0x000008, "Wrong alignment on MovementUtils_CanEscapeGravity");
static_assert(sizeof(MovementUtils_CanEscapeGravity) == 0x000050, "Wrong size on MovementUtils_CanEscapeGravity");
static_assert(offsetof(MovementUtils_CanEscapeGravity, PriorVelocity) == 0x000000, "Member 'MovementUtils_CanEscapeGravity::PriorVelocity' has a wrong offset!");
static_assert(offsetof(MovementUtils_CanEscapeGravity, NewVelocity) == 0x000018, "Member 'MovementUtils_CanEscapeGravity::NewVelocity' has a wrong offset!");
static_assert(offsetof(MovementUtils_CanEscapeGravity, GravityAccel) == 0x000030, "Member 'MovementUtils_CanEscapeGravity::GravityAccel' has a wrong offset!");
static_assert(offsetof(MovementUtils_CanEscapeGravity, DeltaSeconds) == 0x000048, "Member 'MovementUtils_CanEscapeGravity::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(MovementUtils_CanEscapeGravity, ReturnValue) == 0x00004C, "Member 'MovementUtils_CanEscapeGravity::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.CanStepUpOnHitSurface
// 0x00F0 (0x00F0 - 0x0000)
struct MovementUtils_CanStepUpOnHitSurface final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_CanStepUpOnHitSurface) == 0x000008, "Wrong alignment on MovementUtils_CanStepUpOnHitSurface");
static_assert(sizeof(MovementUtils_CanStepUpOnHitSurface) == 0x0000F0, "Wrong size on MovementUtils_CanStepUpOnHitSurface");
static_assert(offsetof(MovementUtils_CanStepUpOnHitSurface, Hit) == 0x000000, "Member 'MovementUtils_CanStepUpOnHitSurface::Hit' has a wrong offset!");
static_assert(offsetof(MovementUtils_CanStepUpOnHitSurface, ReturnValue) == 0x0000E8, "Member 'MovementUtils_CanStepUpOnHitSurface::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeAngularVelocity
// 0x0050 (0x0050 - 0x0000)
struct MovementUtils_ComputeAngularVelocity final
{
public:
	struct FRotator                               From;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               To;                                                // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningRateLimit;                                  // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeAngularVelocity) == 0x000008, "Wrong alignment on MovementUtils_ComputeAngularVelocity");
static_assert(sizeof(MovementUtils_ComputeAngularVelocity) == 0x000050, "Wrong size on MovementUtils_ComputeAngularVelocity");
static_assert(offsetof(MovementUtils_ComputeAngularVelocity, From) == 0x000000, "Member 'MovementUtils_ComputeAngularVelocity::From' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeAngularVelocity, To) == 0x000018, "Member 'MovementUtils_ComputeAngularVelocity::To' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeAngularVelocity, DeltaSeconds) == 0x000030, "Member 'MovementUtils_ComputeAngularVelocity::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeAngularVelocity, TurningRateLimit) == 0x000034, "Member 'MovementUtils_ComputeAngularVelocity::TurningRateLimit' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeAngularVelocity, ReturnValue) == 0x000038, "Member 'MovementUtils_ComputeAngularVelocity::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeControlledFreeMove
// 0x0108 (0x0108 - 0x0000)
struct MovementUtils_ComputeControlledFreeMove final
{
public:
	struct FFreeMoveParams                        InParams;                                          // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FProposedMove                          ReturnValue;                                       // 0x0080(0x0088)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeControlledFreeMove) == 0x000008, "Wrong alignment on MovementUtils_ComputeControlledFreeMove");
static_assert(sizeof(MovementUtils_ComputeControlledFreeMove) == 0x000108, "Wrong size on MovementUtils_ComputeControlledFreeMove");
static_assert(offsetof(MovementUtils_ComputeControlledFreeMove, InParams) == 0x000000, "Member 'MovementUtils_ComputeControlledFreeMove::InParams' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeControlledFreeMove, ReturnValue) == 0x000080, "Member 'MovementUtils_ComputeControlledFreeMove::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeControlledGroundMove
// 0x0128 (0x0128 - 0x0000)
struct MovementUtils_ComputeControlledGroundMove final
{
public:
	struct FGroundMoveParams                      InParams;                                          // 0x0000(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FProposedMove                          ReturnValue;                                       // 0x00A0(0x0088)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeControlledGroundMove) == 0x000008, "Wrong alignment on MovementUtils_ComputeControlledGroundMove");
static_assert(sizeof(MovementUtils_ComputeControlledGroundMove) == 0x000128, "Wrong size on MovementUtils_ComputeControlledGroundMove");
static_assert(offsetof(MovementUtils_ComputeControlledGroundMove, InParams) == 0x000000, "Member 'MovementUtils_ComputeControlledGroundMove::InParams' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeControlledGroundMove, ReturnValue) == 0x0000A0, "Member 'MovementUtils_ComputeControlledGroundMove::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeDeflectedMoveOntoRamp
// 0x0120 (0x0120 - 0x0000)
struct MovementUtils_ComputeDeflectedMoveOntoRamp final
{
public:
	struct FVector                                OrigMoveDelta;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             RampHitResult;                                     // 0x0018(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MaxWalkSlopeCosine;                                // 0x0100(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitFromLineTrace;                                 // 0x0104(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0108(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeDeflectedMoveOntoRamp) == 0x000008, "Wrong alignment on MovementUtils_ComputeDeflectedMoveOntoRamp");
static_assert(sizeof(MovementUtils_ComputeDeflectedMoveOntoRamp) == 0x000120, "Wrong size on MovementUtils_ComputeDeflectedMoveOntoRamp");
static_assert(offsetof(MovementUtils_ComputeDeflectedMoveOntoRamp, OrigMoveDelta) == 0x000000, "Member 'MovementUtils_ComputeDeflectedMoveOntoRamp::OrigMoveDelta' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeDeflectedMoveOntoRamp, RampHitResult) == 0x000018, "Member 'MovementUtils_ComputeDeflectedMoveOntoRamp::RampHitResult' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeDeflectedMoveOntoRamp, MaxWalkSlopeCosine) == 0x000100, "Member 'MovementUtils_ComputeDeflectedMoveOntoRamp::MaxWalkSlopeCosine' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeDeflectedMoveOntoRamp, bHitFromLineTrace) == 0x000104, "Member 'MovementUtils_ComputeDeflectedMoveOntoRamp::bHitFromLineTrace' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeDeflectedMoveOntoRamp, ReturnValue) == 0x000108, "Member 'MovementUtils_ComputeDeflectedMoveOntoRamp::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeDirectionIntent
// 0x0038 (0x0038 - 0x0000)
struct MovementUtils_ComputeDirectionIntent final
{
public:
	struct FVector                                MoveInput;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveInputType                                MoveInputType;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeDirectionIntent) == 0x000008, "Wrong alignment on MovementUtils_ComputeDirectionIntent");
static_assert(sizeof(MovementUtils_ComputeDirectionIntent) == 0x000038, "Wrong size on MovementUtils_ComputeDirectionIntent");
static_assert(offsetof(MovementUtils_ComputeDirectionIntent, MoveInput) == 0x000000, "Member 'MovementUtils_ComputeDirectionIntent::MoveInput' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeDirectionIntent, MoveInputType) == 0x000018, "Member 'MovementUtils_ComputeDirectionIntent::MoveInputType' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeDirectionIntent, ReturnValue) == 0x000020, "Member 'MovementUtils_ComputeDirectionIntent::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeSlideDelta
// 0x0138 (0x0138 - 0x0000)
struct MovementUtils_ComputeSlideDelta final
{
public:
	struct FVector                                Delta;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PctOfDeltaToMove;                                  // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Normal;                                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0038(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0120(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeSlideDelta) == 0x000008, "Wrong alignment on MovementUtils_ComputeSlideDelta");
static_assert(sizeof(MovementUtils_ComputeSlideDelta) == 0x000138, "Wrong size on MovementUtils_ComputeSlideDelta");
static_assert(offsetof(MovementUtils_ComputeSlideDelta, Delta) == 0x000000, "Member 'MovementUtils_ComputeSlideDelta::Delta' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeSlideDelta, PctOfDeltaToMove) == 0x000018, "Member 'MovementUtils_ComputeSlideDelta::PctOfDeltaToMove' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeSlideDelta, Normal) == 0x000020, "Member 'MovementUtils_ComputeSlideDelta::Normal' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeSlideDelta, Hit) == 0x000038, "Member 'MovementUtils_ComputeSlideDelta::Hit' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeSlideDelta, ReturnValue) == 0x000120, "Member 'MovementUtils_ComputeSlideDelta::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeVelocity
// 0x0068 (0x0068 - 0x0000)
struct MovementUtils_ComputeVelocity final
{
public:
	struct FComputeVelocityParams                 InParams;                                          // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0050(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeVelocity) == 0x000008, "Wrong alignment on MovementUtils_ComputeVelocity");
static_assert(sizeof(MovementUtils_ComputeVelocity) == 0x000068, "Wrong size on MovementUtils_ComputeVelocity");
static_assert(offsetof(MovementUtils_ComputeVelocity, InParams) == 0x000000, "Member 'MovementUtils_ComputeVelocity::InParams' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeVelocity, ReturnValue) == 0x000050, "Member 'MovementUtils_ComputeVelocity::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeVelocityFromGravity
// 0x0038 (0x0038 - 0x0000)
struct MovementUtils_ComputeVelocityFromGravity final
{
public:
	struct FVector                                GravityAccel;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeVelocityFromGravity) == 0x000008, "Wrong alignment on MovementUtils_ComputeVelocityFromGravity");
static_assert(sizeof(MovementUtils_ComputeVelocityFromGravity) == 0x000038, "Wrong size on MovementUtils_ComputeVelocityFromGravity");
static_assert(offsetof(MovementUtils_ComputeVelocityFromGravity, GravityAccel) == 0x000000, "Member 'MovementUtils_ComputeVelocityFromGravity::GravityAccel' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeVelocityFromGravity, DeltaSeconds) == 0x000018, "Member 'MovementUtils_ComputeVelocityFromGravity::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeVelocityFromGravity, ReturnValue) == 0x000020, "Member 'MovementUtils_ComputeVelocityFromGravity::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ComputeVelocityFromPositions
// 0x0050 (0x0050 - 0x0000)
struct MovementUtils_ComputeVelocityFromPositions final
{
public:
	struct FVector                                FromPos;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ToPos;                                             // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ComputeVelocityFromPositions) == 0x000008, "Wrong alignment on MovementUtils_ComputeVelocityFromPositions");
static_assert(sizeof(MovementUtils_ComputeVelocityFromPositions) == 0x000050, "Wrong size on MovementUtils_ComputeVelocityFromPositions");
static_assert(offsetof(MovementUtils_ComputeVelocityFromPositions, FromPos) == 0x000000, "Member 'MovementUtils_ComputeVelocityFromPositions::FromPos' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeVelocityFromPositions, ToPos) == 0x000018, "Member 'MovementUtils_ComputeVelocityFromPositions::ToPos' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeVelocityFromPositions, DeltaSeconds) == 0x000030, "Member 'MovementUtils_ComputeVelocityFromPositions::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(MovementUtils_ComputeVelocityFromPositions, ReturnValue) == 0x000038, "Member 'MovementUtils_ComputeVelocityFromPositions::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.ConstrainToPlane
// 0x0060 (0x0060 - 0x0000)
struct MovementUtils_ConstrainToPlane final
{
public:
	struct FVector                                Vector;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlane                                 MovementPlane;                                     // 0x0020(0x0020)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainMagnitude;                                // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementUtils_ConstrainToPlane) == 0x000010, "Wrong alignment on MovementUtils_ConstrainToPlane");
static_assert(sizeof(MovementUtils_ConstrainToPlane) == 0x000060, "Wrong size on MovementUtils_ConstrainToPlane");
static_assert(offsetof(MovementUtils_ConstrainToPlane, Vector) == 0x000000, "Member 'MovementUtils_ConstrainToPlane::Vector' has a wrong offset!");
static_assert(offsetof(MovementUtils_ConstrainToPlane, MovementPlane) == 0x000020, "Member 'MovementUtils_ConstrainToPlane::MovementPlane' has a wrong offset!");
static_assert(offsetof(MovementUtils_ConstrainToPlane, bMaintainMagnitude) == 0x000040, "Member 'MovementUtils_ConstrainToPlane::bMaintainMagnitude' has a wrong offset!");
static_assert(offsetof(MovementUtils_ConstrainToPlane, ReturnValue) == 0x000048, "Member 'MovementUtils_ConstrainToPlane::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.IsExceedingMaxSpeed
// 0x0020 (0x0020 - 0x0000)
struct MovementUtils_IsExceedingMaxSpeed final
{
public:
	struct FVector                                Velocity;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMaxSpeed;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_IsExceedingMaxSpeed) == 0x000008, "Wrong alignment on MovementUtils_IsExceedingMaxSpeed");
static_assert(sizeof(MovementUtils_IsExceedingMaxSpeed) == 0x000020, "Wrong size on MovementUtils_IsExceedingMaxSpeed");
static_assert(offsetof(MovementUtils_IsExceedingMaxSpeed, Velocity) == 0x000000, "Member 'MovementUtils_IsExceedingMaxSpeed::Velocity' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsExceedingMaxSpeed, InMaxSpeed) == 0x000018, "Member 'MovementUtils_IsExceedingMaxSpeed::InMaxSpeed' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsExceedingMaxSpeed, ReturnValue) == 0x00001C, "Member 'MovementUtils_IsExceedingMaxSpeed::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.IsHitSurfaceWalkable
// 0x00F0 (0x00F0 - 0x0000)
struct MovementUtils_IsHitSurfaceWalkable final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MaxWalkSlopeCosine;                                // 0x00E8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00EC(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_IsHitSurfaceWalkable) == 0x000008, "Wrong alignment on MovementUtils_IsHitSurfaceWalkable");
static_assert(sizeof(MovementUtils_IsHitSurfaceWalkable) == 0x0000F0, "Wrong size on MovementUtils_IsHitSurfaceWalkable");
static_assert(offsetof(MovementUtils_IsHitSurfaceWalkable, Hit) == 0x000000, "Member 'MovementUtils_IsHitSurfaceWalkable::Hit' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsHitSurfaceWalkable, MaxWalkSlopeCosine) == 0x0000E8, "Member 'MovementUtils_IsHitSurfaceWalkable::MaxWalkSlopeCosine' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsHitSurfaceWalkable, ReturnValue) == 0x0000EC, "Member 'MovementUtils_IsHitSurfaceWalkable::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.IsValidLandingSpot
// 0x0218 (0x0218 - 0x0000)
struct MovementUtils_IsValidLandingSpot final
{
public:
	class USceneComponent*                        UpdatedComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    UpdatedPrimitive;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0028(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         FloorSweepDistance;                                // 0x0110(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSlopeCosine;                                // 0x0114(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloorCheckResult                      OutFloorResult;                                    // 0x0118(0x00F8)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0210(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_IsValidLandingSpot) == 0x000008, "Wrong alignment on MovementUtils_IsValidLandingSpot");
static_assert(sizeof(MovementUtils_IsValidLandingSpot) == 0x000218, "Wrong size on MovementUtils_IsValidLandingSpot");
static_assert(offsetof(MovementUtils_IsValidLandingSpot, UpdatedComponent) == 0x000000, "Member 'MovementUtils_IsValidLandingSpot::UpdatedComponent' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsValidLandingSpot, UpdatedPrimitive) == 0x000008, "Member 'MovementUtils_IsValidLandingSpot::UpdatedPrimitive' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsValidLandingSpot, Location) == 0x000010, "Member 'MovementUtils_IsValidLandingSpot::Location' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsValidLandingSpot, Hit) == 0x000028, "Member 'MovementUtils_IsValidLandingSpot::Hit' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsValidLandingSpot, FloorSweepDistance) == 0x000110, "Member 'MovementUtils_IsValidLandingSpot::FloorSweepDistance' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsValidLandingSpot, MaxWalkSlopeCosine) == 0x000114, "Member 'MovementUtils_IsValidLandingSpot::MaxWalkSlopeCosine' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsValidLandingSpot, OutFloorResult) == 0x000118, "Member 'MovementUtils_IsValidLandingSpot::OutFloorResult' has a wrong offset!");
static_assert(offsetof(MovementUtils_IsValidLandingSpot, ReturnValue) == 0x000210, "Member 'MovementUtils_IsValidLandingSpot::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.TryMoveToFallAlongSurface
// 0x02C0 (0x02C0 - 0x0000)
struct MovementUtils_TryMoveToFallAlongSurface final
{
public:
	class USceneComponent*                        UpdatedComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    UpdatedPrimitive;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoverComponent*                        MoverComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Delta;                                             // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PctOfDeltaToMove;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0040(0x0020)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0060(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0078(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHandleImpact;                                     // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloorSweepDistance;                                // 0x0164(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSlopeCosine;                                // 0x0168(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloorCheckResult                      OutFloorResult;                                    // 0x0170(0x00F8)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMovementRecord                        MoveRecord;                                        // 0x0268(0x0048)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x02B0(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0xC];                                      // 0x02B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_TryMoveToFallAlongSurface) == 0x000010, "Wrong alignment on MovementUtils_TryMoveToFallAlongSurface");
static_assert(sizeof(MovementUtils_TryMoveToFallAlongSurface) == 0x0002C0, "Wrong size on MovementUtils_TryMoveToFallAlongSurface");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, UpdatedComponent) == 0x000000, "Member 'MovementUtils_TryMoveToFallAlongSurface::UpdatedComponent' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, UpdatedPrimitive) == 0x000008, "Member 'MovementUtils_TryMoveToFallAlongSurface::UpdatedPrimitive' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, MoverComponent) == 0x000010, "Member 'MovementUtils_TryMoveToFallAlongSurface::MoverComponent' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, Delta) == 0x000018, "Member 'MovementUtils_TryMoveToFallAlongSurface::Delta' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, PctOfDeltaToMove) == 0x000030, "Member 'MovementUtils_TryMoveToFallAlongSurface::PctOfDeltaToMove' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, Rotation) == 0x000040, "Member 'MovementUtils_TryMoveToFallAlongSurface::Rotation' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, Normal) == 0x000060, "Member 'MovementUtils_TryMoveToFallAlongSurface::Normal' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, Hit) == 0x000078, "Member 'MovementUtils_TryMoveToFallAlongSurface::Hit' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, bHandleImpact) == 0x000160, "Member 'MovementUtils_TryMoveToFallAlongSurface::bHandleImpact' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, FloorSweepDistance) == 0x000164, "Member 'MovementUtils_TryMoveToFallAlongSurface::FloorSweepDistance' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, MaxWalkSlopeCosine) == 0x000168, "Member 'MovementUtils_TryMoveToFallAlongSurface::MaxWalkSlopeCosine' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, OutFloorResult) == 0x000170, "Member 'MovementUtils_TryMoveToFallAlongSurface::OutFloorResult' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, MoveRecord) == 0x000268, "Member 'MovementUtils_TryMoveToFallAlongSurface::MoveRecord' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToFallAlongSurface, ReturnValue) == 0x0002B0, "Member 'MovementUtils_TryMoveToFallAlongSurface::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.TryMoveToSlideAlongSurface
// 0x01C0 (0x01C0 - 0x0000)
struct MovementUtils_TryMoveToSlideAlongSurface final
{
public:
	class USceneComponent*                        UpdatedComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    UpdatedPrimitive;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoverComponent*                        MoverComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Delta;                                             // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PctOfDeltaToMove;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0040(0x0020)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0060(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0078(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHandleImpact;                                     // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementRecord                        MoveRecord;                                        // 0x0168(0x0048)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x01B0(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0xC];                                      // 0x01B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_TryMoveToSlideAlongSurface) == 0x000010, "Wrong alignment on MovementUtils_TryMoveToSlideAlongSurface");
static_assert(sizeof(MovementUtils_TryMoveToSlideAlongSurface) == 0x0001C0, "Wrong size on MovementUtils_TryMoveToSlideAlongSurface");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, UpdatedComponent) == 0x000000, "Member 'MovementUtils_TryMoveToSlideAlongSurface::UpdatedComponent' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, UpdatedPrimitive) == 0x000008, "Member 'MovementUtils_TryMoveToSlideAlongSurface::UpdatedPrimitive' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, MoverComponent) == 0x000010, "Member 'MovementUtils_TryMoveToSlideAlongSurface::MoverComponent' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, Delta) == 0x000018, "Member 'MovementUtils_TryMoveToSlideAlongSurface::Delta' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, PctOfDeltaToMove) == 0x000030, "Member 'MovementUtils_TryMoveToSlideAlongSurface::PctOfDeltaToMove' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, Rotation) == 0x000040, "Member 'MovementUtils_TryMoveToSlideAlongSurface::Rotation' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, Normal) == 0x000060, "Member 'MovementUtils_TryMoveToSlideAlongSurface::Normal' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, Hit) == 0x000078, "Member 'MovementUtils_TryMoveToSlideAlongSurface::Hit' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, bHandleImpact) == 0x000160, "Member 'MovementUtils_TryMoveToSlideAlongSurface::bHandleImpact' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, MoveRecord) == 0x000168, "Member 'MovementUtils_TryMoveToSlideAlongSurface::MoveRecord' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryMoveToSlideAlongSurface, ReturnValue) == 0x0001B0, "Member 'MovementUtils_TryMoveToSlideAlongSurface::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.TrySafeMoveUpdatedComponent
// 0x01A0 (0x01A0 - 0x0000)
struct MovementUtils_TrySafeMoveUpdatedComponent final
{
public:
	class USceneComponent*                        UpdatedComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    UpdatedPrimitive;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Delta;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  NewRotation;                                       // 0x0030(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0058(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ETeleportType                                 Teleport;                                          // 0x0140(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementRecord                        MoveRecord;                                        // 0x0148(0x0048)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0190(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0xF];                                      // 0x0191(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_TrySafeMoveUpdatedComponent) == 0x000010, "Wrong alignment on MovementUtils_TrySafeMoveUpdatedComponent");
static_assert(sizeof(MovementUtils_TrySafeMoveUpdatedComponent) == 0x0001A0, "Wrong size on MovementUtils_TrySafeMoveUpdatedComponent");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, UpdatedComponent) == 0x000000, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::UpdatedComponent' has a wrong offset!");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, UpdatedPrimitive) == 0x000008, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::UpdatedPrimitive' has a wrong offset!");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, Delta) == 0x000010, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::Delta' has a wrong offset!");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, NewRotation) == 0x000030, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::NewRotation' has a wrong offset!");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, bSweep) == 0x000050, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::bSweep' has a wrong offset!");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, OutHit) == 0x000058, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::OutHit' has a wrong offset!");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, Teleport) == 0x000140, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::Teleport' has a wrong offset!");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, MoveRecord) == 0x000148, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::MoveRecord' has a wrong offset!");
static_assert(offsetof(MovementUtils_TrySafeMoveUpdatedComponent, ReturnValue) == 0x000190, "Member 'MovementUtils_TrySafeMoveUpdatedComponent::ReturnValue' has a wrong offset!");

// Function Mover.MovementUtils.TryWalkToSlideAlongSurface
// 0x01C0 (0x01C0 - 0x0000)
struct MovementUtils_TryWalkToSlideAlongSurface final
{
public:
	class USceneComponent*                        UpdatedComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    UpdatedPrimitive;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoverComponent*                        MoverComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Delta;                                             // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PctOfDeltaToMove;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0040(0x0020)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0060(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0078(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHandleImpact;                                     // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementRecord                        MoveRecord;                                        // 0x0168(0x0048)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         MaxWalkSlopeCosine;                                // 0x01B0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x01B4(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementUtils_TryWalkToSlideAlongSurface) == 0x000010, "Wrong alignment on MovementUtils_TryWalkToSlideAlongSurface");
static_assert(sizeof(MovementUtils_TryWalkToSlideAlongSurface) == 0x0001C0, "Wrong size on MovementUtils_TryWalkToSlideAlongSurface");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, UpdatedComponent) == 0x000000, "Member 'MovementUtils_TryWalkToSlideAlongSurface::UpdatedComponent' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, UpdatedPrimitive) == 0x000008, "Member 'MovementUtils_TryWalkToSlideAlongSurface::UpdatedPrimitive' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, MoverComponent) == 0x000010, "Member 'MovementUtils_TryWalkToSlideAlongSurface::MoverComponent' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, Delta) == 0x000018, "Member 'MovementUtils_TryWalkToSlideAlongSurface::Delta' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, PctOfDeltaToMove) == 0x000030, "Member 'MovementUtils_TryWalkToSlideAlongSurface::PctOfDeltaToMove' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, Rotation) == 0x000040, "Member 'MovementUtils_TryWalkToSlideAlongSurface::Rotation' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, Normal) == 0x000060, "Member 'MovementUtils_TryWalkToSlideAlongSurface::Normal' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, Hit) == 0x000078, "Member 'MovementUtils_TryWalkToSlideAlongSurface::Hit' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, bHandleImpact) == 0x000160, "Member 'MovementUtils_TryWalkToSlideAlongSurface::bHandleImpact' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, MoveRecord) == 0x000168, "Member 'MovementUtils_TryWalkToSlideAlongSurface::MoveRecord' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, MaxWalkSlopeCosine) == 0x0001B0, "Member 'MovementUtils_TryWalkToSlideAlongSurface::MaxWalkSlopeCosine' has a wrong offset!");
static_assert(offsetof(MovementUtils_TryWalkToSlideAlongSurface, ReturnValue) == 0x0001B4, "Member 'MovementUtils_TryWalkToSlideAlongSurface::ReturnValue' has a wrong offset!");

// Function Mover.PlayMoverMontageCallbackProxy.CreateProxyObjectForPlayMoverMontage
// 0x0028 (0x0028 - 0x0000)
struct PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage final
{
public:
	class UMoverComponent*                        InMoverComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingPosition;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartingSection;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayMoverMontageCallbackProxy*         ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage) == 0x000008, "Wrong alignment on PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage");
static_assert(sizeof(PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage) == 0x000028, "Wrong size on PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage");
static_assert(offsetof(PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage, InMoverComponent) == 0x000000, "Member 'PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage::InMoverComponent' has a wrong offset!");
static_assert(offsetof(PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage, MontageToPlay) == 0x000008, "Member 'PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage::MontageToPlay' has a wrong offset!");
static_assert(offsetof(PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage, PlayRate) == 0x000010, "Member 'PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage::PlayRate' has a wrong offset!");
static_assert(offsetof(PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage, StartingPosition) == 0x000014, "Member 'PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage::StartingPosition' has a wrong offset!");
static_assert(offsetof(PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage, StartingSection) == 0x000018, "Member 'PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage::StartingSection' has a wrong offset!");
static_assert(offsetof(PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage, ReturnValue) == 0x000020, "Member 'PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage::ReturnValue' has a wrong offset!");

// Function Mover.PlayMoverMontageCallbackProxy.OnMoverMontageEnded
// 0x0004 (0x0004 - 0x0000)
struct PlayMoverMontageCallbackProxy_OnMoverMontageEnded final
{
public:
	class FName                                   IgnoredNotifyName;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayMoverMontageCallbackProxy_OnMoverMontageEnded) == 0x000004, "Wrong alignment on PlayMoverMontageCallbackProxy_OnMoverMontageEnded");
static_assert(sizeof(PlayMoverMontageCallbackProxy_OnMoverMontageEnded) == 0x000004, "Wrong size on PlayMoverMontageCallbackProxy_OnMoverMontageEnded");
static_assert(offsetof(PlayMoverMontageCallbackProxy_OnMoverMontageEnded, IgnoredNotifyName) == 0x000000, "Member 'PlayMoverMontageCallbackProxy_OnMoverMontageEnded::IgnoredNotifyName' has a wrong offset!");

// Function Mover.MoverComponent.HandleImpact
// 0x0108 (0x0108 - 0x0000)
struct MoverComponent_HandleImpact final
{
public:
	struct FMoverOnImpactParams                   ImpactParams;                                      // 0x0000(0x0108)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_HandleImpact) == 0x000008, "Wrong alignment on MoverComponent_HandleImpact");
static_assert(sizeof(MoverComponent_HandleImpact) == 0x000108, "Wrong size on MoverComponent_HandleImpact");
static_assert(offsetof(MoverComponent_HandleImpact, ImpactParams) == 0x000000, "Member 'MoverComponent_HandleImpact::ImpactParams' has a wrong offset!");

// Function Mover.MoverComponent.K2_QueueLayeredMove
// 0x0004 (0x0004 - 0x0000)
struct MoverComponent_K2_QueueLayeredMove final
{
public:
	int32                                         MoveAsRawData;                                     // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_K2_QueueLayeredMove) == 0x000004, "Wrong alignment on MoverComponent_K2_QueueLayeredMove");
static_assert(sizeof(MoverComponent_K2_QueueLayeredMove) == 0x000004, "Wrong size on MoverComponent_K2_QueueLayeredMove");
static_assert(offsetof(MoverComponent_K2_QueueLayeredMove, MoveAsRawData) == 0x000000, "Member 'MoverComponent_K2_QueueLayeredMove::MoveAsRawData' has a wrong offset!");

// Function Mover.MoverComponent.OnBeginOverlap
// 0x0108 (0x0108 - 0x0000)
struct MoverComponent_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_OnBeginOverlap) == 0x000008, "Wrong alignment on MoverComponent_OnBeginOverlap");
static_assert(sizeof(MoverComponent_OnBeginOverlap) == 0x000108, "Wrong size on MoverComponent_OnBeginOverlap");
static_assert(offsetof(MoverComponent_OnBeginOverlap, OverlappedComp) == 0x000000, "Member 'MoverComponent_OnBeginOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(MoverComponent_OnBeginOverlap, Other) == 0x000008, "Member 'MoverComponent_OnBeginOverlap::Other' has a wrong offset!");
static_assert(offsetof(MoverComponent_OnBeginOverlap, OtherComp) == 0x000010, "Member 'MoverComponent_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(MoverComponent_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'MoverComponent_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(MoverComponent_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'MoverComponent_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(MoverComponent_OnBeginOverlap, SweepResult) == 0x000020, "Member 'MoverComponent_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function Mover.MoverComponent.PhysicsVolumeChanged
// 0x0008 (0x0008 - 0x0000)
struct MoverComponent_PhysicsVolumeChanged final
{
public:
	class APhysicsVolume*                         NewVolume;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_PhysicsVolumeChanged) == 0x000008, "Wrong alignment on MoverComponent_PhysicsVolumeChanged");
static_assert(sizeof(MoverComponent_PhysicsVolumeChanged) == 0x000008, "Wrong size on MoverComponent_PhysicsVolumeChanged");
static_assert(offsetof(MoverComponent_PhysicsVolumeChanged, NewVolume) == 0x000000, "Member 'MoverComponent_PhysicsVolumeChanged::NewVolume' has a wrong offset!");

// Function Mover.MoverComponent.QueueNextMode
// 0x0008 (0x0008 - 0x0000)
struct MoverComponent_QueueNextMode final
{
public:
	class FName                                   DesiredModeName;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldReenter;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoverComponent_QueueNextMode) == 0x000004, "Wrong alignment on MoverComponent_QueueNextMode");
static_assert(sizeof(MoverComponent_QueueNextMode) == 0x000008, "Wrong size on MoverComponent_QueueNextMode");
static_assert(offsetof(MoverComponent_QueueNextMode, DesiredModeName) == 0x000000, "Member 'MoverComponent_QueueNextMode::DesiredModeName' has a wrong offset!");
static_assert(offsetof(MoverComponent_QueueNextMode, bShouldReenter) == 0x000004, "Member 'MoverComponent_QueueNextMode::bShouldReenter' has a wrong offset!");

// Function Mover.MoverComponent.SetGravityOverride
// 0x0020 (0x0020 - 0x0000)
struct MoverComponent_SetGravityOverride final
{
public:
	bool                                          bOverrideGravity;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GravityAcceleration;                               // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_SetGravityOverride) == 0x000008, "Wrong alignment on MoverComponent_SetGravityOverride");
static_assert(sizeof(MoverComponent_SetGravityOverride) == 0x000020, "Wrong size on MoverComponent_SetGravityOverride");
static_assert(offsetof(MoverComponent_SetGravityOverride, bOverrideGravity) == 0x000000, "Member 'MoverComponent_SetGravityOverride::bOverrideGravity' has a wrong offset!");
static_assert(offsetof(MoverComponent_SetGravityOverride, GravityAcceleration) == 0x000008, "Member 'MoverComponent_SetGravityOverride::GravityAcceleration' has a wrong offset!");

// Function Mover.MoverComponent.FindMovementMode
// 0x0010 (0x0010 - 0x0000)
struct MoverComponent_FindMovementMode final
{
public:
	TSubclassOf<class UBaseMovementMode>          MovementMode;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBaseMovementMode*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_FindMovementMode) == 0x000008, "Wrong alignment on MoverComponent_FindMovementMode");
static_assert(sizeof(MoverComponent_FindMovementMode) == 0x000010, "Wrong size on MoverComponent_FindMovementMode");
static_assert(offsetof(MoverComponent_FindMovementMode, MovementMode) == 0x000000, "Member 'MoverComponent_FindMovementMode::MovementMode' has a wrong offset!");
static_assert(offsetof(MoverComponent_FindMovementMode, ReturnValue) == 0x000008, "Member 'MoverComponent_FindMovementMode::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.FindSharedSettings_BP
// 0x0010 (0x0010 - 0x0000)
struct MoverComponent_FindSharedSettings_BP final
{
public:
	TSubclassOf<class UObject>                    SharedSetting;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_FindSharedSettings_BP) == 0x000008, "Wrong alignment on MoverComponent_FindSharedSettings_BP");
static_assert(sizeof(MoverComponent_FindSharedSettings_BP) == 0x000010, "Wrong size on MoverComponent_FindSharedSettings_BP");
static_assert(offsetof(MoverComponent_FindSharedSettings_BP, SharedSetting) == 0x000000, "Member 'MoverComponent_FindSharedSettings_BP::SharedSetting' has a wrong offset!");
static_assert(offsetof(MoverComponent_FindSharedSettings_BP, ReturnValue) == 0x000008, "Member 'MoverComponent_FindSharedSettings_BP::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.FindSharedSettings_Mutable_BP
// 0x0010 (0x0010 - 0x0000)
struct MoverComponent_FindSharedSettings_Mutable_BP final
{
public:
	TSubclassOf<class UObject>                    SharedSetting;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_FindSharedSettings_Mutable_BP) == 0x000008, "Wrong alignment on MoverComponent_FindSharedSettings_Mutable_BP");
static_assert(sizeof(MoverComponent_FindSharedSettings_Mutable_BP) == 0x000010, "Wrong size on MoverComponent_FindSharedSettings_Mutable_BP");
static_assert(offsetof(MoverComponent_FindSharedSettings_Mutable_BP, SharedSetting) == 0x000000, "Member 'MoverComponent_FindSharedSettings_Mutable_BP::SharedSetting' has a wrong offset!");
static_assert(offsetof(MoverComponent_FindSharedSettings_Mutable_BP, ReturnValue) == 0x000008, "Member 'MoverComponent_FindSharedSettings_Mutable_BP::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetGravityAcceleration
// 0x0018 (0x0018 - 0x0000)
struct MoverComponent_GetGravityAcceleration final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetGravityAcceleration) == 0x000008, "Wrong alignment on MoverComponent_GetGravityAcceleration");
static_assert(sizeof(MoverComponent_GetGravityAcceleration) == 0x000018, "Wrong size on MoverComponent_GetGravityAcceleration");
static_assert(offsetof(MoverComponent_GetGravityAcceleration, ReturnValue) == 0x000000, "Member 'MoverComponent_GetGravityAcceleration::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetLastInputCmd
// 0x0018 (0x0018 - 0x0000)
struct MoverComponent_GetLastInputCmd final
{
public:
	struct FMoverInputCmdContext                  ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetLastInputCmd) == 0x000008, "Wrong alignment on MoverComponent_GetLastInputCmd");
static_assert(sizeof(MoverComponent_GetLastInputCmd) == 0x000018, "Wrong size on MoverComponent_GetLastInputCmd");
static_assert(offsetof(MoverComponent_GetLastInputCmd, ReturnValue) == 0x000000, "Member 'MoverComponent_GetLastInputCmd::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetMovementBase
// 0x0008 (0x0008 - 0x0000)
struct MoverComponent_GetMovementBase final
{
public:
	class UPrimitiveComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetMovementBase) == 0x000008, "Wrong alignment on MoverComponent_GetMovementBase");
static_assert(sizeof(MoverComponent_GetMovementBase) == 0x000008, "Wrong size on MoverComponent_GetMovementBase");
static_assert(offsetof(MoverComponent_GetMovementBase, ReturnValue) == 0x000000, "Member 'MoverComponent_GetMovementBase::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetMovementBaseBoneName
// 0x0004 (0x0004 - 0x0000)
struct MoverComponent_GetMovementBaseBoneName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetMovementBaseBoneName) == 0x000004, "Wrong alignment on MoverComponent_GetMovementBaseBoneName");
static_assert(sizeof(MoverComponent_GetMovementBaseBoneName) == 0x000004, "Wrong size on MoverComponent_GetMovementBaseBoneName");
static_assert(offsetof(MoverComponent_GetMovementBaseBoneName, ReturnValue) == 0x000000, "Member 'MoverComponent_GetMovementBaseBoneName::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetMovementIntent
// 0x0018 (0x0018 - 0x0000)
struct MoverComponent_GetMovementIntent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetMovementIntent) == 0x000008, "Wrong alignment on MoverComponent_GetMovementIntent");
static_assert(sizeof(MoverComponent_GetMovementIntent) == 0x000018, "Wrong size on MoverComponent_GetMovementIntent");
static_assert(offsetof(MoverComponent_GetMovementIntent, ReturnValue) == 0x000000, "Member 'MoverComponent_GetMovementIntent::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetMovementModeName
// 0x0004 (0x0004 - 0x0000)
struct MoverComponent_GetMovementModeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetMovementModeName) == 0x000004, "Wrong alignment on MoverComponent_GetMovementModeName");
static_assert(sizeof(MoverComponent_GetMovementModeName) == 0x000004, "Wrong size on MoverComponent_GetMovementModeName");
static_assert(offsetof(MoverComponent_GetMovementModeName, ReturnValue) == 0x000000, "Member 'MoverComponent_GetMovementModeName::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetSyncState
// 0x0018 (0x0018 - 0x0000)
struct MoverComponent_GetSyncState final
{
public:
	struct FMoverSyncState                        ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetSyncState) == 0x000008, "Wrong alignment on MoverComponent_GetSyncState");
static_assert(sizeof(MoverComponent_GetSyncState) == 0x000018, "Wrong size on MoverComponent_GetSyncState");
static_assert(offsetof(MoverComponent_GetSyncState, ReturnValue) == 0x000000, "Member 'MoverComponent_GetSyncState::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetTargetOrientation
// 0x0018 (0x0018 - 0x0000)
struct MoverComponent_GetTargetOrientation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetTargetOrientation) == 0x000008, "Wrong alignment on MoverComponent_GetTargetOrientation");
static_assert(sizeof(MoverComponent_GetTargetOrientation) == 0x000018, "Wrong size on MoverComponent_GetTargetOrientation");
static_assert(offsetof(MoverComponent_GetTargetOrientation, ReturnValue) == 0x000000, "Member 'MoverComponent_GetTargetOrientation::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetUpDirection
// 0x0018 (0x0018 - 0x0000)
struct MoverComponent_GetUpDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetUpDirection) == 0x000008, "Wrong alignment on MoverComponent_GetUpDirection");
static_assert(sizeof(MoverComponent_GetUpDirection) == 0x000018, "Wrong size on MoverComponent_GetUpDirection");
static_assert(offsetof(MoverComponent_GetUpDirection, ReturnValue) == 0x000000, "Member 'MoverComponent_GetUpDirection::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.GetVelocity
// 0x0018 (0x0018 - 0x0000)
struct MoverComponent_GetVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_GetVelocity) == 0x000008, "Wrong alignment on MoverComponent_GetVelocity");
static_assert(sizeof(MoverComponent_GetVelocity) == 0x000018, "Wrong size on MoverComponent_GetVelocity");
static_assert(offsetof(MoverComponent_GetVelocity, ReturnValue) == 0x000000, "Member 'MoverComponent_GetVelocity::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.HasValidCachedInputCmd
// 0x0001 (0x0001 - 0x0000)
struct MoverComponent_HasValidCachedInputCmd final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_HasValidCachedInputCmd) == 0x000001, "Wrong alignment on MoverComponent_HasValidCachedInputCmd");
static_assert(sizeof(MoverComponent_HasValidCachedInputCmd) == 0x000001, "Wrong size on MoverComponent_HasValidCachedInputCmd");
static_assert(offsetof(MoverComponent_HasValidCachedInputCmd, ReturnValue) == 0x000000, "Member 'MoverComponent_HasValidCachedInputCmd::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.HasValidCachedState
// 0x0001 (0x0001 - 0x0000)
struct MoverComponent_HasValidCachedState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_HasValidCachedState) == 0x000001, "Wrong alignment on MoverComponent_HasValidCachedState");
static_assert(sizeof(MoverComponent_HasValidCachedState) == 0x000001, "Wrong size on MoverComponent_HasValidCachedState");
static_assert(offsetof(MoverComponent_HasValidCachedState, ReturnValue) == 0x000000, "Member 'MoverComponent_HasValidCachedState::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.IsAirborne
// 0x0001 (0x0001 - 0x0000)
struct MoverComponent_IsAirborne final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_IsAirborne) == 0x000001, "Wrong alignment on MoverComponent_IsAirborne");
static_assert(sizeof(MoverComponent_IsAirborne) == 0x000001, "Wrong size on MoverComponent_IsAirborne");
static_assert(offsetof(MoverComponent_IsAirborne, ReturnValue) == 0x000000, "Member 'MoverComponent_IsAirborne::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.IsFalling
// 0x0001 (0x0001 - 0x0000)
struct MoverComponent_IsFalling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_IsFalling) == 0x000001, "Wrong alignment on MoverComponent_IsFalling");
static_assert(sizeof(MoverComponent_IsFalling) == 0x000001, "Wrong size on MoverComponent_IsFalling");
static_assert(offsetof(MoverComponent_IsFalling, ReturnValue) == 0x000000, "Member 'MoverComponent_IsFalling::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.IsOnGround
// 0x0001 (0x0001 - 0x0000)
struct MoverComponent_IsOnGround final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_IsOnGround) == 0x000001, "Wrong alignment on MoverComponent_IsOnGround");
static_assert(sizeof(MoverComponent_IsOnGround) == 0x000001, "Wrong size on MoverComponent_IsOnGround");
static_assert(offsetof(MoverComponent_IsOnGround, ReturnValue) == 0x000000, "Member 'MoverComponent_IsOnGround::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.IsSlopeSliding
// 0x0001 (0x0001 - 0x0000)
struct MoverComponent_IsSlopeSliding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoverComponent_IsSlopeSliding) == 0x000001, "Wrong alignment on MoverComponent_IsSlopeSliding");
static_assert(sizeof(MoverComponent_IsSlopeSliding) == 0x000001, "Wrong size on MoverComponent_IsSlopeSliding");
static_assert(offsetof(MoverComponent_IsSlopeSliding, ReturnValue) == 0x000000, "Member 'MoverComponent_IsSlopeSliding::ReturnValue' has a wrong offset!");

// Function Mover.MoverComponent.TryGetFloorCheckHitResult
// 0x00F0 (0x00F0 - 0x0000)
struct MoverComponent_TryGetFloorCheckHitResult final
{
public:
	struct FHitResult                             OutHitResult;                                      // 0x0000(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoverComponent_TryGetFloorCheckHitResult) == 0x000008, "Wrong alignment on MoverComponent_TryGetFloorCheckHitResult");
static_assert(sizeof(MoverComponent_TryGetFloorCheckHitResult) == 0x0000F0, "Wrong size on MoverComponent_TryGetFloorCheckHitResult");
static_assert(offsetof(MoverComponent_TryGetFloorCheckHitResult, OutHitResult) == 0x000000, "Member 'MoverComponent_TryGetFloorCheckHitResult::OutHitResult' has a wrong offset!");
static_assert(offsetof(MoverComponent_TryGetFloorCheckHitResult, ReturnValue) == 0x0000E8, "Member 'MoverComponent_TryGetFloorCheckHitResult::ReturnValue' has a wrong offset!");

}

