#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AtomRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "StructUtils_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum AtomRuntime.EAtomModelMergedMeshSelection
// NumValues: 0x0003
enum class EAtomModelMergedMeshSelection : uint8
{
	AllMeshes                                = 0,
	OnlyOpaqueMeshes                         = 1,
	OnlyTransparentMeshes                    = 2,
};

// Enum AtomRuntime.EAtomMaterialType
// NumValues: 0x0005
enum class EAtomMaterialType : uint8
{
	Standard                                 = 0,
	Transparent                              = 1,
	Glitter                                  = 2,
	Opalescent                               = 3,
	Metallic                                 = 4,
};

// Enum AtomRuntime.EAtomPrimitiveCollisionVolumeType
// NumValues: 0x0006
enum class EAtomPrimitiveCollisionVolumeType : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Capsule                                  = 2,
	Cylinder                                 = 3,
	Tube                                     = 4,
	Crate                                    = 5,
};

// Enum AtomRuntime.EPrimitiveAutoCollisionType
// NumValues: 0x0007
enum class EPrimitiveAutoCollisionType : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	NDOP10_X                                 = 2,
	NDOP10_Y                                 = 3,
	NDOP10_Z                                 = 4,
	NDOP18                                   = 5,
	NDOP26                                   = 6,
};

// Enum AtomRuntime.EPrimitiveGeometryComplexity
// NumValues: 0x0006
enum class EPrimitiveGeometryComplexity : uint8
{
	JustShell                                = 0,
	ShellAndUncommonParts                    = 1,
	ShellWithInsideDetailsAndUncommonParts   = 2,
	ShellWithInsideDetails                   = 3,
	ShellWithFlatCapAndUncommonParts         = 4,
	ShellWithFlatCap                         = 5,
};

// Enum AtomRuntime.EGetCommonPartDescriptionResult
// NumValues: 0x0002
enum class EGetCommonPartDescriptionResult : uint8
{
	Valid                                    = 0,
	Invalid                                  = 1,
};

// Enum AtomRuntime.EAtomShaderType
// NumValues: 0x000A
enum class EAtomShaderType : uint32
{
	Unknown                                  = 0,
	ShinyPlastic                             = 1,
	MattePlastic                             = 2,
	Rubber                                   = 3,
	ShinySteel                               = 4,
	BrushedSteel                             = 5,
	MatteSteel                               = 6,
	Glitter                                  = 7,
	Metallic                                 = 8,
	Opalescence                              = 9,
};

// Enum AtomRuntime.EColorEffects
// NumValues: 0x0004
enum class EColorEffects : uint8
{
	None                                     = 0,
	Metallic                                 = 1,
	Glitter                                  = 2,
	Opalescent                               = 3,
};

// Enum AtomRuntime.EAtomModelCommonPartOptimizationFlag
// NumValues: 0x0006
enum class EAtomModelCommonPartOptimizationFlag : uint8
{
	None                                     = 0,
	RemoveConnected                          = 1,
	RemoveKnobs                              = 2,
	RemoveTubes                              = 4,
	RemovePins                               = 8,
	All                                      = 15,
};

// Enum AtomRuntime.EAtomModelPivotAnchor
// NumValues: 0x0004
enum class EAtomModelPivotAnchor : uint32
{
	Original                                 = 0,
	TopCenter                                = 1,
	Center                                   = 2,
	BottomCenter                             = 3,
};

// Enum AtomRuntime.EAtomIssue
// NumValues: 0x0010
enum class EAtomIssue : uint32
{
	None                                     = 0,
	FailedToLoadModelFile                    = 1,
	UnsupportedLxFMLVersion                  = 2,
	UnsupportedLxFMLSticker                  = 3,
	MissingPrimitive                         = 4,
	MismatchedPrimitive                      = 5,
	UnsupportedPrimitive                     = 6,
	UnplacedPrimitive                        = 7,
	MissingPrimitiveSourceGeometry           = 8,
	ExcludedByFilter                         = 9,
	UnsupportedCommonPart                    = 10,
	OldVersionPrimitive                      = 11,
	UnknownDecorationTexture                 = 12,
	UnknownDecorationSurface                 = 13,
	DuplicatedSelectionSet                   = 14,
	EmptySelectionSet                        = 15,
};

// Enum AtomRuntime.EAtomModelInstanceType
// NumValues: 0x0005
enum class EAtomModelInstanceType : uint8
{
	Components                               = 0,
	Actors                                   = 1,
	HISM                                     = 2,
	ComponentsWithVertexColor                = 3,
	RenderStylesComponents                   = 4,
};

// Enum AtomRuntime.EAtomPlatform
// NumValues: 0x0015
enum class EAtomPlatform : uint8
{
	NA                                       = 0,
	Duplo                                    = 1,
	Atom                                     = 2,
	Technic                                  = 3,
	Clickits                                 = 4,
	ActionFigures                            = 5,
	Outdoor                                  = 6,
	SoftPrimitives                           = 7,
	ExtendedLine                             = 8,
	Scala                                    = 9,
	Znap                                     = 10,
	Toolo                                    = 11,
	Storage                                  = 12,
	MusicBuilder                             = 13,
	StoryBuilder                             = 14,
	Quatro                                   = 15,
	Ccbs                                     = 16,
	Primo1                                   = 17,
	AtomFoundation                           = 18,
	DieCutToStickers                         = 98,
	GeneralPlatform                          = 99,
};

// Enum AtomRuntime.EAtomCommonPartType
// NumValues: 0x0019
enum class EAtomCommonPartType : uint8
{
	None                                     = 0,
	Dknob_01_C                               = 1,
	Dknob_01_D                               = 2,
	Dpin_01_C                                = 3,
	Dtube_01_C                               = 4,
	Dtube_02_C                               = 5,
	Dtube_03_C                               = 6,
	Dtube_04_C                               = 7,
	knob_01_C                                = 8,
	knob_01_D                                = 9,
	knob_01_P                                = 10,
	knob_01_PC                               = 11,
	knob_02_P                                = 12,
	knob_02_PC                               = 13,
	knob_03_P                                = 14,
	knob_03_PC                               = 15,
	knob_04_P                                = 16,
	knob_04_PC                               = 17,
	pin_01_C                                 = 18,
	pin_01_D                                 = 19,
	pin_02_C                                 = 20,
	pin_02_D                                 = 21,
	tube_01_D                                = 22,
	tube_02_D                                = 23,
	tube_03_D                                = 24,
};

// Enum AtomRuntime.EAtomCommonPartCategory
// NumValues: 0x0004
enum class EAtomCommonPartCategory : uint8
{
	None                                     = 0,
	Knob                                     = 1,
	Pin                                      = 2,
	Tube                                     = 3,
};

// Enum AtomRuntime.EAtomPrimitiveImportWarningFlags
// NumValues: 0x0008
enum class EAtomPrimitiveImportWarningFlags : uint8
{
	None                                     = 0,
	UnableToFindUnwrappedMeshUVSet           = 1,
	BrokenPrincipalUVSet                     = 2,
	InvalidFBXFile                           = 4,
	InvalidMeshInFBXScene                    = 8,
	CommonPartMeshNotFound                   = 16,
	FullyTriangulated                        = 32,
	TransformedMeshes                        = 64,
};

// Enum AtomRuntime.EAtomPrimitiveGeoOptimization
// NumValues: 0x0003
enum class EAtomPrimitiveGeoOptimization : uint8
{
	Default                                  = 0,
	UseForDetailOnly                         = 1,
	UseApproximationForLODs                  = 2,
};

// Enum AtomRuntime.EAtomPrimitiveGeoOptimization_Old
// NumValues: 0x0003
enum class EAtomPrimitiveGeoOptimization_Old : uint32
{
	Default                                  = 0,
	UseForDetailOnly                         = 1,
	UseApproximationForLODs                  = 2,
};

// Enum AtomRuntime.EAtomPrimitiveApproximationShapeType
// NumValues: 0x0005
enum class EAtomPrimitiveApproximationShapeType : uint8
{
	Auto                                     = 0,
	OrientedBox                              = 1,
	ExtrudedConvexHull2D                     = 2,
	ConvexHull3D                             = 3,
	Extrusion                                = 4,
};

// Enum AtomRuntime.EAtomPrimitiveApproximationShapeType_Old
// NumValues: 0x0005
enum class EAtomPrimitiveApproximationShapeType_Old : uint32
{
	Auto                                     = 0,
	OrientedBox                              = 1,
	ExtrudedConvexHull2D                     = 2,
	ConvexHull3D                             = 3,
	Extrusion                                = 4,
};

// Enum AtomRuntime.EConnectionFieldType
// NumValues: 0x000A
enum class EConnectionFieldType : uint8
{
	Planar                                   = 0,
	Hinge                                    = 1,
	Axle                                     = 2,
	Ball                                     = 3,
	Cardan                                   = 4,
	Fixed                                    = 5,
	Rail                                     = 6,
	Slider                                   = 7,
	Gear                                     = 8,
	User                                     = 9,
};

// Enum AtomRuntime.EConnectionFieldSuperType
// NumValues: 0x0003
enum class EConnectionFieldSuperType : uint8
{
	Planar                                   = 0,
	Line                                     = 1,
	Point                                    = 2,
};

// Enum AtomRuntime.EConnectionFieldGender
// NumValues: 0x0003
enum class EConnectionFieldGender : uint8
{
	Receptor                                 = 0,
	Connector                                = 1,
	Any                                      = 2,
};

// Enum AtomRuntime.EFieldConnectResult
// NumValues: 0x000E
enum class EFieldConnectResult : uint8
{
	NoConnection                             = 0,
	Rejection                                = 1,
	FixedConnection                          = 2,
	FreeConnection                           = 3,
	HingeConnection                          = 4,
	CardanConnection                         = 5,
	BallConnection                           = 6,
	PrismaticConnection                      = 7,
	CylindricalConnection                    = 8,
	PrismaticAPerpendicularHingeConnection   = 9,
	PrismaticBPerpendicularHingeConnection   = 10,
	ConnectResultMax                         = 11,
	FirstConnection                          = 2,
	LastConnection                           = 10,
};

// Enum AtomRuntime.EAxleDiameter
// NumValues: 0x0003
enum class EAxleDiameter : uint8
{
	Tiny                                     = 0,
	Medium                                   = 1,
	Large                                    = 2,
};

// Enum AtomRuntime.EConnectionAxleType
// NumValues: 0x0017
enum class EConnectionAxleType : uint8
{
	UnusedReceptor                           = 0,
	UnusedConnector                          = 1,
	RoundAxleReceptor                        = 2,
	RoundAxleConnector                       = 3,
	CrossAxleReceptor                        = 4,
	CrossAxleConnector                       = 5,
	SecondaryPinReceptor                     = 6,
	SecondaryPinConnector                    = 7,
	PlateRoundCrossAxleReceptor              = 8,
	UnusedPlateRoundCrossAxleConnector       = 9,
	MiniFigNeckReceptor                      = 10,
	MiniFigNeckConnector                     = 11,
	RoundCrossAxleReceptor                   = 12,
	RoundCrossAxleConnector                  = 13,
	TinyPinReceptor                          = 14,
	TinyPinConnector                         = 15,
	UnusedCrossAxlePegHoleCapAlignmentReceptor = 16,
	CrossAxlePegHoleCapAlignmentConnector    = 17,
	UnusedRoundAxleReceptorDontRejectSecondaryPinConnector = 18,
	RoundAxleConnectorDontRejectSecondaryPinConnector = 19,
	UnusedSecondaryPinReceptorDontRejectTinyPinConnector = 20,
	SecondaryPinConnectorDontRejectTinyPinConnector = 21,
	SubTypeSize                              = 22,
};

// Enum AtomRuntime.EConnectionPointType
// NumValues: 0x002E
enum class EConnectionPointType : uint8
{
	Knob                                     = 0,
	HollowKnob                               = 1,
	KnobFitInPegHole                         = 2,
	HollowKnobFitInPegHole                   = 3,
	SquareKnob                               = 4,
	Tube                                     = 5,
	TubeWithRib                              = 6,
	BottomTube                               = 7,
	BottomTubeWithRib                        = 8,
	SecondaryPin                             = 9,
	SecondaryPinWithRib                      = 10,
	SecondaryPinWithTinyPinReceptor          = 11,
	SecondaryPinWithRibAndTinyPinReceptor    = 12,
	FixedTube                                = 13,
	FixedTubeWithAntiKnob                    = 14,
	AntiKnob                                 = 15,
	PegHole                                  = 16,
	SquareAntiKnob                           = 17,
	TubeGap                                  = 18,
	TubeGrabber                              = 19,
	TinyPin                                  = 20,
	TinyPinReceptor                          = 21,
	Edge                                     = 22,
	EdgeGap                                  = 23,
	KnobReject                               = 24,
	PowerFuncLeftTop                         = 25,
	PowerFuncRightTop                        = 26,
	PowerFuncLeftBottom                      = 27,
	PowerFuncRightBottom                     = 28,
	VoidFeature                              = 29,
	DuploKnob                                = 30,
	DuploHollowKnob                          = 31,
	DuploAntiKnob                            = 32,
	DuploTube                                = 33,
	DuploFixedTube                           = 34,
	DuploTubeGap                             = 35,
	DuploAnimalKnob                          = 36,
	DuploAnimalTube                          = 37,
	SecondaryPinReceptor                     = 38,
	DuploFixedAnimalTube                     = 39,
	DuploSecondaryPinWithRib                 = 40,
	DuploSecondaryPin                        = 41,
	DuploKnobReject                          = 42,
	_size                                    = 43,
	_duploBegin                              = 30,
	_duploEnd                                = 42,
};

// Enum AtomRuntime.EConnectionPointFlags
// NumValues: 0x0014
enum class EConnectionPointFlags : uint32
{
	SquareFeature                            = 1,
	RoundFeature                             = 2,
	KnobWithHole                             = 4,
	KnobWithMiniFigHandHole                  = 8,
	KnobWithSingleCollision                  = 16,
	SingleFeature                            = 32,
	ReceptorDontRemoveKnobCollision          = 64,
	KnobWithoutCollision                     = 128,
	CreationValidFlags                       = 255,
	ThisSideTransparent                      = 256,
	ThisSideHidden                           = 512,
	DynamicValidFlags                        = 768,
	InternalIsDuploSecondaryPin              = 268435456,
	InternalIsQuadConnector                  = 536870912,
	InternalIsSecondaryPin                   = 1073741824,
	InternalIsAnyKnob                        = 2147483648,
	SquareOcclusionShapeIndex                = 1,
	RoundOcclusionShapeIndex                 = 2,
	OtherOcclusionShapeIndex                 = 0,
	OcclusionShapeMask                       = 3,
};

// ScriptStruct AtomRuntime.AtomColorInfo
// 0x0020 (0x0028 - 0x0008)
struct FAtomColorInfo final : public FTableRowBase
{
public:
	struct FColor                                 Color;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtomMaterialType                             MaterialType;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomColorInfo) == 0x000008, "Wrong alignment on FAtomColorInfo");
static_assert(sizeof(FAtomColorInfo) == 0x000028, "Wrong size on FAtomColorInfo");
static_assert(offsetof(FAtomColorInfo, Color) == 0x000008, "Member 'FAtomColorInfo::Color' has a wrong offset!");
static_assert(offsetof(FAtomColorInfo, MaterialType) == 0x00000C, "Member 'FAtomColorInfo::MaterialType' has a wrong offset!");
static_assert(offsetof(FAtomColorInfo, Name) == 0x000010, "Member 'FAtomColorInfo::Name' has a wrong offset!");
static_assert(offsetof(FAtomColorInfo, bIsActive) == 0x000020, "Member 'FAtomColorInfo::bIsActive' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomMergedMeshLODDistanceSettings
// 0x0020 (0x0020 - 0x0000)
struct FAtomMergedMeshLODDistanceSettings final
{
public:
	bool                                          bOverrideLODScreenSizes;                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseLODScreenSize;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLODScreenSizeScaling;                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 LODDistances;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomMergedMeshLODDistanceSettings) == 0x000008, "Wrong alignment on FAtomMergedMeshLODDistanceSettings");
static_assert(sizeof(FAtomMergedMeshLODDistanceSettings) == 0x000020, "Wrong size on FAtomMergedMeshLODDistanceSettings");
static_assert(offsetof(FAtomMergedMeshLODDistanceSettings, bOverrideLODScreenSizes) == 0x000000, "Member 'FAtomMergedMeshLODDistanceSettings::bOverrideLODScreenSizes' has a wrong offset!");
static_assert(offsetof(FAtomMergedMeshLODDistanceSettings, BaseLODScreenSize) == 0x000004, "Member 'FAtomMergedMeshLODDistanceSettings::BaseLODScreenSize' has a wrong offset!");
static_assert(offsetof(FAtomMergedMeshLODDistanceSettings, BaseLODScreenSizeScaling) == 0x000008, "Member 'FAtomMergedMeshLODDistanceSettings::BaseLODScreenSizeScaling' has a wrong offset!");
static_assert(offsetof(FAtomMergedMeshLODDistanceSettings, LODDistances) == 0x000010, "Member 'FAtomMergedMeshLODDistanceSettings::LODDistances' has a wrong offset!");

// ScriptStruct AtomRuntime.CommonPartInstanceDescription
// 0x0040 (0x0040 - 0x0000)
struct FCommonPartInstanceDescription final
{
public:
	struct FTransform3f                           Transform;                                         // 0x0000(0x0030)(Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         MeshIdx;                                           // 0x0030(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         MaterialIdx;                                       // 0x0032(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         UUIDIdx;                                           // 0x0034(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ColorId;                                           // 0x0036(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommonPartInstanceDescription) == 0x000010, "Wrong alignment on FCommonPartInstanceDescription");
static_assert(sizeof(FCommonPartInstanceDescription) == 0x000040, "Wrong size on FCommonPartInstanceDescription");
static_assert(offsetof(FCommonPartInstanceDescription, Transform) == 0x000000, "Member 'FCommonPartInstanceDescription::Transform' has a wrong offset!");
static_assert(offsetof(FCommonPartInstanceDescription, MeshIdx) == 0x000030, "Member 'FCommonPartInstanceDescription::MeshIdx' has a wrong offset!");
static_assert(offsetof(FCommonPartInstanceDescription, MaterialIdx) == 0x000032, "Member 'FCommonPartInstanceDescription::MaterialIdx' has a wrong offset!");
static_assert(offsetof(FCommonPartInstanceDescription, UUIDIdx) == 0x000034, "Member 'FCommonPartInstanceDescription::UUIDIdx' has a wrong offset!");
static_assert(offsetof(FCommonPartInstanceDescription, ColorId) == 0x000036, "Member 'FCommonPartInstanceDescription::ColorId' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomCommonPartInstancesCache
// 0x0050 (0x0050 - 0x0000)
struct FAtomCommonPartInstancesCache final
{
public:
	TArray<class UStaticMesh*>                    Meshes;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          UUIDs;                                             // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCommonPartInstanceDescription> Instances;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform3f>                   InstanceTransforms;                                // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomCommonPartInstancesCache) == 0x000008, "Wrong alignment on FAtomCommonPartInstancesCache");
static_assert(sizeof(FAtomCommonPartInstancesCache) == 0x000050, "Wrong size on FAtomCommonPartInstancesCache");
static_assert(offsetof(FAtomCommonPartInstancesCache, Meshes) == 0x000000, "Member 'FAtomCommonPartInstancesCache::Meshes' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartInstancesCache, Materials) == 0x000010, "Member 'FAtomCommonPartInstancesCache::Materials' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartInstancesCache, UUIDs) == 0x000020, "Member 'FAtomCommonPartInstancesCache::UUIDs' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartInstancesCache, Instances) == 0x000030, "Member 'FAtomCommonPartInstancesCache::Instances' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartInstancesCache, InstanceTransforms) == 0x000040, "Member 'FAtomCommonPartInstancesCache::InstanceTransforms' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomCommonPartAssetDescription
// 0x000C (0x000C - 0x0000)
struct FAtomCommonPartAssetDescription final
{
public:
	EAtomCommonPartType                           CommonPartType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CommonPartStyle;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomCommonPartAssetDescription) == 0x000004, "Wrong alignment on FAtomCommonPartAssetDescription");
static_assert(sizeof(FAtomCommonPartAssetDescription) == 0x00000C, "Wrong size on FAtomCommonPartAssetDescription");
static_assert(offsetof(FAtomCommonPartAssetDescription, CommonPartType) == 0x000000, "Member 'FAtomCommonPartAssetDescription::CommonPartType' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartAssetDescription, CommonPartStyle) == 0x000004, "Member 'FAtomCommonPartAssetDescription::CommonPartStyle' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartAssetDescription, Scale) == 0x000008, "Member 'FAtomCommonPartAssetDescription::Scale' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPartGuid
// 0x0014 (0x0014 - 0x0000)
struct FAtomModelPartGuid final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartIndex;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelPartGuid) == 0x000004, "Wrong alignment on FAtomModelPartGuid");
static_assert(sizeof(FAtomModelPartGuid) == 0x000014, "Wrong size on FAtomModelPartGuid");
static_assert(offsetof(FAtomModelPartGuid, Guid) == 0x000000, "Member 'FAtomModelPartGuid::Guid' has a wrong offset!");
static_assert(offsetof(FAtomModelPartGuid, PartIndex) == 0x000010, "Member 'FAtomModelPartGuid::PartIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPartColorInfo
// 0x000C (0x000C - 0x0000)
struct FAtomModelPartColorInfo final
{
public:
	struct FColor                                 Color;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorId;                                           // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtomMaterialType                             MaterialType;                                      // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomModelPartColorInfo) == 0x000004, "Wrong alignment on FAtomModelPartColorInfo");
static_assert(sizeof(FAtomModelPartColorInfo) == 0x00000C, "Wrong size on FAtomModelPartColorInfo");
static_assert(offsetof(FAtomModelPartColorInfo, Color) == 0x000000, "Member 'FAtomModelPartColorInfo::Color' has a wrong offset!");
static_assert(offsetof(FAtomModelPartColorInfo, ColorId) == 0x000004, "Member 'FAtomModelPartColorInfo::ColorId' has a wrong offset!");
static_assert(offsetof(FAtomModelPartColorInfo, MaterialType) == 0x000008, "Member 'FAtomModelPartColorInfo::MaterialType' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPartDecorationInfo
// 0x0028 (0x0028 - 0x0000)
struct FAtomModelPartDecorationInfo final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Texture;                                           // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrimitiveSurfaceName;                              // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimitiveSurfaceIndex;                             // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomModelPartDecorationInfo) == 0x000008, "Wrong alignment on FAtomModelPartDecorationInfo");
static_assert(sizeof(FAtomModelPartDecorationInfo) == 0x000028, "Wrong size on FAtomModelPartDecorationInfo");
static_assert(offsetof(FAtomModelPartDecorationInfo, Material) == 0x000000, "Member 'FAtomModelPartDecorationInfo::Material' has a wrong offset!");
static_assert(offsetof(FAtomModelPartDecorationInfo, Texture) == 0x000008, "Member 'FAtomModelPartDecorationInfo::Texture' has a wrong offset!");
static_assert(offsetof(FAtomModelPartDecorationInfo, PrimitiveSurfaceName) == 0x000010, "Member 'FAtomModelPartDecorationInfo::PrimitiveSurfaceName' has a wrong offset!");
static_assert(offsetof(FAtomModelPartDecorationInfo, PrimitiveSurfaceIndex) == 0x000020, "Member 'FAtomModelPartDecorationInfo::PrimitiveSurfaceIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomCommonPartAndTransform
// 0x0070 (0x0070 - 0x0000)
struct FAtomCommonPartAndTransform final
{
public:
	EAtomCommonPartType                           Type;                                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomCommonPartAndTransform) == 0x000010, "Wrong alignment on FAtomCommonPartAndTransform");
static_assert(sizeof(FAtomCommonPartAndTransform) == 0x000070, "Wrong size on FAtomCommonPartAndTransform");
static_assert(offsetof(FAtomCommonPartAndTransform, Type) == 0x000000, "Member 'FAtomCommonPartAndTransform::Type' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartAndTransform, Transform) == 0x000010, "Member 'FAtomCommonPartAndTransform::Transform' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPartInstanceInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FAtomModelPartInstanceInfo final
{
public:
	struct FAtomModelPartGuid                     PartGuid;                                          // 0x0000(0x0014)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PartId;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomPrimitive*                         Primitive;                                         // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Transforms;                                        // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelPartDecorationInfo>   Decorations;                                       // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelPartColorInfo>        Colors;                                            // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         SelectionSets;                                     // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Group;                                             // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentGroup;                                       // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAtomCommonPartAndTransform>    CommonParts;                                       // 0x0088(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsUndersideVisible;                               // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomModelPartInstanceInfo) == 0x000008, "Wrong alignment on FAtomModelPartInstanceInfo");
static_assert(sizeof(FAtomModelPartInstanceInfo) == 0x0000A0, "Wrong size on FAtomModelPartInstanceInfo");
static_assert(offsetof(FAtomModelPartInstanceInfo, PartGuid) == 0x000000, "Member 'FAtomModelPartInstanceInfo::PartGuid' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, PartId) == 0x000018, "Member 'FAtomModelPartInstanceInfo::PartId' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, Primitive) == 0x000020, "Member 'FAtomModelPartInstanceInfo::Primitive' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, Transforms) == 0x000028, "Member 'FAtomModelPartInstanceInfo::Transforms' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, Decorations) == 0x000038, "Member 'FAtomModelPartInstanceInfo::Decorations' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, Colors) == 0x000048, "Member 'FAtomModelPartInstanceInfo::Colors' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, SelectionSets) == 0x000058, "Member 'FAtomModelPartInstanceInfo::SelectionSets' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, Group) == 0x000068, "Member 'FAtomModelPartInstanceInfo::Group' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, ParentGroup) == 0x000078, "Member 'FAtomModelPartInstanceInfo::ParentGroup' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, CommonParts) == 0x000088, "Member 'FAtomModelPartInstanceInfo::CommonParts' has a wrong offset!");
static_assert(offsetof(FAtomModelPartInstanceInfo, bIsUndersideVisible) == 0x000098, "Member 'FAtomModelPartInstanceInfo::bIsUndersideVisible' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPartsCollection
// 0x0080 (0x0080 - 0x0000)
struct FAtomModelPartsCollection final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Pivot;                                             // 0x0010(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelPartInstanceInfo>     Parts;                                             // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelPartsCollection) == 0x000010, "Wrong alignment on FAtomModelPartsCollection");
static_assert(sizeof(FAtomModelPartsCollection) == 0x000080, "Wrong size on FAtomModelPartsCollection");
static_assert(offsetof(FAtomModelPartsCollection, Name) == 0x000000, "Member 'FAtomModelPartsCollection::Name' has a wrong offset!");
static_assert(offsetof(FAtomModelPartsCollection, Pivot) == 0x000010, "Member 'FAtomModelPartsCollection::Pivot' has a wrong offset!");
static_assert(offsetof(FAtomModelPartsCollection, Parts) == 0x000070, "Member 'FAtomModelPartsCollection::Parts' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCollisionVolumeBase
// 0x0020 (0x0020 - 0x0000)
struct FAtomPrimitiveCollisionVolumeBase
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        BoneIndex;                                         // 0x0018(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomPrimitiveCollisionVolumeBase) == 0x000008, "Wrong alignment on FAtomPrimitiveCollisionVolumeBase");
static_assert(sizeof(FAtomPrimitiveCollisionVolumeBase) == 0x000020, "Wrong size on FAtomPrimitiveCollisionVolumeBase");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeBase, Location) == 0x000000, "Member 'FAtomPrimitiveCollisionVolumeBase::Location' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeBase, BoneIndex) == 0x000018, "Member 'FAtomPrimitiveCollisionVolumeBase::BoneIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCollisionVolumeBox
// 0x0030 (0x0050 - 0x0020)
struct FAtomPrimitiveCollisionVolumeBox final : public FAtomPrimitiveCollisionVolumeBase
{
public:
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HalfExtent;                                        // 0x0038(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveCollisionVolumeBox) == 0x000008, "Wrong alignment on FAtomPrimitiveCollisionVolumeBox");
static_assert(sizeof(FAtomPrimitiveCollisionVolumeBox) == 0x000050, "Wrong size on FAtomPrimitiveCollisionVolumeBox");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeBox, Rotation) == 0x000020, "Member 'FAtomPrimitiveCollisionVolumeBox::Rotation' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeBox, HalfExtent) == 0x000038, "Member 'FAtomPrimitiveCollisionVolumeBox::HalfExtent' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCollisionVolumeCapsule
// 0x0020 (0x0040 - 0x0020)
struct FAtomPrimitiveCollisionVolumeCapsule final : public FAtomPrimitiveCollisionVolumeBase
{
public:
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfLength;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveCollisionVolumeCapsule) == 0x000008, "Wrong alignment on FAtomPrimitiveCollisionVolumeCapsule");
static_assert(sizeof(FAtomPrimitiveCollisionVolumeCapsule) == 0x000040, "Wrong size on FAtomPrimitiveCollisionVolumeCapsule");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeCapsule, Rotation) == 0x000020, "Member 'FAtomPrimitiveCollisionVolumeCapsule::Rotation' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeCapsule, Radius) == 0x000038, "Member 'FAtomPrimitiveCollisionVolumeCapsule::Radius' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeCapsule, HalfLength) == 0x00003C, "Member 'FAtomPrimitiveCollisionVolumeCapsule::HalfLength' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCollisionVolumeCylinder
// 0x0020 (0x0040 - 0x0020)
struct FAtomPrimitiveCollisionVolumeCylinder final : public FAtomPrimitiveCollisionVolumeBase
{
public:
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfLength;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveCollisionVolumeCylinder) == 0x000008, "Wrong alignment on FAtomPrimitiveCollisionVolumeCylinder");
static_assert(sizeof(FAtomPrimitiveCollisionVolumeCylinder) == 0x000040, "Wrong size on FAtomPrimitiveCollisionVolumeCylinder");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeCylinder, Rotation) == 0x000020, "Member 'FAtomPrimitiveCollisionVolumeCylinder::Rotation' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeCylinder, Radius) == 0x000038, "Member 'FAtomPrimitiveCollisionVolumeCylinder::Radius' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeCylinder, HalfLength) == 0x00003C, "Member 'FAtomPrimitiveCollisionVolumeCylinder::HalfLength' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCollisionVolumeTube
// 0x0028 (0x0048 - 0x0020)
struct FAtomPrimitiveCollisionVolumeTube final : public FAtomPrimitiveCollisionVolumeBase
{
public:
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x003C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfLength;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomPrimitiveCollisionVolumeTube) == 0x000008, "Wrong alignment on FAtomPrimitiveCollisionVolumeTube");
static_assert(sizeof(FAtomPrimitiveCollisionVolumeTube) == 0x000048, "Wrong size on FAtomPrimitiveCollisionVolumeTube");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeTube, Rotation) == 0x000020, "Member 'FAtomPrimitiveCollisionVolumeTube::Rotation' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeTube, InnerRadius) == 0x000038, "Member 'FAtomPrimitiveCollisionVolumeTube::InnerRadius' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeTube, OuterRadius) == 0x00003C, "Member 'FAtomPrimitiveCollisionVolumeTube::OuterRadius' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeTube, HalfLength) == 0x000040, "Member 'FAtomPrimitiveCollisionVolumeTube::HalfLength' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCollisionVolumeSphere
// 0x0008 (0x0028 - 0x0020)
struct FAtomPrimitiveCollisionVolumeSphere final : public FAtomPrimitiveCollisionVolumeBase
{
public:
	float                                         Radius;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomPrimitiveCollisionVolumeSphere) == 0x000008, "Wrong alignment on FAtomPrimitiveCollisionVolumeSphere");
static_assert(sizeof(FAtomPrimitiveCollisionVolumeSphere) == 0x000028, "Wrong size on FAtomPrimitiveCollisionVolumeSphere");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeSphere, Radius) == 0x000020, "Member 'FAtomPrimitiveCollisionVolumeSphere::Radius' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCollisionVolumeContainer
// 0x0050 (0x0050 - 0x0000)
struct FAtomPrimitiveCollisionVolumeContainer final
{
public:
	TArray<struct FAtomPrimitiveCollisionVolumeBox> Boxes;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAtomPrimitiveCollisionVolumeSphere> Spheres;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAtomPrimitiveCollisionVolumeCapsule> Capsules;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAtomPrimitiveCollisionVolumeCylinder> Cylinders;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAtomPrimitiveCollisionVolumeTube> Tubes;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveCollisionVolumeContainer) == 0x000008, "Wrong alignment on FAtomPrimitiveCollisionVolumeContainer");
static_assert(sizeof(FAtomPrimitiveCollisionVolumeContainer) == 0x000050, "Wrong size on FAtomPrimitiveCollisionVolumeContainer");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeContainer, Boxes) == 0x000000, "Member 'FAtomPrimitiveCollisionVolumeContainer::Boxes' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeContainer, Spheres) == 0x000010, "Member 'FAtomPrimitiveCollisionVolumeContainer::Spheres' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeContainer, Capsules) == 0x000020, "Member 'FAtomPrimitiveCollisionVolumeContainer::Capsules' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeContainer, Cylinders) == 0x000030, "Member 'FAtomPrimitiveCollisionVolumeContainer::Cylinders' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveCollisionVolumeContainer, Tubes) == 0x000040, "Member 'FAtomPrimitiveCollisionVolumeContainer::Tubes' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCollisionGeometry
// 0x0078 (0x0078 - 0x0000)
struct FAtomPrimitiveCollisionGeometry final
{
public:
	struct FKAggregateGeom                        AggGeom;                                           // 0x0000(0x0078)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveCollisionGeometry) == 0x000008, "Wrong alignment on FAtomPrimitiveCollisionGeometry");
static_assert(sizeof(FAtomPrimitiveCollisionGeometry) == 0x000078, "Wrong size on FAtomPrimitiveCollisionGeometry");
static_assert(offsetof(FAtomPrimitiveCollisionGeometry, AggGeom) == 0x000000, "Member 'FAtomPrimitiveCollisionGeometry::AggGeom' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveGeometryLODs
// 0x0090 (0x0090 - 0x0000)
struct FAtomPrimitiveGeometryLODs final
{
public:
	TArray<class UAtomPrimitiveGeometry*>         GeometryLODs;                                      // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAtomPrimitiveGeometry*                 HiResNaniteGeomery;                                // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAtomPrimitiveCollisionGeometry        Collision;                                         // 0x0018(0x0078)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveGeometryLODs) == 0x000008, "Wrong alignment on FAtomPrimitiveGeometryLODs");
static_assert(sizeof(FAtomPrimitiveGeometryLODs) == 0x000090, "Wrong size on FAtomPrimitiveGeometryLODs");
static_assert(offsetof(FAtomPrimitiveGeometryLODs, GeometryLODs) == 0x000000, "Member 'FAtomPrimitiveGeometryLODs::GeometryLODs' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveGeometryLODs, HiResNaniteGeomery) == 0x000010, "Member 'FAtomPrimitiveGeometryLODs::HiResNaniteGeomery' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveGeometryLODs, Collision) == 0x000018, "Member 'FAtomPrimitiveGeometryLODs::Collision' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveGeometryAndTransform
// 0x0040 (0x0040 - 0x0000)
struct FAtomPrimitiveGeometryAndTransform final
{
public:
	class UAtomPrimitiveGeometry*                 AtomPrimitiveGeometry;                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform3f                           Transform;                                         // 0x0010(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveGeometryAndTransform) == 0x000010, "Wrong alignment on FAtomPrimitiveGeometryAndTransform");
static_assert(sizeof(FAtomPrimitiveGeometryAndTransform) == 0x000040, "Wrong size on FAtomPrimitiveGeometryAndTransform");
static_assert(offsetof(FAtomPrimitiveGeometryAndTransform, AtomPrimitiveGeometry) == 0x000000, "Member 'FAtomPrimitiveGeometryAndTransform::AtomPrimitiveGeometry' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveGeometryAndTransform, Transform) == 0x000010, "Member 'FAtomPrimitiveGeometryAndTransform::Transform' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionField
// 0x0040 (0x0040 - 0x0000)
struct FConnectionField
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0020)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Subtype;                                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        BoneIndex;                                         // 0x003C(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConnectionFieldType                          Type;                                              // 0x003E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectionField) == 0x000010, "Wrong alignment on FConnectionField");
static_assert(sizeof(FConnectionField) == 0x000040, "Wrong size on FConnectionField");
static_assert(offsetof(FConnectionField, Rotation) == 0x000000, "Member 'FConnectionField::Rotation' has a wrong offset!");
static_assert(offsetof(FConnectionField, Location) == 0x000020, "Member 'FConnectionField::Location' has a wrong offset!");
static_assert(offsetof(FConnectionField, Subtype) == 0x000038, "Member 'FConnectionField::Subtype' has a wrong offset!");
static_assert(offsetof(FConnectionField, BoneIndex) == 0x00003C, "Member 'FConnectionField::BoneIndex' has a wrong offset!");
static_assert(offsetof(FConnectionField, Type) == 0x00003E, "Member 'FConnectionField::Type' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldLine
// 0x0010 (0x0050 - 0x0040)
struct FConnectionFieldLine : public FConnectionField
{
public:
	double                                        Length;                                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartCapped;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EndCapped;                                         // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectionFieldLine) == 0x000010, "Wrong alignment on FConnectionFieldLine");
static_assert(sizeof(FConnectionFieldLine) == 0x000050, "Wrong size on FConnectionFieldLine");
static_assert(offsetof(FConnectionFieldLine, Length) == 0x000040, "Member 'FConnectionFieldLine::Length' has a wrong offset!");
static_assert(offsetof(FConnectionFieldLine, StartCapped) == 0x000048, "Member 'FConnectionFieldLine::StartCapped' has a wrong offset!");
static_assert(offsetof(FConnectionFieldLine, EndCapped) == 0x000049, "Member 'FConnectionFieldLine::EndCapped' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldAxle
// 0x0010 (0x0060 - 0x0050)
struct FConnectionFieldAxle final : public FConnectionFieldLine
{
public:
	bool                                          Grabbing;                                          // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequireGrabbing;                                   // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiscreteSnapInterval;                              // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectionFieldAxle) == 0x000010, "Wrong alignment on FConnectionFieldAxle");
static_assert(sizeof(FConnectionFieldAxle) == 0x000060, "Wrong size on FConnectionFieldAxle");
static_assert(offsetof(FConnectionFieldAxle, Grabbing) == 0x000050, "Member 'FConnectionFieldAxle::Grabbing' has a wrong offset!");
static_assert(offsetof(FConnectionFieldAxle, RequireGrabbing) == 0x000051, "Member 'FConnectionFieldAxle::RequireGrabbing' has a wrong offset!");
static_assert(offsetof(FConnectionFieldAxle, DiscreteSnapInterval) == 0x000054, "Member 'FConnectionFieldAxle::DiscreteSnapInterval' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldPoint
// 0x0000 (0x0040 - 0x0040)
struct FConnectionFieldPoint : public FConnectionField
{
};
static_assert(alignof(FConnectionFieldPoint) == 0x000010, "Wrong alignment on FConnectionFieldPoint");
static_assert(sizeof(FConnectionFieldPoint) == 0x000040, "Wrong size on FConnectionFieldPoint");

// ScriptStruct AtomRuntime.ConnectionFieldBall
// 0x0000 (0x0040 - 0x0040)
struct FConnectionFieldBall final : public FConnectionFieldPoint
{
};
static_assert(alignof(FConnectionFieldBall) == 0x000010, "Wrong alignment on FConnectionFieldBall");
static_assert(sizeof(FConnectionFieldBall) == 0x000040, "Wrong size on FConnectionFieldBall");

// ScriptStruct AtomRuntime.ConnectionPoint
// 0x0008 (0x0008 - 0x0000)
struct FConnectionPoint final
{
public:
	EConnectionPointFlags                         Flags;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConnectionPointType                          Type;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Size;                                              // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectionPoint) == 0x000004, "Wrong alignment on FConnectionPoint");
static_assert(sizeof(FConnectionPoint) == 0x000008, "Wrong size on FConnectionPoint");
static_assert(offsetof(FConnectionPoint, Flags) == 0x000000, "Member 'FConnectionPoint::Flags' has a wrong offset!");
static_assert(offsetof(FConnectionPoint, Type) == 0x000004, "Member 'FConnectionPoint::Type' has a wrong offset!");
static_assert(offsetof(FConnectionPoint, Size) == 0x000005, "Member 'FConnectionPoint::Size' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldPlanar
// 0x0020 (0x0060 - 0x0040)
struct FConnectionFieldPlanar final : public FConnectionField
{
public:
	uint8                                         Width;                                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Height;                                            // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConnectionPoint>               Points;                                            // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectionFieldPlanar) == 0x000010, "Wrong alignment on FConnectionFieldPlanar");
static_assert(sizeof(FConnectionFieldPlanar) == 0x000060, "Wrong size on FConnectionFieldPlanar");
static_assert(offsetof(FConnectionFieldPlanar, Width) == 0x000040, "Member 'FConnectionFieldPlanar::Width' has a wrong offset!");
static_assert(offsetof(FConnectionFieldPlanar, Height) == 0x000041, "Member 'FConnectionFieldPlanar::Height' has a wrong offset!");
static_assert(offsetof(FConnectionFieldPlanar, Points) == 0x000048, "Member 'FConnectionFieldPlanar::Points' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldContainer
// 0x0030 (0x0030 - 0x0000)
struct FConnectionFieldContainer final
{
public:
	TArray<struct FConnectionFieldPlanar>         PlanarFields;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInstancedStruct>               LineFields;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInstancedStruct>               PointFields;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConnectionFieldContainer) == 0x000008, "Wrong alignment on FConnectionFieldContainer");
static_assert(sizeof(FConnectionFieldContainer) == 0x000030, "Wrong size on FConnectionFieldContainer");
static_assert(offsetof(FConnectionFieldContainer, PlanarFields) == 0x000000, "Member 'FConnectionFieldContainer::PlanarFields' has a wrong offset!");
static_assert(offsetof(FConnectionFieldContainer, LineFields) == 0x000010, "Member 'FConnectionFieldContainer::LineFields' has a wrong offset!");
static_assert(offsetof(FConnectionFieldContainer, PointFields) == 0x000020, "Member 'FConnectionFieldContainer::PointFields' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldFixed
// 0x0010 (0x0050 - 0x0040)
struct FConnectionFieldFixed final : public FConnectionFieldPoint
{
public:
	uint32                                        Axes;                                              // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectionFieldFixed) == 0x000010, "Wrong alignment on FConnectionFieldFixed");
static_assert(sizeof(FConnectionFieldFixed) == 0x000050, "Wrong size on FConnectionFieldFixed");
static_assert(offsetof(FConnectionFieldFixed, Axes) == 0x000040, "Member 'FConnectionFieldFixed::Axes' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldGear
// 0x0010 (0x0060 - 0x0050)
struct FConnectionFieldGear final : public FConnectionFieldLine
{
public:
	double                                        Radius;                                            // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ToothCount;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectionFieldGear) == 0x000010, "Wrong alignment on FConnectionFieldGear");
static_assert(sizeof(FConnectionFieldGear) == 0x000060, "Wrong size on FConnectionFieldGear");
static_assert(offsetof(FConnectionFieldGear, Radius) == 0x000050, "Member 'FConnectionFieldGear::Radius' has a wrong offset!");
static_assert(offsetof(FConnectionFieldGear, ToothCount) == 0x000058, "Member 'FConnectionFieldGear::ToothCount' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldHinge
// 0x0030 (0x0070 - 0x0040)
struct FConnectionFieldHinge final : public FConnectionFieldPoint
{
public:
	bool                                          Oriented;                                          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Flip;                                              // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasLimits;                                         // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequireGrabbing;                                   // 0x0043(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        OrientedMin;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        OrientedMax;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        FlippedMin;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        FlippedMax;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectionFieldHinge) == 0x000010, "Wrong alignment on FConnectionFieldHinge");
static_assert(sizeof(FConnectionFieldHinge) == 0x000070, "Wrong size on FConnectionFieldHinge");
static_assert(offsetof(FConnectionFieldHinge, Oriented) == 0x000040, "Member 'FConnectionFieldHinge::Oriented' has a wrong offset!");
static_assert(offsetof(FConnectionFieldHinge, Flip) == 0x000041, "Member 'FConnectionFieldHinge::Flip' has a wrong offset!");
static_assert(offsetof(FConnectionFieldHinge, HasLimits) == 0x000042, "Member 'FConnectionFieldHinge::HasLimits' has a wrong offset!");
static_assert(offsetof(FConnectionFieldHinge, RequireGrabbing) == 0x000043, "Member 'FConnectionFieldHinge::RequireGrabbing' has a wrong offset!");
static_assert(offsetof(FConnectionFieldHinge, OrientedMin) == 0x000048, "Member 'FConnectionFieldHinge::OrientedMin' has a wrong offset!");
static_assert(offsetof(FConnectionFieldHinge, OrientedMax) == 0x000050, "Member 'FConnectionFieldHinge::OrientedMax' has a wrong offset!");
static_assert(offsetof(FConnectionFieldHinge, FlippedMin) == 0x000058, "Member 'FConnectionFieldHinge::FlippedMin' has a wrong offset!");
static_assert(offsetof(FConnectionFieldHinge, FlippedMax) == 0x000060, "Member 'FConnectionFieldHinge::FlippedMax' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectionFieldSlider
// 0x0020 (0x0070 - 0x0050)
struct FConnectionFieldSlider final : public FConnectionFieldLine
{
public:
	bool                                          Cylindrical;                                       // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSpring;                                         // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SpringRest;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SpringStrength;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SpringDamping;                                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConnectionFieldSlider) == 0x000010, "Wrong alignment on FConnectionFieldSlider");
static_assert(sizeof(FConnectionFieldSlider) == 0x000070, "Wrong size on FConnectionFieldSlider");
static_assert(offsetof(FConnectionFieldSlider, Cylindrical) == 0x000050, "Member 'FConnectionFieldSlider::Cylindrical' has a wrong offset!");
static_assert(offsetof(FConnectionFieldSlider, HasSpring) == 0x000051, "Member 'FConnectionFieldSlider::HasSpring' has a wrong offset!");
static_assert(offsetof(FConnectionFieldSlider, SpringRest) == 0x000058, "Member 'FConnectionFieldSlider::SpringRest' has a wrong offset!");
static_assert(offsetof(FConnectionFieldSlider, SpringStrength) == 0x000060, "Member 'FConnectionFieldSlider::SpringStrength' has a wrong offset!");
static_assert(offsetof(FConnectionFieldSlider, SpringDamping) == 0x000068, "Member 'FConnectionFieldSlider::SpringDamping' has a wrong offset!");

// ScriptStruct AtomRuntime.PlanarFieldPointConnectionInfo
// 0x0004 (0x0004 - 0x0000)
struct FPlanarFieldPointConnectionInfo final
{
public:
	uint16                                        IndexA;                                            // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        IndexB;                                            // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlanarFieldPointConnectionInfo) == 0x000002, "Wrong alignment on FPlanarFieldPointConnectionInfo");
static_assert(sizeof(FPlanarFieldPointConnectionInfo) == 0x000004, "Wrong size on FPlanarFieldPointConnectionInfo");
static_assert(offsetof(FPlanarFieldPointConnectionInfo, IndexA) == 0x000000, "Member 'FPlanarFieldPointConnectionInfo::IndexA' has a wrong offset!");
static_assert(offsetof(FPlanarFieldPointConnectionInfo, IndexB) == 0x000002, "Member 'FPlanarFieldPointConnectionInfo::IndexB' has a wrong offset!");

// ScriptStruct AtomRuntime.PlanarFieldConnectionInfo
// 0x0020 (0x0020 - 0x0000)
struct FPlanarFieldConnectionInfo final
{
public:
	TArray<struct FPlanarFieldPointConnectionInfo> PointConnections;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EFieldConnectResult                           ConnectResult;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        OverlapA;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        OverlapB;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanarFieldConnectionInfo) == 0x000008, "Wrong alignment on FPlanarFieldConnectionInfo");
static_assert(sizeof(FPlanarFieldConnectionInfo) == 0x000020, "Wrong size on FPlanarFieldConnectionInfo");
static_assert(offsetof(FPlanarFieldConnectionInfo, PointConnections) == 0x000000, "Member 'FPlanarFieldConnectionInfo::PointConnections' has a wrong offset!");
static_assert(offsetof(FPlanarFieldConnectionInfo, ConnectResult) == 0x000010, "Member 'FPlanarFieldConnectionInfo::ConnectResult' has a wrong offset!");
static_assert(offsetof(FPlanarFieldConnectionInfo, OverlapA) == 0x000014, "Member 'FPlanarFieldConnectionInfo::OverlapA' has a wrong offset!");
static_assert(offsetof(FPlanarFieldConnectionInfo, OverlapB) == 0x000018, "Member 'FPlanarFieldConnectionInfo::OverlapB' has a wrong offset!");

// ScriptStruct AtomRuntime.ConnectivityFieldReference
// 0x0008 (0x0008 - 0x0000)
struct FConnectivityFieldReference final
{
public:
	int32                                         ObjectId;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        FieldIndex;                                        // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectivityFieldReference) == 0x000004, "Wrong alignment on FConnectivityFieldReference");
static_assert(sizeof(FConnectivityFieldReference) == 0x000008, "Wrong size on FConnectivityFieldReference");
static_assert(offsetof(FConnectivityFieldReference, ObjectId) == 0x000000, "Member 'FConnectivityFieldReference::ObjectId' has a wrong offset!");
static_assert(offsetof(FConnectivityFieldReference, FieldIndex) == 0x000004, "Member 'FConnectivityFieldReference::FieldIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.SerializedPlanarConnection
// 0x0030 (0x0030 - 0x0000)
struct FSerializedPlanarConnection final
{
public:
	struct FPlanarFieldConnectionInfo             Connection;                                        // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FConnectivityFieldReference            FieldA;                                            // 0x0020(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FConnectivityFieldReference            FieldB;                                            // 0x0028(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSerializedPlanarConnection) == 0x000008, "Wrong alignment on FSerializedPlanarConnection");
static_assert(sizeof(FSerializedPlanarConnection) == 0x000030, "Wrong size on FSerializedPlanarConnection");
static_assert(offsetof(FSerializedPlanarConnection, Connection) == 0x000000, "Member 'FSerializedPlanarConnection::Connection' has a wrong offset!");
static_assert(offsetof(FSerializedPlanarConnection, FieldA) == 0x000020, "Member 'FSerializedPlanarConnection::FieldA' has a wrong offset!");
static_assert(offsetof(FSerializedPlanarConnection, FieldB) == 0x000028, "Member 'FSerializedPlanarConnection::FieldB' has a wrong offset!");

// ScriptStruct AtomRuntime.SerializedConnectivityObjects
// 0x0020 (0x0020 - 0x0000)
struct FSerializedConnectivityObjects final
{
public:
	TArray<struct FConnectionFieldContainer>      Fields;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSerializedPlanarConnection>    PlanarConnections;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSerializedConnectivityObjects) == 0x000008, "Wrong alignment on FSerializedConnectivityObjects");
static_assert(sizeof(FSerializedConnectivityObjects) == 0x000020, "Wrong size on FSerializedConnectivityObjects");
static_assert(offsetof(FSerializedConnectivityObjects, Fields) == 0x000000, "Member 'FSerializedConnectivityObjects::Fields' has a wrong offset!");
static_assert(offsetof(FSerializedConnectivityObjects, PlanarConnections) == 0x000010, "Member 'FSerializedConnectivityObjects::PlanarConnections' has a wrong offset!");

// ScriptStruct AtomRuntime.PlanarFieldPointInfo
// 0x0020 (0x0020 - 0x0000)
struct FPlanarFieldPointInfo final
{
public:
	struct FVector                                PointLocation;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConnectionPointType                          PointType;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailable;                                       // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanarFieldPointInfo) == 0x000008, "Wrong alignment on FPlanarFieldPointInfo");
static_assert(sizeof(FPlanarFieldPointInfo) == 0x000020, "Wrong size on FPlanarFieldPointInfo");
static_assert(offsetof(FPlanarFieldPointInfo, PointLocation) == 0x000000, "Member 'FPlanarFieldPointInfo::PointLocation' has a wrong offset!");
static_assert(offsetof(FPlanarFieldPointInfo, PointType) == 0x000018, "Member 'FPlanarFieldPointInfo::PointType' has a wrong offset!");
static_assert(offsetof(FPlanarFieldPointInfo, IsAvailable) == 0x000019, "Member 'FPlanarFieldPointInfo::IsAvailable' has a wrong offset!");

// ScriptStruct AtomRuntime.PlanarFieldInfo
// 0x0090 (0x0090 - 0x0000)
struct FPlanarFieldInfo final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConnectionFieldGender                        PlanarFieldType;                                   // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlanarFieldPointInfo>          PointInfo;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanarFieldInfo) == 0x000010, "Wrong alignment on FPlanarFieldInfo");
static_assert(sizeof(FPlanarFieldInfo) == 0x000090, "Wrong size on FPlanarFieldInfo");
static_assert(offsetof(FPlanarFieldInfo, Transform) == 0x000000, "Member 'FPlanarFieldInfo::Transform' has a wrong offset!");
static_assert(offsetof(FPlanarFieldInfo, Size) == 0x000060, "Member 'FPlanarFieldInfo::Size' has a wrong offset!");
static_assert(offsetof(FPlanarFieldInfo, PlanarFieldType) == 0x000070, "Member 'FPlanarFieldInfo::PlanarFieldType' has a wrong offset!");
static_assert(offsetof(FPlanarFieldInfo, PointInfo) == 0x000078, "Member 'FPlanarFieldInfo::PointInfo' has a wrong offset!");

// ScriptStruct AtomRuntime.WorldConnectivityHandle
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FWorldConnectivityHandle final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldConnectivityHandle) == 0x000004, "Wrong alignment on FWorldConnectivityHandle");
static_assert(sizeof(FWorldConnectivityHandle) == 0x000004, "Wrong size on FWorldConnectivityHandle");

// ScriptStruct AtomRuntime.ConnectivityQueryResult
// 0x00C0 (0x00C0 - 0x0000)
struct FConnectivityQueryResult final
{
public:
	bool                                          bHasValidConnection;                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TargetTransformToConnect;                          // 0x0010(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetToBestFit;                                   // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceFieldIndex;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceFieldObjectId;                               // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceFieldConnectionPointIndex;                   // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetFieldIndex;                                  // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetFieldObjectId;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetFieldConnectionPointIndex;                   // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ErrorMessage;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectivityQueryResult) == 0x000010, "Wrong alignment on FConnectivityQueryResult");
static_assert(sizeof(FConnectivityQueryResult) == 0x0000C0, "Wrong size on FConnectivityQueryResult");
static_assert(offsetof(FConnectivityQueryResult, bHasValidConnection) == 0x000000, "Member 'FConnectivityQueryResult::bHasValidConnection' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, TargetTransformToConnect) == 0x000010, "Member 'FConnectivityQueryResult::TargetTransformToConnect' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, HitLocation) == 0x000070, "Member 'FConnectivityQueryResult::HitLocation' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, OffsetToBestFit) == 0x000088, "Member 'FConnectivityQueryResult::OffsetToBestFit' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, SourceFieldIndex) == 0x0000A0, "Member 'FConnectivityQueryResult::SourceFieldIndex' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, SourceFieldObjectId) == 0x0000A4, "Member 'FConnectivityQueryResult::SourceFieldObjectId' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, SourceFieldConnectionPointIndex) == 0x0000A8, "Member 'FConnectivityQueryResult::SourceFieldConnectionPointIndex' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, TargetFieldIndex) == 0x0000AC, "Member 'FConnectivityQueryResult::TargetFieldIndex' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, TargetFieldObjectId) == 0x0000B0, "Member 'FConnectivityQueryResult::TargetFieldObjectId' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, TargetFieldConnectionPointIndex) == 0x0000B4, "Member 'FConnectivityQueryResult::TargetFieldConnectionPointIndex' has a wrong offset!");
static_assert(offsetof(FConnectivityQueryResult, ErrorMessage) == 0x0000B8, "Member 'FConnectivityQueryResult::ErrorMessage' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomColor
// 0x0018 (0x0018 - 0x0000)
struct FAtomColor final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EColorEffects                                 Effects;                                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomColor) == 0x000004, "Wrong alignment on FAtomColor");
static_assert(sizeof(FAtomColor) == 0x000018, "Wrong size on FAtomColor");
static_assert(offsetof(FAtomColor, ID) == 0x000000, "Member 'FAtomColor::ID' has a wrong offset!");
static_assert(offsetof(FAtomColor, Effects) == 0x000004, "Member 'FAtomColor::Effects' has a wrong offset!");
static_assert(offsetof(FAtomColor, Color) == 0x000008, "Member 'FAtomColor::Color' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomColorSurface
// 0x0008 (0x0008 - 0x0000)
struct FAtomColorSurface final
{
public:
	int32                                         ColorId;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtomShaderType                               ShaderType;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomColorSurface) == 0x000004, "Wrong alignment on FAtomColorSurface");
static_assert(sizeof(FAtomColorSurface) == 0x000008, "Wrong size on FAtomColorSurface");
static_assert(offsetof(FAtomColorSurface, ColorId) == 0x000000, "Member 'FAtomColorSurface::ColorId' has a wrong offset!");
static_assert(offsetof(FAtomColorSurface, ShaderType) == 0x000004, "Member 'FAtomColorSurface::ShaderType' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomDecorationAssignment
// 0x0030 (0x0030 - 0x0000)
struct FAtomDecorationAssignment final
{
public:
	class FString                                 SurfaceName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextureName;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Version;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomDecorationAssignment) == 0x000008, "Wrong alignment on FAtomDecorationAssignment");
static_assert(sizeof(FAtomDecorationAssignment) == 0x000030, "Wrong size on FAtomDecorationAssignment");
static_assert(offsetof(FAtomDecorationAssignment, SurfaceName) == 0x000000, "Member 'FAtomDecorationAssignment::SurfaceName' has a wrong offset!");
static_assert(offsetof(FAtomDecorationAssignment, TextureName) == 0x000010, "Member 'FAtomDecorationAssignment::TextureName' has a wrong offset!");
static_assert(offsetof(FAtomDecorationAssignment, Version) == 0x000020, "Member 'FAtomDecorationAssignment::Version' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPrimitiveInstance
// 0x0090 (0x0090 - 0x0000)
struct FAtomModelPrimitiveInstance final
{
public:
	class UAtomPrimitive*                         Primitive;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PrimitiveTransform;                                // 0x0010(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PivotOrigin;                                       // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomModelPrimitiveInstance) == 0x000010, "Wrong alignment on FAtomModelPrimitiveInstance");
static_assert(sizeof(FAtomModelPrimitiveInstance) == 0x000090, "Wrong size on FAtomModelPrimitiveInstance");
static_assert(offsetof(FAtomModelPrimitiveInstance, Primitive) == 0x000000, "Member 'FAtomModelPrimitiveInstance::Primitive' has a wrong offset!");
static_assert(offsetof(FAtomModelPrimitiveInstance, PrimitiveTransform) == 0x000010, "Member 'FAtomModelPrimitiveInstance::PrimitiveTransform' has a wrong offset!");
static_assert(offsetof(FAtomModelPrimitiveInstance, PivotOrigin) == 0x000070, "Member 'FAtomModelPrimitiveInstance::PivotOrigin' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPart
// 0x00B0 (0x00B0 - 0x0000)
struct FAtomModelPart final
{
public:
	TSoftObjectPtr<class UAtomPrimitive>          AtomPrimitive;                                     // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      MaterialInstance;                                  // 0x0020(0x0020)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      MaterialWithPayload;                               // 0x0040(0x0020)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Transforms;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint32                                        PartId;                                            // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PartRevision;                                      // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAtomColorSurface>              ColorSurfaces;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAtomDecorationAssignment>      Decorations;                                       // 0x0098(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCommonPartCulling;                          // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomModelPart) == 0x000008, "Wrong alignment on FAtomModelPart");
static_assert(sizeof(FAtomModelPart) == 0x0000B0, "Wrong size on FAtomModelPart");
static_assert(offsetof(FAtomModelPart, AtomPrimitive) == 0x000000, "Member 'FAtomModelPart::AtomPrimitive' has a wrong offset!");
static_assert(offsetof(FAtomModelPart, MaterialInstance) == 0x000020, "Member 'FAtomModelPart::MaterialInstance' has a wrong offset!");
static_assert(offsetof(FAtomModelPart, MaterialWithPayload) == 0x000040, "Member 'FAtomModelPart::MaterialWithPayload' has a wrong offset!");
static_assert(offsetof(FAtomModelPart, Transforms) == 0x000060, "Member 'FAtomModelPart::Transforms' has a wrong offset!");
static_assert(offsetof(FAtomModelPart, PartId) == 0x000070, "Member 'FAtomModelPart::PartId' has a wrong offset!");
static_assert(offsetof(FAtomModelPart, PartRevision) == 0x000078, "Member 'FAtomModelPart::PartRevision' has a wrong offset!");
static_assert(offsetof(FAtomModelPart, ColorSurfaces) == 0x000088, "Member 'FAtomModelPart::ColorSurfaces' has a wrong offset!");
static_assert(offsetof(FAtomModelPart, Decorations) == 0x000098, "Member 'FAtomModelPart::Decorations' has a wrong offset!");
static_assert(offsetof(FAtomModelPart, bIgnoreCommonPartCulling) == 0x0000A8, "Member 'FAtomModelPart::bIgnoreCommonPartCulling' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelSocket
// 0x0080 (0x0080 - 0x0000)
struct FAtomModelSocket final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelSocket) == 0x000010, "Wrong alignment on FAtomModelSocket");
static_assert(sizeof(FAtomModelSocket) == 0x000080, "Wrong size on FAtomModelSocket");
static_assert(offsetof(FAtomModelSocket, ID) == 0x000000, "Member 'FAtomModelSocket::ID' has a wrong offset!");
static_assert(offsetof(FAtomModelSocket, Name) == 0x000010, "Member 'FAtomModelSocket::Name' has a wrong offset!");
static_assert(offsetof(FAtomModelSocket, Transform) == 0x000020, "Member 'FAtomModelSocket::Transform' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPrimitive
// 0x0028 (0x0028 - 0x0000)
struct FAtomModelPrimitive final
{
public:
	TArray<struct FAtomModelPart>                 Parts;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DesignId;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  UUID;                                              // 0x0014(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DesignName;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelPrimitive) == 0x000008, "Wrong alignment on FAtomModelPrimitive");
static_assert(sizeof(FAtomModelPrimitive) == 0x000028, "Wrong size on FAtomModelPrimitive");
static_assert(offsetof(FAtomModelPrimitive, Parts) == 0x000000, "Member 'FAtomModelPrimitive::Parts' has a wrong offset!");
static_assert(offsetof(FAtomModelPrimitive, DesignId) == 0x000010, "Member 'FAtomModelPrimitive::DesignId' has a wrong offset!");
static_assert(offsetof(FAtomModelPrimitive, UUID) == 0x000014, "Member 'FAtomModelPrimitive::UUID' has a wrong offset!");
static_assert(offsetof(FAtomModelPrimitive, DesignName) == 0x000024, "Member 'FAtomModelPrimitive::DesignName' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomBoneReference
// 0x000C (0x000C - 0x0000)
struct FAtomBoneReference final
{
public:
	int32                                         PrimitiveIndex;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartIndex;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomBoneReference) == 0x000004, "Wrong alignment on FAtomBoneReference");
static_assert(sizeof(FAtomBoneReference) == 0x00000C, "Wrong size on FAtomBoneReference");
static_assert(offsetof(FAtomBoneReference, PrimitiveIndex) == 0x000000, "Member 'FAtomBoneReference::PrimitiveIndex' has a wrong offset!");
static_assert(offsetof(FAtomBoneReference, PartIndex) == 0x000004, "Member 'FAtomBoneReference::PartIndex' has a wrong offset!");
static_assert(offsetof(FAtomBoneReference, BoneIndex) == 0x000008, "Member 'FAtomBoneReference::BoneIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveConnection
// 0x0018 (0x0018 - 0x0000)
struct FAtomPrimitiveConnection final
{
public:
	struct FAtomBoneReference                     From;                                              // 0x0000(0x000C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FAtomBoneReference                     To;                                                // 0x000C(0x000C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveConnection) == 0x000004, "Wrong alignment on FAtomPrimitiveConnection");
static_assert(sizeof(FAtomPrimitiveConnection) == 0x000018, "Wrong size on FAtomPrimitiveConnection");
static_assert(offsetof(FAtomPrimitiveConnection, From) == 0x000000, "Member 'FAtomPrimitiveConnection::From' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveConnection, To) == 0x00000C, "Member 'FAtomPrimitiveConnection::To' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomRigidElementConnection
// 0x0080 (0x0080 - 0x0000)
struct FAtomRigidElementConnection final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherElementIndex;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConnectionUniqueId;                                // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAtomPrimitiveConnection>       PrimitiveConnections;                              // 0x0068(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomRigidElementConnection) == 0x000010, "Wrong alignment on FAtomRigidElementConnection");
static_assert(sizeof(FAtomRigidElementConnection) == 0x000080, "Wrong size on FAtomRigidElementConnection");
static_assert(offsetof(FAtomRigidElementConnection, Transform) == 0x000000, "Member 'FAtomRigidElementConnection::Transform' has a wrong offset!");
static_assert(offsetof(FAtomRigidElementConnection, OtherElementIndex) == 0x000060, "Member 'FAtomRigidElementConnection::OtherElementIndex' has a wrong offset!");
static_assert(offsetof(FAtomRigidElementConnection, ConnectionUniqueId) == 0x000064, "Member 'FAtomRigidElementConnection::ConnectionUniqueId' has a wrong offset!");
static_assert(offsetof(FAtomRigidElementConnection, PrimitiveConnections) == 0x000068, "Member 'FAtomRigidElementConnection::PrimitiveConnections' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomRigidElement
// 0x0028 (0x0028 - 0x0000)
struct FAtomRigidElement final
{
public:
	TArray<struct FAtomBoneReference>             BoneReferences;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAtomRigidElementConnection>    Connections;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexOfMetaBone;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomRigidElement) == 0x000008, "Wrong alignment on FAtomRigidElement");
static_assert(sizeof(FAtomRigidElement) == 0x000028, "Wrong size on FAtomRigidElement");
static_assert(offsetof(FAtomRigidElement, BoneReferences) == 0x000000, "Member 'FAtomRigidElement::BoneReferences' has a wrong offset!");
static_assert(offsetof(FAtomRigidElement, Connections) == 0x000010, "Member 'FAtomRigidElement::Connections' has a wrong offset!");
static_assert(offsetof(FAtomRigidElement, Name) == 0x000020, "Member 'FAtomRigidElement::Name' has a wrong offset!");
static_assert(offsetof(FAtomRigidElement, IndexOfMetaBone) == 0x000024, "Member 'FAtomRigidElement::IndexOfMetaBone' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomHingedElement
// 0x0018 (0x0018 - 0x0000)
struct FAtomHingedElement final
{
public:
	TArray<struct FAtomRigidElement>              RigidElements;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         HierarchyRootIndex;                                // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomHingedElement) == 0x000008, "Wrong alignment on FAtomHingedElement");
static_assert(sizeof(FAtomHingedElement) == 0x000018, "Wrong size on FAtomHingedElement");
static_assert(offsetof(FAtomHingedElement, RigidElements) == 0x000000, "Member 'FAtomHingedElement::RigidElements' has a wrong offset!");
static_assert(offsetof(FAtomHingedElement, HierarchyRootIndex) == 0x000010, "Member 'FAtomHingedElement::HierarchyRootIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPartReference
// 0x0014 (0x0014 - 0x0000)
struct FAtomModelPartReference final
{
public:
	struct FGuid                                  PrimitiveUUID;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartIndex;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelPartReference) == 0x000004, "Wrong alignment on FAtomModelPartReference");
static_assert(sizeof(FAtomModelPartReference) == 0x000014, "Wrong size on FAtomModelPartReference");
static_assert(offsetof(FAtomModelPartReference, PrimitiveUUID) == 0x000000, "Member 'FAtomModelPartReference::PrimitiveUUID' has a wrong offset!");
static_assert(offsetof(FAtomModelPartReference, PartIndex) == 0x000010, "Member 'FAtomModelPartReference::PartIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomGlueSet
// 0x0050 (0x0050 - 0x0000)
struct FAtomGlueSet final
{
public:
	TSet<struct FAtomModelPartReference>          Entries;                                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomGlueSet) == 0x000008, "Wrong alignment on FAtomGlueSet");
static_assert(sizeof(FAtomGlueSet) == 0x000050, "Wrong size on FAtomGlueSet");
static_assert(offsetof(FAtomGlueSet, Entries) == 0x000000, "Member 'FAtomGlueSet::Entries' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveGroup
// 0x0018 (0x0018 - 0x0000)
struct FAtomPrimitiveGroup
{
public:
	struct FVector                                PivotOrigin;                                       // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveGroup) == 0x000008, "Wrong alignment on FAtomPrimitiveGroup");
static_assert(sizeof(FAtomPrimitiveGroup) == 0x000018, "Wrong size on FAtomPrimitiveGroup");
static_assert(offsetof(FAtomPrimitiveGroup, PivotOrigin) == 0x000000, "Member 'FAtomPrimitiveGroup::PivotOrigin' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelGeometryOptimizationSettings
// 0x0018 (0x0018 - 0x0000)
struct FAtomModelGeometryOptimizationSettings final
{
public:
	bool                                          bEnforceLODBudgets;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTagBudget;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TriangleBudget;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SimplifyBaseTolerance;                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        OptimizeBaseTriCost;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelGeometryOptimizationSettings) == 0x000008, "Wrong alignment on FAtomModelGeometryOptimizationSettings");
static_assert(sizeof(FAtomModelGeometryOptimizationSettings) == 0x000018, "Wrong size on FAtomModelGeometryOptimizationSettings");
static_assert(offsetof(FAtomModelGeometryOptimizationSettings, bEnforceLODBudgets) == 0x000000, "Member 'FAtomModelGeometryOptimizationSettings::bEnforceLODBudgets' has a wrong offset!");
static_assert(offsetof(FAtomModelGeometryOptimizationSettings, bUseTagBudget) == 0x000001, "Member 'FAtomModelGeometryOptimizationSettings::bUseTagBudget' has a wrong offset!");
static_assert(offsetof(FAtomModelGeometryOptimizationSettings, TriangleBudget) == 0x000004, "Member 'FAtomModelGeometryOptimizationSettings::TriangleBudget' has a wrong offset!");
static_assert(offsetof(FAtomModelGeometryOptimizationSettings, SimplifyBaseTolerance) == 0x000008, "Member 'FAtomModelGeometryOptimizationSettings::SimplifyBaseTolerance' has a wrong offset!");
static_assert(offsetof(FAtomModelGeometryOptimizationSettings, OptimizeBaseTriCost) == 0x000010, "Member 'FAtomModelGeometryOptimizationSettings::OptimizeBaseTriCost' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomSelectionSetPrimitiveGroup
// 0x0008 (0x0020 - 0x0018)
struct FAtomSelectionSetPrimitiveGroup final : public FAtomPrimitiveGroup
{
public:
	class FName                                   SelectionSetName;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomSelectionSetPrimitiveGroup) == 0x000008, "Wrong alignment on FAtomSelectionSetPrimitiveGroup");
static_assert(sizeof(FAtomSelectionSetPrimitiveGroup) == 0x000020, "Wrong size on FAtomSelectionSetPrimitiveGroup");
static_assert(offsetof(FAtomSelectionSetPrimitiveGroup, SelectionSetName) == 0x000018, "Member 'FAtomSelectionSetPrimitiveGroup::SelectionSetName' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelPrimitiveGroup
// 0x0000 (0x0018 - 0x0018)
struct FAtomModelPrimitiveGroup final : public FAtomPrimitiveGroup
{
};
static_assert(alignof(FAtomModelPrimitiveGroup) == 0x000008, "Wrong alignment on FAtomModelPrimitiveGroup");
static_assert(sizeof(FAtomModelPrimitiveGroup) == 0x000018, "Wrong size on FAtomModelPrimitiveGroup");

// ScriptStruct AtomRuntime.AtomRigidElementIndices
// 0x000C (0x000C - 0x0000)
struct FAtomRigidElementIndices final
{
public:
	int32                                         HingedElementIndex;                                // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RigidElementIndex;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomRigidElementIndices) == 0x000004, "Wrong alignment on FAtomRigidElementIndices");
static_assert(sizeof(FAtomRigidElementIndices) == 0x00000C, "Wrong size on FAtomRigidElementIndices");
static_assert(offsetof(FAtomRigidElementIndices, HingedElementIndex) == 0x000000, "Member 'FAtomRigidElementIndices::HingedElementIndex' has a wrong offset!");
static_assert(offsetof(FAtomRigidElementIndices, RigidElementIndex) == 0x000004, "Member 'FAtomRigidElementIndices::RigidElementIndex' has a wrong offset!");
static_assert(offsetof(FAtomRigidElementIndices, BoneIndex) == 0x000008, "Member 'FAtomRigidElementIndices::BoneIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomResolvedModelPartReference
// 0x0018 (0x0018 - 0x0000)
struct FAtomResolvedModelPartReference final
{
public:
	struct FAtomBoneReference                     Indices;                                           // 0x0000(0x000C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FAtomRigidElementIndices               ElementIndices;                                    // 0x000C(0x000C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomResolvedModelPartReference) == 0x000004, "Wrong alignment on FAtomResolvedModelPartReference");
static_assert(sizeof(FAtomResolvedModelPartReference) == 0x000018, "Wrong size on FAtomResolvedModelPartReference");
static_assert(offsetof(FAtomResolvedModelPartReference, Indices) == 0x000000, "Member 'FAtomResolvedModelPartReference::Indices' has a wrong offset!");
static_assert(offsetof(FAtomResolvedModelPartReference, ElementIndices) == 0x00000C, "Member 'FAtomResolvedModelPartReference::ElementIndices' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomRigidElementSettings
// 0x001C (0x001C - 0x0000)
struct FAtomRigidElementSettings final
{
public:
	struct FAtomModelPartReference                ElementIdentifyingPart;                            // 0x0000(0x0014)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RigidElementName;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MergeWithParentElement;                            // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldBeRootElement;                               // 0x0019(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomRigidElementSettings) == 0x000004, "Wrong alignment on FAtomRigidElementSettings");
static_assert(sizeof(FAtomRigidElementSettings) == 0x00001C, "Wrong size on FAtomRigidElementSettings");
static_assert(offsetof(FAtomRigidElementSettings, ElementIdentifyingPart) == 0x000000, "Member 'FAtomRigidElementSettings::ElementIdentifyingPart' has a wrong offset!");
static_assert(offsetof(FAtomRigidElementSettings, RigidElementName) == 0x000014, "Member 'FAtomRigidElementSettings::RigidElementName' has a wrong offset!");
static_assert(offsetof(FAtomRigidElementSettings, MergeWithParentElement) == 0x000018, "Member 'FAtomRigidElementSettings::MergeWithParentElement' has a wrong offset!");
static_assert(offsetof(FAtomRigidElementSettings, ShouldBeRootElement) == 0x000019, "Member 'FAtomRigidElementSettings::ShouldBeRootElement' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelTags
// 0x0010 (0x0010 - 0x0000)
struct FAtomModelTags final
{
public:
	TArray<class FName>                           Tags;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelTags) == 0x000008, "Wrong alignment on FAtomModelTags");
static_assert(sizeof(FAtomModelTags) == 0x000010, "Wrong size on FAtomModelTags");
static_assert(offsetof(FAtomModelTags, Tags) == 0x000000, "Member 'FAtomModelTags::Tags' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelAssetSettings
// 0x0038 (0x0038 - 0x0000)
struct FAtomModelAssetSettings final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CreateRigidElementComponents;                      // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableConnectivity;                               // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EAtomModelPivotAnchor                         PivotAnchor;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAtomModelTags                         Tags;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAtomModelGeometryOptimizationSettings OptimizationSettings;                              // 0x0020(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelAssetSettings) == 0x000008, "Wrong alignment on FAtomModelAssetSettings");
static_assert(sizeof(FAtomModelAssetSettings) == 0x000038, "Wrong size on FAtomModelAssetSettings");
static_assert(offsetof(FAtomModelAssetSettings, Scale) == 0x000000, "Member 'FAtomModelAssetSettings::Scale' has a wrong offset!");
static_assert(offsetof(FAtomModelAssetSettings, CreateRigidElementComponents) == 0x000004, "Member 'FAtomModelAssetSettings::CreateRigidElementComponents' has a wrong offset!");
static_assert(offsetof(FAtomModelAssetSettings, bEnableConnectivity) == 0x000005, "Member 'FAtomModelAssetSettings::bEnableConnectivity' has a wrong offset!");
static_assert(offsetof(FAtomModelAssetSettings, PivotAnchor) == 0x000008, "Member 'FAtomModelAssetSettings::PivotAnchor' has a wrong offset!");
static_assert(offsetof(FAtomModelAssetSettings, Tags) == 0x000010, "Member 'FAtomModelAssetSettings::Tags' has a wrong offset!");
static_assert(offsetof(FAtomModelAssetSettings, OptimizationSettings) == 0x000020, "Member 'FAtomModelAssetSettings::OptimizationSettings' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelSelectionSet
// 0x0068 (0x0068 - 0x0000)
struct FAtomModelSelectionSet final
{
public:
	TSet<struct FGuid>                            PrimitiveIds;                                      // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   SelectionSetName;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ImportedName;                                      // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ID;                                                // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelSelectionSet) == 0x000008, "Wrong alignment on FAtomModelSelectionSet");
static_assert(sizeof(FAtomModelSelectionSet) == 0x000068, "Wrong size on FAtomModelSelectionSet");
static_assert(offsetof(FAtomModelSelectionSet, PrimitiveIds) == 0x000000, "Member 'FAtomModelSelectionSet::PrimitiveIds' has a wrong offset!");
static_assert(offsetof(FAtomModelSelectionSet, SelectionSetName) == 0x000050, "Member 'FAtomModelSelectionSet::SelectionSetName' has a wrong offset!");
static_assert(offsetof(FAtomModelSelectionSet, ImportedName) == 0x000054, "Member 'FAtomModelSelectionSet::ImportedName' has a wrong offset!");
static_assert(offsetof(FAtomModelSelectionSet, ID) == 0x000058, "Member 'FAtomModelSelectionSet::ID' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelConfigurationGroup
// 0x00F0 (0x00F0 - 0x0000)
struct FAtomModelConfigurationGroup final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ParentGroupId;                                     // 0x0014(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGuid>                            PrimitiveIds;                                      // 0x0028(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelSocket>               Sockets;                                           // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasGroupPivot;                                    // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             GroupPivot;                                        // 0x0090(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelConfigurationGroup) == 0x000010, "Wrong alignment on FAtomModelConfigurationGroup");
static_assert(sizeof(FAtomModelConfigurationGroup) == 0x0000F0, "Wrong size on FAtomModelConfigurationGroup");
static_assert(offsetof(FAtomModelConfigurationGroup, ID) == 0x000000, "Member 'FAtomModelConfigurationGroup::ID' has a wrong offset!");
static_assert(offsetof(FAtomModelConfigurationGroup, Name) == 0x000010, "Member 'FAtomModelConfigurationGroup::Name' has a wrong offset!");
static_assert(offsetof(FAtomModelConfigurationGroup, ParentGroupId) == 0x000014, "Member 'FAtomModelConfigurationGroup::ParentGroupId' has a wrong offset!");
static_assert(offsetof(FAtomModelConfigurationGroup, PrimitiveIds) == 0x000028, "Member 'FAtomModelConfigurationGroup::PrimitiveIds' has a wrong offset!");
static_assert(offsetof(FAtomModelConfigurationGroup, Sockets) == 0x000078, "Member 'FAtomModelConfigurationGroup::Sockets' has a wrong offset!");
static_assert(offsetof(FAtomModelConfigurationGroup, bHasGroupPivot) == 0x000088, "Member 'FAtomModelConfigurationGroup::bHasGroupPivot' has a wrong offset!");
static_assert(offsetof(FAtomModelConfigurationGroup, GroupPivot) == 0x000090, "Member 'FAtomModelConfigurationGroup::GroupPivot' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelHierarchicalSceneNode
// 0x0090 (0x0090 - 0x0000)
struct FAtomModelHierarchicalSceneNode final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldTransform;                                    // 0x0010(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ItemNames;                                         // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomModelHierarchicalSceneNode) == 0x000010, "Wrong alignment on FAtomModelHierarchicalSceneNode");
static_assert(sizeof(FAtomModelHierarchicalSceneNode) == 0x000090, "Wrong size on FAtomModelHierarchicalSceneNode");
static_assert(offsetof(FAtomModelHierarchicalSceneNode, Name) == 0x000000, "Member 'FAtomModelHierarchicalSceneNode::Name' has a wrong offset!");
static_assert(offsetof(FAtomModelHierarchicalSceneNode, WorldTransform) == 0x000010, "Member 'FAtomModelHierarchicalSceneNode::WorldTransform' has a wrong offset!");
static_assert(offsetof(FAtomModelHierarchicalSceneNode, ParentIndex) == 0x000070, "Member 'FAtomModelHierarchicalSceneNode::ParentIndex' has a wrong offset!");
static_assert(offsetof(FAtomModelHierarchicalSceneNode, ItemNames) == 0x000078, "Member 'FAtomModelHierarchicalSceneNode::ItemNames' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelHierarchicalScene
// 0x0010 (0x0010 - 0x0000)
struct FAtomModelHierarchicalScene final
{
public:
	TArray<struct FAtomModelHierarchicalSceneNode> SceneNodes;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelHierarchicalScene) == 0x000008, "Wrong alignment on FAtomModelHierarchicalScene");
static_assert(sizeof(FAtomModelHierarchicalScene) == 0x000010, "Wrong size on FAtomModelHierarchicalScene");
static_assert(offsetof(FAtomModelHierarchicalScene, SceneNodes) == 0x000000, "Member 'FAtomModelHierarchicalScene::SceneNodes' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomSourceModel
// 0x00A0 (0x00A0 - 0x0000)
struct FAtomSourceModel final
{
public:
	TArray<struct FAtomModelPrimitive>            Primitives;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtomHingedElement>             Elements;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelSelectionSet>         SelectionSets;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtomGlueSet>                   GlueSets;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelConfigurationGroup>   Groups;                                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0050(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Pivot;                                             // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomSourceModel) == 0x000008, "Wrong alignment on FAtomSourceModel");
static_assert(sizeof(FAtomSourceModel) == 0x0000A0, "Wrong size on FAtomSourceModel");
static_assert(offsetof(FAtomSourceModel, Primitives) == 0x000000, "Member 'FAtomSourceModel::Primitives' has a wrong offset!");
static_assert(offsetof(FAtomSourceModel, Elements) == 0x000010, "Member 'FAtomSourceModel::Elements' has a wrong offset!");
static_assert(offsetof(FAtomSourceModel, SelectionSets) == 0x000020, "Member 'FAtomSourceModel::SelectionSets' has a wrong offset!");
static_assert(offsetof(FAtomSourceModel, GlueSets) == 0x000030, "Member 'FAtomSourceModel::GlueSets' has a wrong offset!");
static_assert(offsetof(FAtomSourceModel, Groups) == 0x000040, "Member 'FAtomSourceModel::Groups' has a wrong offset!");
static_assert(offsetof(FAtomSourceModel, Bounds) == 0x000050, "Member 'FAtomSourceModel::Bounds' has a wrong offset!");
static_assert(offsetof(FAtomSourceModel, Pivot) == 0x000088, "Member 'FAtomSourceModel::Pivot' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelIssue
// 0x0018 (0x0018 - 0x0000)
struct FAtomModelIssue final
{
public:
	EAtomIssue                                    Issue;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringData;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelIssue) == 0x000008, "Wrong alignment on FAtomModelIssue");
static_assert(sizeof(FAtomModelIssue) == 0x000018, "Wrong size on FAtomModelIssue");
static_assert(offsetof(FAtomModelIssue, Issue) == 0x000000, "Member 'FAtomModelIssue::Issue' has a wrong offset!");
static_assert(offsetof(FAtomModelIssue, ID) == 0x000004, "Member 'FAtomModelIssue::ID' has a wrong offset!");
static_assert(offsetof(FAtomModelIssue, StringData) == 0x000008, "Member 'FAtomModelIssue::StringData' has a wrong offset!");

// ScriptStruct AtomRuntime.ModelPrimitiveEntry
// 0x0038 (0x0038 - 0x0000)
struct FModelPrimitiveEntry final
{
public:
	TSoftObjectPtr<class UMeshComponent>          Component;                                         // 0x0000(0x0020)(ExportObject, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAtomModelPartReference                PartReference;                                     // 0x0020(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModelPrimitiveEntry) == 0x000008, "Wrong alignment on FModelPrimitiveEntry");
static_assert(sizeof(FModelPrimitiveEntry) == 0x000038, "Wrong size on FModelPrimitiveEntry");
static_assert(offsetof(FModelPrimitiveEntry, Component) == 0x000000, "Member 'FModelPrimitiveEntry::Component' has a wrong offset!");
static_assert(offsetof(FModelPrimitiveEntry, PartReference) == 0x000020, "Member 'FModelPrimitiveEntry::PartReference' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomProcessorResult
// 0x0028 (0x0028 - 0x0000)
struct FAtomProcessorResult final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ProcessedObjects;                                  // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        SharedAssets;                                      // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomProcessorResult) == 0x000008, "Wrong alignment on FAtomProcessorResult");
static_assert(sizeof(FAtomProcessorResult) == 0x000028, "Wrong size on FAtomProcessorResult");
static_assert(offsetof(FAtomProcessorResult, bSuccess) == 0x000000, "Member 'FAtomProcessorResult::bSuccess' has a wrong offset!");
static_assert(offsetof(FAtomProcessorResult, ProcessedObjects) == 0x000008, "Member 'FAtomProcessorResult::ProcessedObjects' has a wrong offset!");
static_assert(offsetof(FAtomProcessorResult, SharedAssets) == 0x000018, "Member 'FAtomProcessorResult::SharedAssets' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomOnProcessPrimitiveSettings
// 0x0001 (0x0001 - 0x0000)
struct FAtomOnProcessPrimitiveSettings final
{
public:
	bool                                          bSupportDecorations;                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomOnProcessPrimitiveSettings) == 0x000001, "Wrong alignment on FAtomOnProcessPrimitiveSettings");
static_assert(sizeof(FAtomOnProcessPrimitiveSettings) == 0x000001, "Wrong size on FAtomOnProcessPrimitiveSettings");
static_assert(offsetof(FAtomOnProcessPrimitiveSettings, bSupportDecorations) == 0x000000, "Member 'FAtomOnProcessPrimitiveSettings::bSupportDecorations' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomModelProcessorInstance
// 0x0028 (0x0028 - 0x0000)
struct FAtomModelProcessorInstance final
{
public:
	bool                                          bUseCustomSettings;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomModelProcessor*                    Processor;                                         // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomModelProcessor*                    InternalTransientPropStorage;                      // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UObject>>         ProcessedObjects;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomModelProcessorInstance) == 0x000008, "Wrong alignment on FAtomModelProcessorInstance");
static_assert(sizeof(FAtomModelProcessorInstance) == 0x000028, "Wrong size on FAtomModelProcessorInstance");
static_assert(offsetof(FAtomModelProcessorInstance, bUseCustomSettings) == 0x000000, "Member 'FAtomModelProcessorInstance::bUseCustomSettings' has a wrong offset!");
static_assert(offsetof(FAtomModelProcessorInstance, Processor) == 0x000008, "Member 'FAtomModelProcessorInstance::Processor' has a wrong offset!");
static_assert(offsetof(FAtomModelProcessorInstance, InternalTransientPropStorage) == 0x000010, "Member 'FAtomModelProcessorInstance::InternalTransientPropStorage' has a wrong offset!");
static_assert(offsetof(FAtomModelProcessorInstance, ProcessedObjects) == 0x000018, "Member 'FAtomModelProcessorInstance::ProcessedObjects' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveConnectionPointReference
// 0x0004 (0x0004 - 0x0000)
struct FAtomPrimitiveConnectionPointReference final
{
public:
	int16                                         PlanarFieldIndex;                                  // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         ConnectionPointIndex;                              // 0x0002(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveConnectionPointReference) == 0x000002, "Wrong alignment on FAtomPrimitiveConnectionPointReference");
static_assert(sizeof(FAtomPrimitiveConnectionPointReference) == 0x000004, "Wrong size on FAtomPrimitiveConnectionPointReference");
static_assert(offsetof(FAtomPrimitiveConnectionPointReference, PlanarFieldIndex) == 0x000000, "Member 'FAtomPrimitiveConnectionPointReference::PlanarFieldIndex' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveConnectionPointReference, ConnectionPointIndex) == 0x000002, "Member 'FAtomPrimitiveConnectionPointReference::ConnectionPointIndex' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomCommonPartDescription
// 0x0010 (0x0010 - 0x0000)
struct FAtomCommonPartDescription final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PlaneQuadrant;                                     // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLogo;                                         // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomCommonPartDescription) == 0x000004, "Wrong alignment on FAtomCommonPartDescription");
static_assert(sizeof(FAtomCommonPartDescription) == 0x000010, "Wrong size on FAtomCommonPartDescription");
static_assert(offsetof(FAtomCommonPartDescription, Radius) == 0x000000, "Member 'FAtomCommonPartDescription::Radius' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartDescription, Height) == 0x000004, "Member 'FAtomCommonPartDescription::Height' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartDescription, InnerRadius) == 0x000008, "Member 'FAtomCommonPartDescription::InnerRadius' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartDescription, PlaneQuadrant) == 0x00000C, "Member 'FAtomCommonPartDescription::PlaneQuadrant' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartDescription, bShowLogo) == 0x00000D, "Member 'FAtomCommonPartDescription::bShowLogo' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomCommonPartInstance
// 0x0040 (0x0040 - 0x0000)
struct FAtomCommonPartInstance final
{
public:
	struct FTransform3f                           Transform;                                         // 0x0000(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAtomPrimitiveConnectionPointReference ConnectionPointReference;                          // 0x0030(0x0004)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomCommonPartInstance) == 0x000010, "Wrong alignment on FAtomCommonPartInstance");
static_assert(sizeof(FAtomCommonPartInstance) == 0x000040, "Wrong size on FAtomCommonPartInstance");
static_assert(offsetof(FAtomCommonPartInstance, Transform) == 0x000000, "Member 'FAtomCommonPartInstance::Transform' has a wrong offset!");
static_assert(offsetof(FAtomCommonPartInstance, ConnectionPointReference) == 0x000030, "Member 'FAtomCommonPartInstance::ConnectionPointReference' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveCommonPart
// 0x0010 (0x0010 - 0x0000)
struct FAtomPrimitiveCommonPart final
{
public:
	TArray<struct FAtomCommonPartInstance>        UnscaledInstances;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveCommonPart) == 0x000008, "Wrong alignment on FAtomPrimitiveCommonPart");
static_assert(sizeof(FAtomPrimitiveCommonPart) == 0x000010, "Wrong size on FAtomPrimitiveCommonPart");
static_assert(offsetof(FAtomPrimitiveCommonPart, UnscaledInstances) == 0x000000, "Member 'FAtomPrimitiveCommonPart::UnscaledInstances' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitivePhysicsAttributes
// 0x00A0 (0x00A0 - 0x0000)
struct FAtomPrimitivePhysicsAttributes final
{
public:
	struct FMatrix                                InertiaTensor;                                     // 0x0000(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CenterOfMass;                                      // 0x0080(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomPrimitivePhysicsAttributes) == 0x000010, "Wrong alignment on FAtomPrimitivePhysicsAttributes");
static_assert(sizeof(FAtomPrimitivePhysicsAttributes) == 0x0000A0, "Wrong size on FAtomPrimitivePhysicsAttributes");
static_assert(offsetof(FAtomPrimitivePhysicsAttributes, InertiaTensor) == 0x000000, "Member 'FAtomPrimitivePhysicsAttributes::InertiaTensor' has a wrong offset!");
static_assert(offsetof(FAtomPrimitivePhysicsAttributes, CenterOfMass) == 0x000080, "Member 'FAtomPrimitivePhysicsAttributes::CenterOfMass' has a wrong offset!");
static_assert(offsetof(FAtomPrimitivePhysicsAttributes, Mass) == 0x000098, "Member 'FAtomPrimitivePhysicsAttributes::Mass' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveUserNote
// 0x0020 (0x0020 - 0x0000)
struct FAtomPrimitiveUserNote final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartRevision;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveUserNote) == 0x000008, "Wrong alignment on FAtomPrimitiveUserNote");
static_assert(sizeof(FAtomPrimitiveUserNote) == 0x000020, "Wrong size on FAtomPrimitiveUserNote");
static_assert(offsetof(FAtomPrimitiveUserNote, Text) == 0x000000, "Member 'FAtomPrimitiveUserNote::Text' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveUserNote, PartRevision) == 0x000010, "Member 'FAtomPrimitiveUserNote::PartRevision' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveOptimizationSettings
// 0x0030 (0x0030 - 0x0000)
struct FAtomPrimitiveOptimizationSettings final
{
public:
	EAtomPrimitiveGeoOptimization                 OptimizationType;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAtomPrimitiveGeoOptimization_Old             GeometryOptions;                                   // 0x0004(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtomPrimitiveApproximationShapeType          ApproximationShapeType;                            // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAtomPrimitiveApproximationShapeType_Old      ApproximationStrategy;                             // 0x000C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOptimizationAxisOverride;                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ApproximationAxisOverride;                         // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtomPrimitiveOptimizationSettings) == 0x000008, "Wrong alignment on FAtomPrimitiveOptimizationSettings");
static_assert(sizeof(FAtomPrimitiveOptimizationSettings) == 0x000030, "Wrong size on FAtomPrimitiveOptimizationSettings");
static_assert(offsetof(FAtomPrimitiveOptimizationSettings, OptimizationType) == 0x000000, "Member 'FAtomPrimitiveOptimizationSettings::OptimizationType' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveOptimizationSettings, GeometryOptions) == 0x000004, "Member 'FAtomPrimitiveOptimizationSettings::GeometryOptions' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveOptimizationSettings, ApproximationShapeType) == 0x000008, "Member 'FAtomPrimitiveOptimizationSettings::ApproximationShapeType' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveOptimizationSettings, ApproximationStrategy) == 0x00000C, "Member 'FAtomPrimitiveOptimizationSettings::ApproximationStrategy' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveOptimizationSettings, bUseOptimizationAxisOverride) == 0x000010, "Member 'FAtomPrimitiveOptimizationSettings::bUseOptimizationAxisOverride' has a wrong offset!");
static_assert(offsetof(FAtomPrimitiveOptimizationSettings, ApproximationAxisOverride) == 0x000018, "Member 'FAtomPrimitiveOptimizationSettings::ApproximationAxisOverride' has a wrong offset!");

// ScriptStruct AtomRuntime.AtomPrimitiveBevelOptions
// 0x0001 (0x0001 - 0x0000)
struct FAtomPrimitiveBevelOptions final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomPrimitiveBevelOptions) == 0x000001, "Wrong alignment on FAtomPrimitiveBevelOptions");
static_assert(sizeof(FAtomPrimitiveBevelOptions) == 0x000001, "Wrong size on FAtomPrimitiveBevelOptions");

// ScriptStruct AtomRuntime.AtomPrimitiveBuildOptions
// 0x0001 (0x0001 - 0x0000)
struct FAtomPrimitiveBuildOptions final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomPrimitiveBuildOptions) == 0x000001, "Wrong alignment on FAtomPrimitiveBuildOptions");
static_assert(sizeof(FAtomPrimitiveBuildOptions) == 0x000001, "Wrong size on FAtomPrimitiveBuildOptions");

// ScriptStruct AtomRuntime.AtomPrimitiveBuildSettings
// 0x0001 (0x0001 - 0x0000)
struct FAtomPrimitiveBuildSettings final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtomPrimitiveBuildSettings) == 0x000001, "Wrong alignment on FAtomPrimitiveBuildSettings");
static_assert(sizeof(FAtomPrimitiveBuildSettings) == 0x000001, "Wrong size on FAtomPrimitiveBuildSettings");

// ScriptStruct AtomRuntime.ConnectivityFieldConnection
// 0x000C (0x000C - 0x0000)
struct FConnectivityFieldConnection final
{
public:
	struct FConnectivityFieldReference            Reference;                                         // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	EFieldConnectResult                           ConnectResult;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectivityFieldConnection) == 0x000004, "Wrong alignment on FConnectivityFieldConnection");
static_assert(sizeof(FConnectivityFieldConnection) == 0x00000C, "Wrong size on FConnectivityFieldConnection");
static_assert(offsetof(FConnectivityFieldConnection, Reference) == 0x000000, "Member 'FConnectivityFieldConnection::Reference' has a wrong offset!");
static_assert(offsetof(FConnectivityFieldConnection, ConnectResult) == 0x000008, "Member 'FConnectivityFieldConnection::ConnectResult' has a wrong offset!");

// ScriptStruct AtomRuntime.LineFieldConnectionInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FLineFieldConnectionInfo final
{
public:
	bool                                          Flip;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	EFieldConnectResult                           ConnectResult;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLineFieldConnectionInfo) == 0x000004, "Wrong alignment on FLineFieldConnectionInfo");
static_assert(sizeof(FLineFieldConnectionInfo) == 0x00000C, "Wrong size on FLineFieldConnectionInfo");
static_assert(offsetof(FLineFieldConnectionInfo, Flip) == 0x000000, "Member 'FLineFieldConnectionInfo::Flip' has a wrong offset!");
static_assert(offsetof(FLineFieldConnectionInfo, ConnectResult) == 0x000008, "Member 'FLineFieldConnectionInfo::ConnectResult' has a wrong offset!");

// ScriptStruct AtomRuntime.PointFieldConnectionInfo
// 0x0010 (0x0010 - 0x0000)
struct FPointFieldConnectionInfo
{
public:
	double                                        OneAxisRotation;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFieldConnectResult                           ConnectResult;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPointFieldConnectionInfo) == 0x000008, "Wrong alignment on FPointFieldConnectionInfo");
static_assert(sizeof(FPointFieldConnectionInfo) == 0x000010, "Wrong size on FPointFieldConnectionInfo");
static_assert(offsetof(FPointFieldConnectionInfo, OneAxisRotation) == 0x000000, "Member 'FPointFieldConnectionInfo::OneAxisRotation' has a wrong offset!");
static_assert(offsetof(FPointFieldConnectionInfo, ConnectResult) == 0x000008, "Member 'FPointFieldConnectionInfo::ConnectResult' has a wrong offset!");

// ScriptStruct AtomRuntime.HingeFieldConnectionInfo
// 0x0008 (0x0018 - 0x0010)
struct FHingeFieldConnectionInfo final : public FPointFieldConnectionInfo
{
public:
	bool                                          Flip;                                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHingeFieldConnectionInfo) == 0x000008, "Wrong alignment on FHingeFieldConnectionInfo");
static_assert(sizeof(FHingeFieldConnectionInfo) == 0x000018, "Wrong size on FHingeFieldConnectionInfo");
static_assert(offsetof(FHingeFieldConnectionInfo, Flip) == 0x000010, "Member 'FHingeFieldConnectionInfo::Flip' has a wrong offset!");

}

