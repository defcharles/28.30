#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SparksCameraDirectorRuntime

#include "Basic.hpp"

#include "SparksCameraDirectorRuntime_classes.hpp"
#include "SparksCameraDirectorRuntime_parameters.hpp"


namespace SDK
{

// Function SparksCameraDirectorRuntime.SparksCameraDebugWidget.ClearAll
// (Event, Public, BlueprintCallable, BlueprintEvent)

void USparksCameraDebugWidget::ClearAll()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCameraDirectorRuntime.SparksCameraDebugWidget.ClearCurrent
// (Event, Public, BlueprintCallable, BlueprintEvent)

void USparksCameraDebugWidget::ClearCurrent()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearCurrent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCameraDirectorRuntime.SparksCameraDebugWidget.LogToScreen
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksCameraLogType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDebugWidget::LogToScreen(const class FString& Data, ESparksCameraLogType Type)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LogToScreen");

	Params::SparksCameraDebugWidget_LogToScreen Parms{};

	Parms.Data = std::move(Data);
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDebugWidget.SetEventRouter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UGameplayEventRouterComponent*    EventRouter                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDebugWidget::SetEventRouter(class UGameplayEventRouterComponent* EventRouter)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEventRouter");

	Params::SparksCameraDebugWidget_SetEventRouter Parms{};

	Parms.EventRouter = EventRouter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.ActivateCameraControl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::ActivateCameraControl(bool bActive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ActivateCameraControl");

	Params::SparksCameraDirectorComponent_ActivateCameraControl Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.DebugLockSpecificCameraShot
// (Net, NetReliable, Native, Event, NetMulticast, Protected, BlueprintCallable)
// Parameters:
// struct FSparksCameraShot                Shot                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bLockToFirstFrame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::DebugLockSpecificCameraShot(const struct FSparksCameraShot& Shot, bool bLockToFirstFrame, class AActor* Target)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugLockSpecificCameraShot");

	Params::SparksCameraDirectorComponent_DebugLockSpecificCameraShot Parms{};

	Parms.Shot = std::move(Shot);
	Parms.bLockToFirstFrame = bLockToFirstFrame;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.FindCurrentShot
// (Final, Native, Protected, HasOutParams)
// Parameters:
// int32                                   SequenceIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EntryIndex                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraDirectorComponent::FindCurrentShot(int32* SequenceIndex, int32* EntryIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindCurrentShot");

	Params::SparksCameraDirectorComponent_FindCurrentShot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SequenceIndex != nullptr)
		*SequenceIndex = Parms.SequenceIndex;

	if (EntryIndex != nullptr)
		*EntryIndex = Parms.EntryIndex;

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.HandleDirectorDynamicEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSparksCommonDynamicCameraDirectorEventPayload                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::HandleDirectorDynamicEvent(const struct FSparksCommonDynamicCameraDirectorEvent& Payload)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleDirectorDynamicEvent");

	Params::SparksCameraDirectorComponent_HandleDirectorDynamicEvent Parms{};

	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.HandleForceIntermissionEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSparksCommonForceIntermissionCameraDirectorEventPayload                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::HandleForceIntermissionEvent(const struct FSparksCommonForceIntermissionCameraDirectorEvent& Payload)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleForceIntermissionEvent");

	Params::SparksCameraDirectorComponent_HandleForceIntermissionEvent Parms{};

	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.HandleIntermissionTagsEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSparksCommonIntermissionCameraDirectorEventPayload                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::HandleIntermissionTagsEvent(const struct FSparksCommonIntermissionCameraDirectorEvent& Payload)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleIntermissionTagsEvent");

	Params::SparksCameraDirectorComponent_HandleIntermissionTagsEvent Parms{};

	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.InitDynamicCameras
// (Final, Native, Protected)

void USparksCameraDirectorComponent::InitDynamicCameras()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitDynamicCameras");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.InsertPerformanceMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USparksPerformanceMap*            Map                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::InsertPerformanceMap(class USparksPerformanceMap* Map)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InsertPerformanceMap");

	Params::SparksCameraDirectorComponent_InsertPerformanceMap Parms{};

	Parms.Map = Map;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.InsertSequence
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSparksCameraDirectorSequence    Sequence                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::InsertSequence(const struct FSparksCameraDirectorSequence& Sequence)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InsertSequence");

	Params::SparksCameraDirectorComponent_InsertSequence Parms{};

	Parms.Sequence = std::move(Sequence);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.LogToScreen
// (Final, Native, Protected)
// Parameters:
// class FString                           Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksCameraLogType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeSeconds                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::LogToScreen(const class FString& Data, ESparksCameraLogType Type, float TimeSeconds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LogToScreen");

	Params::SparksCameraDirectorComponent_LogToScreen Parms{};

	Parms.Data = std::move(Data);
	Parms.Type = Type;
	Parms.TimeSeconds = TimeSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.OnShotFinished
// (Final, Native, Protected)

void USparksCameraDirectorComponent::OnShotFinished()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnShotFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.PlayNextShot
// (Final, Native, Protected)

void USparksCameraDirectorComponent::PlayNextShot()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayNextShot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.PlaySequenceEntry
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSparksCameraDirectorSequenceEntryEntry                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MsOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIntermission                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ForceTarget                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::PlaySequenceEntry(const struct FSparksCameraDirectorSequenceEntry& Entry, float MsOffset, bool bIntermission, class AActor* ForceTarget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlaySequenceEntry");

	Params::SparksCameraDirectorComponent_PlaySequenceEntry Parms{};

	Parms.Entry = std::move(Entry);
	Parms.MsOffset = MsOffset;
	Parms.bIntermission = bIntermission;
	Parms.ForceTarget = ForceTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.PlayShot
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSparksCameraDirectorSequenceEntryEntry                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USparksCameraDirectorComponent::PlayShot(const struct FSparksCameraDirectorSequenceEntry& Entry)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayShot");

	Params::SparksCameraDirectorComponent_PlayShot Parms{};

	Parms.Entry = std::move(Entry);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.ReplaceWithNonCloseupShot
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSparksCameraDirectorSequenceEntryOldEntry                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::ReplaceWithNonCloseupShot(const struct FSparksCameraDirectorSequenceEntry& OldEntry)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReplaceWithNonCloseupShot");

	Params::SparksCameraDirectorComponent_ReplaceWithNonCloseupShot Parms{};

	Parms.OldEntry = std::move(OldEntry);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.Reset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceShotChange                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::Reset(bool bForceShotChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Reset");

	Params::SparksCameraDirectorComponent_Reset Parms{};

	Parms.bForceShotChange = bForceShotChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.StartIntermissionCameras
// (Final, Native, Public)
// Parameters:
// float                                   ForceLengthMS                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReloadNewSequence                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceShotChange                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDirectorComponent::StartIntermissionCameras(float ForceLengthMS, bool bForceReloadNewSequence, bool bForceShotChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartIntermissionCameras");

	Params::SparksCameraDirectorComponent_StartIntermissionCameras Parms{};

	Parms.ForceLengthMS = ForceLengthMS;
	Parms.bForceReloadNewSequence = bForceReloadNewSequence;
	Parms.bForceShotChange = bForceShotChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorComponent.GetCameraActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraDirectorComponent::GetCameraActive() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCameraActive");

	Params::SparksCameraDirectorComponent_GetCameraActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorConfig.FindBestGenerator
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USparksCameraDirectorSequenceGenerator*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksCameraDirectorSequenceGenerator* USparksCameraDirectorConfig::FindBestGenerator(const struct FSparksPerformanceMapSection& Section)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindBestGenerator");

	Params::SparksCameraDirectorConfig_FindBestGenerator Parms{};

	Parms.Section = std::move(Section);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorConfig.GenerateEntry
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequenceEntryOutEntry                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraDirectorConfig::GenerateEntry(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutEntry)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateEntry");

	Params::SparksCameraDirectorConfig_GenerateEntry Parms{};

	Parms.Section = std::move(Section);

	UObject::ProcessEvent(Func, &Parms);

	if (OutEntry != nullptr)
		*OutEntry = std::move(Parms.OutEntry);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorConfig.GenerateSequence
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequence    OutSequence                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraDirectorConfig::GenerateSequence(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequence* OutSequence)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateSequence");

	Params::SparksCameraDirectorConfig_GenerateSequence Parms{};

	Parms.Section = std::move(Section);

	UObject::ProcessEvent(Func, &Parms);

	if (OutSequence != nullptr)
		*OutSequence = std::move(Parms.OutSequence);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorConfig.Init
// (Final, Native, Public)

void USparksCameraDirectorConfig::Init()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Init");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorConfig.MarkShotTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   Shot                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AtTimestamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCameraDirectorConfig::MarkShotTime(class ULevelSequence* Shot, float AtTimestamp)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MarkShotTime");

	Params::SparksCameraDirectorConfig_MarkShotTime Parms{};

	Parms.Shot = Shot;
	Parms.AtTimestamp = AtTimestamp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorConfig.ResetCache
// (Final, Native, Public, BlueprintCallable)

void USparksCameraDirectorConfig::ResetCache()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetCache");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorConfig.ShouldUseShot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   Shot                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AtTimestamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraDirectorConfig::ShouldUseShot(class ULevelSequence* Shot, float AtTimestamp)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShouldUseShot");

	Params::SparksCameraDirectorConfig_ShouldUseShot Parms{};

	Parms.Shot = Shot;
	Parms.AtTimestamp = AtTimestamp;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPluginDataProvider.GetAllTargets
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> USparksCameraPluginDataProvider::GetAllTargets()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllTargets");

	Params::SparksCameraPluginDataProvider_GetAllTargets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPluginDataProvider.GetCurrentMSTimeInCameraEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USparksCameraPluginDataProvider::GetCurrentMSTimeInCameraEvent()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentMSTimeInCameraEvent");

	Params::SparksCameraPluginDataProvider_GetCurrentMSTimeInCameraEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPluginDataProvider.GetMatchingCameraTarget
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ShotTimeMS                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreferLocal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* USparksCameraPluginDataProvider::GetMatchingCameraTarget(const struct FGameplayTagContainer& Tags, float ShotTimeMS, bool bPreferLocal)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMatchingCameraTarget");

	Params::SparksCameraPluginDataProvider_GetMatchingCameraTarget Parms{};

	Parms.Tags = std::move(Tags);
	Parms.ShotTimeMS = ShotTimeMS;
	Parms.bPreferLocal = bPreferLocal;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPluginDataProvider.GetTargetForCloseup
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   ShotTimeMS                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagsOut                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    bPreferLocal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* USparksCameraPluginDataProvider::GetTargetForCloseup(float ShotTimeMS, struct FGameplayTagContainer* TagsOut, bool bPreferLocal)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTargetForCloseup");

	Params::SparksCameraPluginDataProvider_GetTargetForCloseup Parms{};

	Parms.ShotTimeMS = ShotTimeMS;
	Parms.bPreferLocal = bPreferLocal;

	UObject::ProcessEvent(Func, &Parms);

	if (TagsOut != nullptr)
		*TagsOut = std::move(Parms.TagsOut);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPluginDataProvider.GetTargetRelevantTags
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSparksCameraFilter              TagsOut                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraPluginDataProvider::GetTargetRelevantTags(class AActor* Target, struct FSparksCameraFilter* TagsOut)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTargetRelevantTags");

	Params::SparksCameraPluginDataProvider_GetTargetRelevantTags Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (TagsOut != nullptr)
		*TagsOut = std::move(Parms.TagsOut);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPluginDataProvider.GetValidTimestamp
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DesiredTimestampMS                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTimestampMSHigh                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTimestampMSLow                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraPluginDataProvider::GetValidTimestamp(float DesiredTimestampMS, float* OutTimestampMSHigh, float* OutTimestampMSLow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValidTimestamp");

	Params::SparksCameraPluginDataProvider_GetValidTimestamp Parms{};

	Parms.DesiredTimestampMS = DesiredTimestampMS;

	UObject::ProcessEvent(Func, &Parms);

	if (OutTimestampMSHigh != nullptr)
		*OutTimestampMSHigh = Parms.OutTimestampMSHigh;

	if (OutTimestampMSLow != nullptr)
		*OutTimestampMSLow = Parms.OutTimestampMSLow;

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPluginDataProvider.GetStaticShot
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSparksCameraShot                OutShot                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraPluginDataProvider::GetStaticShot(int32 Index_0, struct FSparksCameraShot* OutShot) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStaticShot");

	Params::SparksCameraPluginDataProvider_GetStaticShot Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	if (OutShot != nullptr)
		*OutShot = std::move(Parms.OutShot);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPluginDataProvider.GetStaticShotCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksCameraPluginDataProvider::GetStaticShotCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStaticShotCount");

	Params::SparksCameraPluginDataProvider_GetStaticShotCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraShotSelectRuleBase.ChooseShot
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequenceEntryOutShot                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraShotSelectRuleBase::ChooseShot(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutShot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChooseShot");

	Params::SparksCameraShotSelectRuleBase_ChooseShot Parms{};

	Parms.Section = std::move(Section);

	UObject::ProcessEvent(Func, &Parms);

	if (OutShot != nullptr)
		*OutShot = std::move(Parms.OutShot);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraShotSelectRuleBase.Init
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class USparksCameraShotPool*            InPool                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraShotSelectRuleBase::Init(class USparksCameraShotPool* InPool)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Init");

	Params::SparksCameraShotSelectRuleBase_Init Parms{};

	Parms.InPool = InPool;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraShotSelectRuleBase.Reset
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraShotSelectRuleBase::Reset()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Reset");

	Params::SparksCameraShotSelectRuleBase_Reset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraShotSelectRuleBase.GetShotCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksCameraShotSelectRuleBase::GetShotCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShotCount");

	Params::SparksCameraShotSelectRuleBase_GetShotCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPoolSelectRuleBase.ChooseExitShot
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequenceEntryOutShot                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraPoolSelectRuleBase::ChooseExitShot(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutShot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChooseExitShot");

	Params::SparksCameraPoolSelectRuleBase_ChooseExitShot Parms{};

	Parms.Section = std::move(Section);

	UObject::ProcessEvent(Func, &Parms);

	if (OutShot != nullptr)
		*OutShot = std::move(Parms.OutShot);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPoolSelectRuleBase.ChooseIntroShot
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequenceEntryOutShot                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraPoolSelectRuleBase::ChooseIntroShot(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutShot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChooseIntroShot");

	Params::SparksCameraPoolSelectRuleBase_ChooseIntroShot Parms{};

	Parms.Section = std::move(Section);

	UObject::ProcessEvent(Func, &Parms);

	if (OutShot != nullptr)
		*OutShot = std::move(Parms.OutShot);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPoolSelectRuleBase.ChooseShot
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequenceEntryOutShot                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraPoolSelectRuleBase::ChooseShot(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutShot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChooseShot");

	Params::SparksCameraPoolSelectRuleBase_ChooseShot Parms{};

	Parms.Section = std::move(Section);

	UObject::ProcessEvent(Func, &Parms);

	if (OutShot != nullptr)
		*OutShot = std::move(Parms.OutShot);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPoolSelectRuleBase.Init
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksCameraSectionWrapper      Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraPoolSelectRuleBase::Init(const struct FSparksCameraSectionWrapper& Section)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Init");

	Params::SparksCameraPoolSelectRuleBase_Init Parms{};

	Parms.Section = std::move(Section);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPoolSelectRuleBase.Reset
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraPoolSelectRuleBase::Reset()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Reset");

	Params::SparksCameraPoolSelectRuleBase_Reset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPoolSelectRuleBase.GetPoolCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksCameraPoolSelectRuleBase::GetPoolCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPoolCount");

	Params::SparksCameraPoolSelectRuleBase_GetPoolCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraPoolSelectRuleBase.GetShotCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksCameraPoolSelectRuleBase::GetShotCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShotCount");

	Params::SparksCameraPoolSelectRuleBase_GetShotCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorSequenceGenerator.GenerateEntry
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USparksCameraPluginDataProvider*  DataProvider                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequenceEntryOutEntry                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// ESparksSectionGeneratorResult           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksSectionGeneratorResult USparksCameraDirectorSequenceGenerator::GenerateEntry(const struct FSparksPerformanceMapSection& Section, class USparksCameraPluginDataProvider* DataProvider, struct FSparksCameraDirectorSequenceEntry* OutEntry)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateEntry");

	Params::SparksCameraDirectorSequenceGenerator_GenerateEntry Parms{};

	Parms.Section = std::move(Section);
	Parms.DataProvider = DataProvider;

	UObject::ProcessEvent(Func, &Parms);

	if (OutEntry != nullptr)
		*OutEntry = std::move(Parms.OutEntry);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorSequenceGenerator.GenerateExitEntry
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USparksCameraPluginDataProvider*  DataProvider                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequenceEntryOutEntry                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// ESparksSectionGeneratorResult           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksSectionGeneratorResult USparksCameraDirectorSequenceGenerator::GenerateExitEntry(const struct FSparksPerformanceMapSection& Section, class USparksCameraPluginDataProvider* DataProvider, struct FSparksCameraDirectorSequenceEntry* OutEntry)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateExitEntry");

	Params::SparksCameraDirectorSequenceGenerator_GenerateExitEntry Parms{};

	Parms.Section = std::move(Section);
	Parms.DataProvider = DataProvider;

	UObject::ProcessEvent(Func, &Parms);

	if (OutEntry != nullptr)
		*OutEntry = std::move(Parms.OutEntry);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorSequenceGenerator.GenerateIntroEntry
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USparksCameraPluginDataProvider*  DataProvider                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequenceEntryOutEntry                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// ESparksSectionGeneratorResult           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksSectionGeneratorResult USparksCameraDirectorSequenceGenerator::GenerateIntroEntry(const struct FSparksPerformanceMapSection& Section, class USparksCameraPluginDataProvider* DataProvider, struct FSparksCameraDirectorSequenceEntry* OutEntry)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateIntroEntry");

	Params::SparksCameraDirectorSequenceGenerator_GenerateIntroEntry Parms{};

	Parms.Section = std::move(Section);
	Parms.DataProvider = DataProvider;

	UObject::ProcessEvent(Func, &Parms);

	if (OutEntry != nullptr)
		*OutEntry = std::move(Parms.OutEntry);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorSequenceGenerator.GenerateSequence
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksPerformanceMapSection     Section                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USparksCameraPluginDataProvider*  DataProvider                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSparksCameraDirectorSequence    OutSequence                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// ESparksSectionGeneratorResult           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksSectionGeneratorResult USparksCameraDirectorSequenceGenerator::GenerateSequence(const struct FSparksPerformanceMapSection& Section, class USparksCameraPluginDataProvider* DataProvider, struct FSparksCameraDirectorSequence* OutSequence)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateSequence");

	Params::SparksCameraDirectorSequenceGenerator_GenerateSequence Parms{};

	Parms.Section = std::move(Section);
	Parms.DataProvider = DataProvider;

	UObject::ProcessEvent(Func, &Parms);

	if (OutSequence != nullptr)
		*OutSequence = std::move(Parms.OutSequence);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorSequenceGenerator.GetFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FSparksCameraFilter        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FSparksCameraFilter USparksCameraDirectorSequenceGenerator::GetFilter()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFilter");

	Params::SparksCameraDirectorSequenceGenerator_GetFilter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorSequenceGenerator.Init
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSparksCameraSectionWrapper      InPool                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USparksCameraDirectorConfig*      Config                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraDirectorSequenceGenerator::Init(const struct FSparksCameraSectionWrapper& InPool, class USparksCameraDirectorConfig* Config)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Init");

	Params::SparksCameraDirectorSequenceGenerator_Init Parms{};

	Parms.InPool = std::move(InPool);
	Parms.Config = Config;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCameraDirectorSequenceGenerator.Reset
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCameraDirectorSequenceGenerator::Reset()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Reset");

	Params::SparksCameraDirectorSequenceGenerator_Reset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCamera_BPFL.GetSubTagForMidiEventName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           EventString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag USparksCamera_BPFL::GetSubTagForMidiEventName(const class FString& EventString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSubTagForMidiEventName");

	Params::SparksCamera_BPFL_GetSubTagForMidiEventName Parms{};

	Parms.EventString = std::move(EventString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCamera_BPFL.GetTagForMidiEventName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           EventString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag USparksCamera_BPFL::GetTagForMidiEventName(const class FString& EventString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTagForMidiEventName");

	Params::SparksCamera_BPFL_GetTagForMidiEventName Parms{};

	Parms.EventString = std::move(EventString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCamera_BPFL.ScoreTagContainers
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Tags1                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Tags2                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USparksCamera_BPFL::ScoreTagContainers(const struct FGameplayTagContainer& Tags1, const struct FGameplayTagContainer& Tags2)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScoreTagContainers");

	Params::SparksCamera_BPFL_ScoreTagContainers Parms{};

	Parms.Tags1 = std::move(Tags1);
	Parms.Tags2 = std::move(Tags2);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksCamera_BPFL.ScoreTagsAgainstFilter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSparksCameraFilter              Filter                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagsToMatch                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   OutScore                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksFilterResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksFilterResult USparksCamera_BPFL::ScoreTagsAgainstFilter(const struct FSparksCameraFilter& Filter, const struct FGameplayTagContainer& TagsToMatch, float* OutScore)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScoreTagsAgainstFilter");

	Params::SparksCamera_BPFL_ScoreTagsAgainstFilter Parms{};

	Parms.Filter = std::move(Filter);
	Parms.TagsToMatch = std::move(TagsToMatch);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutScore != nullptr)
		*OutScore = Parms.OutScore;

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksLevelSequencePlayer.SparksCreateLevelSequencePlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   LevelSequence                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneSequencePlaybackSettingsSettings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ASparksLevelSequenceActor*        OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           TargetActor                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSparksCameraShot                Shot                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USparksLevelSequencePlayer*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksLevelSequencePlayer* USparksLevelSequencePlayer::SparksCreateLevelSequencePlayer(class UObject* WorldContextObject, class ULevelSequence* LevelSequence, const struct FMovieSceneSequencePlaybackSettings& Settings, class ASparksLevelSequenceActor** OutActor, class USkeletalMeshComponent* TargetActor, const struct FSparksCameraShot& Shot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SparksCreateLevelSequencePlayer");

	Params::SparksLevelSequencePlayer_SparksCreateLevelSequencePlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelSequence = LevelSequence;
	Parms.Settings = std::move(Settings);
	Parms.TargetActor = TargetActor;
	Parms.Shot = std::move(Shot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksPerformanceMap.AddSection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   StartMS                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     PrimaryTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            SecondaryTags                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USparksPerformanceMap::AddSection(float StartMS, const struct FGameplayTag& PrimaryTag, const struct FGameplayTagContainer& SecondaryTags)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddSection");

	Params::SparksPerformanceMap_AddSection Parms{};

	Parms.StartMS = StartMS;
	Parms.PrimaryTag = std::move(PrimaryTag);
	Parms.SecondaryTags = std::move(SecondaryTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCameraDirectorRuntime.SparksPerformanceMap.FixupSectionTimeLengths
// (Final, Native, Public, BlueprintCallable)

void USparksPerformanceMap::FixupSectionTimeLengths()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FixupSectionTimeLengths");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SparksCameraDirectorRuntime.SparksPerformanceMap.InsertTimeline
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USparksPerformanceMap*            Map                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutFirstIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutLastIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverwrite                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksPerformanceMap::InsertTimeline(class USparksPerformanceMap* Map, int32* OutFirstIndex, int32* OutLastIndex, bool bOverwrite)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InsertTimeline");

	Params::SparksPerformanceMap_InsertTimeline Parms{};

	Parms.Map = Map;
	Parms.bOverwrite = bOverwrite;

	UObject::ProcessEvent(Func, &Parms);

	if (OutFirstIndex != nullptr)
		*OutFirstIndex = Parms.OutFirstIndex;

	if (OutLastIndex != nullptr)
		*OutLastIndex = Parms.OutLastIndex;

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksPerformanceMap.GetNextSectionIndexAtTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   TimeMS                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksPerformanceMap::GetNextSectionIndexAtTime(float TimeMS) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNextSectionIndexAtTime");

	Params::SparksPerformanceMap_GetNextSectionIndexAtTime Parms{};

	Parms.TimeMS = TimeMS;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCameraDirectorRuntime.SparksPerformanceMap.GetSectionIndexAtTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   TimeMS                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksPerformanceMap::GetSectionIndexAtTime(float TimeMS) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSectionIndexAtTime");

	Params::SparksPerformanceMap_GetSectionIndexAtTime Parms{};

	Parms.TimeMS = TimeMS;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

