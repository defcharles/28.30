#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VerseAIBase_0

#include "Basic.hpp"

#include "EpicGamesTemporary_0_structs.hpp"


namespace SDK
{

// VerseEnum VerseAIBase.VerseAIBase_action_result
// NumValues: 0x0003
enum class EVerseAIBase_action_result : uint8
{
	Success                                  = 0,
	Canceled                                 = 1,
	Disallowed                               = 2,
};

// VerseEnum VerseAIBase.VerseAIBase_fallible_action_result
// NumValues: 0x0004
enum class EVerseAIBase_fallible_action_result : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
	Canceled                                 = 2,
	Disallowed                               = 3,
};

// VerseEnum VerseAIBase.VerseAIBase_fort_loot_type
// NumValues: 0x0004
enum class EVerseAIBase_fort_loot_type : uint8
{
	pickup                                   = 0,
	chest                                    = 1,
	supply_drop                              = 2,
	unknown                                  = 3,
};

// VerseEnum VerseAIBase.VerseAIBase_fort_obstacle_status
// NumValues: 0x0003
enum class EVerseAIBase_fort_obstacle_status : uint8
{
	incoming_obstacle                        = 0,
	blocked_by_obstacle                      = 1,
	trap_obstacle                            = 2,
};

// VerseStruct VerseAIBase.tuple_L_R
// 0x0001 (0x0001 - 0x0000)
struct VerseAIBase_0::Ftuple_L_R final
{
public:
	uint8                                         _StructPaddingDummy;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(VerseAIBase_0::Ftuple_L_R) == 0x000001, "Wrong alignment on VerseAIBase_0::Ftuple_L_R");
static_assert(sizeof(VerseAIBase_0::Ftuple_L_R) == 0x000001, "Wrong size on VerseAIBase_0::Ftuple_L_R");
static_assert(offsetof(VerseAIBase_0::Ftuple_L_R, _StructPaddingDummy) == 0x000000, "Member 'VerseAIBase_0::Ftuple_L_R::_StructPaddingDummy' has a wrong offset!");

// VerseStruct VerseAIBase.tuple_Lany_M_Kchar_R
// 0x0018 (0x0018 - 0x0000)
struct VerseAIBase_0::Ftuple_Lany_M_Kchar_R final
{
public:
	class UClass*                                 __verse_0x18E3F084_Elem0;                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	FVerseStringProperty_                         __verse_0x7D844C3C_Elem1;                          // 0x0008(0x0010)(InstancedReference, HasGetValueTypeHash)
};
static_assert(alignof(VerseAIBase_0::Ftuple_Lany_M_Kchar_R) == 0x000008, "Wrong alignment on VerseAIBase_0::Ftuple_Lany_M_Kchar_R");
static_assert(sizeof(VerseAIBase_0::Ftuple_Lany_M_Kchar_R) == 0x000018, "Wrong size on VerseAIBase_0::Ftuple_Lany_M_Kchar_R");
static_assert(offsetof(VerseAIBase_0::Ftuple_Lany_M_Kchar_R, __verse_0x18E3F084_Elem0) == 0x000000, "Member 'VerseAIBase_0::Ftuple_Lany_M_Kchar_R::__verse_0x18E3F084_Elem0' has a wrong offset!");
static_assert(offsetof(VerseAIBase_0::Ftuple_Lany_M_Kchar_R, __verse_0x7D844C3C_Elem1) == 0x000008, "Member 'VerseAIBase_0::Ftuple_Lany_M_Kchar_R::__verse_0x7D844C3C_Elem1' has a wrong offset!");

// VerseStruct VerseAIBase.tuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R
// 0x0010 (0x0010 - 0x0000)
struct VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R final
{
public:
	class UObject*                                __verse_0x18E3F084_Elem0;                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	struct VerseAIBase_0::Ftuple_L_R              __verse_0x7D844C3C_Elem1;                          // 0x0008(0x0001)(InstancedReference, HasGetValueTypeHash)
	struct VerseAIBase_0::Ftuple_L_R              __verse_0x932BF92E_Elem2;                          // 0x0009(0x0001)(InstancedReference, HasGetValueTypeHash)
};
static_assert(alignof(VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R) == 0x000008, "Wrong alignment on VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R");
static_assert(sizeof(VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R) == 0x000010, "Wrong size on VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R");
static_assert(offsetof(VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R, __verse_0x18E3F084_Elem0) == 0x000000, "Member 'VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R::__verse_0x18E3F084_Elem0' has a wrong offset!");
static_assert(offsetof(VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R, __verse_0x7D844C3C_Elem1) == 0x000008, "Member 'VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R::__verse_0x7D844C3C_Elem1' has a wrong offset!");
static_assert(offsetof(VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R, __verse_0x932BF92E_Elem2) == 0x000009, "Member 'VerseAIBase_0::Ftuple_Lfort__character_Mtuple_L_R_Mtuple_L_R_R::__verse_0x932BF92E_Elem2' has a wrong offset!");

// VerseStruct VerseAIBase.tuple_Lfort__inventory__item__asset_Mint_R
// 0x0010 (0x0010 - 0x0000)
struct VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R final
{
public:
	class UVerseAIBase_fort_inventory_item_asset* __verse_0x18E3F084_Elem0;                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	int64                                         __verse_0x7D844C3C_Elem1;                          // 0x0008(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R) == 0x000008, "Wrong alignment on VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R");
static_assert(sizeof(VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R) == 0x000010, "Wrong size on VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R");
static_assert(offsetof(VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R, __verse_0x18E3F084_Elem0) == 0x000000, "Member 'VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R::__verse_0x18E3F084_Elem0' has a wrong offset!");
static_assert(offsetof(VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R, __verse_0x7D844C3C_Elem1) == 0x000008, "Member 'VerseAIBase_0::Ftuple_Lfort__inventory__item__asset_Mint_R::__verse_0x7D844C3C_Elem1' has a wrong offset!");

// VerseStruct VerseAIBase.VerseAIBase_fort_item_descriptor
// 0x0018 (0x0018 - 0x0000)
struct FVerseAIBase_fort_item_descriptor final
{
public:
	class UVerseAIBase_fort_item_tag*             __verse_0x93BEB694_ItemType;                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVerseAIBase_fort_item_descriptor) == 0x000008, "Wrong alignment on FVerseAIBase_fort_item_descriptor");
static_assert(sizeof(FVerseAIBase_fort_item_descriptor) == 0x000018, "Wrong size on FVerseAIBase_fort_item_descriptor");
static_assert(offsetof(FVerseAIBase_fort_item_descriptor, __verse_0x93BEB694_ItemType) == 0x000000, "Member 'FVerseAIBase_fort_item_descriptor::__verse_0x93BEB694_ItemType' has a wrong offset!");

// VerseStruct VerseAIBase.tuple_Lfort__item__descriptor_Mfort__item__tag_R
// 0x0020 (0x0020 - 0x0000)
struct Ftuple_Lfort__item__descriptor_Mfort__item__tag_R final
{
public:
	struct FVerseAIBase_fort_item_descriptor      __verse_0x18E3F084_Elem0;                          // 0x0000(0x0018)(InstancedReference, NoDestructor)
	class UVerseAIBase_fort_item_tag*             __verse_0x7D844C3C_Elem1;                          // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash)
};
static_assert(alignof(Ftuple_Lfort__item__descriptor_Mfort__item__tag_R) == 0x000008, "Wrong alignment on Ftuple_Lfort__item__descriptor_Mfort__item__tag_R");
static_assert(sizeof(Ftuple_Lfort__item__descriptor_Mfort__item__tag_R) == 0x000020, "Wrong size on Ftuple_Lfort__item__descriptor_Mfort__item__tag_R");
static_assert(offsetof(Ftuple_Lfort__item__descriptor_Mfort__item__tag_R, __verse_0x18E3F084_Elem0) == 0x000000, "Member 'Ftuple_Lfort__item__descriptor_Mfort__item__tag_R::__verse_0x18E3F084_Elem0' has a wrong offset!");
static_assert(offsetof(Ftuple_Lfort__item__descriptor_Mfort__item__tag_R, __verse_0x7D844C3C_Elem1) == 0x000018, "Member 'Ftuple_Lfort__item__descriptor_Mfort__item__tag_R::__verse_0x7D844C3C_Elem1' has a wrong offset!");

// VerseStruct VerseAIBase.tuple_Lgameplay__ability__asset_M_Kchar_R
// 0x0018 (0x0018 - 0x0000)
struct Ftuple_Lgameplay__ability__asset_M_Kchar_R final
{
public:
	class UClass*                                 __verse_0x18E3F084_Elem0;                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	FVerseStringProperty_                         __verse_0x7D844C3C_Elem1;                          // 0x0008(0x0010)(InstancedReference, HasGetValueTypeHash)
};
static_assert(alignof(Ftuple_Lgameplay__ability__asset_M_Kchar_R) == 0x000008, "Wrong alignment on Ftuple_Lgameplay__ability__asset_M_Kchar_R");
static_assert(sizeof(Ftuple_Lgameplay__ability__asset_M_Kchar_R) == 0x000018, "Wrong size on Ftuple_Lgameplay__ability__asset_M_Kchar_R");
static_assert(offsetof(Ftuple_Lgameplay__ability__asset_M_Kchar_R, __verse_0x18E3F084_Elem0) == 0x000000, "Member 'Ftuple_Lgameplay__ability__asset_M_Kchar_R::__verse_0x18E3F084_Elem0' has a wrong offset!");
static_assert(offsetof(Ftuple_Lgameplay__ability__asset_M_Kchar_R, __verse_0x7D844C3C_Elem1) == 0x000008, "Member 'Ftuple_Lgameplay__ability__asset_M_Kchar_R::__verse_0x7D844C3C_Elem1' has a wrong offset!");

// VerseStruct VerseAIBase.VerseAIBase_fort_loot_info
// 0x0028 (0x0028 - 0x0000)
struct FVerseAIBase_fort_loot_info final
{
public:
	struct FSpatialMath_vector3                   __verse_0xB0C27E0A_Location;                       // 0x0000(0x0018)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	EVerseAIBase_fort_loot_type                   __verse_0x72E298E9_Type;                           // 0x0018(0x0001)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerseEngine_Entity_entity*             __verse_0xC218B7D2_Loot;                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash)
};
static_assert(alignof(FVerseAIBase_fort_loot_info) == 0x000008, "Wrong alignment on FVerseAIBase_fort_loot_info");
static_assert(sizeof(FVerseAIBase_fort_loot_info) == 0x000028, "Wrong size on FVerseAIBase_fort_loot_info");
static_assert(offsetof(FVerseAIBase_fort_loot_info, __verse_0xB0C27E0A_Location) == 0x000000, "Member 'FVerseAIBase_fort_loot_info::__verse_0xB0C27E0A_Location' has a wrong offset!");
static_assert(offsetof(FVerseAIBase_fort_loot_info, __verse_0x72E298E9_Type) == 0x000018, "Member 'FVerseAIBase_fort_loot_info::__verse_0x72E298E9_Type' has a wrong offset!");
static_assert(offsetof(FVerseAIBase_fort_loot_info, __verse_0xC218B7D2_Loot) == 0x000020, "Member 'FVerseAIBase_fort_loot_info::__verse_0xC218B7D2_Loot' has a wrong offset!");

// VerseStruct VerseAIBase.VerseAIBase_fort_obstacle_info
// 0x0028 (0x0028 - 0x0000)
struct FVerseAIBase_fort_obstacle_info final
{
public:
	struct FSpatialMath_vector3                   __verse_0xB0C27E0A_Location;                       // 0x0000(0x0018)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	EVerseAIBase_fort_obstacle_status             __verse_0xFA60180E_Status;                         // 0x0018(0x0001)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerseEngine_Entity_entity*             __verse_0x82A44C52_Obstacle;                       // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash)
};
static_assert(alignof(FVerseAIBase_fort_obstacle_info) == 0x000008, "Wrong alignment on FVerseAIBase_fort_obstacle_info");
static_assert(sizeof(FVerseAIBase_fort_obstacle_info) == 0x000028, "Wrong size on FVerseAIBase_fort_obstacle_info");
static_assert(offsetof(FVerseAIBase_fort_obstacle_info, __verse_0xB0C27E0A_Location) == 0x000000, "Member 'FVerseAIBase_fort_obstacle_info::__verse_0xB0C27E0A_Location' has a wrong offset!");
static_assert(offsetof(FVerseAIBase_fort_obstacle_info, __verse_0xFA60180E_Status) == 0x000018, "Member 'FVerseAIBase_fort_obstacle_info::__verse_0xFA60180E_Status' has a wrong offset!");
static_assert(offsetof(FVerseAIBase_fort_obstacle_info, __verse_0x82A44C52_Obstacle) == 0x000020, "Member 'FVerseAIBase_fort_obstacle_info::__verse_0x82A44C52_Obstacle' has a wrong offset!");

// VerseStruct VerseAIBase.VerseAIBase_fort_weapon_descriptor
// 0x0018 (0x0018 - 0x0000)
struct FVerseAIBase_fort_weapon_descriptor final
{
public:
	int64                                         __verse_0xB3780369_TotalAmmo;                      // 0x0000(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int64                                         __verse_0xAEE6FE8C_LoadedAmmo;                     // 0x0008(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        __verse_0x40EB5EBF_MaxRange;                       // 0x0010(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(FVerseAIBase_fort_weapon_descriptor) == 0x000008, "Wrong alignment on FVerseAIBase_fort_weapon_descriptor");
static_assert(sizeof(FVerseAIBase_fort_weapon_descriptor) == 0x000018, "Wrong size on FVerseAIBase_fort_weapon_descriptor");
static_assert(offsetof(FVerseAIBase_fort_weapon_descriptor, __verse_0xB3780369_TotalAmmo) == 0x000000, "Member 'FVerseAIBase_fort_weapon_descriptor::__verse_0xB3780369_TotalAmmo' has a wrong offset!");
static_assert(offsetof(FVerseAIBase_fort_weapon_descriptor, __verse_0xAEE6FE8C_LoadedAmmo) == 0x000008, "Member 'FVerseAIBase_fort_weapon_descriptor::__verse_0xAEE6FE8C_LoadedAmmo' has a wrong offset!");
static_assert(offsetof(FVerseAIBase_fort_weapon_descriptor, __verse_0x40EB5EBF_MaxRange) == 0x000010, "Member 'FVerseAIBase_fort_weapon_descriptor::__verse_0x40EB5EBF_MaxRange' has a wrong offset!");

}

