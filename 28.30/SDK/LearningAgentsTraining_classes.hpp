#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LearningAgentsTraining

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "LearningAgents_classes.hpp"
#include "Engine_classes.hpp"
#include "LearningAgentsTraining_structs.hpp"


namespace SDK
{

// Class LearningAgentsTraining.LearningAgentsCompletion
// 0x0118 (0x0140 - 0x0028)
class ULearningAgentsCompletion : public UObject
{
public:
	class ULearningAgentsTrainer*                 AgentTrainer;                                      // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LearningAgentsCompletion">();
	}
	static class ULearningAgentsCompletion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULearningAgentsCompletion>();
	}
};
static_assert(alignof(ULearningAgentsCompletion) == 0x000008, "Wrong alignment on ULearningAgentsCompletion");
static_assert(sizeof(ULearningAgentsCompletion) == 0x000140, "Wrong size on ULearningAgentsCompletion");
static_assert(offsetof(ULearningAgentsCompletion, AgentTrainer) == 0x000028, "Member 'ULearningAgentsCompletion::AgentTrainer' has a wrong offset!");

// Class LearningAgentsTraining.ConditionalCompletion
// 0x0010 (0x0150 - 0x0140)
class UConditionalCompletion final : public ULearningAgentsCompletion
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UConditionalCompletion* AddConditionalCompletion(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const ELearningAgentsCompletion InCompletionMode);

	void SetConditionalCompletion(const int32 AgentId, const bool bIsCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalCompletion">();
	}
	static class UConditionalCompletion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalCompletion>();
	}
};
static_assert(alignof(UConditionalCompletion) == 0x000008, "Wrong alignment on UConditionalCompletion");
static_assert(sizeof(UConditionalCompletion) == 0x000150, "Wrong size on UConditionalCompletion");

// Class LearningAgentsTraining.TimeElapsedCompletion
// 0x0010 (0x0150 - 0x0140)
class UTimeElapsedCompletion final : public ULearningAgentsCompletion
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTimeElapsedCompletion* AddTimeElapsedCompletion(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const float Threshold, const ELearningAgentsCompletion InCompletionMode);

	void SetTimeElapsedCompletion(const int32 AgentId, const float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeElapsedCompletion">();
	}
	static class UTimeElapsedCompletion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeElapsedCompletion>();
	}
};
static_assert(alignof(UTimeElapsedCompletion) == 0x000008, "Wrong alignment on UTimeElapsedCompletion");
static_assert(sizeof(UTimeElapsedCompletion) == 0x000150, "Wrong size on UTimeElapsedCompletion");

// Class LearningAgentsTraining.PlanarPositionDifferenceCompletion
// 0x0010 (0x0150 - 0x0140)
class UPlanarPositionDifferenceCompletion final : public ULearningAgentsCompletion
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlanarPositionDifferenceCompletion* AddPlanarPositionDifferenceCompletion(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const float Threshold, const ELearningAgentsCompletion InCompletionMode, const struct FVector& Axis0, const struct FVector& Axis1);

	void SetPlanarPositionDifferenceCompletion(const int32 AgentId, const struct FVector& Position0, const struct FVector& Position1);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanarPositionDifferenceCompletion">();
	}
	static class UPlanarPositionDifferenceCompletion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlanarPositionDifferenceCompletion>();
	}
};
static_assert(alignof(UPlanarPositionDifferenceCompletion) == 0x000008, "Wrong alignment on UPlanarPositionDifferenceCompletion");
static_assert(sizeof(UPlanarPositionDifferenceCompletion) == 0x000150, "Wrong size on UPlanarPositionDifferenceCompletion");

// Class LearningAgentsTraining.PlanarPositionSimilarityCompletion
// 0x0010 (0x0150 - 0x0140)
class UPlanarPositionSimilarityCompletion final : public ULearningAgentsCompletion
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlanarPositionSimilarityCompletion* AddPlanarPositionSimilarityCompletion(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const float Threshold, const ELearningAgentsCompletion InCompletionMode, const struct FVector& Axis0, const struct FVector& Axis1);

	void SetPlanarPositionSimilarityCompletion(const int32 AgentId, const struct FVector& Position0, const struct FVector& Position1);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanarPositionSimilarityCompletion">();
	}
	static class UPlanarPositionSimilarityCompletion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlanarPositionSimilarityCompletion>();
	}
};
static_assert(alignof(UPlanarPositionSimilarityCompletion) == 0x000008, "Wrong alignment on UPlanarPositionSimilarityCompletion");
static_assert(sizeof(UPlanarPositionSimilarityCompletion) == 0x000150, "Wrong size on UPlanarPositionSimilarityCompletion");

// Class LearningAgentsTraining.LearningAgentsImitationTrainer
// 0x0058 (0x00F8 - 0x00A0)
class ULearningAgentsImitationTrainer final : public UActorComponent
{
public:
	class ULearningAgentsPolicy*                  Policy;                                            // 0x00A0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTraining;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasTrainingFailed;                                // 0x00A9(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA[0x4E];                                      // 0x00AA(0x004E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginTraining(class ULearningAgentsPolicy* InPolicy, const class ULearningAgentsRecording* Recording, const struct FLearningAgentsImitationTrainerSettings& ImitationTrainerSettings, const struct FLearningAgentsImitationTrainerTrainingSettings& ImitationTrainerTrainingSettings, const struct FLearningAgentsTrainerPathSettings& ImitationTrainerPathSettings, const bool bReinitializePolicyNetwork);
	void EndTraining();
	void IterateTraining();
	void RunTraining(class ULearningAgentsPolicy* InPolicy, const class ULearningAgentsRecording* Recording, const struct FLearningAgentsImitationTrainerSettings& ImitationTrainerSettings, const struct FLearningAgentsImitationTrainerTrainingSettings& ImitationTrainerTrainingSettings, const struct FLearningAgentsTrainerPathSettings& ImitationTrainerPathSettings, const bool bReinitializePolicyNetwork);

	bool HasTrainingFailed() const;
	bool IsTraining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LearningAgentsImitationTrainer">();
	}
	static class ULearningAgentsImitationTrainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULearningAgentsImitationTrainer>();
	}
};
static_assert(alignof(ULearningAgentsImitationTrainer) == 0x000008, "Wrong alignment on ULearningAgentsImitationTrainer");
static_assert(sizeof(ULearningAgentsImitationTrainer) == 0x0000F8, "Wrong size on ULearningAgentsImitationTrainer");
static_assert(offsetof(ULearningAgentsImitationTrainer, Policy) == 0x0000A0, "Member 'ULearningAgentsImitationTrainer::Policy' has a wrong offset!");
static_assert(offsetof(ULearningAgentsImitationTrainer, bIsTraining) == 0x0000A8, "Member 'ULearningAgentsImitationTrainer::bIsTraining' has a wrong offset!");
static_assert(offsetof(ULearningAgentsImitationTrainer, bHasTrainingFailed) == 0x0000A9, "Member 'ULearningAgentsImitationTrainer::bHasTrainingFailed' has a wrong offset!");

// Class LearningAgentsTraining.LearningAgentsRecorder
// 0x4538 (0x45F8 - 0x00C0)
class ULearningAgentsRecorder final : public ULearningAgentsManagerComponent
{
public:
	class ULearningAgentsInteractor*              Interactor;                                        // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULearningAgentsRecording*               Recording;                                         // 0x00C8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRecording;                                      // 0x00D0(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x4527];                                    // 0x00D1(0x4527)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExperience();
	void AppendRecordingFromFile(const struct FFilePath& File);
	void AppendRecordingToAsset(class ULearningAgentsRecording* RecordingAsset);
	void BeginRecording(bool bReinitializeRecording);
	void EndRecording();
	void LoadRecordingFromAsset(class ULearningAgentsRecording* RecordingAsset);
	void LoadRecordingFromFile(const struct FFilePath& File);
	void SaveRecordingToAsset(class ULearningAgentsRecording* RecordingAsset);
	void SetupRecorder(class ULearningAgentsInteractor* InInteractor, const struct FLearningAgentsRecorderPathSettings& RecorderPathSettings, class ULearningAgentsRecording* RecordingAsset);
	void UseRecordingAsset(class ULearningAgentsRecording* RecordingAsset);

	const class ULearningAgentsRecording* GetCurrentRecording() const;
	bool IsRecording() const;
	void SaveRecordingToFile(const struct FFilePath& File) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LearningAgentsRecorder">();
	}
	static class ULearningAgentsRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULearningAgentsRecorder>();
	}
};
static_assert(alignof(ULearningAgentsRecorder) == 0x000008, "Wrong alignment on ULearningAgentsRecorder");
static_assert(sizeof(ULearningAgentsRecorder) == 0x0045F8, "Wrong size on ULearningAgentsRecorder");
static_assert(offsetof(ULearningAgentsRecorder, Interactor) == 0x0000C0, "Member 'ULearningAgentsRecorder::Interactor' has a wrong offset!");
static_assert(offsetof(ULearningAgentsRecorder, Recording) == 0x0000C8, "Member 'ULearningAgentsRecorder::Recording' has a wrong offset!");
static_assert(offsetof(ULearningAgentsRecorder, bIsRecording) == 0x0000D0, "Member 'ULearningAgentsRecorder::bIsRecording' has a wrong offset!");

// Class LearningAgentsTraining.LearningAgentsRecording
// 0x0010 (0x0040 - 0x0030)
class ULearningAgentsRecording final : public UDataAsset
{
public:
	TArray<struct FLearningAgentsRecord>          Records;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	void AppendRecordingFromFile(const struct FFilePath& File);
	void AppendRecordingToAsset(class ULearningAgentsRecording* RecordingAsset);
	void LoadRecordingFromAsset(class ULearningAgentsRecording* RecordingAsset);
	void LoadRecordingFromFile(const struct FFilePath& File);
	void SaveRecordingToAsset(class ULearningAgentsRecording* RecordingAsset);

	void SaveRecordingToFile(const struct FFilePath& File) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LearningAgentsRecording">();
	}
	static class ULearningAgentsRecording* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULearningAgentsRecording>();
	}
};
static_assert(alignof(ULearningAgentsRecording) == 0x000008, "Wrong alignment on ULearningAgentsRecording");
static_assert(sizeof(ULearningAgentsRecording) == 0x000040, "Wrong size on ULearningAgentsRecording");
static_assert(offsetof(ULearningAgentsRecording, Records) == 0x000030, "Member 'ULearningAgentsRecording::Records' has a wrong offset!");

// Class LearningAgentsTraining.LearningAgentsReward
// 0x0118 (0x0140 - 0x0028)
class ULearningAgentsReward : public UObject
{
public:
	class ULearningAgentsTrainer*                 AgentTrainer;                                      // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LearningAgentsReward">();
	}
	static class ULearningAgentsReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULearningAgentsReward>();
	}
};
static_assert(alignof(ULearningAgentsReward) == 0x000008, "Wrong alignment on ULearningAgentsReward");
static_assert(sizeof(ULearningAgentsReward) == 0x000140, "Wrong size on ULearningAgentsReward");
static_assert(offsetof(ULearningAgentsReward, AgentTrainer) == 0x000028, "Member 'ULearningAgentsReward::AgentTrainer' has a wrong offset!");

// Class LearningAgentsTraining.FloatReward
// 0x0010 (0x0150 - 0x0140)
class UFloatReward final : public ULearningAgentsReward
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFloatReward* AddFloatReward(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const float Weight);

	void SetFloatReward(const int32 AgentId, const float Reward);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatReward">();
	}
	static class UFloatReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatReward>();
	}
};
static_assert(alignof(UFloatReward) == 0x000008, "Wrong alignment on UFloatReward");
static_assert(sizeof(UFloatReward) == 0x000150, "Wrong size on UFloatReward");

// Class LearningAgentsTraining.ConditionalReward
// 0x0010 (0x0150 - 0x0140)
class UConditionalReward final : public ULearningAgentsReward
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UConditionalReward* AddConditionalReward(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const float Value);

	void SetConditionalReward(const int32 AgentId, const bool bCondition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalReward">();
	}
	static class UConditionalReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalReward>();
	}
};
static_assert(alignof(UConditionalReward) == 0x000008, "Wrong alignment on UConditionalReward");
static_assert(sizeof(UConditionalReward) == 0x000150, "Wrong size on UConditionalReward");

// Class LearningAgentsTraining.ScalarVelocityReward
// 0x0010 (0x0150 - 0x0140)
class UScalarVelocityReward final : public ULearningAgentsReward
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UScalarVelocityReward* AddScalarVelocityReward(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const float Weight, const float Scale);

	void SetScalarVelocityReward(const int32 AgentId, const float Velocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScalarVelocityReward">();
	}
	static class UScalarVelocityReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScalarVelocityReward>();
	}
};
static_assert(alignof(UScalarVelocityReward) == 0x000008, "Wrong alignment on UScalarVelocityReward");
static_assert(sizeof(UScalarVelocityReward) == 0x000150, "Wrong size on UScalarVelocityReward");

// Class LearningAgentsTraining.LocalDirectionalVelocityReward
// 0x0010 (0x0150 - 0x0140)
class ULocalDirectionalVelocityReward final : public ULearningAgentsReward
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULocalDirectionalVelocityReward* AddLocalDirectionalVelocityReward(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const float Weight, const float Scale, const struct FVector& Axis);

	void SetLocalDirectionalVelocityReward(const int32 AgentId, const struct FVector& Velocity, const struct FRotator& RelativeRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalDirectionalVelocityReward">();
	}
	static class ULocalDirectionalVelocityReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalDirectionalVelocityReward>();
	}
};
static_assert(alignof(ULocalDirectionalVelocityReward) == 0x000008, "Wrong alignment on ULocalDirectionalVelocityReward");
static_assert(sizeof(ULocalDirectionalVelocityReward) == 0x000150, "Wrong size on ULocalDirectionalVelocityReward");

// Class LearningAgentsTraining.PlanarPositionDifferencePenalty
// 0x0010 (0x0150 - 0x0140)
class UPlanarPositionDifferencePenalty final : public ULearningAgentsReward
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlanarPositionDifferencePenalty* AddPlanarPositionDifferencePenalty(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const float Weight, const float Scale, const float Threshold, const struct FVector& Axis0, const struct FVector& Axis1);

	void SetPlanarPositionDifferencePenalty(const int32 AgentId, const struct FVector& Position0, const struct FVector& Position1);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanarPositionDifferencePenalty">();
	}
	static class UPlanarPositionDifferencePenalty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlanarPositionDifferencePenalty>();
	}
};
static_assert(alignof(UPlanarPositionDifferencePenalty) == 0x000008, "Wrong alignment on UPlanarPositionDifferencePenalty");
static_assert(sizeof(UPlanarPositionDifferencePenalty) == 0x000150, "Wrong size on UPlanarPositionDifferencePenalty");

// Class LearningAgentsTraining.PositionArraySimilarityReward
// 0x0010 (0x0150 - 0x0140)
class UPositionArraySimilarityReward final : public ULearningAgentsReward
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPositionArraySimilarityReward* AddPositionArraySimilarityReward(class ULearningAgentsTrainer* InAgentTrainer, const class FName Name_0, const int32 PositionNum, const float Scale, const float Weight);

	void SetPositionArraySimilarityReward(const int32 AgentId, const TArray<struct FVector>& Positions0, const TArray<struct FVector>& Positions1, const struct FVector& RelativePosition0, const struct FVector& RelativePosition1, const struct FRotator& RelativeRotation0, const struct FRotator& RelativeRotation1);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PositionArraySimilarityReward">();
	}
	static class UPositionArraySimilarityReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPositionArraySimilarityReward>();
	}
};
static_assert(alignof(UPositionArraySimilarityReward) == 0x000008, "Wrong alignment on UPositionArraySimilarityReward");
static_assert(sizeof(UPositionArraySimilarityReward) == 0x000150, "Wrong size on UPositionArraySimilarityReward");

// Class LearningAgentsTraining.LearningAgentsTrainer
// 0x05C0 (0x0680 - 0x00C0)
class ULearningAgentsTrainer final : public ULearningAgentsManagerComponent
{
public:
	class ULearningAgentsInteractor*              Interactor;                                        // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULearningAgentsPolicy*                  Policy;                                            // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULearningAgentsCritic*                  Critic;                                            // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTraining;                                       // 0x00D8(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasTrainingFailed;                                // 0x00D9(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULearningAgentsReward*>          RewardObjects;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULearningAgentsCompletion*>      CompletionObjects;                                 // 0x00F0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x580];                                    // 0x0100(0x0580)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginTraining(const struct FLearningAgentsTrainerTrainingSettings& TrainerTrainingSettings, const struct FLearningAgentsTrainerGameSettings& TrainerGameSettings, const struct FLearningAgentsTrainerPathSettings& TrainerPathSettings, const bool bReinitializePolicyNetwork, const bool bReinitializeCriticNetwork, const bool bResetAgentsOnBegin);
	void EndTraining();
	void EvaluateCompletions();
	void EvaluateRewards();
	void ProcessExperience();
	void ResetEpisodes(const TArray<int32>& AgentIds);
	void RunTraining(const struct FLearningAgentsTrainerTrainingSettings& TrainerTrainingSettings, const struct FLearningAgentsTrainerGameSettings& TrainerGameSettings, const struct FLearningAgentsTrainerPathSettings& TrainerPathSettings, const bool bReinitializePolicyNetwork, const bool bReinitializeCriticNetwork, const bool bResetAgentsOnBegin);
	void SetCompletions(const TArray<int32>& AgentIds);
	void SetRewards(const TArray<int32>& AgentIds);
	void SetupCompletions();
	void SetupRewards();
	void SetupTrainer(class ULearningAgentsInteractor* InInteractor, class ULearningAgentsPolicy* InPolicy, class ULearningAgentsCritic* InCritic, const struct FLearningAgentsTrainerSettings& TrainerSettings);

	float GetReward(const int32 AgentId) const;
	bool HasTrainingFailed() const;
	bool IsCompleted(const int32 AgentId, ELearningAgentsCompletion* OutCompletion) const;
	const bool IsTraining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LearningAgentsTrainer">();
	}
	static class ULearningAgentsTrainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULearningAgentsTrainer>();
	}
};
static_assert(alignof(ULearningAgentsTrainer) == 0x000008, "Wrong alignment on ULearningAgentsTrainer");
static_assert(sizeof(ULearningAgentsTrainer) == 0x000680, "Wrong size on ULearningAgentsTrainer");
static_assert(offsetof(ULearningAgentsTrainer, Interactor) == 0x0000C0, "Member 'ULearningAgentsTrainer::Interactor' has a wrong offset!");
static_assert(offsetof(ULearningAgentsTrainer, Policy) == 0x0000C8, "Member 'ULearningAgentsTrainer::Policy' has a wrong offset!");
static_assert(offsetof(ULearningAgentsTrainer, Critic) == 0x0000D0, "Member 'ULearningAgentsTrainer::Critic' has a wrong offset!");
static_assert(offsetof(ULearningAgentsTrainer, bIsTraining) == 0x0000D8, "Member 'ULearningAgentsTrainer::bIsTraining' has a wrong offset!");
static_assert(offsetof(ULearningAgentsTrainer, bHasTrainingFailed) == 0x0000D9, "Member 'ULearningAgentsTrainer::bHasTrainingFailed' has a wrong offset!");
static_assert(offsetof(ULearningAgentsTrainer, RewardObjects) == 0x0000E0, "Member 'ULearningAgentsTrainer::RewardObjects' has a wrong offset!");
static_assert(offsetof(ULearningAgentsTrainer, CompletionObjects) == 0x0000F0, "Member 'ULearningAgentsTrainer::CompletionObjects' has a wrong offset!");

}

