#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FMDeviceCablesRuntime

#include "Basic.hpp"

#include "FortniteGame_classes.hpp"
#include "FMDeviceCablesRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "GameplayEventRouter_structs.hpp"


namespace SDK
{

// Class FMDeviceCablesRuntime.FMDeviceCableAnimatorBase
// 0x00C0 (0x00E8 - 0x0028)
class UFMDeviceCableAnimatorBase : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UFMDeviceCablePortComponent> OwnerPort;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x68];                                      // 0x0080(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMaterialInstance(class UMaterialInstanceDynamic* InMaterialInstance);
	void OnConnectionEnded(class UFMDeviceCableConnectionBase* EndedConnection);
	void OnConnectionStarted(class UFMDeviceCableConnectionBase* NewConnection);
	void OnPortArtifactUpdated();
	void ReceiveTick(float DeltaSeconds);
	void RemoveMaterialInstance(class UMaterialInstanceDynamic* InMaterialInstance);
	void SetOwnerPort(class UFMDeviceCablePortComponent* OwnerPort_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableAnimatorBase">();
	}
	static class UFMDeviceCableAnimatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableAnimatorBase>();
	}
};
static_assert(alignof(UFMDeviceCableAnimatorBase) == 0x000008, "Wrong alignment on UFMDeviceCableAnimatorBase");
static_assert(sizeof(UFMDeviceCableAnimatorBase) == 0x0000E8, "Wrong size on UFMDeviceCableAnimatorBase");
static_assert(offsetof(UFMDeviceCableAnimatorBase, OwnerPort) == 0x000078, "Member 'UFMDeviceCableAnimatorBase::OwnerPort' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableAnimatorAudioAnalyzer
// 0x0080 (0x0168 - 0x00E8)
class UFMDeviceCableAnimatorAudioAnalyzer final : public UFMDeviceCableAnimatorBase
{
public:
	class FName                                   FftTextureParam;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WaveformTextureParam;                              // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AmplitudeTextureParam;                             // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AmplitudeDataParam;                                // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CableQualityParam;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CableReactivityParam;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WaveformNumSamplesHeld;                            // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WaveformSmoothingDistance;                         // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaveformSmoothingFactor;                           // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaveformDecayPerSecond;                            // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WaveformTexture;                                   // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             AmplitudeTexture;                                  // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFabricMetaSoundPatchWrapper*           PatchWrapper;                                      // 0x0120(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x40];                                     // 0x0128(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMetaSoundOutputFloatChangedBatch(const class FName& OutputName, TArray<float>* Output, struct FFabricMetaSoundPatchWrapperPeakTamer* PeakTamer, float DeltaSeconds);
	void SetAnalyzerName(class FName AnalyzerName);

	float GetLastAnalyzerValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableAnimatorAudioAnalyzer">();
	}
	static class UFMDeviceCableAnimatorAudioAnalyzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableAnimatorAudioAnalyzer>();
	}
};
static_assert(alignof(UFMDeviceCableAnimatorAudioAnalyzer) == 0x000008, "Wrong alignment on UFMDeviceCableAnimatorAudioAnalyzer");
static_assert(sizeof(UFMDeviceCableAnimatorAudioAnalyzer) == 0x000168, "Wrong size on UFMDeviceCableAnimatorAudioAnalyzer");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, FftTextureParam) == 0x0000E8, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::FftTextureParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, WaveformTextureParam) == 0x0000EC, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::WaveformTextureParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, AmplitudeTextureParam) == 0x0000F0, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::AmplitudeTextureParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, AmplitudeDataParam) == 0x0000F4, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::AmplitudeDataParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, CableQualityParam) == 0x0000F8, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::CableQualityParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, CableReactivityParam) == 0x0000FC, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::CableReactivityParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, WaveformNumSamplesHeld) == 0x000100, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::WaveformNumSamplesHeld' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, WaveformSmoothingDistance) == 0x000104, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::WaveformSmoothingDistance' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, WaveformSmoothingFactor) == 0x000108, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::WaveformSmoothingFactor' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, WaveformDecayPerSecond) == 0x00010C, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::WaveformDecayPerSecond' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, WaveformTexture) == 0x000110, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::WaveformTexture' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, AmplitudeTexture) == 0x000118, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::AmplitudeTexture' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorAudioAnalyzer, PatchWrapper) == 0x000120, "Member 'UFMDeviceCableAnimatorAudioAnalyzer::PatchWrapper' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCable
// 0x01D8 (0x08F0 - 0x0718)
class AFMDeviceCable final : public ABuildingActor
{
public:
	uint8                                         Pad_718[0x18];                                     // 0x0718(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x0730(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DeviceCableHead;                                   // 0x0738(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USplineMeshComponent>       SplineMeshComponentClass;                          // 0x0740(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             ScalarStaticMesh;                                  // 0x0748(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             AudioStaticMesh;                                   // 0x0768(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             NoteStaticMesh;                                    // 0x0788(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             TextureStaticMesh;                                 // 0x07A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             MeshStaticMesh;                                    // 0x07C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SplineLengthParam;                                 // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SplineStartParam;                                  // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SplineEndParam;                                    // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PortTypeParam;                                     // 0x07F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CableStubLength;                                   // 0x07F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CableDistanceFromPortB;                            // 0x07FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CableMinTangent;                                   // 0x0800(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CableMaxTangent;                                   // 0x0804(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CableSectionLengthAtCableCenter;                   // 0x0808(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CableSectionLengthAtCableHeads;                    // 0x080C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CableSectionCountAtCableHeads;                     // 0x0810(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CableCenterSectionsMaxCount;                       // 0x0814(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtremeMinDotProduct;                              // 0x0818(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxExtremeCableBendSize;                           // 0x081C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtremeAngleTangentScale;                          // 0x0820(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_824[0x4];                                      // 0x0824(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USplineMeshComponent*>           CableSplineMeshArray;                              // 0x0828(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UFMDeviceCableAnimatorBase> DeviceCableAnimator;                               // 0x0838(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DeviceCableMaterial;                               // 0x0840(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DeviceCableHeadMaterial;                           // 0x0848(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_850[0x10];                                     // 0x0850(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMDeviceCablePortComponent*            ConstantPort;                                      // 0x0860(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMDeviceCablePortComponent*            PortA;                                             // 0x0868(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMDeviceCablePortComponent*            ServerPortA;                                       // 0x0870(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMDeviceCablePortComponent*            PortB;                                             // 0x0878(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMDeviceCablePortComponent*            ServerPortB;                                       // 0x0880(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_888[0x68];                                     // 0x0888(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildMeshOnSpline(bool bCollisionEnabled);
	void ConnectConstantPort(class UFMDeviceCablePortComponent* Port);
	void ConnectPort(class UFMDeviceCablePortComponent* Port);
	void Disconnect();
	void OnCableConnected(bool bThroughReplication);
	void OnCableDisconnected(bool bThroughReplication);
	void OnCableGrabbed(bool bThroughReplication);
	void OnCableReturned();
	void OnRep_ServerPortA();
	void OnRep_ServerPortB();
	void OnScalesUpdated(const struct FVector& StartScale, const struct FVector& EndScale);
	void OnSplineUpdated(bool bCollisionEnabled);
	void SetFocusedVisuals(bool bIsFocused);
	void UpdateDeviceCableAnimator();
	void UpdateVisualParameters();

	EDeviceCablePortDataType GetCableDataType() const;
	class USplineComponent* GetCableSpline() const;
	class UFMDeviceCablePortComponent* GetConstantPort() const;
	class UStaticMeshComponent* GetDeviceCableHead() const;
	class UFMDeviceCablePortComponent* GetPortA() const;
	class UFMDeviceCablePortComponent* GetPortB() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCable">();
	}
	static class AFMDeviceCable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFMDeviceCable>();
	}
};
static_assert(alignof(AFMDeviceCable) == 0x000008, "Wrong alignment on AFMDeviceCable");
static_assert(sizeof(AFMDeviceCable) == 0x0008F0, "Wrong size on AFMDeviceCable");
static_assert(offsetof(AFMDeviceCable, SplineComponent) == 0x000730, "Member 'AFMDeviceCable::SplineComponent' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, DeviceCableHead) == 0x000738, "Member 'AFMDeviceCable::DeviceCableHead' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, SplineMeshComponentClass) == 0x000740, "Member 'AFMDeviceCable::SplineMeshComponentClass' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, ScalarStaticMesh) == 0x000748, "Member 'AFMDeviceCable::ScalarStaticMesh' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, AudioStaticMesh) == 0x000768, "Member 'AFMDeviceCable::AudioStaticMesh' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, NoteStaticMesh) == 0x000788, "Member 'AFMDeviceCable::NoteStaticMesh' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, TextureStaticMesh) == 0x0007A8, "Member 'AFMDeviceCable::TextureStaticMesh' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, MeshStaticMesh) == 0x0007C8, "Member 'AFMDeviceCable::MeshStaticMesh' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, SplineLengthParam) == 0x0007E8, "Member 'AFMDeviceCable::SplineLengthParam' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, SplineStartParam) == 0x0007EC, "Member 'AFMDeviceCable::SplineStartParam' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, SplineEndParam) == 0x0007F0, "Member 'AFMDeviceCable::SplineEndParam' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, PortTypeParam) == 0x0007F4, "Member 'AFMDeviceCable::PortTypeParam' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableStubLength) == 0x0007F8, "Member 'AFMDeviceCable::CableStubLength' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableDistanceFromPortB) == 0x0007FC, "Member 'AFMDeviceCable::CableDistanceFromPortB' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableMinTangent) == 0x000800, "Member 'AFMDeviceCable::CableMinTangent' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableMaxTangent) == 0x000804, "Member 'AFMDeviceCable::CableMaxTangent' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableSectionLengthAtCableCenter) == 0x000808, "Member 'AFMDeviceCable::CableSectionLengthAtCableCenter' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableSectionLengthAtCableHeads) == 0x00080C, "Member 'AFMDeviceCable::CableSectionLengthAtCableHeads' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableSectionCountAtCableHeads) == 0x000810, "Member 'AFMDeviceCable::CableSectionCountAtCableHeads' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableCenterSectionsMaxCount) == 0x000814, "Member 'AFMDeviceCable::CableCenterSectionsMaxCount' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, ExtremeMinDotProduct) == 0x000818, "Member 'AFMDeviceCable::ExtremeMinDotProduct' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, MaxExtremeCableBendSize) == 0x00081C, "Member 'AFMDeviceCable::MaxExtremeCableBendSize' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, ExtremeAngleTangentScale) == 0x000820, "Member 'AFMDeviceCable::ExtremeAngleTangentScale' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, CableSplineMeshArray) == 0x000828, "Member 'AFMDeviceCable::CableSplineMeshArray' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, DeviceCableAnimator) == 0x000838, "Member 'AFMDeviceCable::DeviceCableAnimator' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, DeviceCableMaterial) == 0x000840, "Member 'AFMDeviceCable::DeviceCableMaterial' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, DeviceCableHeadMaterial) == 0x000848, "Member 'AFMDeviceCable::DeviceCableHeadMaterial' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, ConstantPort) == 0x000860, "Member 'AFMDeviceCable::ConstantPort' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, PortA) == 0x000868, "Member 'AFMDeviceCable::PortA' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, ServerPortA) == 0x000870, "Member 'AFMDeviceCable::ServerPortA' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, PortB) == 0x000878, "Member 'AFMDeviceCable::PortB' has a wrong offset!");
static_assert(offsetof(AFMDeviceCable, ServerPortB) == 0x000880, "Member 'AFMDeviceCable::ServerPortB' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableAnimatorTickSubsystem
// 0x0050 (0x0120 - 0x00D0)
class UFMDeviceCableAnimatorTickSubsystem final : public UFortManagedTickSubsystem
{
public:
	uint8                                         Pad_D0[0x50];                                      // 0x00D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableAnimatorTickSubsystem">();
	}
	static class UFMDeviceCableAnimatorTickSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableAnimatorTickSubsystem>();
	}
};
static_assert(alignof(UFMDeviceCableAnimatorTickSubsystem) == 0x000008, "Wrong alignment on UFMDeviceCableAnimatorTickSubsystem");
static_assert(sizeof(UFMDeviceCableAnimatorTickSubsystem) == 0x000120, "Wrong size on UFMDeviceCableAnimatorTickSubsystem");

// Class FMDeviceCablesRuntime.FMDeviceCableAnimatorMidiEvent
// 0x00A8 (0x0190 - 0x00E8)
class UFMDeviceCableAnimatorMidiEvent final : public UFMDeviceCableAnimatorBase
{
public:
	class FName                                   NoteTextureParam;                                  // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            NoteShapeCurve;                                    // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotePercentOfTexture;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoteTravelBeats;                                   // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoteStartDelayBeats;                               // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x14];                                     // 0x0104(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             NoteTexture;                                       // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFabricMetaSoundPatchWrapper*           PatchWrapper;                                      // 0x0120(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x68];                                     // 0x0128(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMetaSoundOutputIntChangedBatch(const class FName& OutputName, const TArray<int32>& Output);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableAnimatorMidiEvent">();
	}
	static class UFMDeviceCableAnimatorMidiEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableAnimatorMidiEvent>();
	}
};
static_assert(alignof(UFMDeviceCableAnimatorMidiEvent) == 0x000008, "Wrong alignment on UFMDeviceCableAnimatorMidiEvent");
static_assert(sizeof(UFMDeviceCableAnimatorMidiEvent) == 0x000190, "Wrong size on UFMDeviceCableAnimatorMidiEvent");
static_assert(offsetof(UFMDeviceCableAnimatorMidiEvent, NoteTextureParam) == 0x0000E8, "Member 'UFMDeviceCableAnimatorMidiEvent::NoteTextureParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorMidiEvent, NoteShapeCurve) == 0x0000F0, "Member 'UFMDeviceCableAnimatorMidiEvent::NoteShapeCurve' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorMidiEvent, NotePercentOfTexture) == 0x0000F8, "Member 'UFMDeviceCableAnimatorMidiEvent::NotePercentOfTexture' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorMidiEvent, NoteTravelBeats) == 0x0000FC, "Member 'UFMDeviceCableAnimatorMidiEvent::NoteTravelBeats' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorMidiEvent, NoteStartDelayBeats) == 0x000100, "Member 'UFMDeviceCableAnimatorMidiEvent::NoteStartDelayBeats' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorMidiEvent, NoteTexture) == 0x000118, "Member 'UFMDeviceCableAnimatorMidiEvent::NoteTexture' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorMidiEvent, PatchWrapper) == 0x000120, "Member 'UFMDeviceCableAnimatorMidiEvent::PatchWrapper' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableAnimatorFloatProvider
// 0x0010 (0x00F8 - 0x00E8)
class UFMDeviceCableAnimatorFloatProvider final : public UFMDeviceCableAnimatorBase
{
public:
	class FName                                   CableDataParam;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FloatProviderTypeParam;                            // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFabricFloatProviderBase*               FloatProvider;                                     // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFloatChanged(float CurrentFloat);
	void SetFloatProvider(class UFabricFloatProviderBase* InFloatProvider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableAnimatorFloatProvider">();
	}
	static class UFMDeviceCableAnimatorFloatProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableAnimatorFloatProvider>();
	}
};
static_assert(alignof(UFMDeviceCableAnimatorFloatProvider) == 0x000008, "Wrong alignment on UFMDeviceCableAnimatorFloatProvider");
static_assert(sizeof(UFMDeviceCableAnimatorFloatProvider) == 0x0000F8, "Wrong size on UFMDeviceCableAnimatorFloatProvider");
static_assert(offsetof(UFMDeviceCableAnimatorFloatProvider, CableDataParam) == 0x0000E8, "Member 'UFMDeviceCableAnimatorFloatProvider::CableDataParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorFloatProvider, FloatProviderTypeParam) == 0x0000EC, "Member 'UFMDeviceCableAnimatorFloatProvider::FloatProviderTypeParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorFloatProvider, FloatProvider) == 0x0000F0, "Member 'UFMDeviceCableAnimatorFloatProvider::FloatProvider' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableAnimatorTextureProvider
// 0x0010 (0x00F8 - 0x00E8)
class UFMDeviceCableAnimatorTextureProvider final : public UFMDeviceCableAnimatorBase
{
public:
	class FName                                   CableDataParam;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecayRate;                                         // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFabricTextureProviderBase*             TextureProvider;                                   // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetTextureProvider(class UFabricTextureProviderBase* InTextureProvider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableAnimatorTextureProvider">();
	}
	static class UFMDeviceCableAnimatorTextureProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableAnimatorTextureProvider>();
	}
};
static_assert(alignof(UFMDeviceCableAnimatorTextureProvider) == 0x000008, "Wrong alignment on UFMDeviceCableAnimatorTextureProvider");
static_assert(sizeof(UFMDeviceCableAnimatorTextureProvider) == 0x0000F8, "Wrong size on UFMDeviceCableAnimatorTextureProvider");
static_assert(offsetof(UFMDeviceCableAnimatorTextureProvider, CableDataParam) == 0x0000E8, "Member 'UFMDeviceCableAnimatorTextureProvider::CableDataParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorTextureProvider, DecayRate) == 0x0000EC, "Member 'UFMDeviceCableAnimatorTextureProvider::DecayRate' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorTextureProvider, TextureProvider) == 0x0000F0, "Member 'UFMDeviceCableAnimatorTextureProvider::TextureProvider' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableAnimatorMeshProvider
// 0x0010 (0x00F8 - 0x00E8)
class UFMDeviceCableAnimatorMeshProvider final : public UFMDeviceCableAnimatorBase
{
public:
	class FName                                   CableDataParam;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecayRate;                                         // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFabricMeshProviderBase*                MeshProvider;                                      // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetMeshProvider(class UFabricMeshProviderBase* InMeshProvider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableAnimatorMeshProvider">();
	}
	static class UFMDeviceCableAnimatorMeshProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableAnimatorMeshProvider>();
	}
};
static_assert(alignof(UFMDeviceCableAnimatorMeshProvider) == 0x000008, "Wrong alignment on UFMDeviceCableAnimatorMeshProvider");
static_assert(sizeof(UFMDeviceCableAnimatorMeshProvider) == 0x0000F8, "Wrong size on UFMDeviceCableAnimatorMeshProvider");
static_assert(offsetof(UFMDeviceCableAnimatorMeshProvider, CableDataParam) == 0x0000E8, "Member 'UFMDeviceCableAnimatorMeshProvider::CableDataParam' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorMeshProvider, DecayRate) == 0x0000EC, "Member 'UFMDeviceCableAnimatorMeshProvider::DecayRate' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableAnimatorMeshProvider, MeshProvider) == 0x0000F0, "Member 'UFMDeviceCableAnimatorMeshProvider::MeshProvider' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableConnectionBase
// 0x00A8 (0x00D0 - 0x0028)
class UFMDeviceCableConnectionBase : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bConnectionActive;                                 // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UFMDeviceCablePortComponent>> BuildingCompositeArtifactFromPorts;                // 0x0088(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FFMDeviceCableConnectedDevicesInfo     ConnectedDevicesInfo;                              // 0x0098(0x0030)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FFMDeviceCableDefaultOutputs           DefaultOutputs;                                    // 0x00C8(0x0008)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void EndConnectionBP();
	void RebuildDirtyConnectionBP();
	void StartConnectionBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableConnectionBase">();
	}
	static class UFMDeviceCableConnectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableConnectionBase>();
	}
};
static_assert(alignof(UFMDeviceCableConnectionBase) == 0x000008, "Wrong alignment on UFMDeviceCableConnectionBase");
static_assert(sizeof(UFMDeviceCableConnectionBase) == 0x0000D0, "Wrong size on UFMDeviceCableConnectionBase");
static_assert(offsetof(UFMDeviceCableConnectionBase, bConnectionActive) == 0x000080, "Member 'UFMDeviceCableConnectionBase::bConnectionActive' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableConnectionBase, BuildingCompositeArtifactFromPorts) == 0x000088, "Member 'UFMDeviceCableConnectionBase::BuildingCompositeArtifactFromPorts' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableConnectionBase, ConnectedDevicesInfo) == 0x000098, "Member 'UFMDeviceCableConnectionBase::ConnectedDevicesInfo' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableConnectionBase, DefaultOutputs) == 0x0000C8, "Member 'UFMDeviceCableConnectionBase::DefaultOutputs' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableMetaSoundConnection
// 0x0000 (0x00D0 - 0x00D0)
class UFMDeviceCableMetaSoundConnection : public UFMDeviceCableConnectionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableMetaSoundConnection">();
	}
	static class UFMDeviceCableMetaSoundConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableMetaSoundConnection>();
	}
};
static_assert(alignof(UFMDeviceCableMetaSoundConnection) == 0x000008, "Wrong alignment on UFMDeviceCableMetaSoundConnection");
static_assert(sizeof(UFMDeviceCableMetaSoundConnection) == 0x0000D0, "Wrong size on UFMDeviceCableMetaSoundConnection");

// Class FMDeviceCablesRuntime.FMDeviceCableNoteConnection
// 0x0000 (0x00D0 - 0x00D0)
class UFMDeviceCableNoteConnection final : public UFMDeviceCableMetaSoundConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableNoteConnection">();
	}
	static class UFMDeviceCableNoteConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableNoteConnection>();
	}
};
static_assert(alignof(UFMDeviceCableNoteConnection) == 0x000008, "Wrong alignment on UFMDeviceCableNoteConnection");
static_assert(sizeof(UFMDeviceCableNoteConnection) == 0x0000D0, "Wrong size on UFMDeviceCableNoteConnection");

// Class FMDeviceCablesRuntime.FMDeviceCableAudioConnection
// 0x0000 (0x00D0 - 0x00D0)
class UFMDeviceCableAudioConnection final : public UFMDeviceCableMetaSoundConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableAudioConnection">();
	}
	static class UFMDeviceCableAudioConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableAudioConnection>();
	}
};
static_assert(alignof(UFMDeviceCableAudioConnection) == 0x000008, "Wrong alignment on UFMDeviceCableAudioConnection");
static_assert(sizeof(UFMDeviceCableAudioConnection) == 0x0000D0, "Wrong size on UFMDeviceCableAudioConnection");

// Class FMDeviceCablesRuntime.FMDeviceCableFloatConnection
// 0x0000 (0x00D0 - 0x00D0)
class UFMDeviceCableFloatConnection final : public UFMDeviceCableConnectionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableFloatConnection">();
	}
	static class UFMDeviceCableFloatConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableFloatConnection>();
	}
};
static_assert(alignof(UFMDeviceCableFloatConnection) == 0x000008, "Wrong alignment on UFMDeviceCableFloatConnection");
static_assert(sizeof(UFMDeviceCableFloatConnection) == 0x0000D0, "Wrong size on UFMDeviceCableFloatConnection");

// Class FMDeviceCablesRuntime.FMDeviceCableTextureConnection
// 0x0000 (0x00D0 - 0x00D0)
class UFMDeviceCableTextureConnection final : public UFMDeviceCableConnectionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableTextureConnection">();
	}
	static class UFMDeviceCableTextureConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableTextureConnection>();
	}
};
static_assert(alignof(UFMDeviceCableTextureConnection) == 0x000008, "Wrong alignment on UFMDeviceCableTextureConnection");
static_assert(sizeof(UFMDeviceCableTextureConnection) == 0x0000D0, "Wrong size on UFMDeviceCableTextureConnection");

// Class FMDeviceCablesRuntime.FMDeviceCableMeshConnection
// 0x0008 (0x00D8 - 0x00D0)
class UFMDeviceCableMeshConnection final : public UFMDeviceCableConnectionBase
{
public:
	uint32                                        PreviousMeshInstanceHash;                          // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableMeshConnection">();
	}
	static class UFMDeviceCableMeshConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableMeshConnection>();
	}
};
static_assert(alignof(UFMDeviceCableMeshConnection) == 0x000008, "Wrong alignment on UFMDeviceCableMeshConnection");
static_assert(sizeof(UFMDeviceCableMeshConnection) == 0x0000D8, "Wrong size on UFMDeviceCableMeshConnection");
static_assert(offsetof(UFMDeviceCableMeshConnection, PreviousMeshInstanceHash) == 0x0000D0, "Member 'UFMDeviceCableMeshConnection::PreviousMeshInstanceHash' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableControllerComponent
// 0x0060 (0x0100 - 0x00A0)
class UFMDeviceCableControllerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(TArray<class UFMDeviceCablePortComponent*>& ConnectedPorts)> OnControllerCableConnected;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnControllerCableDisconnected;                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ControllerCablePort;                               // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     DeviceCableManagerClass;                           // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerControllerAthena*            PlayerController;                                  // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMDeviceCablePortComponent*            LocalControllerPort;                               // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMDeviceCablePortComponent*            ServerControllerPort;                              // 0x00E0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  LocalControllerPortActor;                          // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMDeviceCableManagerComponent*         LocalDeviceCableManager;                           // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMDeviceCableManagerComponent*         ServerDeviceCableManager;                          // 0x00F8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DropCable();
	void OnCreativePlotLinkedVolumeChanged(class AFortVolume* FortVolume);
	void OnFortPawnChanged(class AFortPawn* Pawn);
	void OnNoFabricInteractablesHit();
	void OnRep_ServerControllerPort();
	void OnRep_ServerDeviceCableManager();
	void OnWeaponEquipped(class AFortWeapon* NewWeapon, class AFortWeapon* PrevWeapon);
	void SelectPort(class UFMDeviceCablePortComponent* SelectedPort);
	void ServerDisconnectController();
	void ServerPortActivatedStateChanged(class UFMDeviceCablePortComponent* Port, EDeviceCableActivatedState ActivatedState);
	void ServerPortsUpdated(const TArray<struct FPortUpdateInfo>& PortChangeInfos);
	void ServerSelectPort(class UFMDeviceCablePortComponent* SelectedPort);
	void ServerVolumeChanged();
	void SetControllerTargetForControllerPortBP(class AActor* ControllerPortActor, class APlayerController* Controller);

	bool IsCableConnectionValid(class UFMDeviceCablePortComponent* OtherPort) const;
	bool IsHoldingCable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableControllerComponent">();
	}
	static class UFMDeviceCableControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableControllerComponent>();
	}
};
static_assert(alignof(UFMDeviceCableControllerComponent) == 0x000008, "Wrong alignment on UFMDeviceCableControllerComponent");
static_assert(sizeof(UFMDeviceCableControllerComponent) == 0x000100, "Wrong size on UFMDeviceCableControllerComponent");
static_assert(offsetof(UFMDeviceCableControllerComponent, OnControllerCableConnected) == 0x0000A0, "Member 'UFMDeviceCableControllerComponent::OnControllerCableConnected' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, OnControllerCableDisconnected) == 0x0000B0, "Member 'UFMDeviceCableControllerComponent::OnControllerCableDisconnected' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, ControllerCablePort) == 0x0000C0, "Member 'UFMDeviceCableControllerComponent::ControllerCablePort' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, DeviceCableManagerClass) == 0x0000C8, "Member 'UFMDeviceCableControllerComponent::DeviceCableManagerClass' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, PlayerController) == 0x0000D0, "Member 'UFMDeviceCableControllerComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, LocalControllerPort) == 0x0000D8, "Member 'UFMDeviceCableControllerComponent::LocalControllerPort' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, ServerControllerPort) == 0x0000E0, "Member 'UFMDeviceCableControllerComponent::ServerControllerPort' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, LocalControllerPortActor) == 0x0000E8, "Member 'UFMDeviceCableControllerComponent::LocalControllerPortActor' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, LocalDeviceCableManager) == 0x0000F0, "Member 'UFMDeviceCableControllerComponent::LocalDeviceCableManager' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableControllerComponent, ServerDeviceCableManager) == 0x0000F8, "Member 'UFMDeviceCableControllerComponent::ServerDeviceCableManager' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableManagerComponent
// 0x0268 (0x0308 - 0x00A0)
class UFMDeviceCableManagerComponent final : public UActorComponent
{
public:
	TSubclassOf<class AFMDeviceCable>             DeviceCableClass;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartingCablePoolSize;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDeviceCableInteractionType                   CableInteractionType;                              // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDeviceCablePortDataType, TSubclassOf<class UFMDeviceCableConnectionBase>> ConnectionClasses;                                 // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class USoundSourceBus*                        DefaultSourceBus;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayEventListenerBackwardCompatibleHandle PlayerEnteredHandle;                               // 0x0108(0x0048)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AFMDeviceCable*>                 FreeDeviceCables;                                  // 0x0150(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFMDeviceCableConnectionBase*>   CableConnections;                                  // 0x0160(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, TWeakObjectPtr<class UFMDeviceCablePortComponent>> PortsInVolume;                                     // 0x0170(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FGuid>              OriginalGuidToDuplicatedGuidThisFrame;             // 0x01C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<TSoftObjectPtr<class UObject>, TSoftObjectPtr<class UObject>> SourceObjectToDuplicatedObjectThisFrame;           // 0x0210(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0xA0];                                     // 0x0260(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFMDeviceCableDefaultOutputs           DefaultConnectionOutputs;                          // 0x0300(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	EDeviceCableInteractionType GetCableInteractionType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableManagerComponent">();
	}
	static class UFMDeviceCableManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableManagerComponent>();
	}
};
static_assert(alignof(UFMDeviceCableManagerComponent) == 0x000008, "Wrong alignment on UFMDeviceCableManagerComponent");
static_assert(sizeof(UFMDeviceCableManagerComponent) == 0x000308, "Wrong size on UFMDeviceCableManagerComponent");
static_assert(offsetof(UFMDeviceCableManagerComponent, DeviceCableClass) == 0x0000A0, "Member 'UFMDeviceCableManagerComponent::DeviceCableClass' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, StartingCablePoolSize) == 0x0000A8, "Member 'UFMDeviceCableManagerComponent::StartingCablePoolSize' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, CableInteractionType) == 0x0000AC, "Member 'UFMDeviceCableManagerComponent::CableInteractionType' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, ConnectionClasses) == 0x0000B0, "Member 'UFMDeviceCableManagerComponent::ConnectionClasses' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, DefaultSourceBus) == 0x000100, "Member 'UFMDeviceCableManagerComponent::DefaultSourceBus' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, PlayerEnteredHandle) == 0x000108, "Member 'UFMDeviceCableManagerComponent::PlayerEnteredHandle' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, FreeDeviceCables) == 0x000150, "Member 'UFMDeviceCableManagerComponent::FreeDeviceCables' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, CableConnections) == 0x000160, "Member 'UFMDeviceCableManagerComponent::CableConnections' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, PortsInVolume) == 0x000170, "Member 'UFMDeviceCableManagerComponent::PortsInVolume' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, OriginalGuidToDuplicatedGuidThisFrame) == 0x0001C0, "Member 'UFMDeviceCableManagerComponent::OriginalGuidToDuplicatedGuidThisFrame' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, SourceObjectToDuplicatedObjectThisFrame) == 0x000210, "Member 'UFMDeviceCableManagerComponent::SourceObjectToDuplicatedObjectThisFrame' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableManagerComponent, DefaultConnectionOutputs) == 0x000300, "Member 'UFMDeviceCableManagerComponent::DefaultConnectionOutputs' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCablePortComponent
// 0x0300 (0x08C0 - 0x05C0)
#pragma pack(push, 0x1)
class alignas(0x10) UFMDeviceCablePortComponent : public UStaticMeshComponent
{
public:
	uint8                                         Pad_5C0[0x38];                                     // 0x05C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float Size)>    OnCablePortSizeUpdated;                            // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFMDeviceCableAnimatorBase* Animator)> OnAnimatorCreated;                                 // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFMDeviceCablePortComponent* ConnectedPort)> OnConnected;                                       // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_628[0x20];                                     // 0x0628(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UFMDeviceCablePortComponent* DisconnectedPort)> OnDisconnected;                                    // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFMDeviceCableConnectionBase* NewConnection)> OnConnectionStarted;                               // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFMDeviceCableConnectionBase* EndedConnection)> OnConnectionEnded;                                 // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPortArtifactUpdated;                             // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<class UFabricFloatProviderBase*>& FloatProviders)> OnReceiveFloatProviders;                           // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFabricFloatProviderBase* FloatProvider)> OnDisconnectFloatProvider;                         // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     DeviceCableManagerClass;                           // 0x06A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             OutputStaticMesh;                                  // 0x06B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             AudioInStaticMesh;                                 // 0x06D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             NoteInStaticMesh;                                  // 0x06F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             TextureInStaticMesh;                               // 0x0710(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             MeshInStaticMesh;                                  // 0x0730(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             ScalarInStaticMesh;                                // 0x0750(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDeviceCablePortDataType, TSubclassOf<class UFMDeviceCableAnimatorBase>> CableAnimatorClasses;                              // 0x0770(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	EDeviceCablePortFlowType                      PortFlowType;                                      // 0x07C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDeviceCablePortDataType                      PortDataType;                                      // 0x07C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDeviceCableLoadableState                     PortLoadableState;                                 // 0x07C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDeviceCablePortAnimationSyncType             AnimationSyncType;                                 // 0x07C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowMultipleConnections;                         // 0x07C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowSiblingConnections;                          // 0x07C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C6[0x2];                                      // 0x07C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EFMDeviceCablePortComponentAllowMultipleConnections OverrideAllowMultipleConnections;                  // 0x07C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFMDeviceCablePortComponentAllowMultipleConnections OverrideAllowSiblingConnections;                   // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideWhenNotRelevant;                              // 0x07D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerPort;                                     // 0x07D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnPreviewBuildingActor;                         // 0x07D2(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D3[0x1];                                      // 0x07D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnterVolumeTag;                                    // 0x07D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ExitVolumeTag;                                     // 0x07D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7DC[0x4];                                      // 0x07DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFMDeviceCablePortComponent*>    ConnectedPorts;                                    // 0x07E0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UFMDeviceCablePortComponent*>    ServerConnectedPorts;                              // 0x07F0(0x0010)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UFMDeviceCableConnectionBase*>   CurrentConnections;                                // 0x0800(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AFMDeviceCable*                         ConstantCable;                                     // 0x0810(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMDeviceCableManagerComponent*         DeviceCableManager;                                // 0x0818(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFMDeviceCablePortComponent*>    OtherPortsOnActor;                                 // 0x0820(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EDeviceCableActivatedState                    PortActivatedState;                                // 0x0830(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDeviceCableActivatedState                    ServerPortActivatedState;                          // 0x0831(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDeviceCablePortSelectableState               PortSelectableState;                               // 0x0832(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_833[0x5];                                      // 0x0833(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMDeviceCableAnimatorBase*             DeviceCableAnimator;                               // 0x0838(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  ConnectionGuid;                                    // 0x0840(0x0010)(ZeroConstructor, Transient, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          ConnectedGuids;                                    // 0x0850(0x0010)(ZeroConstructor, Transient, SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FFMDeviceCableArtifact                 CachedArtifact;                                    // 0x0860(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_880[0x10];                                     // 0x0880(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFMDeviceCablePortComponent*>    PendingConnectionBroadcasts;                       // 0x0890(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGuid                                  SaveGuid;                                          // 0x08A0(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B0[0x8];                                      // 0x08B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActorHasValidControllerBP(class AActor* Actor, class AFortPlayerPawn** OutFortPlayerPawn, class APlayerController** OutPlayerController);
	void EndConnectionWithPort(class UFMDeviceCablePortComponent* OtherPort);
	class AFMDeviceCable* GetConstantCable();
	class UFMDeviceCableAnimatorBase* GetDeviceCableAnimator();
	struct FGuid GetGuid();
	void OnPlayerControllerPortConnected(const TArray<class UFMDeviceCablePortComponent*>& ControllerPorts);
	void OnPlayerControllerPortDisconnected();
	void OnRep_ConstantCable();
	void OnRep_DeviceCableManager();
	void OnRep_ServerConnectedPorts();
	void OnRep_ServerPortActivatedState();
	void OpenConnectionToPort(class UFMDeviceCablePortComponent* OtherPort);
	EPortSelectStatus Select(class UFMDeviceCablePortComponent* PlayerSelectionPort, TArray<struct FPortUpdateInfo>* OutPortUpdates);
	EPortSelectStatus SelectWithStaticOutputInteraction(class UFMDeviceCablePortComponent* PlayerSelectionPort, TArray<struct FPortUpdateInfo>* OutPortUpdates);
	void SetCachedArtifact(const struct FFMDeviceCableArtifact& InCachedArtifact);
	void SetDeviceCableAnimator(class UFMDeviceCableAnimatorBase* InAnimator);
	void SetPortActivatedState(EDeviceCableActivatedState NewActivatedState);
	void SetPortConnectionsDirty();
	void SetPortSelectableState(EDeviceCablePortSelectableState NewSelectableState);
	void SetPortVisibility(bool bPortVisible);
	void UpdateStaticMesh();

	EDeviceCablePortAnimationSyncType GetAnimationSyncType() const;
	const struct FFMDeviceCableArtifact GetCachedArtifact() const;
	const TArray<class UFMDeviceCablePortComponent*> GetConnectedPorts() const;
	const TArray<class UFMDeviceCableConnectionBase*> GetConnections() const;
	bool GetIsPlayerPort() const;
	bool GetIsTerminalPort(EDeviceCablePortFlowType FlowType) const;
	TArray<class UFMDeviceCablePortComponent*> GetNextPortsInConnections() const;
	const TArray<class UFMDeviceCablePortComponent*> GetOtherPortsOnActor() const;
	EDeviceCableActivatedState GetPortActivatedState() const;
	EDeviceCablePortDataType GetPortDataType() const;
	EDeviceCablePortFlowType GetPortFlowType() const;
	EDeviceCablePortSelectableState GetPortSelectableState() const;
	TArray<class UFMDeviceCablePortComponent*> GetPreviousPortsInConnections() const;
	bool HasSavedConnections() const;
	bool IsConnected() const;
	bool IsConnectedToPort(class UFMDeviceCablePortComponent* Port) const;
	bool MatchesPortConnectionType(class UFMDeviceCablePortComponent* OtherPort) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCablePortComponent">();
	}
	static class UFMDeviceCablePortComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCablePortComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFMDeviceCablePortComponent) == 0x000010, "Wrong alignment on UFMDeviceCablePortComponent");
static_assert(sizeof(UFMDeviceCablePortComponent) == 0x0008C0, "Wrong size on UFMDeviceCablePortComponent");
static_assert(offsetof(UFMDeviceCablePortComponent, OnCablePortSizeUpdated) == 0x0005F8, "Member 'UFMDeviceCablePortComponent::OnCablePortSizeUpdated' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OnAnimatorCreated) == 0x000608, "Member 'UFMDeviceCablePortComponent::OnAnimatorCreated' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OnConnected) == 0x000618, "Member 'UFMDeviceCablePortComponent::OnConnected' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OnDisconnected) == 0x000648, "Member 'UFMDeviceCablePortComponent::OnDisconnected' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OnConnectionStarted) == 0x000658, "Member 'UFMDeviceCablePortComponent::OnConnectionStarted' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OnConnectionEnded) == 0x000668, "Member 'UFMDeviceCablePortComponent::OnConnectionEnded' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OnPortArtifactUpdated) == 0x000678, "Member 'UFMDeviceCablePortComponent::OnPortArtifactUpdated' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OnReceiveFloatProviders) == 0x000688, "Member 'UFMDeviceCablePortComponent::OnReceiveFloatProviders' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OnDisconnectFloatProvider) == 0x000698, "Member 'UFMDeviceCablePortComponent::OnDisconnectFloatProvider' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, DeviceCableManagerClass) == 0x0006A8, "Member 'UFMDeviceCablePortComponent::DeviceCableManagerClass' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OutputStaticMesh) == 0x0006B0, "Member 'UFMDeviceCablePortComponent::OutputStaticMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, AudioInStaticMesh) == 0x0006D0, "Member 'UFMDeviceCablePortComponent::AudioInStaticMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, NoteInStaticMesh) == 0x0006F0, "Member 'UFMDeviceCablePortComponent::NoteInStaticMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, TextureInStaticMesh) == 0x000710, "Member 'UFMDeviceCablePortComponent::TextureInStaticMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, MeshInStaticMesh) == 0x000730, "Member 'UFMDeviceCablePortComponent::MeshInStaticMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, ScalarInStaticMesh) == 0x000750, "Member 'UFMDeviceCablePortComponent::ScalarInStaticMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, CableAnimatorClasses) == 0x000770, "Member 'UFMDeviceCablePortComponent::CableAnimatorClasses' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, PortFlowType) == 0x0007C0, "Member 'UFMDeviceCablePortComponent::PortFlowType' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, PortDataType) == 0x0007C1, "Member 'UFMDeviceCablePortComponent::PortDataType' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, PortLoadableState) == 0x0007C2, "Member 'UFMDeviceCablePortComponent::PortLoadableState' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, AnimationSyncType) == 0x0007C3, "Member 'UFMDeviceCablePortComponent::AnimationSyncType' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, bAllowMultipleConnections) == 0x0007C4, "Member 'UFMDeviceCablePortComponent::bAllowMultipleConnections' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, bAllowSiblingConnections) == 0x0007C5, "Member 'UFMDeviceCablePortComponent::bAllowSiblingConnections' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OverrideAllowMultipleConnections) == 0x0007C8, "Member 'UFMDeviceCablePortComponent::OverrideAllowMultipleConnections' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OverrideAllowSiblingConnections) == 0x0007CC, "Member 'UFMDeviceCablePortComponent::OverrideAllowSiblingConnections' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, bHideWhenNotRelevant) == 0x0007D0, "Member 'UFMDeviceCablePortComponent::bHideWhenNotRelevant' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, bIsPlayerPort) == 0x0007D1, "Member 'UFMDeviceCablePortComponent::bIsPlayerPort' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, bIsOnPreviewBuildingActor) == 0x0007D2, "Member 'UFMDeviceCablePortComponent::bIsOnPreviewBuildingActor' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, EnterVolumeTag) == 0x0007D4, "Member 'UFMDeviceCablePortComponent::EnterVolumeTag' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, ExitVolumeTag) == 0x0007D8, "Member 'UFMDeviceCablePortComponent::ExitVolumeTag' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, ConnectedPorts) == 0x0007E0, "Member 'UFMDeviceCablePortComponent::ConnectedPorts' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, ServerConnectedPorts) == 0x0007F0, "Member 'UFMDeviceCablePortComponent::ServerConnectedPorts' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, CurrentConnections) == 0x000800, "Member 'UFMDeviceCablePortComponent::CurrentConnections' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, ConstantCable) == 0x000810, "Member 'UFMDeviceCablePortComponent::ConstantCable' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, DeviceCableManager) == 0x000818, "Member 'UFMDeviceCablePortComponent::DeviceCableManager' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, OtherPortsOnActor) == 0x000820, "Member 'UFMDeviceCablePortComponent::OtherPortsOnActor' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, PortActivatedState) == 0x000830, "Member 'UFMDeviceCablePortComponent::PortActivatedState' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, ServerPortActivatedState) == 0x000831, "Member 'UFMDeviceCablePortComponent::ServerPortActivatedState' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, PortSelectableState) == 0x000832, "Member 'UFMDeviceCablePortComponent::PortSelectableState' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, DeviceCableAnimator) == 0x000838, "Member 'UFMDeviceCablePortComponent::DeviceCableAnimator' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, ConnectionGuid) == 0x000840, "Member 'UFMDeviceCablePortComponent::ConnectionGuid' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, ConnectedGuids) == 0x000850, "Member 'UFMDeviceCablePortComponent::ConnectedGuids' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, CachedArtifact) == 0x000860, "Member 'UFMDeviceCablePortComponent::CachedArtifact' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, PendingConnectionBroadcasts) == 0x000890, "Member 'UFMDeviceCablePortComponent::PendingConnectionBroadcasts' has a wrong offset!");
static_assert(offsetof(UFMDeviceCablePortComponent, SaveGuid) == 0x0008A0, "Member 'UFMDeviceCablePortComponent::SaveGuid' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableModulatorPortComponent
// 0x0020 (0x08E0 - 0x08C0)
class UFMDeviceCableModulatorPortComponent final : public UFMDeviceCablePortComponent
{
public:
	uint8                                         Pad_8B8[0x8];                                      // 0x08B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AssociatedProperty;                                // 0x08C0(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UObject>                 AssociatedObject;                                  // 0x08D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D8[0x8];                                      // 0x08D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDeviceCableManager(class UFMDeviceCableManagerComponent* InDeviceCableManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableModulatorPortComponent">();
	}
	static class UFMDeviceCableModulatorPortComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableModulatorPortComponent>();
	}
};
static_assert(alignof(UFMDeviceCableModulatorPortComponent) == 0x000010, "Wrong alignment on UFMDeviceCableModulatorPortComponent");
static_assert(sizeof(UFMDeviceCableModulatorPortComponent) == 0x0008E0, "Wrong size on UFMDeviceCableModulatorPortComponent");
static_assert(offsetof(UFMDeviceCableModulatorPortComponent, AssociatedProperty) == 0x0008C0, "Member 'UFMDeviceCableModulatorPortComponent::AssociatedProperty' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableModulatorPortComponent, AssociatedObject) == 0x0008D0, "Member 'UFMDeviceCableModulatorPortComponent::AssociatedObject' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCablesFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFMDeviceCablesFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class USoundSourceBus* DeepCopySoundSourceBus(const class UObject* Context, class UObject* Outer_0, class USoundSourceBus* Source);
	static struct FSoundSourceBusSendInfo MakeSoundSourceBusSendInfo(class USoundSourceBus* SoundSourceBus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCablesFunctionLibrary">();
	}
	static class UFMDeviceCablesFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCablesFunctionLibrary>();
	}
};
static_assert(alignof(UFMDeviceCablesFunctionLibrary) == 0x000008, "Wrong alignment on UFMDeviceCablesFunctionLibrary");
static_assert(sizeof(UFMDeviceCablesFunctionLibrary) == 0x000028, "Wrong size on UFMDeviceCablesFunctionLibrary");

// Class FMDeviceCablesRuntime.FMDeviceCableWildcardOrderingComponent
// 0x04D0 (0x0570 - 0x00A0)
class UFMDeviceCableWildcardOrderingComponent final : public UActorComponent
{
public:
	struct FFMDeviceCableOrderingMovementState    InputsShowHideMovement;                            // 0x00A0(0x00A0)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FFMDeviceCableOrderingMovementStateIndividual OutputsShowHideMovement;                           // 0x0140(0x0140)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FFMDeviceCableOrderingMovementStateSlot OutputsCollapseExpandMovement;                     // 0x0280(0x00A0)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FFMDeviceCableOrderingMovementStateIndividual OutputListShiftMovement;                           // 0x0320(0x0140)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FName                                   ClosedMeshTag;                                     // 0x0460(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TopMeshTag;                                        // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MiddleMeshTag;                                     // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BottomMeshTag;                                     // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ClosedMesh;                                        // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   TopMesh;                                           // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           MiddleMeshes;                                      // 0x0480(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BottomMesh;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFMDeviceCableWildcardPortComponent*> InputWildcardPorts;                                // 0x04A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UFMDeviceCableWildcardPortComponent*> OutputWildcardPorts;                               // 0x04B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x30];                                     // 0x04C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFMDeviceCableWildcardPortComponent*> PortsWithPendingDisconnects;                       // 0x04F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x50];                                     // 0x0508(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFMDeviceCableOrderingPortState> ServerPortStates;                                  // 0x0558(0x0010)(Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputPortConnected(class UFMDeviceCablePortComponent* ConnectedPort);
	void OnInputPortDataTypeChanged(class UFMDeviceCableWildcardPortComponent* WildcardPort, EDeviceCablePortDataType DataType);
	void OnInputPortDisconnected(class UFMDeviceCablePortComponent* DisconnectedPort);
	void OnOutputPortConnected(class UFMDeviceCablePortComponent* SourcePort, class UFMDeviceCablePortComponent* ConnectedPort);
	void OnOutputPortDisconnected(class UFMDeviceCablePortComponent* SourcePort, class UFMDeviceCablePortComponent* DisconnectedPort);
	void OnOutputPortSlotSetFromSave(class UFMDeviceCableWildcardPortComponent* WildcardPort, bool bHasConnections);
	void OnRep_ServerPortStates();
	void SetInputRoot(const struct FVector& RootLocation);
	void SetOutputPortsExpanded(bool bExpanded);
	void SetOutputRoot(const struct FVector& RootLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableWildcardOrderingComponent">();
	}
	static class UFMDeviceCableWildcardOrderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableWildcardOrderingComponent>();
	}
};
static_assert(alignof(UFMDeviceCableWildcardOrderingComponent) == 0x000008, "Wrong alignment on UFMDeviceCableWildcardOrderingComponent");
static_assert(sizeof(UFMDeviceCableWildcardOrderingComponent) == 0x000570, "Wrong size on UFMDeviceCableWildcardOrderingComponent");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, InputsShowHideMovement) == 0x0000A0, "Member 'UFMDeviceCableWildcardOrderingComponent::InputsShowHideMovement' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, OutputsShowHideMovement) == 0x000140, "Member 'UFMDeviceCableWildcardOrderingComponent::OutputsShowHideMovement' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, OutputsCollapseExpandMovement) == 0x000280, "Member 'UFMDeviceCableWildcardOrderingComponent::OutputsCollapseExpandMovement' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, OutputListShiftMovement) == 0x000320, "Member 'UFMDeviceCableWildcardOrderingComponent::OutputListShiftMovement' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, ClosedMeshTag) == 0x000460, "Member 'UFMDeviceCableWildcardOrderingComponent::ClosedMeshTag' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, TopMeshTag) == 0x000464, "Member 'UFMDeviceCableWildcardOrderingComponent::TopMeshTag' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, MiddleMeshTag) == 0x000468, "Member 'UFMDeviceCableWildcardOrderingComponent::MiddleMeshTag' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, BottomMeshTag) == 0x00046C, "Member 'UFMDeviceCableWildcardOrderingComponent::BottomMeshTag' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, ClosedMesh) == 0x000470, "Member 'UFMDeviceCableWildcardOrderingComponent::ClosedMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, TopMesh) == 0x000478, "Member 'UFMDeviceCableWildcardOrderingComponent::TopMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, MiddleMeshes) == 0x000480, "Member 'UFMDeviceCableWildcardOrderingComponent::MiddleMeshes' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, BottomMesh) == 0x000490, "Member 'UFMDeviceCableWildcardOrderingComponent::BottomMesh' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, InputWildcardPorts) == 0x0004A8, "Member 'UFMDeviceCableWildcardOrderingComponent::InputWildcardPorts' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, OutputWildcardPorts) == 0x0004B8, "Member 'UFMDeviceCableWildcardOrderingComponent::OutputWildcardPorts' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, PortsWithPendingDisconnects) == 0x0004F8, "Member 'UFMDeviceCableWildcardOrderingComponent::PortsWithPendingDisconnects' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardOrderingComponent, ServerPortStates) == 0x000558, "Member 'UFMDeviceCableWildcardOrderingComponent::ServerPortStates' has a wrong offset!");

// Class FMDeviceCablesRuntime.FMDeviceCableWildcardPortComponent
// 0x0030 (0x08F0 - 0x08C0)
class UFMDeviceCableWildcardPortComponent final : public UFMDeviceCablePortComponent
{
public:
	TMulticastInlineDelegate<void(class UFMDeviceCableWildcardPortComponent* WildcardPort, EDeviceCablePortDataType DataType)> OnWildcardDataTypeChanged;                         // 0x08B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFMDeviceCableWildcardPortComponent* WildcardPort, bool bHasConnections)> OnWildcardPortSlotSetFromSave;                     // 0x08C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x08D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SavedSlotIndex;                                    // 0x08DC(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E0[0x10];                                     // 0x08E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerControllerPortConnectedWildcard(const TArray<class UFMDeviceCablePortComponent*>& ControllerPorts);
	void OnPlayerControllerPortDisconnectedWildcard();
	void OnRep_SavedSlotIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMDeviceCableWildcardPortComponent">();
	}
	static class UFMDeviceCableWildcardPortComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMDeviceCableWildcardPortComponent>();
	}
};
static_assert(alignof(UFMDeviceCableWildcardPortComponent) == 0x000010, "Wrong alignment on UFMDeviceCableWildcardPortComponent");
static_assert(sizeof(UFMDeviceCableWildcardPortComponent) == 0x0008F0, "Wrong size on UFMDeviceCableWildcardPortComponent");
static_assert(offsetof(UFMDeviceCableWildcardPortComponent, OnWildcardDataTypeChanged) == 0x0008B8, "Member 'UFMDeviceCableWildcardPortComponent::OnWildcardDataTypeChanged' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardPortComponent, OnWildcardPortSlotSetFromSave) == 0x0008C8, "Member 'UFMDeviceCableWildcardPortComponent::OnWildcardPortSlotSetFromSave' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardPortComponent, SlotIndex) == 0x0008D8, "Member 'UFMDeviceCableWildcardPortComponent::SlotIndex' has a wrong offset!");
static_assert(offsetof(UFMDeviceCableWildcardPortComponent, SavedSlotIndex) == 0x0008DC, "Member 'UFMDeviceCableWildcardPortComponent::SavedSlotIndex' has a wrong offset!");

}

