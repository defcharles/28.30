#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KatanaGameplayRuntime

#include "Basic.hpp"

#include "MantisRuntime_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "KatanaGameplayRuntime_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class KatanaGameplayRuntime.FortKatanaLayerAnimInstance
// 0x0170 (0x17A0 - 0x1630)
class UFortKatanaLayerAnimInstance final : public UFortMantisLayerAnimInstance
{
public:
	bool                                          IsDashCharge;                                      // 0x1630(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1631[0x7];                                     // 0x1631(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerPawn*                        AsFortPlayerPawn;                                  // 0x1638(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBMeleeKatana;                                    // 0x1640(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1641[0x3];                                     // 0x1641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HandIKHipAttachAlpha;                              // 0x1644(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeftAttachedHandIKLoc;                             // 0x1648(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LeftAttachedhandIKRot;                             // 0x1660(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                RightWeaponLoc;                                    // 0x1678(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RightWeaponRot;                                    // 0x1690(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LeftAttachedHandIKLocOffsetMED;                    // 0x16A8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LeftAttachedHandIKRotOffset;                       // 0x16C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                RightWeaponLocOffsetMED;                           // 0x16D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RightWeaponRotOffset;                              // 0x16F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          IsDashAttack;                                      // 0x1708(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDashOutro;                                       // 0x1709(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170A[0x2];                                     // 0x170A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PelvisAOAlpha;                                     // 0x170C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClampedAimPitch;                                   // 0x1710(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EarlyExitFromDashOutro;                            // 0x1714(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTechniqueActive;                                 // 0x1715(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPrimaryAttack;                                   // 0x1716(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1717[0x1];                                     // 0x1717(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponHipAttachAlpha;                              // 0x1718(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171C[0x4];                                     // 0x171C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftAttachedHandIKLocOffsetLRG;                    // 0x1720(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RightWeaponLocOffsetLRG;                           // 0x1738(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FeetCorrectionAlpha;                               // 0x1750(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInAirAttackLeap;                                 // 0x1754(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldStartDashOutro;                              // 0x1755(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          StartedDashOutro;                                  // 0x1756(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1757[0x1];                                     // 0x1757(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         DashRootMotionDuration;                            // 0x1758(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          IsPrimaryAttack2;                                  // 0x1780(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsAirAttackSlam;                                   // 0x1781(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TransitionRuleToDefault;                           // 0x1782(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsGrindRailSwing;                                  // 0x1783(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanExitDashCharge;                                 // 0x1784(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1785[0x3];                                     // 0x1785(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashChargePlayRate;                                // 0x1788(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawForKatanaDashAO;                                // 0x178C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1790[0x10];                                    // 0x1790(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKatanaLayerAnimInstance">();
	}
	static class UFortKatanaLayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKatanaLayerAnimInstance>();
	}
};
static_assert(alignof(UFortKatanaLayerAnimInstance) == 0x000010, "Wrong alignment on UFortKatanaLayerAnimInstance");
static_assert(sizeof(UFortKatanaLayerAnimInstance) == 0x0017A0, "Wrong size on UFortKatanaLayerAnimInstance");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsDashCharge) == 0x001630, "Member 'UFortKatanaLayerAnimInstance::IsDashCharge' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, AsFortPlayerPawn) == 0x001638, "Member 'UFortKatanaLayerAnimInstance::AsFortPlayerPawn' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsBMeleeKatana) == 0x001640, "Member 'UFortKatanaLayerAnimInstance::IsBMeleeKatana' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, HandIKHipAttachAlpha) == 0x001644, "Member 'UFortKatanaLayerAnimInstance::HandIKHipAttachAlpha' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, LeftAttachedHandIKLoc) == 0x001648, "Member 'UFortKatanaLayerAnimInstance::LeftAttachedHandIKLoc' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, LeftAttachedhandIKRot) == 0x001660, "Member 'UFortKatanaLayerAnimInstance::LeftAttachedhandIKRot' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, RightWeaponLoc) == 0x001678, "Member 'UFortKatanaLayerAnimInstance::RightWeaponLoc' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, RightWeaponRot) == 0x001690, "Member 'UFortKatanaLayerAnimInstance::RightWeaponRot' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, LeftAttachedHandIKLocOffsetMED) == 0x0016A8, "Member 'UFortKatanaLayerAnimInstance::LeftAttachedHandIKLocOffsetMED' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, LeftAttachedHandIKRotOffset) == 0x0016C0, "Member 'UFortKatanaLayerAnimInstance::LeftAttachedHandIKRotOffset' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, RightWeaponLocOffsetMED) == 0x0016D8, "Member 'UFortKatanaLayerAnimInstance::RightWeaponLocOffsetMED' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, RightWeaponRotOffset) == 0x0016F0, "Member 'UFortKatanaLayerAnimInstance::RightWeaponRotOffset' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsDashAttack) == 0x001708, "Member 'UFortKatanaLayerAnimInstance::IsDashAttack' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsDashOutro) == 0x001709, "Member 'UFortKatanaLayerAnimInstance::IsDashOutro' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, PelvisAOAlpha) == 0x00170C, "Member 'UFortKatanaLayerAnimInstance::PelvisAOAlpha' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, ClampedAimPitch) == 0x001710, "Member 'UFortKatanaLayerAnimInstance::ClampedAimPitch' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, EarlyExitFromDashOutro) == 0x001714, "Member 'UFortKatanaLayerAnimInstance::EarlyExitFromDashOutro' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsTechniqueActive) == 0x001715, "Member 'UFortKatanaLayerAnimInstance::IsTechniqueActive' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsPrimaryAttack) == 0x001716, "Member 'UFortKatanaLayerAnimInstance::IsPrimaryAttack' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, WeaponHipAttachAlpha) == 0x001718, "Member 'UFortKatanaLayerAnimInstance::WeaponHipAttachAlpha' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, LeftAttachedHandIKLocOffsetLRG) == 0x001720, "Member 'UFortKatanaLayerAnimInstance::LeftAttachedHandIKLocOffsetLRG' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, RightWeaponLocOffsetLRG) == 0x001738, "Member 'UFortKatanaLayerAnimInstance::RightWeaponLocOffsetLRG' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, FeetCorrectionAlpha) == 0x001750, "Member 'UFortKatanaLayerAnimInstance::FeetCorrectionAlpha' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsInAirAttackLeap) == 0x001754, "Member 'UFortKatanaLayerAnimInstance::IsInAirAttackLeap' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, ShouldStartDashOutro) == 0x001755, "Member 'UFortKatanaLayerAnimInstance::ShouldStartDashOutro' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, StartedDashOutro) == 0x001756, "Member 'UFortKatanaLayerAnimInstance::StartedDashOutro' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, DashRootMotionDuration) == 0x001758, "Member 'UFortKatanaLayerAnimInstance::DashRootMotionDuration' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsPrimaryAttack2) == 0x001780, "Member 'UFortKatanaLayerAnimInstance::IsPrimaryAttack2' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsAirAttackSlam) == 0x001781, "Member 'UFortKatanaLayerAnimInstance::IsAirAttackSlam' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, TransitionRuleToDefault) == 0x001782, "Member 'UFortKatanaLayerAnimInstance::TransitionRuleToDefault' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, IsGrindRailSwing) == 0x001783, "Member 'UFortKatanaLayerAnimInstance::IsGrindRailSwing' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, CanExitDashCharge) == 0x001784, "Member 'UFortKatanaLayerAnimInstance::CanExitDashCharge' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, DashChargePlayRate) == 0x001788, "Member 'UFortKatanaLayerAnimInstance::DashChargePlayRate' has a wrong offset!");
static_assert(offsetof(UFortKatanaLayerAnimInstance, YawForKatanaDashAO) == 0x00178C, "Member 'UFortKatanaLayerAnimInstance::YawForKatanaDashAO' has a wrong offset!");

// Class KatanaGameplayRuntime.FortKatanaWeaponAnimInstance
// 0x0150 (0x05C0 - 0x0470)
class UFortKatanaWeaponAnimInstance final : public UFortMantisAnimInstance
{
public:
	class AFortPlayerPawn*                        AsFortPlayerPawn;                                  // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortWeapon*                            BMeleeKatanaAsWeapon;                              // 0x0470(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBMeleeKatana;                                    // 0x0478(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x3];                                      // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalLeftHandIKAlpha;                              // 0x047C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocalRightHandIKAlpha;                             // 0x0480(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDashCharge;                                      // 0x0484(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDashAttack;                                      // 0x0485(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_486[0x2];                                      // 0x0486(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwordPlayRate;                                     // 0x0488(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInAirAttack_Leap;                                // 0x048C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInAirAttack_Slam;                                // 0x048D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48E[0x2];                                      // 0x048E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortKatanaLayerAnimInstance*           KatanaPlayer;                                      // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EarlyExitFromDashOutro;                            // 0x0498(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDashOutro;                                       // 0x0499(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49A[0x6];                                      // 0x049A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScabbardLoc;                                       // 0x04A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ScabbardRot;                                       // 0x04B8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ScabbardLocOffset;                                 // 0x04D0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ScabbardRotOffset;                                 // 0x04E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          IsSurfaceSwimming;                                 // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTechniqueActive;                                 // 0x0501(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_502[0x6];                                      // 0x0502(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SwordLoc;                                          // 0x0508(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               SwordRot;                                          // 0x0520(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                SwordLocOffset;                                    // 0x0538(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               SwordRotOffset;                                    // 0x0550(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          IsRidingSwing;                                     // 0x0568(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPrimaryAttack;                                   // 0x0569(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPrimaryAttack2;                                  // 0x056A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExitFromPrimaryAttack;                             // 0x056B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExitFromPrimaryAttack2;                            // 0x056C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          NonPrimaryAttackState;                             // 0x056D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsComboAttack;                                     // 0x056E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TransitionRuleToDefaultPose;                       // 0x056F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExitFromInAirLand;                                 // 0x0570(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsGrindRailSwing;                                  // 0x0571(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_572[0x2];                                      // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTechniqueBranch;                            // 0x0574(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousTechniqueBranch;                           // 0x0578(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PelvisSocket;                                      // 0x057C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ScabbardLocOffsetVeh;                              // 0x0580(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ScabbardRotOffsetVeh;                              // 0x0598(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DashChargePlayRate;                                // 0x05B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0xC];                                      // 0x05B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKatanaWeaponAnimInstance">();
	}
	static class UFortKatanaWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKatanaWeaponAnimInstance>();
	}
};
static_assert(alignof(UFortKatanaWeaponAnimInstance) == 0x000010, "Wrong alignment on UFortKatanaWeaponAnimInstance");
static_assert(sizeof(UFortKatanaWeaponAnimInstance) == 0x0005C0, "Wrong size on UFortKatanaWeaponAnimInstance");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, AsFortPlayerPawn) == 0x000468, "Member 'UFortKatanaWeaponAnimInstance::AsFortPlayerPawn' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, BMeleeKatanaAsWeapon) == 0x000470, "Member 'UFortKatanaWeaponAnimInstance::BMeleeKatanaAsWeapon' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsBMeleeKatana) == 0x000478, "Member 'UFortKatanaWeaponAnimInstance::IsBMeleeKatana' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, LocalLeftHandIKAlpha) == 0x00047C, "Member 'UFortKatanaWeaponAnimInstance::LocalLeftHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, LocalRightHandIKAlpha) == 0x000480, "Member 'UFortKatanaWeaponAnimInstance::LocalRightHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsDashCharge) == 0x000484, "Member 'UFortKatanaWeaponAnimInstance::IsDashCharge' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsDashAttack) == 0x000485, "Member 'UFortKatanaWeaponAnimInstance::IsDashAttack' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, SwordPlayRate) == 0x000488, "Member 'UFortKatanaWeaponAnimInstance::SwordPlayRate' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsInAirAttack_Leap) == 0x00048C, "Member 'UFortKatanaWeaponAnimInstance::IsInAirAttack_Leap' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsInAirAttack_Slam) == 0x00048D, "Member 'UFortKatanaWeaponAnimInstance::IsInAirAttack_Slam' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, KatanaPlayer) == 0x000490, "Member 'UFortKatanaWeaponAnimInstance::KatanaPlayer' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, EarlyExitFromDashOutro) == 0x000498, "Member 'UFortKatanaWeaponAnimInstance::EarlyExitFromDashOutro' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsDashOutro) == 0x000499, "Member 'UFortKatanaWeaponAnimInstance::IsDashOutro' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ScabbardLoc) == 0x0004A0, "Member 'UFortKatanaWeaponAnimInstance::ScabbardLoc' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ScabbardRot) == 0x0004B8, "Member 'UFortKatanaWeaponAnimInstance::ScabbardRot' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ScabbardLocOffset) == 0x0004D0, "Member 'UFortKatanaWeaponAnimInstance::ScabbardLocOffset' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ScabbardRotOffset) == 0x0004E8, "Member 'UFortKatanaWeaponAnimInstance::ScabbardRotOffset' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsSurfaceSwimming) == 0x000500, "Member 'UFortKatanaWeaponAnimInstance::IsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsTechniqueActive) == 0x000501, "Member 'UFortKatanaWeaponAnimInstance::IsTechniqueActive' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, SwordLoc) == 0x000508, "Member 'UFortKatanaWeaponAnimInstance::SwordLoc' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, SwordRot) == 0x000520, "Member 'UFortKatanaWeaponAnimInstance::SwordRot' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, SwordLocOffset) == 0x000538, "Member 'UFortKatanaWeaponAnimInstance::SwordLocOffset' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, SwordRotOffset) == 0x000550, "Member 'UFortKatanaWeaponAnimInstance::SwordRotOffset' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsRidingSwing) == 0x000568, "Member 'UFortKatanaWeaponAnimInstance::IsRidingSwing' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsPrimaryAttack) == 0x000569, "Member 'UFortKatanaWeaponAnimInstance::IsPrimaryAttack' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsPrimaryAttack2) == 0x00056A, "Member 'UFortKatanaWeaponAnimInstance::IsPrimaryAttack2' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ExitFromPrimaryAttack) == 0x00056B, "Member 'UFortKatanaWeaponAnimInstance::ExitFromPrimaryAttack' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ExitFromPrimaryAttack2) == 0x00056C, "Member 'UFortKatanaWeaponAnimInstance::ExitFromPrimaryAttack2' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, NonPrimaryAttackState) == 0x00056D, "Member 'UFortKatanaWeaponAnimInstance::NonPrimaryAttackState' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsComboAttack) == 0x00056E, "Member 'UFortKatanaWeaponAnimInstance::IsComboAttack' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, TransitionRuleToDefaultPose) == 0x00056F, "Member 'UFortKatanaWeaponAnimInstance::TransitionRuleToDefaultPose' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ExitFromInAirLand) == 0x000570, "Member 'UFortKatanaWeaponAnimInstance::ExitFromInAirLand' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, IsGrindRailSwing) == 0x000571, "Member 'UFortKatanaWeaponAnimInstance::IsGrindRailSwing' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, CurrentTechniqueBranch) == 0x000574, "Member 'UFortKatanaWeaponAnimInstance::CurrentTechniqueBranch' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, PreviousTechniqueBranch) == 0x000578, "Member 'UFortKatanaWeaponAnimInstance::PreviousTechniqueBranch' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, PelvisSocket) == 0x00057C, "Member 'UFortKatanaWeaponAnimInstance::PelvisSocket' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ScabbardLocOffsetVeh) == 0x000580, "Member 'UFortKatanaWeaponAnimInstance::ScabbardLocOffsetVeh' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, ScabbardRotOffsetVeh) == 0x000598, "Member 'UFortKatanaWeaponAnimInstance::ScabbardRotOffsetVeh' has a wrong offset!");
static_assert(offsetof(UFortKatanaWeaponAnimInstance, DashChargePlayRate) == 0x0005B0, "Member 'UFortKatanaWeaponAnimInstance::DashChargePlayRate' has a wrong offset!");

// Class KatanaGameplayRuntime.KatanaTargetingComponent
// 0x0270 (0x0310 - 0x00A0)
class UKatanaTargetingComponent final : public UFortWeaponComponent
{
public:
	TSubclassOf<class UGameplayAbility>           KatanaTechniqueAbilityClass;                       // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortGameplayAbility*                   CachedTechniqueAbilityCDO;                         // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         DashDistance;                                      // 0x00B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AdditionalDashForwardAttackRange;                  // 0x00D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AdditionalOutOfRangeDetection;                     // 0x0100(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DashOffsetFromTarget;                              // 0x0128(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PropRemainingHealthToDestroy;                      // 0x0150(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuildingRemainingHealthToDestroy;                  // 0x0178(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DashBlockingBuildingTags;                          // 0x01A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class ABuildingActor>>       DashBlockingBuildingClasses;                       // 0x01C0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FFortAbilityTargetSelectionList        PawnTargetSelectionList;                           // 0x0210(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ECollisionChannel                             DashTraceChannel;                                  // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObstructionOverlapBoxHalfSize;                     // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortTargetFilter                      ObstructionTargetFilter;                           // 0x0260(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DashBlockIgnoreTags;                               // 0x0298(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EFortKatanaPrimaryAttackVariation, struct FFortKatanaPrimaryAttackVariationInfo> PrimaryAttackVariationInfos;                       // 0x02B8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         PrimaryAttackMinForwardMovement;                   // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             PrimaryAttackObstructionTraceChannel;              // 0x030C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool PerformDashTargeting(struct FFortKatanaDashTargetingInfo* OutDashTargetingInfo);
	struct FVector PerformPrimaryAttackTargeting(const EFortKatanaPrimaryAttackVariation AttackVariation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KatanaTargetingComponent">();
	}
	static class UKatanaTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKatanaTargetingComponent>();
	}
};
static_assert(alignof(UKatanaTargetingComponent) == 0x000008, "Wrong alignment on UKatanaTargetingComponent");
static_assert(sizeof(UKatanaTargetingComponent) == 0x000310, "Wrong size on UKatanaTargetingComponent");
static_assert(offsetof(UKatanaTargetingComponent, KatanaTechniqueAbilityClass) == 0x0000A0, "Member 'UKatanaTargetingComponent::KatanaTechniqueAbilityClass' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, CachedTechniqueAbilityCDO) == 0x0000A8, "Member 'UKatanaTargetingComponent::CachedTechniqueAbilityCDO' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, DashDistance) == 0x0000B0, "Member 'UKatanaTargetingComponent::DashDistance' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, AdditionalDashForwardAttackRange) == 0x0000D8, "Member 'UKatanaTargetingComponent::AdditionalDashForwardAttackRange' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, AdditionalOutOfRangeDetection) == 0x000100, "Member 'UKatanaTargetingComponent::AdditionalOutOfRangeDetection' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, DashOffsetFromTarget) == 0x000128, "Member 'UKatanaTargetingComponent::DashOffsetFromTarget' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, PropRemainingHealthToDestroy) == 0x000150, "Member 'UKatanaTargetingComponent::PropRemainingHealthToDestroy' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, BuildingRemainingHealthToDestroy) == 0x000178, "Member 'UKatanaTargetingComponent::BuildingRemainingHealthToDestroy' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, DashBlockingBuildingTags) == 0x0001A0, "Member 'UKatanaTargetingComponent::DashBlockingBuildingTags' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, DashBlockingBuildingClasses) == 0x0001C0, "Member 'UKatanaTargetingComponent::DashBlockingBuildingClasses' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, PawnTargetSelectionList) == 0x000210, "Member 'UKatanaTargetingComponent::PawnTargetSelectionList' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, DashTraceChannel) == 0x000258, "Member 'UKatanaTargetingComponent::DashTraceChannel' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, ObstructionOverlapBoxHalfSize) == 0x00025C, "Member 'UKatanaTargetingComponent::ObstructionOverlapBoxHalfSize' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, ObstructionTargetFilter) == 0x000260, "Member 'UKatanaTargetingComponent::ObstructionTargetFilter' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, DashBlockIgnoreTags) == 0x000298, "Member 'UKatanaTargetingComponent::DashBlockIgnoreTags' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, PrimaryAttackVariationInfos) == 0x0002B8, "Member 'UKatanaTargetingComponent::PrimaryAttackVariationInfos' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, PrimaryAttackMinForwardMovement) == 0x000308, "Member 'UKatanaTargetingComponent::PrimaryAttackMinForwardMovement' has a wrong offset!");
static_assert(offsetof(UKatanaTargetingComponent, PrimaryAttackObstructionTraceChannel) == 0x00030C, "Member 'UKatanaTargetingComponent::PrimaryAttackObstructionTraceChannel' has a wrong offset!");

}

