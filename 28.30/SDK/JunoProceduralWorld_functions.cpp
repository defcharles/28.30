#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JunoProceduralWorld

#include "Basic.hpp"

#include "JunoProceduralWorld_classes.hpp"
#include "JunoProceduralWorld_parameters.hpp"


namespace SDK
{

// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.ApplyLandscapeTileSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALandscape*                       LandscapeTile                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LODBlendRange                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCompressedHeightmapStorage                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableRuntimeGrassMapGeneration                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::ApplyLandscapeTileSettings(class ALandscape* LandscapeTile, float LODBlendRange, bool bUseCompressedHeightmapStorage, bool bDisableRuntimeGrassMapGeneration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ApplyLandscapeTileSettings");

	Params::JunoProceduralWorldBlueprintLibrary_ApplyLandscapeTileSettings Parms{};

	Parms.LandscapeTile = LandscapeTile;
	Parms.LODBlendRange = LODBlendRange;
	Parms.bUseCompressedHeightmapStorage = bUseCompressedHeightmapStorage;
	Parms.bDisableRuntimeGrassMapGeneration = bDisableRuntimeGrassMapGeneration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.CalcPOISizeExtent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// EJunoPOISize                            Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UJunoProceduralWorldBlueprintLibrary::CalcPOISizeExtent(EJunoPOISize Size)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CalcPOISizeExtent");

	Params::JunoProceduralWorldBlueprintLibrary_CalcPOISizeExtent Parms{};

	Parms.Size = Size;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.CompareTagSets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<class FName>                       Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<class FName>                       Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoCompareTagSetsResult               Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::CompareTagSets(const TSet<class FName>& Source, const TSet<class FName>& Target, EJunoCompareTagSetsResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CompareTagSets");

	Params::JunoProceduralWorldBlueprintLibrary_CompareTagSets Parms{};

	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.CreateJunoRandomTableKeysIterator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream                    RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FName>                     Keys                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FJunoRandomTableKeysIterator     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FJunoRandomTableKeysIterator UJunoProceduralWorldBlueprintLibrary::CreateJunoRandomTableKeysIterator(const struct FRandomStream& RandomStream, const TArray<class FName>& Keys)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateJunoRandomTableKeysIterator");

	Params::JunoProceduralWorldBlueprintLibrary_CreateJunoRandomTableKeysIterator Parms{};

	Parms.RandomStream = std::move(RandomStream);
	Parms.Keys = std::move(Keys);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.CreateJunoWPLevelFromActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           LevelPackageName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            CreatedLevel                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseWorldPartition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GridName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LoadingRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WorldPartitionGridCellSize                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        WorldPartitionGridCellOrigin                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHLODLayer*                       DefaultHLODLayer                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorldPartitionServerStreamingMode      ServerStreamingMode                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorldPartitionServerStreamingOutMode   ServerStreamingOutMode                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::CreateJunoWPLevelFromActors(const class FString& LevelPackageName, const TArray<class AActor*>& Actors, TSoftObjectPtr<class UWorld>* CreatedLevel, bool bUseWorldPartition, class FName GridName, float LoadingRange, int32 WorldPartitionGridCellSize, const struct FVector2D& WorldPartitionGridCellOrigin, class UHLODLayer* DefaultHLODLayer, EWorldPartitionServerStreamingMode ServerStreamingMode, EWorldPartitionServerStreamingOutMode ServerStreamingOutMode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateJunoWPLevelFromActors");

	Params::JunoProceduralWorldBlueprintLibrary_CreateJunoWPLevelFromActors Parms{};

	Parms.LevelPackageName = std::move(LevelPackageName);
	Parms.Actors = std::move(Actors);
	Parms.bUseWorldPartition = bUseWorldPartition;
	Parms.GridName = GridName;
	Parms.LoadingRange = LoadingRange;
	Parms.WorldPartitionGridCellSize = WorldPartitionGridCellSize;
	Parms.WorldPartitionGridCellOrigin = std::move(WorldPartitionGridCellOrigin);
	Parms.DefaultHLODLayer = DefaultHLODLayer;
	Parms.ServerStreamingMode = ServerStreamingMode;
	Parms.ServerStreamingOutMode = ServerStreamingOutMode;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (CreatedLevel != nullptr)
		*CreatedLevel = Parms.CreatedLevel;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.DeterministicShuffleKeys
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream                    RandomSource                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FName>                     Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UJunoProceduralWorldBlueprintLibrary::DeterministicShuffleKeys(const struct FRandomStream& RandomSource, const TArray<class FName>& Array)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DeterministicShuffleKeys");

	Params::JunoProceduralWorldBlueprintLibrary_DeterministicShuffleKeys Parms{};

	Parms.RandomSource = std::move(RandomSource);
	Parms.Array = std::move(Array);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.DisableLandscapeEditLayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALandscape*                       Landscape                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::DisableLandscapeEditLayers(class ALandscape* Landscape)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DisableLandscapeEditLayers");

	Params::JunoProceduralWorldBlueprintLibrary_DisableLandscapeEditLayers Parms{};

	Parms.Landscape = Landscape;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.EnableLandscapeNaniteSkirts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALandscape*                       Landscape                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SkirtDepth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::EnableLandscapeNaniteSkirts(class ALandscape* Landscape, bool bEnable, float SkirtDepth)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EnableLandscapeNaniteSkirts");

	Params::JunoProceduralWorldBlueprintLibrary_EnableLandscapeNaniteSkirts Parms{};

	Parms.Landscape = Landscape;
	Parms.bEnable = bEnable;
	Parms.SkirtDepth = SkirtDepth;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.FindAllResourcesInFolder
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Folder                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           AssetClass                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          OutPaths                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::FindAllResourcesInFolder(const class FString& Folder, class UClass* AssetClass, TArray<struct FSoftObjectPath>* OutPaths)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindAllResourcesInFolder");

	Params::JunoProceduralWorldBlueprintLibrary_FindAllResourcesInFolder Parms{};

	Parms.Folder = std::move(Folder);
	Parms.AssetClass = AssetClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPaths != nullptr)
		*OutPaths = std::move(Parms.OutPaths);
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.FindNextMatchingPOIResource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoRandomTableKeysIterator     Iterator                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UDataTable*                       DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoPOISize                            SlotPOISize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     SlotTags                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTilePOI             FoundPOI                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoFindNextMatchingPOIResourceResult  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveFromIterator                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::FindNextMatchingPOIResource(const struct FJunoRandomTableKeysIterator& Iterator, const class UDataTable* DataTable, EJunoPOISize SlotPOISize, const TArray<class FName>& SlotTags, struct FPCGJunoWorldTilePOI* FoundPOI, EJunoFindNextMatchingPOIResourceResult* Result, bool bRemoveFromIterator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindNextMatchingPOIResource");

	Params::JunoProceduralWorldBlueprintLibrary_FindNextMatchingPOIResource Parms{};

	Parms.Iterator = std::move(Iterator);
	Parms.DataTable = DataTable;
	Parms.SlotPOISize = SlotPOISize;
	Parms.SlotTags = std::move(SlotTags);
	Parms.bRemoveFromIterator = bRemoveFromIterator;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (FoundPOI != nullptr)
		*FoundPOI = std::move(Parms.FoundPOI);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.FindNextMatchingPOIResourceEx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoRandomTableKeysIterator     Iterator                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UDataTable*                       DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoPOISize                            Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTilePOI             FoundPOI                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoFindNextMatchingPOIResourceResult  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::FindNextMatchingPOIResourceEx(const struct FJunoRandomTableKeysIterator& Iterator, const class UDataTable* DataTable, EJunoPOISize Size, EJunoBiome Biome, struct FPCGJunoWorldTilePOI* FoundPOI, EJunoFindNextMatchingPOIResourceResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindNextMatchingPOIResourceEx");

	Params::JunoProceduralWorldBlueprintLibrary_FindNextMatchingPOIResourceEx Parms{};

	Parms.Iterator = std::move(Iterator);
	Parms.DataTable = DataTable;
	Parms.Size = Size;
	Parms.Biome = Biome;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (FoundPOI != nullptr)
		*FoundPOI = std::move(Parms.FoundPOI);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.GetJunoWorldRegistry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJunoWorldRegistryManager*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJunoWorldRegistryManager* UJunoProceduralWorldBlueprintLibrary::GetJunoWorldRegistry(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetJunoWorldRegistry");

	Params::JunoProceduralWorldBlueprintLibrary_GetJunoWorldRegistry Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.JunoCreateLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoCreateLevelParams           Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            CreatedLevel                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoCreateLevelResult                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::JunoCreateLevel(const struct FJunoCreateLevelParams& Params_0, TSoftObjectPtr<class UWorld>* CreatedLevel, EJunoCreateLevelResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("JunoCreateLevel");

	Params::JunoProceduralWorldBlueprintLibrary_JunoCreateLevel Parms{};

	Parms.Params_0 = std::move(Params_0);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (CreatedLevel != nullptr)
		*CreatedLevel = Parms.CreatedLevel;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.RunParallelCommandlets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             DialogueTitle                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   Commands                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   MaxProcesses                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::RunParallelCommandlets(const class FText& DialogueTitle, const TArray<class FString>& Commands, int32 MaxProcesses)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RunParallelCommandlets");

	Params::JunoProceduralWorldBlueprintLibrary_RunParallelCommandlets Parms{};

	Parms.DialogueTitle = std::move(DialogueTitle);
	Parms.Commands = std::move(Commands);
	Parms.MaxProcesses = MaxProcesses;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.SaveCurrentLevelAs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           NewPackageName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoProceduralWorldBlueprintLibrary::SaveCurrentLevelAs(const class FString& NewPackageName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SaveCurrentLevelAs");

	Params::JunoProceduralWorldBlueprintLibrary_SaveCurrentLevelAs Parms{};

	Parms.NewPackageName = std::move(NewPackageName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.SetBoxBrushSize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Volume                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Size                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::SetBoxBrushSize(class AActor* Volume, const struct FVector& Size)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetBoxBrushSize");

	Params::JunoProceduralWorldBlueprintLibrary_SetBoxBrushSize Parms{};

	Parms.Volume = Volume;
	Parms.Size = std::move(Size);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.SetGridCellSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GridName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CellSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LoadingRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Origin                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::SetGridCellSize(class AActor* WorldContextObject, class FName GridName, float CellSize, float LoadingRange, const struct FVector2D& Origin)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetGridCellSize");

	Params::JunoProceduralWorldBlueprintLibrary_SetGridCellSize Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.GridName = GridName;
	Parms.CellSize = CellSize;
	Parms.LoadingRange = LoadingRange;
	Parms.Origin = std::move(Origin);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.UnionActorBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UJunoProceduralWorldBlueprintLibrary::UnionActorBounds(const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnionActorBounds");

	Params::JunoProceduralWorldBlueprintLibrary_UnionActorBounds Parms{};

	Parms.Actors = std::move(Actors);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointLayerWidthRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULandmassFunctionLibrary::GetControlPointLayerWidthRatio(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetControlPointLayerWidthRatio");

	Params::LandmassFunctionLibrary_GetControlPointLayerWidthRatio Parms{};

	Parms.InControlPoint = InControlPoint;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULandmassFunctionLibrary::GetControlPointLocation(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetControlPointLocation");

	Params::LandmassFunctionLibrary_GetControlPointLocation Parms{};

	Parms.InControlPoint = InControlPoint;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ULandmassFunctionLibrary::GetControlPointRotation(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetControlPointRotation");

	Params::LandmassFunctionLibrary_GetControlPointRotation Parms{};

	Parms.InControlPoint = InControlPoint;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointSideFalloff
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULandmassFunctionLibrary::GetControlPointSideFalloff(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetControlPointSideFalloff");

	Params::LandmassFunctionLibrary_GetControlPointSideFalloff Parms{};

	Parms.InControlPoint = InControlPoint;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointWidth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULandmassFunctionLibrary::GetControlPointWidth(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetControlPointWidth");

	Params::LandmassFunctionLibrary_GetControlPointWidth Parms{};

	Parms.InControlPoint = InControlPoint;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetLandscapeGradientAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D ULandmassFunctionLibrary::GetLandscapeGradientAtLocation(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLandscapeGradientAtLocation");

	Params::LandmassFunctionLibrary_GetLandscapeGradientAtLocation Parms{};

	Parms.LandscapeProxy = LandscapeProxy;
	Parms.Location = std::move(Location);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetLandscapeHeightAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsValidLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULandmassFunctionLibrary::GetLandscapeHeightAtLocation(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location, bool* bIsValidLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLandscapeHeightAtLocation");

	Params::LandmassFunctionLibrary_GetLandscapeHeightAtLocation Parms{};

	Parms.LandscapeProxy = LandscapeProxy;
	Parms.Location = std::move(Location);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (bIsValidLocation != nullptr)
		*bIsValidLocation = Parms.bIsValidLocation;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.LevelInstanceSetAndUpdateWorldAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALevelInstance*                   LevelInstance                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::LevelInstanceSetAndUpdateWorldAsset(class ALevelInstance* LevelInstance, const TSoftObjectPtr<class UWorld>& WorldAsset)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LevelInstanceSetAndUpdateWorldAsset");

	Params::LandmassFunctionLibrary_LevelInstanceSetAndUpdateWorldAsset Parms{};

	Parms.LevelInstance = LevelInstance;
	Parms.WorldAsset = WorldAsset;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.ProjectLocationOnLandscape
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsValidLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULandmassFunctionLibrary::ProjectLocationOnLandscape(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location, bool* bIsValidLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectLocationOnLandscape");

	Params::LandmassFunctionLibrary_ProjectLocationOnLandscape Parms{};

	Parms.LandscapeProxy = LandscapeProxy;
	Parms.Location = std::move(Location);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (bIsValidLocation != nullptr)
		*bIsValidLocation = Parms.bIsValidLocation;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointLayerWidthRatio
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLayerWidthRatio                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointLayerWidthRatio(class ULandscapeSplineControlPoint* InControlPoint, float InLayerWidthRatio)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetControlPointLayerWidthRatio");

	Params::LandmassFunctionLibrary_SetControlPointLayerWidthRatio Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InLayerWidthRatio = InLayerWidthRatio;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointLocation(class ULandscapeSplineControlPoint* InControlPoint, const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetControlPointLocation");

	Params::LandmassFunctionLibrary_SetControlPointLocation Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InLocation = std::move(InLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointRotation(class ULandscapeSplineControlPoint* InControlPoint, const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetControlPointRotation");

	Params::LandmassFunctionLibrary_SetControlPointRotation Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InRotation = std::move(InRotation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointSideFalloff
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSideFalloff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointSideFalloff(class ULandscapeSplineControlPoint* InControlPoint, float InSideFalloff)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetControlPointSideFalloff");

	Params::LandmassFunctionLibrary_SetControlPointSideFalloff Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InSideFalloff = InSideFalloff;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointWidth
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWidth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointWidth(class ULandscapeSplineControlPoint* InControlPoint, float InWidth)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetControlPointWidth");

	Params::LandmassFunctionLibrary_SetControlPointWidth Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InWidth = InWidth;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetStaticMeshAffectDistanceField
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetStaticMeshAffectDistanceField(class UStaticMeshComponent* Mesh, bool bNewValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetStaticMeshAffectDistanceField");

	Params::LandmassFunctionLibrary_SetStaticMeshAffectDistanceField Parms{};

	Parms.Mesh = Mesh;
	Parms.bNewValue = bNewValue;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoBridgePOISelectorComponent.BeginBridgeSelection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoBridgePOISelectorParams     Param_Params_0                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UJunoBridgePOISelectorComponent::BeginBridgeSelection(const struct FJunoBridgePOISelectorParams& Param_Params_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BeginBridgeSelection");

	Params::JunoBridgePOISelectorComponent_BeginBridgeSelection Parms{};

	Parms.Param_Params_0 = std::move(Param_Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoBridgePOISelectorComponent.DoSelection
// (Final, Native, Protected)

void UJunoBridgePOISelectorComponent::DoSelection()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DoSelection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoCaveGeneratorDataMergerInterface.MergeCaveData
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FJunoCaveGeneratorData           CaveData                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void IJunoCaveGeneratorDataMergerInterface::MergeCaveData(struct FJunoCaveGeneratorData* CaveData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MergeCaveData");

	Params::JunoCaveGeneratorDataMergerInterface_MergeCaveData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CaveData != nullptr)
		*CaveData = std::move(Parms.CaveData);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GenerateCaveData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FJunoCaveGeneratorData           ResourceData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDataRegistryType                POIDataRegistry_0                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FJunoCaveSurfaceData             CaveSurfaceData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AJunoTeleporter>      SurfaceTeleporterClass                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoGeneratedCaveShellData>Shells                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIData>             POIs                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveGeneratorPlayspaceComponent::GenerateCaveData(const struct FJunoCaveGeneratorData& ResourceData, const struct FDataRegistryType& POIDataRegistry_0, const struct FRandomStream& RandomStream, const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, const struct FBox& Bounds, const TSubclassOf<class AJunoTeleporter>& SurfaceTeleporterClass, TArray<struct FJunoGeneratedCaveShellData>* Shells, TArray<struct FJunoPOIData>* POIs)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GenerateCaveData");

	Params::JunoCaveGeneratorPlayspaceComponent_GenerateCaveData Parms{};

	Parms.ResourceData = std::move(ResourceData);
	Parms.POIDataRegistry_0 = std::move(POIDataRegistry_0);
	Parms.RandomStream = std::move(RandomStream);
	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.Biome = Biome;
	Parms.Bounds = std::move(Bounds);
	Parms.SurfaceTeleporterClass = SurfaceTeleporterClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Shells != nullptr)
		*Shells = std::move(Parms.Shells);

	if (POIs != nullptr)
		*POIs = std::move(Parms.POIs);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GetMergedCaveDataRegistryData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDataRegistryType                CaveGeneratorDataRegistry                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveGeneratorData           ResourceData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetMergedCaveDataRegistryDataResultResult                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::GetMergedCaveDataRegistryData(const struct FDataRegistryType& CaveGeneratorDataRegistry, struct FJunoCaveGeneratorData* ResourceData, EJunoGetMergedCaveDataRegistryDataResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMergedCaveDataRegistryData");

	Params::JunoCaveGeneratorPlayspaceComponent_GetMergedCaveDataRegistryData Parms{};

	Parms.CaveGeneratorDataRegistry = std::move(CaveGeneratorDataRegistry);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (ResourceData != nullptr)
		*ResourceData = std::move(Parms.ResourceData);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GetMergedMultiCaveDataRegistryData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDataRegistryType                ShellRegistry                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataRegistryType                ThemeRegistry                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataRegistryType                TypeRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataRegistryType                RuleRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveGeneratorData           ResourceData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetMergedCaveDataRegistryDataResultResult                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::GetMergedMultiCaveDataRegistryData(const struct FDataRegistryType& ShellRegistry, const struct FDataRegistryType& ThemeRegistry, const struct FDataRegistryType& TypeRegistry, const struct FDataRegistryType& RuleRegistry, struct FJunoCaveGeneratorData* ResourceData, EJunoGetMergedCaveDataRegistryDataResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMergedMultiCaveDataRegistryData");

	Params::JunoCaveGeneratorPlayspaceComponent_GetMergedMultiCaveDataRegistryData Parms{};

	Parms.ShellRegistry = std::move(ShellRegistry);
	Parms.ThemeRegistry = std::move(ThemeRegistry);
	Parms.TypeRegistry = std::move(TypeRegistry);
	Parms.RuleRegistry = std::move(RuleRegistry);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (ResourceData != nullptr)
		*ResourceData = std::move(Parms.ResourceData);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GetRootCaveGeneratorComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJunoCaveGeneratorPlayspaceComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJunoCaveGeneratorPlayspaceComponent* UJunoCaveGeneratorPlayspaceComponent::GetRootCaveGeneratorComponent(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRootCaveGeneratorComponent");

	Params::JunoCaveGeneratorPlayspaceComponent_GetRootCaveGeneratorComponent Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.IsNativeCaveGeneratorEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveGeneratorPlayspaceComponent::IsNativeCaveGeneratorEnabled()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsNativeCaveGeneratorEnabled");

	Params::JunoCaveGeneratorPlayspaceComponent_IsNativeCaveGeneratorEnabled Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SortCaveGeneratorRules
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FJunoCaveGeneratorRule>   Rules                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveGeneratorRule>   SortedRules                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SortCaveGeneratorRules(const TArray<struct FJunoCaveGeneratorRule>& Rules, TArray<struct FJunoCaveGeneratorRule>* SortedRules)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SortCaveGeneratorRules");

	Params::JunoCaveGeneratorPlayspaceComponent_SortCaveGeneratorRules Parms{};

	Parms.Rules = std::move(Rules);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (SortedRules != nullptr)
		*SortedRules = std::move(Parms.SortedRules);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SortCaveGeneratorShells
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FJunoCaveGeneratorShellData>Shells                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveGeneratorShellData>SortedShells                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SortCaveGeneratorShells(const TArray<struct FJunoCaveGeneratorShellData>& Shells, TArray<struct FJunoCaveGeneratorShellData>* SortedShells)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SortCaveGeneratorShells");

	Params::JunoCaveGeneratorPlayspaceComponent_SortCaveGeneratorShells Parms{};

	Parms.Shells = std::move(Shells);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (SortedShells != nullptr)
		*SortedShells = std::move(Parms.SortedShells);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SortCaveGeneratorThemes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FJunoCaveGeneratorThemeEntry>Themes                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveGeneratorThemeEntry>SortedThemes                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SortCaveGeneratorThemes(const TArray<struct FJunoCaveGeneratorThemeEntry>& Themes, TArray<struct FJunoCaveGeneratorThemeEntry>* SortedThemes)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SortCaveGeneratorThemes");

	Params::JunoCaveGeneratorPlayspaceComponent_SortCaveGeneratorThemes Parms{};

	Parms.Themes = std::move(Themes);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (SortedThemes != nullptr)
		*SortedThemes = std::move(Parms.SortedThemes);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SortCaveGeneratorTypes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FJunoCaveGeneratorTypeData>Types                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveGeneratorTypeData>SortedTypes                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SortCaveGeneratorTypes(const TArray<struct FJunoCaveGeneratorTypeData>& Types, TArray<struct FJunoCaveGeneratorTypeData>* SortedTypes)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SortCaveGeneratorTypes");

	Params::JunoCaveGeneratorPlayspaceComponent_SortCaveGeneratorTypes Parms{};

	Parms.Types = std::move(Types);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (SortedTypes != nullptr)
		*SortedTypes = std::move(Parms.SortedTypes);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GenerateCave
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FJunoCaveSurfaceData             CaveSurfaceData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AJunoTeleporter>      SurfaceTeleporterClass                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::GenerateCave(class AActor* WorldActor, const struct FRandomStream& RandomStream, const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, const struct FBox& Bounds, const TSubclassOf<class AJunoTeleporter>& SurfaceTeleporterClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateCave");

	Params::JunoCaveGeneratorPlayspaceComponent_GenerateCave Parms{};

	Parms.WorldActor = WorldActor;
	Parms.RandomStream = std::move(RandomStream);
	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.Biome = Biome;
	Parms.Bounds = std::move(Bounds);
	Parms.SurfaceTeleporterClass = SurfaceTeleporterClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SetMergedData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoCaveGeneratorData           Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SetMergedData(const struct FJunoCaveGeneratorData& Data)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMergedData");

	Params::JunoCaveGeneratorPlayspaceComponent_SetMergedData Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoLivingWorldStaticPointProvider.AppendFiltersTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoLivingWorldStaticPointProvider::AppendFiltersTags(const struct FGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AppendFiltersTags");

	Params::JunoLivingWorldStaticPointProvider_AppendFiltersTags Parms{};

	Parms.Container = std::move(Container);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveLivingWorldStaticPointProvider.GetCaveShellInstanceData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoCaveShellInstanceData       Data                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetCaveShellInstanceDataResult     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoCaveLivingWorldStaticPointProvider::GetCaveShellInstanceData(struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCaveShellInstanceData");

	Params::JunoCaveLivingWorldStaticPointProvider_GetCaveShellInstanceData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.Load
// (Native, Public, BlueprintCallable)

void AJunoStreamingGameplayVolume::Load()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Load");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.SetBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoStreamingGameplayVolume::SetBounds(const struct FVector& Offset, const struct FVector& Extent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBounds");

	Params::JunoStreamingGameplayVolume_SetBounds Parms{};

	Parms.Offset = std::move(Offset);
	Parms.Extent = std::move(Extent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.Unload
// (Native, Public, BlueprintCallable)

void AJunoStreamingGameplayVolume::Unload()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Unload");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoTileSubsystem.HandlePossessedPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTileSubsystem::HandlePossessedPawnChanged(class APawn* OldPawn, class APawn* Pawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandlePossessedPawnChanged");

	Params::JunoTileSubsystem_HandlePossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTileSubsystem.OnCellActivate
// (Final, Native, Public)
// Parameters:
// class UJunoDynamicRuntimeCell*          Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTileSubsystem::OnCellActivate(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCellActivate");

	Params::JunoTileSubsystem_OnCellActivate Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTileSubsystem.OnCellDeactivate
// (Final, Native, Public)
// Parameters:
// class UJunoDynamicRuntimeCell*          Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTileSubsystem::OnCellDeactivate(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCellDeactivate");

	Params::JunoTileSubsystem_OnCellDeactivate Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTileSubsystem.OnCellLoad
// (Final, Native, Public)
// Parameters:
// class UJunoDynamicRuntimeCell*          Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTileSubsystem::OnCellLoad(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCellLoad");

	Params::JunoTileSubsystem_OnCellLoad Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTileSubsystem.OnCellUnload
// (Final, Native, Public)
// Parameters:
// class UJunoDynamicRuntimeCell*          Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTileSubsystem::OnCellUnload(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCellUnload");

	Params::JunoTileSubsystem_OnCellUnload Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.CalculateCaveShellDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoCave                        Cave                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ShellID_A                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ShellID_B                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoCalculateCaveDistanceResult        Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::CalculateCaveShellDistance(const struct FJunoCave& Cave, const class FName ShellID_A, const class FName ShellID_B, int32* Distance, EJunoCalculateCaveDistanceResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CalculateCaveShellDistance");

	Params::JunoCaveBlueprintLibrary_CalculateCaveShellDistance Parms{};

	Parms.Cave = std::move(Cave);
	Parms.ShellID_A = ShellID_A;
	Parms.ShellID_B = ShellID_B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.CreateCaveInstanceData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoGeneratedCaveShellData>CaveShellData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoCreateCaveResult                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::CreateCaveInstanceData(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const TArray<struct FJunoGeneratedCaveShellData>& CaveShellData, EJunoCreateCaveResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateCaveInstanceData");

	Params::JunoCaveBlueprintLibrary_CreateCaveInstanceData Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellData = std::move(CaveShellData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.CreateCaveInstanceDataForSurfaceData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveSurfaceData             SurfaceData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoGeneratedCaveShellData>CaveShellData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoCreateCaveResult                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::CreateCaveInstanceDataForSurfaceData(const class AActor* POISlotActor, const struct FJunoCaveSurfaceData& SurfaceData, const TArray<struct FJunoGeneratedCaveShellData>& CaveShellData, EJunoCreateCaveResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateCaveInstanceDataForSurfaceData");

	Params::JunoCaveBlueprintLibrary_CreateCaveInstanceDataForSurfaceData Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.SurfaceData = std::move(SurfaceData);
	Parms.CaveShellData = std::move(CaveShellData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.CreateExitsUsedMaskFromArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           ExitsUsed                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UJunoCaveBlueprintLibrary::CreateExitsUsedMaskFromArray(const TArray<int32>& ExitsUsed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateExitsUsedMaskFromArray");

	Params::JunoCaveBlueprintLibrary_CreateExitsUsedMaskFromArray Parms{};

	Parms.ExitsUsed = std::move(ExitsUsed);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.ExitsUsedMaskToArray
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ExitsUsedMask                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UJunoCaveBlueprintLibrary::ExitsUsedMaskToArray(int32 ExitsUsedMask)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ExitsUsedMaskToArray");

	Params::JunoCaveBlueprintLibrary_ExitsUsedMaskToArray Parms{};

	Parms.ExitsUsedMask = ExitsUsedMask;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetBestCaveShellFromArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Area                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FJunoCave                        Cave                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FGuid                            CaveGuid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoGetBestCaveResult                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetBestCaveShellFromArea(const class UObject* WorldContextObject, const struct FBox& Area, struct FJunoCave* Cave, struct FGuid* CaveGuid, class FName* ShellID, EJunoGetBestCaveResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetBestCaveShellFromArea");

	Params::JunoCaveBlueprintLibrary_GetBestCaveShellFromArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Area = std::move(Area);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Cave != nullptr)
		*Cave = std::move(Parms.Cave);

	if (CaveGuid != nullptr)
		*CaveGuid = std::move(Parms.CaveGuid);

	if (ShellID != nullptr)
		*ShellID = Parms.ShellID;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveDataCollectionsFromRegistry
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDataRegistryType                DataRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UJunoCaveDataCollectionBase>>Array                                                  (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// EJunoGetCaveDataCollectionsFromRegistryResultResult                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveDataCollectionsFromRegistry(const struct FDataRegistryType& DataRegistry, TArray<TSoftObjectPtr<class UJunoCaveDataCollectionBase>>* Array, EJunoGetCaveDataCollectionsFromRegistryResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCaveDataCollectionsFromRegistry");

	Params::JunoCaveBlueprintLibrary_GetCaveDataCollectionsFromRegistry Parms{};

	Parms.DataRegistry = std::move(DataRegistry);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Array != nullptr)
		*Array = std::move(Parms.Array);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellInstanceData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           CaveShellChildActor                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveShellInstanceData       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FJunoCaveShellInstanceData UJunoCaveBlueprintLibrary::GetCaveShellInstanceData(const class AActor* CaveShellChildActor, class FName ShellID, bool* Success)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCaveShellInstanceData");

	Params::JunoCaveBlueprintLibrary_GetCaveShellInstanceData Parms{};

	Parms.CaveShellChildActor = CaveShellChildActor;
	Parms.ShellID = ShellID;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellInstanceDataFromActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CaveShellChildActor                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveShellInstanceData       Data                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetCaveShellInstanceDataResult     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveShellInstanceDataFromActor(const class AActor* CaveShellChildActor, class FName ShellID, struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCaveShellInstanceDataFromActor");

	Params::JunoCaveBlueprintLibrary_GetCaveShellInstanceDataFromActor Parms{};

	Parms.CaveShellChildActor = CaveShellChildActor;
	Parms.ShellID = ShellID;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellInstanceDataFromArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Area                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveShellInstanceData       Data                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetCaveShellInstanceDataResult     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveShellInstanceDataFromArea(const class UObject* WorldContextObject, const struct FBox& Area, class FName ShellID, struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCaveShellInstanceDataFromArea");

	Params::JunoCaveBlueprintLibrary_GetCaveShellInstanceDataFromArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Area = std::move(Area);
	Parms.ShellID = ShellID;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellVolumeFromArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Area                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AJunoCaveShellGameplayVolume*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AJunoCaveShellGameplayVolume* UJunoCaveBlueprintLibrary::GetCaveShellVolumeFromArea(const class UObject* WorldContextObject, const struct FBox& Area, class FName ShellID)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCaveShellVolumeFromArea");

	Params::JunoCaveBlueprintLibrary_GetCaveShellVolumeFromArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Area = std::move(Area);
	Parms.ShellID = ShellID;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveSurfaceDataForEntrance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            EntranceGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveSurfaceData             CaveSurfaceData                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// int32                                   CaveIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoGetCaveSurfaceDataForEntranceResultResult                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWorldTeleporterTransforms                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveSurfaceDataForEntrance(const class AActor* Actor, const struct FGuid& EntranceGuid, struct FJunoCaveSurfaceData* CaveSurfaceData, int32* CaveIndex, EJunoGetCaveSurfaceDataForEntranceResult* Result, bool bWorldTeleporterTransforms)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCaveSurfaceDataForEntrance");

	Params::JunoCaveBlueprintLibrary_GetCaveSurfaceDataForEntrance Parms{};

	Parms.Actor = Actor;
	Parms.EntranceGuid = std::move(EntranceGuid);
	Parms.bWorldTeleporterTransforms = bWorldTeleporterTransforms;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (CaveSurfaceData != nullptr)
		*CaveSurfaceData = std::move(Parms.CaveSurfaceData);

	if (CaveIndex != nullptr)
		*CaveIndex = Parms.CaveIndex;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.IsBitSet
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bit                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveBlueprintLibrary::IsBitSet(int32 BitMask, int32 Bit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsBitSet");

	Params::JunoCaveBlueprintLibrary_IsBitSet Parms{};

	Parms.BitMask = BitMask;
	Parms.Bit = Bit;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.NeedsCaveShellInstanceData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveBlueprintLibrary::NeedsCaveShellInstanceData(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NeedsCaveShellInstanceData");

	Params::JunoCaveBlueprintLibrary_NeedsCaveShellInstanceData Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.QueryCaveDataStateFromActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoQueryCaveDataResult                Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveTeleporterLink>  Teleporters                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::QueryCaveDataStateFromActor(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, EJunoQueryCaveDataResult* Result, struct FBox* WorldTileBounds, TArray<struct FJunoCaveTeleporterLink>* Teleporters)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("QueryCaveDataStateFromActor");

	Params::JunoCaveBlueprintLibrary_QueryCaveDataStateFromActor Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);

	if (Teleporters != nullptr)
		*Teleporters = std::move(Parms.Teleporters);
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.QueryCaveDataStateFromSurfaceData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveSurfaceData             SurfaceData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoQueryCaveDataResult                Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveTeleporterLink>  Teleporters                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::QueryCaveDataStateFromSurfaceData(const class AActor* POISlotActor, const struct FJunoCaveSurfaceData& SurfaceData, EJunoQueryCaveDataResult* Result, struct FBox* WorldTileBounds, TArray<struct FJunoCaveTeleporterLink>* Teleporters)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("QueryCaveDataStateFromSurfaceData");

	Params::JunoCaveBlueprintLibrary_QueryCaveDataStateFromSurfaceData Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.SurfaceData = std::move(SurfaceData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);

	if (Teleporters != nullptr)
		*Teleporters = std::move(Parms.Teleporters);
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.QueryCaveShellInstanceDataState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoQueryCaveDataResult                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EJunoQueryCaveDataResult UJunoCaveBlueprintLibrary::QueryCaveShellInstanceDataState(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("QueryCaveShellInstanceDataState");

	Params::JunoCaveBlueprintLibrary_QueryCaveShellInstanceDataState Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.QueryCaveSurfaceDataState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoQueryCaveSurfaceDataStateResult    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::QueryCaveSurfaceDataState(const class AActor* Actor, EJunoQueryCaveSurfaceDataStateResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("QueryCaveSurfaceDataState");

	Params::JunoCaveBlueprintLibrary_QueryCaveSurfaceDataState Parms{};

	Parms.Actor = Actor;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.SetCaveSurfaceData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveSurfaceData>     CaveSurfaceData                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::SetCaveSurfaceData(const class AActor* Actor, const TArray<struct FJunoCaveSurfaceData>& CaveSurfaceData)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetCaveSurfaceData");

	Params::JunoCaveBlueprintLibrary_SetCaveSurfaceData Parms{};

	Parms.Actor = Actor;
	Parms.CaveSurfaceData = std::move(CaveSurfaceData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolumePlayspaceComponent.NotifyActorBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveVolumePlayspaceComponent::NotifyActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NotifyActorBeginOverlap");

	Params::JunoCaveVolumePlayspaceComponent_NotifyActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolumePlayspaceComponent.NotifyActorEndOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveVolumePlayspaceComponent::NotifyActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NotifyActorEndOverlap");

	Params::JunoCaveVolumePlayspaceComponent_NotifyActorEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolumePlayspaceComponent.OnPlayerEnteringCaveVolume
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveVolumePlayspaceComponent::OnPlayerEnteringCaveVolume(class AFortPlayerPawnAthena* PlayerPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlayerEnteringCaveVolume");

	Params::JunoCaveVolumePlayspaceComponent_OnPlayerEnteringCaveVolume Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolumePlayspaceComponent.OnPlayerLeavingCaveVolume
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveVolumePlayspaceComponent::OnPlayerLeavingCaveVolume(class AFortPlayerPawnAthena* PlayerPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlayerLeavingCaveVolume");

	Params::JunoCaveVolumePlayspaceComponent_OnPlayerLeavingCaveVolume Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoDumpMapTileImages
// (Final, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoDumpMapTileImages()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("JunoDumpMapTileImages");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoGoActor
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           ActorClassName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoGoActor(const class FString& ActorClassName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("JunoGoActor");

	Params::JunoCheatManager_ProceduralWorld_JunoGoActor Parms{};

	Parms.ActorClassName = std::move(ActorClassName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoGoBiome
// (Final, Exec, Native, Private)
// Parameters:
// class FName                             Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoGoBiome(class FName Biome)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("JunoGoBiome");

	Params::JunoCheatManager_ProceduralWorld_JunoGoBiome Parms{};

	Parms.Biome = Biome;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoGoNearActor
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           ActorClassName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoGoNearActor(const class FString& ActorClassName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("JunoGoNearActor");

	Params::JunoCheatManager_ProceduralWorld_JunoGoNearActor Parms{};

	Parms.ActorClassName = std::move(ActorClassName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoLogStreamingVolumesDebugInfo
// (Final, BlueprintAuthorityOnly, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoLogStreamingVolumesDebugInfo()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("JunoLogStreamingVolumesDebugInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoPOIVolumeDump
// (Final, BlueprintAuthorityOnly, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoPOIVolumeDump()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("JunoPOIVolumeDump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoPOIVolumeDumpAll
// (Final, BlueprintAuthorityOnly, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoPOIVolumeDumpAll()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("JunoPOIVolumeDumpAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoGenerateTileInterface.GenerateTile
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FJunoGenerateTileParams          Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IJunoGenerateTileInterface::GenerateTile(const struct FJunoGenerateTileParams& Params_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateTile");

	Params::JunoGenerateTileInterface_GenerateTile Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoGenerateTileCommandlet.FinishedGenerating
// (Final, Native, Public, BlueprintCallable)

void UJunoGenerateTileCommandlet::FinishedGenerating()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FinishedGenerating");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoInstancedActorComponent.OnRep_InstanceHandle
// (Final, Native, Protected)

void UJunoInstancedActorComponent::OnRep_InstanceHandle()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_InstanceHandle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoInstancedActorComponent.HasMassEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoInstancedActorComponent::HasMassEntity() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasMassEntity");

	Params::JunoInstancedActorComponent_HasMassEntity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoInstancedActorData.GetManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AJunoInstancedActorManager*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AJunoInstancedActorManager* UJunoInstancedActorData::GetManager() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetManager");

	Params::JunoInstancedActorData_GetManager Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ChooseDebugTile
// (RequiredAPI, Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile                OutSelectedTile                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::ChooseDebugTile(const class UObject* WorldContextObject, const struct FVector& Position, struct FPCGJunoWorldTile* OutSelectedTile)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChooseDebugTile");

	Params::JunoWorldTileSelectionBase_ChooseDebugTile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);

	UObject::ProcessEvent(Func, &Parms);

	if (OutSelectedTile != nullptr)
		*OutSelectedTile = std::move(Parms.OutSelectedTile);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ChooseOutOfBoundsTile
// (RequiredAPI, Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile                OutSelectedTile                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::ChooseOutOfBoundsTile(const class UObject* WorldContextObject, struct FPCGJunoWorldTile* OutSelectedTile)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChooseOutOfBoundsTile");

	Params::JunoWorldTileSelectionBase_ChooseOutOfBoundsTile Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);

	if (OutSelectedTile != nullptr)
		*OutSelectedTile = std::move(Parms.OutSelectedTile);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ChooseStartTile
// (RequiredAPI, Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartTileLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::ChooseStartTile(const class UObject* WorldContextObject, struct FVector* StartTileLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChooseStartTile");

	Params::JunoWorldTileSelectionBase_ChooseStartTile Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);

	if (StartTileLocation != nullptr)
		*StartTileLocation = std::move(Parms.StartTileLocation);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ChooseTile
// (RequiredAPI, Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile                OutSelectedTile                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::ChooseTile(const class UObject* WorldContextObject, const struct FVector& Position, struct FPCGJunoWorldTile* OutSelectedTile)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChooseTile");

	Params::JunoWorldTileSelectionBase_ChooseTile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);

	UObject::ProcessEvent(Func, &Parms);

	if (OutSelectedTile != nullptr)
		*OutSelectedTile = std::move(Parms.OutSelectedTile);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.GetDebugLevelLocation
// (RequiredAPI, Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UJunoWorldTileSelectionBase::GetDebugLevelLocation(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDebugLevelLocation");

	Params::JunoWorldTileSelectionBase_GetDebugLevelLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.Setup
// (RequiredAPI, Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::Setup(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Setup");

	Params::JunoWorldTileSelectionBase_Setup Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.UpdateTile
// (RequiredAPI, Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile                CurrentTile                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile                OutUpdatedTile                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::UpdateTile(const class UObject* WorldContextObject, const struct FPCGJunoWorldTile& CurrentTile, struct FPCGJunoWorldTile* OutUpdatedTile)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateTile");

	Params::JunoWorldTileSelectionBase_UpdateTile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CurrentTile = std::move(CurrentTile);

	UObject::ProcessEvent(Func, &Parms);

	if (OutUpdatedTile != nullptr)
		*OutUpdatedTile = std::move(Parms.OutUpdatedTile);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.UseReservedArea
// (RequiredAPI, Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, struct FBox2D>        AreaTiles                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FPCGJunoWorldTile>        OutNewTiles                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::UseReservedArea(const class UObject* WorldContextObject, const class FName& AreaName, const TMap<class FName, struct FBox2D>& AreaTiles, TArray<struct FPCGJunoWorldTile>* OutNewTiles)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UseReservedArea");

	Params::JunoWorldTileSelectionBase_UseReservedArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AreaName = AreaName;
	Parms.AreaTiles = std::move(AreaTiles);

	UObject::ProcessEvent(Func, &Parms);

	if (OutNewTiles != nullptr)
		*OutNewTiles = std::move(Parms.OutNewTiles);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.ApplyCurrentPhaseOverrides
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UJunoLifecycleComponent::ApplyCurrentPhaseOverrides()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ApplyCurrentPhaseOverrides");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoLifecycleComponent.OnRep_CurrentPhaseIndex
// (Final, Native, Protected)
// Parameters:
// uint8                                   PreviousLifecyclePhaseIndex                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoLifecycleComponent::OnRep_CurrentPhaseIndex(uint8 PreviousLifecyclePhaseIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_CurrentPhaseIndex");

	Params::JunoLifecycleComponent_OnRep_CurrentPhaseIndex Parms{};

	Parms.PreviousLifecyclePhaseIndex = PreviousLifecyclePhaseIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoLifecycleComponent.SetCurrentPhaseByIndex
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   NewCurrentPhaseIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeElapsedInNewPhase                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::SetCurrentPhaseByIndex(uint8 NewCurrentPhaseIndex, float TimeElapsedInNewPhase, bool bUpdateMass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCurrentPhaseByIndex");

	Params::JunoLifecycleComponent_SetCurrentPhaseByIndex Parms{};

	Parms.NewCurrentPhaseIndex = NewCurrentPhaseIndex;
	Parms.TimeElapsedInNewPhase = TimeElapsedInNewPhase;
	Parms.bUpdateMass = bUpdateMass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.BP_GetCurrentPhase
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FJunoLifecyclePhase              OutCurrentPhase                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::BP_GetCurrentPhase(struct FJunoLifecyclePhase* OutCurrentPhase) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_GetCurrentPhase");

	Params::JunoLifecycleComponent_BP_GetCurrentPhase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutCurrentPhase != nullptr)
		*OutCurrentPhase = std::move(Parms.OutCurrentPhase);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.GetCurrentPhaseIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UJunoLifecycleComponent::GetCurrentPhaseIndex() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentPhaseIndex");

	Params::JunoLifecycleComponent_GetCurrentPhaseIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.GetCurrentPhaseTimeElapsed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UJunoLifecycleComponent::GetCurrentPhaseTimeElapsed() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentPhaseTimeElapsed");

	Params::JunoLifecycleComponent_GetCurrentPhaseTimeElapsed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.HasCompletedLifecycle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::HasCompletedLifecycle() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasCompletedLifecycle");

	Params::JunoLifecycleComponent_HasCompletedLifecycle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetTileForLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AJunoWorldTile*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AJunoWorldTile* UJunoWorldRegistryManager::GetTileForLocation(const class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTileForLocation");

	Params::JunoWorldRegistryManager_GetTileForLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetClosestEntryUsingTagQuery
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// EJunoWorldRegistryType                  EntryType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagQuery                TagQuery                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          QueryLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoWorldRegistryEntry          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FJunoWorldRegistryEntry UJunoWorldRegistryManager::GetClosestEntryUsingTagQuery(EJunoWorldRegistryType EntryType, const struct FGameplayTagQuery& TagQuery, const struct FVector& QueryLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClosestEntryUsingTagQuery");

	Params::JunoWorldRegistryManager_GetClosestEntryUsingTagQuery Parms{};

	Parms.EntryType = EntryType;
	Parms.TagQuery = std::move(TagQuery);
	Parms.QueryLocation = std::move(QueryLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetBiomeAtLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoBiomeInfoQueryResult        OutResult                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetBiomeAtLocation(const struct FVector& Location, struct FJunoBiomeInfoQueryResult* OutResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBiomeAtLocation");

	Params::JunoWorldRegistryManager_GetBiomeAtLocation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetNormalizedTileLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldRegistryManager::GetNormalizedTileLocation(const class UObject* WorldContextObject, const struct FVector& WorldLocation, struct FVector* OutResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNormalizedTileLocation");

	Params::JunoWorldRegistryManager_GetNormalizedTileLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetTileMiniMapTexture
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UJunoWorldRegistryManager::GetTileMiniMapTexture(const class UObject* WorldContextObject, const struct FVector& WorldLocation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTileMiniMapTexture");

	Params::JunoWorldRegistryManager_GetTileMiniMapTexture Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWaterDirectionInformationAtLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeNearMisses                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutInWater                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoWaterLocationResult> OutResult                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetWaterDirectionInformationAtLocation(const struct FVector& Location, bool bIncludeNearMisses, bool* OutInWater, TArray<struct FJunoWaterLocationResult>* OutResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWaterDirectionInformationAtLocation");

	Params::JunoWorldRegistryManager_GetWaterDirectionInformationAtLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.bIncludeNearMisses = bIncludeNearMisses;

	UObject::ProcessEvent(Func, &Parms);

	if (OutInWater != nullptr)
		*OutInWater = Parms.OutInWater;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWaterInformationInDirection
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoWaterLocationResult         OutResult                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetWaterInformationInDirection(const struct FVector& Location, const struct FVector& Direction, struct FJunoWaterLocationResult* OutResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWaterInformationInDirection");

	Params::JunoWorldRegistryManager_GetWaterInformationInDirection Parms{};

	Parms.Location = std::move(Location);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWorldAnalyticsInfo
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoWorldAnalyticsInfoResult    WorldAnalyticsInfo                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetWorldAnalyticsInfo(const class UObject* WorldContextObject, const struct FVector& WorldLocation, struct FJunoWorldAnalyticsInfoResult* WorldAnalyticsInfo) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldAnalyticsInfo");

	Params::JunoWorldRegistryManager_GetWorldAnalyticsInfo Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (WorldAnalyticsInfo != nullptr)
		*WorldAnalyticsInfo = std::move(Parms.WorldAnalyticsInfo);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWorldBounds
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds UJunoWorldRegistryManager::GetWorldBounds() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldBounds");

	Params::JunoWorldRegistryManager_GetWorldBounds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWorldDebugInfoText
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AFortPlayerPawn*                  PlayerPawn                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoDebugWorldInfoResult        WorldDebugInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetWorldDebugInfoText(const class AFortPlayerPawn* PlayerPawn, struct FJunoDebugWorldInfoResult* WorldDebugInfo) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldDebugInfoText");

	Params::JunoWorldRegistryManager_GetWorldDebugInfoText Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);

	if (WorldDebugInfo != nullptr)
		*WorldDebugInfo = std::move(Parms.WorldDebugInfo);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.FixupAllJunoLandscapeWeightmapLayers
// (Final, Native, Static, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::FixupAllJunoLandscapeWeightmapLayers()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FixupAllJunoLandscapeWeightmapLayers");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.FixupWorldLandscapeWeightmapLayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::FixupWorldLandscapeWeightmapLayers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FixupWorldLandscapeWeightmapLayers");

	Params::JunoTerrainGenerationSystem_FixupWorldLandscapeWeightmapLayers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.ForceSaveForMissingLayers
// (Final, Native, Static, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::ForceSaveForMissingLayers()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ForceSaveForMissingLayers");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.ValidateSavedTiles
// (Final, Native, Static, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::ValidateSavedTiles()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ValidateSavedTiles");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GenerateServerPrecachedData
// (Final, Native, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::GenerateServerPrecachedData()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateServerPrecachedData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnCellActivate
// (Final, Native, Public)
// Parameters:
// class UJunoDynamicRuntimeCell*          Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnCellActivate(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCellActivate");

	Params::JunoTerrainGenerationSystem_OnCellActivate Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnCellDeactivate
// (Final, Native, Public)
// Parameters:
// class UJunoDynamicRuntimeCell*          Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnCellDeactivate(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCellDeactivate");

	Params::JunoTerrainGenerationSystem_OnCellDeactivate Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnCellLoad
// (Final, Native, Public)
// Parameters:
// class UJunoDynamicRuntimeCell*          Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnCellLoad(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCellLoad");

	Params::JunoTerrainGenerationSystem_OnCellLoad Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnCellUnload
// (Final, Native, Public)
// Parameters:
// class UJunoDynamicRuntimeCell*          Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnCellUnload(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCellUnload");

	Params::JunoTerrainGenerationSystem_OnCellUnload Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnProxyDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnProxyDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnProxyDestroyed");

	Params::JunoTerrainGenerationSystem_OnProxyDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GetInterpolatedOceanInformation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutLocationIsOcean                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoTerrainWaterInformation>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FJunoTerrainWaterInformation> UJunoTerrainGenerationSystem::GetInterpolatedOceanInformation(const struct FVector& Location, bool* OutLocationIsOcean) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInterpolatedOceanInformation");

	Params::JunoTerrainGenerationSystem_GetInterpolatedOceanInformation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (OutLocationIsOcean != nullptr)
		*OutLocationIsOcean = Parms.OutLocationIsOcean;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GetInterpolatedWaterInformation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutLocationIsWater                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoTerrainWaterInformation>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FJunoTerrainWaterInformation> UJunoTerrainGenerationSystem::GetInterpolatedWaterInformation(const struct FVector& Location, bool* OutLocationIsWater) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInterpolatedWaterInformation");

	Params::JunoTerrainGenerationSystem_GetInterpolatedWaterInformation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (OutLocationIsWater != nullptr)
		*OutLocationIsWater = Parms.OutLocationIsWater;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GetWaterInformationAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoTerrainWaterInformation     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FJunoTerrainWaterInformation UJunoTerrainGenerationSystem::GetWaterInformationAtLocation(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWaterInformationAtLocation");

	Params::JunoTerrainGenerationSystem_GetWaterInformationAtLocation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GetWaterInformationInDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoTerrainWaterInformation     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FJunoTerrainWaterInformation UJunoTerrainGenerationSystem::GetWaterInformationInDirection(const struct FVector& Location, const struct FVector& Direction) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWaterInformationInDirection");

	Params::JunoTerrainGenerationSystem_GetWaterInformationInDirection Parms{};

	Parms.Location = std::move(Location);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoMinimapGenerator.CreatePackageAndSaveTexture2D
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PackageName                                            (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPackage*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPackage* AJunoMinimapGenerator::CreatePackageAndSaveTexture2D(class UTextureRenderTarget2D* RenderTarget, const class FString& PackageName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreatePackageAndSaveTexture2D");

	Params::JunoMinimapGenerator_CreatePackageAndSaveTexture2D Parms{};

	Parms.RenderTarget = RenderTarget;
	Parms.PackageName = std::move(PackageName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPCGVolume.CalcCompressedObjectCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AJunoPCGVolume::CalcCompressedObjectCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CalcCompressedObjectCount");

	Params::JunoPCGVolume_CalcCompressedObjectCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPCGVolume.CalculateCompressedDataSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AJunoPCGVolume::CalculateCompressedDataSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CalculateCompressedDataSize");

	Params::JunoPCGVolume_CalculateCompressedDataSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPCGVolume.IsGeneratorBusy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoPCGVolume::IsGeneratorBusy() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsGeneratorBusy");

	Params::JunoPCGVolume_IsGeneratorBusy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPCGVolume.IsSpawnerBusy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoPCGVolume::IsSpawnerBusy() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSpawnerBusy");

	Params::JunoPCGVolume_IsSpawnerBusy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPOIPreselectorComponent.BeginPreselection
// (Final, Native, Public, BlueprintCallable)

void UJunoPOIPreselectorComponent::BeginPreselection()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BeginPreselection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoPOIPreselectorComponent.OnSpawnPositionSet
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FUniqueNetIdRepl                 ID                                                     (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIPreselectorComponent::OnSpawnPositionSet(const struct FUniqueNetIdRepl& ID, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSpawnPositionSet");

	Params::JunoPOIPreselectorComponent_OnSpawnPositionSet Parms{};

	Parms.ID = std::move(ID);
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoPOIPreselectorComponent.OnWorldTileContentsAvailable
// (Final, Native, Protected)

void UJunoPOIPreselectorComponent::OnWorldTileContentsAvailable()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnWorldTileContentsAvailable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoCaveGeneratorInterface.GenerateCave
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FJunoCaveSurfaceData             CaveSurfaceData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CaveIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void IJunoCaveGeneratorInterface::GenerateCave(const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, int32 CaveIndex, const struct FBox& Bounds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateCave");

	Params::JunoCaveGeneratorInterface_GenerateCave Parms{};

	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.Biome = Biome;
	Parms.CaveIndex = CaveIndex;
	Parms.Bounds = std::move(Bounds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.CaveGridResolution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UJunoPOISelectorComponent::CaveGridResolution()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CaveGridResolution");

	Params::JunoPOISelectorComponent_CaveGridResolution Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.IsNativePOISelectorEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoPOISelectorComponent::IsNativePOISelectorEnabled()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsNativePOISelectorEnabled");

	Params::JunoPOISelectorComponent_IsNativePOISelectorEnabled Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.IsPOIPreselectorActorReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoPOISelectorComponent::IsPOIPreselectorActorReady(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsPOIPreselectorActorReady");

	Params::JunoPOISelectorComponent_IsPOIPreselectorActorReady Parms{};

	Parms.Actor = Actor;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.BeginPOISelection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoPOISelectorParams           Param_Params_0                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoPOISelectorComponent::BeginPOISelection(const struct FJunoPOISelectorParams& Param_Params_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BeginPOISelection");

	Params::JunoPOISelectorComponent_BeginPOISelection Parms{};

	Parms.Param_Params_0 = std::move(Param_Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.DoSelection
// (Final, Native, Protected)

void UJunoPOISelectorComponent::DoSelection()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DoSelection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.TriggerCaveGeneration
// (Final, Native, Public, BlueprintCallable)

void UJunoPOISelectorComponent::TriggerCaveGeneration()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TriggerCaveGeneration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoWaterSplineInjector.ForceWaterUpdate
// (Final, Native, Public, BlueprintCallable)

void UJunoWaterSplineInjector::ForceWaterUpdate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceWaterUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoWaterSplineInjector.InjectSplineGuideIntoWaterBody
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoWaterSplineInjectorParams   Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoWaterSplineInjector::InjectSplineGuideIntoWaterBody(const struct FJunoWaterSplineInjectorParams& Params_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InjectSplineGuideIntoWaterBody");

	Params::JunoWaterSplineInjector_InjectSplineGuideIntoWaterBody Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoWorldLocalEnvironmentComponent.OnRep_ServerBiome
// (Final, Native, Private)

void UJunoWorldLocalEnvironmentComponent::OnRep_ServerBiome()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ServerBiome");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoWorldTile.ArePositionsInSameWorldTile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationA                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationB                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoWorldTile::ArePositionsInSameWorldTile(class UObject* WorldContextObject, const struct FVector& LocationA, const struct FVector& LocationB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ArePositionsInSameWorldTile");

	Params::JunoWorldTile_ArePositionsInSameWorldTile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LocationA = std::move(LocationA);
	Parms.LocationB = std::move(LocationB);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTile.GetJunoWorldTileBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ActorInWorldTile                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             TileBounds                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EJunoGetWorldTileBoundsResult           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoWorldTile::GetJunoWorldTileBounds(class AActor* ActorInWorldTile, struct FBox* TileBounds, EJunoGetWorldTileBoundsResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetJunoWorldTileBounds");

	Params::JunoWorldTile_GetJunoWorldTileBounds Parms{};

	Parms.ActorInWorldTile = ActorInWorldTile;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (TileBounds != nullptr)
		*TileBounds = std::move(Parms.TileBounds);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoWorldTile.GetJunoWorldTileTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ActorInWorldTile                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoGetWorldTileTransformResult        Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoWorldTile::GetJunoWorldTileTransform(class AActor* ActorInWorldTile, struct FTransform* Transform, EJunoGetWorldTileTransformResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetJunoWorldTileTransform");

	Params::JunoWorldTile_GetJunoWorldTileTransform Parms{};

	Parms.ActorInWorldTile = ActorInWorldTile;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoWorldTile.ClientOnAllLevelsLoaded
// (Final, Native, Private)

void AJunoWorldTile::ClientOnAllLevelsLoaded()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientOnAllLevelsLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoWorldTile.OnUnloadBegin
// (Final, Native, Private)
// Parameters:
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoWorldTile::OnUnloadBegin(class ULevel* Level)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnUnloadBegin");

	Params::JunoWorldTile_OnUnloadBegin Parms{};

	Parms.Level = Level;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoWorldTile.IsTestLevelWorldTile
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoWorldTile::IsTestLevelWorldTile() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsTestLevelWorldTile");

	Params::JunoWorldTile_IsTestLevelWorldTile Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileControllerComponent.ClientCheckWorldTileState
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// TArray<struct FJunoDebugWorldTileState> WorldTileState                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoWorldTileControllerComponent::ClientCheckWorldTileState(const TArray<struct FJunoDebugWorldTileState>& WorldTileState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientCheckWorldTileState");

	Params::JunoWorldTileControllerComponent_ClientCheckWorldTileState Parms{};

	Parms.WorldTileState = std::move(WorldTileState);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoWorldTileControllerComponent.ServerCheckWorldTileState
// (Net, NetReliable, Native, Event, Public, NetServer)

void UJunoWorldTileControllerComponent::ServerCheckWorldTileState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerCheckWorldTileState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionAgatha.GenerateCornersForUI
// (Final, RequiredAPI, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EJunoBiome>                      Corners                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionAgatha::GenerateCornersForUI(const class UObject* WorldContextObject, TArray<EJunoBiome>* Corners)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateCornersForUI");

	Params::JunoWorldTileSelectionAgatha_GenerateCornersForUI Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);

	if (Corners != nullptr)
		*Corners = std::move(Parms.Corners);
}


// Function JunoProceduralWorld.JunoWorldWeatherLocationComponent.HandleEnvironmentChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoBiomeInfoQueryResult        PreviousEnvironmentResult                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FJunoBiomeInfoQueryResult        NewEnvironmentResult                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UJunoWorldWeatherLocationComponent::HandleEnvironmentChanged(const class AActor* Actor, const struct FJunoBiomeInfoQueryResult& PreviousEnvironmentResult, const struct FJunoBiomeInfoQueryResult& NewEnvironmentResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleEnvironmentChanged");

	Params::JunoWorldWeatherLocationComponent_HandleEnvironmentChanged Parms{};

	Parms.Actor = Actor;
	Parms.PreviousEnvironmentResult = std::move(PreviousEnvironmentResult);
	Parms.NewEnvironmentResult = std::move(NewEnvironmentResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.AdditionalPushFrontierResultCondition
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// EPushFrontierResult                     ResultFromLastPush                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLandmassPathfinderRules         InCurrentRules                                         (Parm, NativeAccessSpecifierPublic)
// struct FVector                          InHome                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InDestination                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InCurrentLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCurrentPushSteps                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCurrentCost                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldUseBestNodeInsteadOfMostRecentNode              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPushFrontierResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPushFrontierResult ULandmassPathfinder::AdditionalPushFrontierResultCondition(EPushFrontierResult ResultFromLastPush, const struct FLandmassPathfinderRules& InCurrentRules, const struct FVector& InHome, const struct FVector& InDestination, const struct FVector& InCurrentLocation, int32 InCurrentPushSteps, float InCurrentCost, bool* bShouldUseBestNodeInsteadOfMostRecentNode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AdditionalPushFrontierResultCondition");

	Params::LandmassPathfinder_AdditionalPushFrontierResultCondition Parms{};

	Parms.ResultFromLastPush = ResultFromLastPush;
	Parms.InCurrentRules = std::move(InCurrentRules);
	Parms.InHome = std::move(InHome);
	Parms.InDestination = std::move(InDestination);
	Parms.InCurrentLocation = std::move(InCurrentLocation);
	Parms.InCurrentPushSteps = InCurrentPushSteps;
	Parms.InCurrentCost = InCurrentCost;

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldUseBestNodeInsteadOfMostRecentNode != nullptr)
		*bShouldUseBestNodeInsteadOfMostRecentNode = Parms.bShouldUseBestNodeInsteadOfMostRecentNode;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.ExecutePathfinderSync
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Locations                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           Costs                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULandmassPathfinder::ExecutePathfinderSync(const struct FVector& A, const struct FVector& B, TArray<struct FVector>* Locations, TArray<float>* Costs)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ExecutePathfinderSync");

	Params::LandmassPathfinder_ExecutePathfinderSync Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	UObject::ProcessEvent(Func, &Parms);

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);

	if (Costs != nullptr)
		*Costs = std::move(Parms.Costs);
}


// Function JunoProceduralWorld.LandmassPathfinder.FindNearestValidLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutValidLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldProject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::FindNearestValidLocation(const struct FVector& InLocation, struct FVector* OutValidLocation, bool bShouldProject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindNearestValidLocation");

	Params::LandmassPathfinder_FindNearestValidLocation Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.bShouldProject = bShouldProject;

	UObject::ProcessEvent(Func, &Parms);

	if (OutValidLocation != nullptr)
		*OutValidLocation = std::move(Parms.OutValidLocation);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy_0                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InRoute                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLandmassPathfinderRules         Rules                                                  (Parm, NativeAccessSpecifierPublic)
// TArray<class ULandmassPathfinder*>      InBackStopPaths                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InBlockingRoute                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::Initialize(class ALandscapeProxy* LandscapeProxy_0, class ALandmassProceduralRoute* InRoute, const struct FLandmassPathfinderRules& Rules, const TArray<class ULandmassPathfinder*>& InBackStopPaths, class ALandmassProceduralRoute* InBlockingRoute)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Initialize");

	Params::LandmassPathfinder_Initialize Parms{};

	Parms.LandscapeProxy_0 = LandscapeProxy_0;
	Parms.InRoute = InRoute;
	Parms.Rules = std::move(Rules);
	Parms.InBackStopPaths = std::move(InBackStopPaths);
	Parms.InBlockingRoute = InBlockingRoute;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.IsTargetLocationValid
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::IsTargetLocationValid(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsTargetLocationValid");

	Params::LandmassPathfinder_IsTargetLocationValid Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.K2_GetPriorityList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Locations                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           Costs                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULandmassPathfinder::K2_GetPriorityList(TArray<struct FVector>* Locations, TArray<float>* Costs)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetPriorityList");

	Params::LandmassPathfinder_K2_GetPriorityList Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);

	if (Costs != nullptr)
		*Costs = std::move(Parms.Costs);
}


// Function JunoProceduralWorld.LandmassPathfinder.K2_StepPathfinder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  OutLocations                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           OutCosts                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>                            bOutIsSnapped                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<EPathfinderNodeState>            OutNodeStates                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EPushFrontierResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPushFrontierResult ULandmassPathfinder::K2_StepPathfinder(TArray<struct FVector>* OutLocations, TArray<float>* OutCosts, TArray<bool>* bOutIsSnapped, TArray<EPathfinderNodeState>* OutNodeStates)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_StepPathfinder");

	Params::LandmassPathfinder_K2_StepPathfinder Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutLocations != nullptr)
		*OutLocations = std::move(Parms.OutLocations);

	if (OutCosts != nullptr)
		*OutCosts = std::move(Parms.OutCosts);

	if (bOutIsSnapped != nullptr)
		*bOutIsSnapped = std::move(Parms.bOutIsSnapped);

	if (OutNodeStates != nullptr)
		*OutNodeStates = std::move(Parms.OutNodeStates);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.OnInitialize
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALandscapeProxy*                  InLandscapeProxy                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InRoute                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLandmassPathfinderRules         Rules                                                  (Parm, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InBlockingRoute                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::OnInitialize(class ALandscapeProxy* InLandscapeProxy, class ALandmassProceduralRoute* InRoute, const struct FLandmassPathfinderRules& Rules, class ALandmassProceduralRoute* InBlockingRoute)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnInitialize");

	Params::LandmassPathfinder_OnInitialize Parms{};

	Parms.InLandscapeProxy = InLandscapeProxy;
	Parms.InRoute = InRoute;
	Parms.Rules = std::move(Rules);
	Parms.InBlockingRoute = InBlockingRoute;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.OnStartPathfinder
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::OnStartPathfinder(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnStartPathfinder");

	Params::LandmassPathfinder_OnStartPathfinder Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.SetDestination
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::SetDestination(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDestination");

	Params::LandmassPathfinder_SetDestination Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.SetDestinationActuallyReached
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::SetDestinationActuallyReached(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDestinationActuallyReached");

	Params::LandmassPathfinder_SetDestinationActuallyReached Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.StartPathfinder
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFindNearestValidLocationForA                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFindNearestValidLocationForB                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::StartPathfinder(const struct FVector& A, const struct FVector& B, const bool bFindNearestValidLocationForA, const bool bFindNearestValidLocationForB)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartPathfinder");

	Params::LandmassPathfinder_StartPathfinder Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.bFindNearestValidLocationForA = bFindNearestValidLocationForA;
	Parms.bFindNearestValidLocationForB = bFindNearestValidLocationForB;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.GetIsInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::GetIsInitialized() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIsInitialized");

	Params::LandmassPathfinder_GetIsInitialized Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.GetLandscapeBox
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox ULandmassPathfinder::GetLandscapeBox() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLandscapeBox");

	Params::LandmassPathfinder_GetLandscapeBox Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.ProjectLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIsValidLocation                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULandmassPathfinder::ProjectLocation(const struct FVector& Location, bool* bOutIsValidLocation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ProjectLocation");

	Params::LandmassPathfinder_ProjectLocation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (bOutIsValidLocation != nullptr)
		*bOutIsValidLocation = Parms.bOutIsValidLocation;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.LoadCurveSetAndAddSplineComponentsToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPathfinderGuideSetsDataAsset::LoadCurveSetAndAddSplineComponentsToActor(class AActor* InActor, int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LoadCurveSetAndAddSplineComponentsToActor");

	Params::PathfinderGuideSetsDataAsset_LoadCurveSetAndAddSplineComponentsToActor Parms{};

	Parms.InActor = InActor;
	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.SaveCurveSetFromSplintComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class USplineComponent*>         SourceComponents                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPathfinderGuideSetsDataAsset::SaveCurveSetFromSplintComponents(const TArray<class USplineComponent*>& SourceComponents, int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SaveCurveSetFromSplintComponents");

	Params::PathfinderGuideSetsDataAsset_SaveCurveSetFromSplintComponents Parms{};

	Parms.SourceComponents = std::move(SourceComponents);
	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.GetRandomGuideSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPathfinderGuideSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPathfinderGuideSet UPathfinderGuideSetsDataAsset::GetRandomGuideSet() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRandomGuideSet");

	Params::PathfinderGuideSetsDataAsset_GetRandomGuideSet Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.GetRandomGuideSetFromSeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPathfinderGuideSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPathfinderGuideSet UPathfinderGuideSetsDataAsset::GetRandomGuideSetFromSeed(int32 Seed) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRandomGuideSetFromSeed");

	Params::PathfinderGuideSetsDataAsset_GetRandomGuideSetFromSeed Parms{};

	Parms.Seed = Seed;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveVolume.OnPlayerEnteringCaveVolume
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoCaveVolume::OnPlayerEnteringCaveVolume(class AFortPlayerPawnAthena* PlayerPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlayerEnteringCaveVolume");

	Params::JunoCaveVolume_OnPlayerEnteringCaveVolume Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolume.OnPlayerLeavingCaveVolume
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoCaveVolume::OnPlayerLeavingCaveVolume(class AFortPlayerPawnAthena* PlayerPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlayerLeavingCaveVolume");

	Params::JunoCaveVolume_OnPlayerLeavingCaveVolume Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolume.RetrievePointProviders
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class AJunoCaveLivingWorldStaticPointProvider*>OutPointProviders                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AJunoCaveVolume::RetrievePointProviders(TArray<class AJunoCaveLivingWorldStaticPointProvider*>* OutPointProviders)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RetrievePointProviders");

	Params::JunoCaveVolume_RetrievePointProviders Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutPointProviders != nullptr)
		*OutPointProviders = std::move(Parms.OutPointProviders);
}


// Function JunoProceduralWorld.JunoLevelInstance.GetActorsInLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> AJunoLevelInstance::GetActorsInLevel()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorsInLevel");

	Params::JunoLevelInstance_GetActorsInLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLivingWorldStaticPointProviderCluster.OnCurrentPlaylistLoaded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             PlaylistName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            PlaylistContextTags                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoLivingWorldStaticPointProviderCluster::OnCurrentPlaylistLoaded(class FName PlaylistName, const struct FGameplayTagContainer& PlaylistContextTags)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCurrentPlaylistLoaded");

	Params::JunoLivingWorldStaticPointProviderCluster_OnCurrentPlaylistLoaded Parms{};

	Parms.PlaylistName = PlaylistName;
	Parms.PlaylistContextTags = std::move(PlaylistContextTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreateCavePOI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoPOIData                     Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGeneratePOIResult                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreateCavePOI(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, const struct FJunoPOIData& Data, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateCavePOI");

	Params::JunoPOIBlueprintLibrary_CreateCavePOI Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);
	Parms.Data = std::move(Data);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreatePOI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoPOIData                     Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGeneratePOIResult                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreatePOI(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, const struct FJunoPOIData& Data, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreatePOI");

	Params::JunoPOIBlueprintLibrary_CreatePOI Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);
	Parms.Data = std::move(Data);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreateRarePOIs
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDataRegistryType                DataRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>      PotentialSlots                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>      UsedSlots                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EGeneratePOIResult                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreateRarePOIs(const class AActor* Actor, const struct FRandomStream& RandomStream, const struct FDataRegistryType& DataRegistry, TArray<struct FJunoPOIManagerSlot>& PotentialSlots, TArray<struct FJunoPOIManagerSlot>* UsedSlots, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateRarePOIs");

	Params::JunoPOIBlueprintLibrary_CreateRarePOIs Parms{};

	Parms.Actor = Actor;
	Parms.RandomStream = std::move(RandomStream);
	Parms.DataRegistry = std::move(DataRegistry);
	Parms.PotentialSlots = std::move(PotentialSlots);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	PotentialSlots = std::move(Parms.PotentialSlots);

	if (UsedSlots != nullptr)
		*UsedSlots = std::move(Parms.UsedSlots);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.FindBestPOISlots
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FJunoPOIManagerSlot>      PotentialSlots                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>      AdditionalCompareSlots                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   DesiredNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  DesiredMinDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>      Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>      Remainder                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FBox                             WorldTileBounds                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnforceMinDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::FindBestPOISlots(const TArray<struct FJunoPOIManagerSlot>& PotentialSlots, const TArray<struct FJunoPOIManagerSlot>& AdditionalCompareSlots, int32 DesiredNumber, double DesiredMinDistance, TArray<struct FJunoPOIManagerSlot>* Result, TArray<struct FJunoPOIManagerSlot>* Remainder, const struct FBox& WorldTileBounds, EJunoBiome Biome, bool bEnforceMinDistance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindBestPOISlots");

	Params::JunoPOIBlueprintLibrary_FindBestPOISlots Parms{};

	Parms.PotentialSlots = std::move(PotentialSlots);
	Parms.AdditionalCompareSlots = std::move(AdditionalCompareSlots);
	Parms.DesiredNumber = DesiredNumber;
	Parms.DesiredMinDistance = DesiredMinDistance;
	Parms.WorldTileBounds = std::move(WorldTileBounds);
	Parms.Biome = Biome;
	Parms.bEnforceMinDistance = bEnforceMinDistance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (Remainder != nullptr)
		*Remainder = std::move(Parms.Remainder);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.GetMatchingPOIsFromDataRegistry
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDataRegistryType                DataRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class FName>                       Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<EJunoPOISize>                      Sizes                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<EJunoBiome>                        Biomes                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FPCGJunoWorldTilePOI>     Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoGetMatchingPOIsFromDataRegistryResultResult                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoWorldTilePOIType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::GetMatchingPOIsFromDataRegistry(const struct FDataRegistryType& DataRegistry, const TSet<class FName>& Tags, const TSet<EJunoPOISize>& Sizes, const TSet<EJunoBiome>& Biomes, const TArray<struct FPCGJunoWorldTilePOI>& Array, EJunoGetMatchingPOIsFromDataRegistryResult* Result, EJunoWorldTilePOIType Type)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMatchingPOIsFromDataRegistry");

	Params::JunoPOIBlueprintLibrary_GetMatchingPOIsFromDataRegistry Parms{};

	Parms.DataRegistry = std::move(DataRegistry);
	Parms.Tags = std::move(Tags);
	Parms.Sizes = std::move(Sizes);
	Parms.Biomes = std::move(Biomes);
	Parms.Array = std::move(Array);
	Parms.Type = Type;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.MarkCavePOISlotUnused
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoMarkSlotPOIUnusedResult            Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::MarkCavePOISlotUnused(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, EJunoMarkSlotPOIUnusedResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MarkCavePOISlotUnused");

	Params::JunoPOIBlueprintLibrary_MarkCavePOISlotUnused Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.MarkPOISlotUnused
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoMarkSlotPOIUnusedResult            Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::MarkPOISlotUnused(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, EJunoMarkSlotPOIUnusedResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MarkPOISlotUnused");

	Params::JunoPOIBlueprintLibrary_MarkPOISlotUnused Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.QueryCavePOIState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQueryPOIStateResult                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::QueryCavePOIState(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, EQueryPOIStateResult* Result, struct FBox* WorldTileBounds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("QueryCavePOIState");

	Params::JunoPOIBlueprintLibrary_QueryCavePOIState Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.QueryPOIState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQueryPOIStateResult                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoPOISlotMetaData             POISlotMetaData                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox                             WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::QueryPOIState(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, EQueryPOIStateResult* Result, struct FJunoPOISlotMetaData* POISlotMetaData, struct FBox* WorldTileBounds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("QueryPOIState");

	Params::JunoPOIBlueprintLibrary_QueryPOIState Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (POISlotMetaData != nullptr)
		*POISlotMetaData = std::move(Parms.POISlotMetaData);

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.SetPOISlotMetaDatas
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>      POISlots                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FJunoPOISlotMetaData             POISlotMetaData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EJunoSetSlotPOIMetaDataResult           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::SetPOISlotMetaDatas(const class AActor* POISlotActor, const TArray<struct FJunoPOIManagerSlot>& POISlots, const struct FJunoPOISlotMetaData& POISlotMetaData, EJunoSetSlotPOIMetaDataResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetPOISlotMetaDatas");

	Params::JunoPOIBlueprintLibrary_SetPOISlotMetaDatas Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlots = std::move(POISlots);
	Parms.POISlotMetaData = std::move(POISlotMetaData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralFoundation.AddAdditionalWorld
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UWorld>            World                                                  (Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoProceduralFoundation::AddAdditionalWorld(TSoftObjectPtr<class UWorld>& World)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAdditionalWorld");

	Params::JunoProceduralFoundation_AddAdditionalWorld Parms{};

	Parms.World = World;

	UObject::ProcessEvent(Func, &Parms);

	World = Parms.World;
}


// Function JunoProceduralWorld.JunoRoadAINavigationCluster.OnCurrentPlaylistLoaded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             PlaylistName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            PlaylistContextTags                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoRoadAINavigationCluster::OnCurrentPlaylistLoaded(class FName PlaylistName, const struct FGameplayTagContainer& PlaylistContextTags)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCurrentPlaylistLoaded");

	Params::JunoRoadAINavigationCluster_OnCurrentPlaylistLoaded Parms{};

	Parms.PlaylistName = PlaylistName;
	Parms.PlaylistContextTags = std::move(PlaylistContextTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassCluster.InitializeDentrogram
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   InActors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDendrogramLeafAttributes>InAttributes                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULandmassCluster::InitializeDentrogram(const TArray<class AActor*>& InActors, const TArray<struct FDendrogramLeafAttributes>& InAttributes)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitializeDentrogram");

	Params::LandmassCluster_InitializeDentrogram Parms{};

	Parms.InActors = std::move(InActors);
	Parms.InAttributes = std::move(InAttributes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassCluster.K2_AddConnection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           LeafActorA                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           LeafActorB                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassCluster::K2_AddConnection(class AActor* LeafActorA, class AActor* LeafActorB)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddConnection");

	Params::LandmassCluster_K2_AddConnection Parms{};

	Parms.LeafActorA = LeafActorA;
	Parms.LeafActorB = LeafActorB;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetClustersAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FDendrogramClusterOutput>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FDendrogramClusterOutput> ULandmassCluster::GetClustersAtLevel(int32 InLevel) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClustersAtLevel");

	Params::LandmassCluster_GetClustersAtLevel Parms{};

	Parms.InLevel = InLevel;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetLeafCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULandmassCluster::GetLeafCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLeafCount");

	Params::LandmassCluster_GetLeafCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetTopLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULandmassCluster::GetTopLevel() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTopLevel");

	Params::LandmassCluster_GetTopLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRouteDefinition.FindLocationClosestToWorldLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDistanceSqr                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UProceduralRouteDefinition::FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, float* OutDistanceSqr) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindLocationClosestToWorldLocation");

	Params::ProceduralRouteDefinition_FindLocationClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutDistanceSqr != nullptr)
		*OutDistanceSqr = Parms.OutDistanceSqr;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddAvoidancePrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FRouteAvoidancePrimitive         InPrimitive                                            (ConstParm, Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::AddAvoidancePrimitive(const struct FRouteAvoidancePrimitive& InPrimitive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAvoidancePrimitive");

	Params::LandmassProceduralRoute_AddAvoidancePrimitive Parms{};

	Parms.InPrimitive = std::move(InPrimitive);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddConnection
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           LeafActorA                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           LeafActorB                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::AddConnection(class AActor* LeafActorA, class AActor* LeafActorB)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddConnection");

	Params::LandmassProceduralRoute_AddConnection Parms{};

	Parms.LeafActorA = LeafActorA;
	Parms.LeafActorB = LeafActorB;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddControlPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::AddControlPoint(const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddControlPoint");

	Params::LandmassProceduralRoute_AddControlPoint Parms{};

	Parms.WorldPosition = std::move(WorldPosition);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.BeginGeneratePCG
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FLandmassPCGRouteInput>   Inputs                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::BeginGeneratePCG(const TArray<struct FLandmassPCGRouteInput>& Inputs)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BeginGeneratePCG");

	Params::LandmassProceduralRoute_BeginGeneratePCG Parms{};

	Parms.Inputs = std::move(Inputs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.ClearCreatedLandscapeSplines
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::ClearCreatedLandscapeSplines()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearCreatedLandscapeSplines");

	Params::LandmassProceduralRoute_ClearCreatedLandscapeSplines Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.CustomTick
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::CustomTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CustomTick");

	Params::LandmassProceduralRoute_CustomTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.FinishRoute
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   OutRouteIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::FinishRoute(int32* OutRouteIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FinishRoute");

	Params::LandmassProceduralRoute_FinishRoute Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutRouteIndex != nullptr)
		*OutRouteIndex = Parms.OutRouteIndex;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GenerateCluster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::GenerateCluster()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateCluster");

	Params::LandmassProceduralRoute_GenerateCluster Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.InitLandmassCluster
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   InActors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDendrogramLeafAttributes>InLeafAttributes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::InitLandmassCluster(const TArray<class AActor*>& InActors, const TArray<struct FDendrogramLeafAttributes>& InLeafAttributes)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitLandmassCluster");

	Params::LandmassProceduralRoute_InitLandmassCluster Parms{};

	Parms.InActors = std::move(InActors);
	Parms.InLeafAttributes = std::move(InLeafAttributes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.InitLandmassClusterLeavesOnly
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FDendrogramLeafAttributes>InLeafAttributes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::InitLandmassClusterLeavesOnly(const TArray<struct FDendrogramLeafAttributes>& InLeafAttributes)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitLandmassClusterLeavesOnly");

	Params::LandmassProceduralRoute_InitLandmassClusterLeavesOnly Parms{};

	Parms.InLeafAttributes = std::move(InLeafAttributes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.OnGenerationFinished
// (Final, Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::OnGenerationFinished()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnGenerationFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.PutIntoDormancy
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::PutIntoDormancy()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PutIntoDormancy");

	Params::LandmassProceduralRoute_PutIntoDormancy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.RasterizeAllPendingRoutesToRouteGrid
// (Final, Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::RasterizeAllPendingRoutesToRouteGrid()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RasterizeAllPendingRoutesToRouteGrid");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.ResetAllAndInitialize
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetAllLandscapeSplines                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::ResetAllAndInitialize(bool bResetAllLandscapeSplines)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetAllAndInitialize");

	Params::LandmassProceduralRoute_ResetAllAndInitialize Parms{};

	Parms.bResetAllLandscapeSplines = bResetAllLandscapeSplines;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetCurrentRouteGenerationState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERouteGenerationState                   InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetCurrentRouteGenerationState(ERouteGenerationState InState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCurrentRouteGenerationState");

	Params::LandmassProceduralRoute_SetCurrentRouteGenerationState Parms{};

	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetEditorTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetEditorTickEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEditorTickEnabled");

	Params::LandmassProceduralRoute_SetEditorTickEnabled Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetWidthAtPointIndex
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetWidthAtPointIndex(int32 Index_0, float NewWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWidthAtPointIndex");

	Params::LandmassProceduralRoute_SetWidthAtPointIndex Parms{};

	Parms.Index_0 = Index_0;
	Parms.NewWidth = NewWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetWidthForLastAddedPoint
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetWidthForLastAddedPoint(float NewWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWidthForLastAddedPoint");

	Params::LandmassProceduralRoute_SetWidthForLastAddedPoint Parms{};

	Parms.NewWidth = NewWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.StartRoute
// (Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::StartRoute()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartRoute");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.WakeUpDormantRoute
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::WakeUpDormantRoute()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WakeUpDormantRoute");

	Params::LandmassProceduralRoute_WakeUpDormantRoute Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetCurrentRouteGenerationState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERouteGenerationState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERouteGenerationState ALandmassProceduralRoute::GetCurrentRouteGenerationState() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentRouteGenerationState");

	Params::LandmassProceduralRoute_GetCurrentRouteGenerationState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetLandmassCluster
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULandmassCluster*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULandmassCluster* ALandmassProceduralRoute::GetLandmassCluster() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLandmassCluster");

	Params::LandmassProceduralRoute_GetLandmassCluster Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetRouteDefinitions
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRouteDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRouteDefinition*> ALandmassProceduralRoute::GetRouteDefinitions() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRouteDefinitions");

	Params::LandmassProceduralRoute_GetRouteDefinitions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideAnyLake
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideAnyLake(const struct FVector& Location, float Tolerance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInsideAnyLake");

	Params::LandmassProceduralRoute_IsInsideAnyLake Parms{};

	Parms.Location = std::move(Location);
	Parms.Tolerance = Tolerance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideAnyLakeAccurate
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideAnyLakeAccurate(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInsideAnyLakeAccurate");

	Params::LandmassProceduralRoute_IsInsideAnyLakeAccurate Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideLake
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWaterBody*                       InLake                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Dilation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideLake(const struct FVector& Location, const class AWaterBody* InLake, float Dilation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInsideLake");

	Params::LandmassProceduralRoute_IsInsideLake Parms{};

	Parms.Location = std::move(Location);
	Parms.InLake = InLake;
	Parms.Dilation = Dilation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideOcean
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideOcean(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInsideOcean");

	Params::LandmassProceduralRoute_IsInsideOcean Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRiverDefinition.GetWaterBodyActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWaterBody*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWaterBody* UProceduralRiverDefinition::GetWaterBodyActor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWaterBodyActor");

	Params::ProceduralRiverDefinition_GetWaterBodyActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRiverDefinition.GetWaterSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWaterSplineComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWaterSplineComponent* UProceduralRiverDefinition::GetWaterSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWaterSpline");

	Params::ProceduralRiverDefinition_GetWaterSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetAudioIntensityAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetAudioIntensityAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAudioIntensityAtDistanceAlongSpline");

	Params::ProceduralRivers_GetAudioIntensityAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetDepthAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetDepthAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDepthAtDistanceAlongSpline");

	Params::ProceduralRivers_GetDepthAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetHalfWidthAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetHalfWidthAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetHalfWidthAtDistanceAlongSpline");

	Params::ProceduralRivers_GetHalfWidthAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetProceduralRiverActorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AProceduralRivers::GetProceduralRiverActorTag()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProceduralRiverActorTag");

	Params::ProceduralRivers_GetProceduralRiverActorTag Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetVelocityScalarAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetVelocityScalarAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetVelocityScalarAtDistanceAlongSpline");

	Params::ProceduralRivers_GetVelocityScalarAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetRiverMergeSearchNeighborGridSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetRiverMergeSearchNeighborGridSize()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRiverMergeSearchNeighborGridSize");

	Params::ProceduralRivers_GetRiverMergeSearchNeighborGridSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.HaltRiverGeneration
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::HaltRiverGeneration()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HaltRiverGeneration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.ProceduralRivers.InitializeNeighborGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRivers::InitializeNeighborGrid()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitializeNeighborGrid");

	Params::ProceduralRivers_InitializeNeighborGrid Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.RebuildLastRiver
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::RebuildLastRiver()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RebuildLastRiver");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.ProceduralRivers.SetRiverTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELandmassRiverTier                      InRiverTier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProceduralRivers::SetRiverTier(ELandmassRiverTier InRiverTier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRiverTier");

	Params::ProceduralRivers_SetRiverTier Parms{};

	Parms.InRiverTier = InRiverTier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.ProceduralRivers.StartRiverGeneration
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::StartRiverGeneration()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartRiverGeneration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.ProceduralRivers.SurfaceLocationOverride
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIsOverriden                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AProceduralRivers::SurfaceLocationOverride(const struct FVector& InLocation, bool* bOutIsOverriden)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SurfaceLocationOverride");

	Params::ProceduralRivers_SurfaceLocationOverride Parms{};

	Parms.InLocation = std::move(InLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (bOutIsOverriden != nullptr)
		*bOutIsOverriden = Parms.bOutIsOverriden;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.VisualizeAnchors
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::VisualizeAnchors()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("VisualizeAnchors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.ProceduralRivers.GetAvailableSourceAnchors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FProceduralRiverAnchor>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FProceduralRiverAnchor> AProceduralRivers::GetAvailableSourceAnchors() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAvailableSourceAnchors");

	Params::ProceduralRivers_GetAvailableSourceAnchors Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetAvailableTargetAnchors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FProceduralRiverAnchor>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FProceduralRiverAnchor> AProceduralRivers::GetAvailableTargetAnchors() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAvailableTargetAnchors");

	Params::ProceduralRivers_GetAvailableTargetAnchors Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetGenerationRules
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELandmassRiverTier                      InRiverTier                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProceduralRiverGenRules         OutRules                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRivers::GetGenerationRules(const ELandmassRiverTier InRiverTier, struct FProceduralRiverGenRules* OutRules) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGenerationRules");

	Params::ProceduralRivers_GetGenerationRules Parms{};

	Parms.InRiverTier = InRiverTier;

	UObject::ProcessEvent(Func, &Parms);

	if (OutRules != nullptr)
		*OutRules = std::move(Parms.OutRules);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetRiverDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRiverDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRiverDefinition*> AProceduralRivers::GetRiverDefinitions() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRiverDefinitions");

	Params::ProceduralRivers_GetRiverDefinitions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.EvaluateRouteAtLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UProceduralRoadDefinition*        InRoute                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTransformToWorld                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSegmentInterpResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSegmentInterpResult AProceduralRoads::EvaluateRouteAtLength(const class UProceduralRoadDefinition* InRoute, float InLength, bool bTransformToWorld)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EvaluateRouteAtLength");

	Params::ProceduralRoads_EvaluateRouteAtLength Parms{};

	Parms.InRoute = InRoute;
	Parms.InLength = InLength;
	Parms.bTransformToWorld = bTransformToWorld;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetProceduralRoadActorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AProceduralRoads::GetProceduralRoadActorTag()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProceduralRoadActorTag");

	Params::ProceduralRoads_GetProceduralRoadActorTag Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetProceduralRoadLoopAnchorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   LoopIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AProceduralRoads::GetProceduralRoadLoopAnchorTag(int32 LoopIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProceduralRoadLoopAnchorTag");

	Params::ProceduralRoads_GetProceduralRoadLoopAnchorTag Parms{};

	Parms.LoopIndex = LoopIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.DisableOverrideGenRules
// (Final, Native, Public, BlueprintCallable)

void AProceduralRoads::DisableOverrideGenRules()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableOverrideGenRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.ProceduralRoads.EnableOverrideGenRules
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FProceduralRoadGenRules          InOverrideGenRules                                     (Parm, NativeAccessSpecifierPublic)

void AProceduralRoads::EnableOverrideGenRules(const struct FProceduralRoadGenRules& InOverrideGenRules)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableOverrideGenRules");

	Params::ProceduralRoads_EnableOverrideGenRules Parms{};

	Parms.InOverrideGenRules = std::move(InOverrideGenRules);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.ProceduralRoads.GetAllControlPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ULandscapeSplineControlPoint*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULandscapeSplineControlPoint*> AProceduralRoads::GetAllControlPoints()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllControlPoints");

	Params::ProceduralRoads_GetAllControlPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.InitializeNeighborGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRoads::InitializeNeighborGrid()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitializeNeighborGrid");

	Params::ProceduralRoads_InitializeNeighborGrid Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.K2_GetRoadGridDataAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> AProceduralRoads::K2_GetRoadGridDataAtLocation(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetRoadGridDataAtLocation");

	Params::ProceduralRoads_K2_GetRoadGridDataAtLocation Parms{};

	Parms.InLocation = std::move(InLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.RemoveHardTurnControlPoint
// (Final, Native, Protected, BlueprintCallable)

void AProceduralRoads::RemoveHardTurnControlPoint()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveHardTurnControlPoint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.ProceduralRoads.SetRoadTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELandmassRoadTier                       InRoadTier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProceduralRoads::SetRoadTier(ELandmassRoadTier InRoadTier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRoadTier");

	Params::ProceduralRoads_SetRoadTier Parms{};

	Parms.InRoadTier = InRoadTier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.ProceduralRoads.UpdateLandscapeSplines
// (Final, Native, Protected, BlueprintCallable)

void AProceduralRoads::UpdateLandscapeSplines()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateLandscapeSplines");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JunoProceduralWorld.ProceduralRoads.GetGenerationRules
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELandmassRoadTier                       InRoadTier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProceduralRoadGenRules          OutRules                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRoads::GetGenerationRules(const ELandmassRoadTier InRoadTier, struct FProceduralRoadGenRules* OutRules) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGenerationRules");

	Params::ProceduralRoads_GetGenerationRules Parms{};

	Parms.InRoadTier = InRoadTier;

	UObject::ProcessEvent(Func, &Parms);

	if (OutRules != nullptr)
		*OutRules = std::move(Parms.OutRules);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetRoadDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRoadDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRoadDefinition*> AProceduralRoads::GetRoadDefinitions() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRoadDefinitions");

	Params::ProceduralRoads_GetRoadDefinitions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetRoadMergeSearchNeighborGridSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRoads::GetRoadMergeSearchNeighborGridSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRoadMergeSearchNeighborGridSize");

	Params::ProceduralRoads_GetRoadMergeSearchNeighborGridSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLivingWorldLightStaticPointProvider.AppendFiltersTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoLivingWorldLightStaticPointProvider::AppendFiltersTags(const struct FGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AppendFiltersTags");

	Params::JunoLivingWorldLightStaticPointProvider_AppendFiltersTags Parms{};

	Parms.Container = std::move(Container);

	UObject::ProcessEvent(Func, &Parms);
}

}

