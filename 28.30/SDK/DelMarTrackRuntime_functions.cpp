#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DelMarTrackRuntime

#include "Basic.hpp"

#include "DelMarTrackRuntime_classes.hpp"
#include "DelMarTrackRuntime_parameters.hpp"


namespace SDK
{

// Function DelMarTrackRuntime.DelMarTrackBase.ConvertTrackTagsToV2
// (Final, Native, Public)

void ADelMarTrackBase::ConvertTrackTagsToV2()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConvertTrackTagsToV2");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetAllTrackSegmentActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ADelMarTrackSegmentBase*>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADelMarTrackSegmentBase*> ADelMarTrackBase::GetAllTrackSegmentActors()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllTrackSegmentActors");

	Params::DelMarTrackBase_GetAllTrackSegmentActors Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.InitializeSpline
// (Event, Protected, BlueprintEvent)

void ADelMarTrackBase::InitializeSpline()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitializeSpline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnMetadataChanged
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnMetadataChanged(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMetadataChanged");

	Params::DelMarTrackBase_OnMetadataChanged Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnSplineClosedLoopChanged
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnSplineClosedLoopChanged(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSplineClosedLoopChanged");

	Params::DelMarTrackBase_OnSplineClosedLoopChanged Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnSplinePointAdded
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnSplinePointAdded(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSplinePointAdded");

	Params::DelMarTrackBase_OnSplinePointAdded Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnSplinePointChanged
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnSplinePointChanged(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSplinePointChanged");

	Params::DelMarTrackBase_OnSplinePointChanged Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnSplinePointRemoved
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnSplinePointRemoved(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnSplinePointRemoved");

	Params::DelMarTrackBase_OnSplinePointRemoved Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.PostRebuildTrack_BP
// (Event, Protected, BlueprintEvent)

void ADelMarTrackBase::PostRebuildTrack_BP()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PostRebuildTrack_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackBase.PostSplineSegmentGenerated
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDelMarTrackSplineComponent*      SplineComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::PostSplineSegmentGenerated(class UDelMarTrackSplineComponent* SplineComp, int32 PointIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PostSplineSegmentGenerated");

	Params::DelMarTrackBase_PostSplineSegmentGenerated Parms{};

	Parms.SplineComp = SplineComp;
	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.PreRebuildTrack_BP
// (Event, Protected, BlueprintEvent)

void ADelMarTrackBase::PreRebuildTrack_BP()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PreRebuildTrack_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackBase.PreSplineSegmentGenerated
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDelMarTrackSplineComponent*      SplineComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::PreSplineSegmentGenerated(class UDelMarTrackSplineComponent* SplineComp, int32 PointIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PreSplineSegmentGenerated");

	Params::DelMarTrackBase_PreSplineSegmentGenerated Parms{};

	Parms.SplineComp = SplineComp;
	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.RebuildTrack
// (Final, Native, Public)

void ADelMarTrackBase::RebuildTrack()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RebuildTrack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackBase.SetTrackTypeTagAtIndex
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::SetTrackTypeTagAtIndex(int32 SplineIndex, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTrackTypeTagAtIndex");

	Params::DelMarTrackBase_SetTrackTypeTagAtIndex Parms{};

	Parms.SplineIndex = SplineIndex;
	Parms.tag = std::move(tag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.ForceValidOOBTube
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::ForceValidOOBTube() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceValidOOBTube");

	Params::DelMarTrackBase_ForceValidOOBTube Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.ForceValidTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::ForceValidTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceValidTrack");

	Params::DelMarTrackBase_ForceValidTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetDistanceRangeFromPointRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDelMarTrackPointIndexRange      InRange                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDelMarTrackPointDistanceRange   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDelMarTrackPointDistanceRange ADelMarTrackBase::GetDistanceRangeFromPointRange(const struct FDelMarTrackPointIndexRange& InRange) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDistanceRangeFromPointRange");

	Params::DelMarTrackBase_GetDistanceRangeFromPointRange Parms{};

	Parms.InRange = std::move(InRange);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetEndCapClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ADelMarTrackBase::GetEndCapClass(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEndCapClass");

	Params::DelMarTrackBase_GetEndCapClass Parms{};

	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetForwardDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrackBase::GetForwardDistance(float Start, float End) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetForwardDistance");

	Params::DelMarTrackBase_GetForwardDistance Parms{};

	Parms.Start = Start;
	Parms.End = End;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetLoopDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTotalDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrackBase::GetLoopDistance(float InTotalDistance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLoopDistance");

	Params::DelMarTrackBase_GetLoopDistance Parms{};

	Parms.InTotalDistance = InTotalDistance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetMetaDataAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDelMarSplinePointMetaData ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDelMarSplinePointMetaData ADelMarTrackBase::GetMetaDataAtSplinePoint(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMetaDataAtSplinePoint");

	Params::DelMarTrackBase_GetMetaDataAtSplinePoint Parms{};

	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetNextSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplinePoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTrackBase::GetNextSplinePoint(int32 InSplinePoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNextSplinePoint");

	Params::DelMarTrackBase_GetNextSplinePoint Parms{};

	Parms.InSplinePoint = InSplinePoint;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetNextSplineSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplineSegmentIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTrackBase::GetNextSplineSegment(int32 InSplineSegmentIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNextSplineSegment");

	Params::DelMarTrackBase_GetNextSplineSegment Parms{};

	Parms.InSplineSegmentIndex = InSplineSegmentIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetPreviousSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplinePoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTrackBase::GetPreviousSplinePoint(int32 InSplinePoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPreviousSplinePoint");

	Params::DelMarTrackBase_GetPreviousSplinePoint Parms{};

	Parms.InSplinePoint = InSplinePoint;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetPreviousSplineSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplineSegmentIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTrackBase::GetPreviousSplineSegment(int32 InSplineSegmentIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPreviousSplineSegment");

	Params::DelMarTrackBase_GetPreviousSplineSegment Parms{};

	Parms.InSplineSegmentIndex = InSplineSegmentIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetSegmentClassAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ADelMarTrackBase::GetSegmentClassAtSplinePoint(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSegmentClassAtSplinePoint");

	Params::DelMarTrackBase_GetSegmentClassAtSplinePoint Parms{};

	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetSegmentTrackTypeTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag ADelMarTrackBase::GetSegmentTrackTypeTag(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSegmentTrackTypeTag");

	Params::DelMarTrackBase_GetSegmentTrackTypeTag Parms{};

	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetStartCapClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ADelMarTrackBase::GetStartCapClass(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStartCapClass");

	Params::DelMarTrackBase_GetStartCapClass Parms{};

	Parms.SplineIndex = SplineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetTransitionSegmentClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FromSplineIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToSplineIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ADelMarTrackBase::GetTransitionSegmentClass(int32 FromSplineIndex, int32 ToSplineIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransitionSegmentClass");

	Params::DelMarTrackBase_GetTransitionSegmentClass Parms{};

	Parms.FromSplineIndex = FromSplineIndex;
	Parms.ToSplineIndex = ToSplineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsCosmetic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsCosmetic() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsCosmetic");

	Params::DelMarTrackBase_IsCosmetic Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsDistanceWithinRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsDistanceWithinRange(float InDistance, float StartDistance, float EndDistance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDistanceWithinRange");

	Params::DelMarTrackBase_IsDistanceWithinRange Parms{};

	Parms.InDistance = InDistance;
	Parms.StartDistance = StartDistance;
	Parms.EndDistance = EndDistance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsPointInOOBTube
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsPointInOOBTube(const struct FVector& Point) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPointInOOBTube");

	Params::DelMarTrackBase_IsPointInOOBTube Parms{};

	Parms.Point = std::move(Point);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsPrimary
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsPrimary() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPrimary");

	Params::DelMarTrackBase_IsPrimary Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsSecondary
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsSecondary() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSecondary");

	Params::DelMarTrackBase_IsSecondary Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsTrackable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsTrackable() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsTrackable");

	Params::DelMarTrackBase_IsTrackable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.MergeTrack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADelMarTrack*                     OtherTrack                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MergeToEndPoint                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CopyFromStartPoint                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrack::MergeTrack(class ADelMarTrack* OtherTrack, bool MergeToEndPoint, bool CopyFromStartPoint)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MergeTrack");

	Params::DelMarTrack_MergeTrack Parms{};

	Parms.OtherTrack = OtherTrack;
	Parms.MergeToEndPoint = MergeToEndPoint;
	Parms.CopyFromStartPoint = CopyFromStartPoint;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.SplitTrackAtPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SplitAtPoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrack::SplitTrackAtPoint(int32 SplitAtPoint)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SplitTrackAtPoint");

	Params::DelMarTrack_SplitTrackAtPoint Parms{};

	Parms.SplitAtPoint = SplitAtPoint;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetParentEndDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetParentEndDistance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParentEndDistance");

	Params::DelMarTrack_GetParentEndDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetParentStartDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetParentStartDistance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParentStartDistance");

	Params::DelMarTrack_GetParentStartDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetPrimaryDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceOnThisTrack                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetPrimaryDistance(float DistanceOnThisTrack) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPrimaryDistance");

	Params::DelMarTrack_GetPrimaryDistance Parms{};

	Parms.DistanceOnThisTrack = DistanceOnThisTrack;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetPrimaryEndDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetPrimaryEndDistance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPrimaryEndDistance");

	Params::DelMarTrack_GetPrimaryEndDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetPrimaryStartDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetPrimaryStartDistance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPrimaryStartDistance");

	Params::DelMarTrack_GetPrimaryStartDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetSecondaryEndTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrack*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrack* ADelMarTrack::GetSecondaryEndTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSecondaryEndTrack");

	Params::DelMarTrack_GetSecondaryEndTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetSecondaryStartTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrack*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrack* ADelMarTrack::GetSecondaryStartTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSecondaryStartTrack");

	Params::DelMarTrack_GetSecondaryStartTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBlueprintFunctionLibrary.IsTrackRadiusCheckDisabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackBlueprintFunctionLibrary::IsTrackRadiusCheckDisabled()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsTrackRadiusCheckDisabled");

	Params::DelMarTrackBlueprintFunctionLibrary_IsTrackRadiusCheckDisabled Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBlueprintFunctionLibrary.TrackPositionDebugDrawEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackBlueprintFunctionLibrary::TrackPositionDebugDrawEnabled()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TrackPositionDebugDrawEnabled");

	Params::DelMarTrackBlueprintFunctionLibrary_TrackPositionDebugDrawEnabled Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSegmentBase.ContainsDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceAlongSpline                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackSegmentBase::ContainsDistanceAlongSpline(const float DistanceAlongSpline) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ContainsDistanceAlongSpline");

	Params::DelMarTrackSegmentBase_ContainsDistanceAlongSpline Parms{};

	Parms.DistanceAlongSpline = DistanceAlongSpline;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSegmentBase.GetSplineDistanceRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDelMarTrackPointDistanceRange   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDelMarTrackPointDistanceRange ADelMarTrackSegmentBase::GetSplineDistanceRange() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplineDistanceRange");

	Params::DelMarTrackSegmentBase_GetSplineDistanceRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSegmentBase.GetSplineMeshComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USplineMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineMeshComponent* ADelMarTrackSegmentBase::GetSplineMeshComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplineMeshComponent");

	Params::DelMarTrackSegmentBase_GetSplineMeshComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnAttachedTrackPointAdded
// (Final, Native, Private)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackOobTube::OnAttachedTrackPointAdded(class UDelMarTrackSplineComponent* InSpline, int32 PointIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnAttachedTrackPointAdded");

	Params::DelMarTrackOobTube_OnAttachedTrackPointAdded Parms{};

	Parms.InSpline = InSpline;
	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnAttachedTrackPointChanged
// (Final, Native, Private)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackOobTube::OnAttachedTrackPointChanged(class UDelMarTrackSplineComponent* InSpline, int32 PointIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnAttachedTrackPointChanged");

	Params::DelMarTrackOobTube_OnAttachedTrackPointChanged Parms{};

	Parms.InSpline = InSpline;
	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnAttachedTrackPointRemoved
// (Final, Native, Private)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackOobTube::OnAttachedTrackPointRemoved(class UDelMarTrackSplineComponent* InSpline, int32 PointIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnAttachedTrackPointRemoved");

	Params::DelMarTrackOobTube_OnAttachedTrackPointRemoved Parms{};

	Parms.InSpline = InSpline;
	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnConstructTubeMesh
// (Event, Protected, BlueprintEvent)
// Parameters:
// class USplineMeshComponent*             TubeMeshComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTransitionMesh                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTransitionIn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackOobTube::OnConstructTubeMesh(class USplineMeshComponent* TubeMeshComponent, bool bIsTransitionMesh, bool bIsTransitionIn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnConstructTubeMesh");

	Params::DelMarTrackOobTube_OnConstructTubeMesh Parms{};

	Parms.TubeMeshComponent = TubeMeshComponent;
	Parms.bIsTransitionMesh = bIsTransitionMesh;
	Parms.bIsTransitionIn = bIsTransitionIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnPostContructedOOBTube
// (Event, Protected, BlueprintEvent)

void ADelMarTrackOobTube::OnPostContructedOOBTube()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPostContructedOOBTube");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.DetermineTubeMeshTransitionType
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// int32                                   CurrentPointIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextPointIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarTrackOobTubeTransitionType       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarTrackOobTubeTransitionType ADelMarTrackOobTube::DetermineTubeMeshTransitionType(int32 CurrentPointIndex, int32 NextPointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DetermineTubeMeshTransitionType");

	Params::DelMarTrackOobTube_DetermineTubeMeshTransitionType Parms{};

	Parms.CurrentPointIndex = CurrentPointIndex;
	Parms.NextPointIndex = NextPointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.GetSplinePointTagAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag ADelMarTrackOobTube::GetSplinePointTagAtIndex(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplinePointTagAtIndex");

	Params::DelMarTrackOobTube_GetSplinePointTagAtIndex Parms{};

	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.HasTubeMeshAtDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackOobTube::HasTubeMeshAtDistance(float InDistance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasTubeMeshAtDistance");

	Params::DelMarTrackOobTube_HasTubeMeshAtDistance Parms{};

	Parms.InDistance = InDistance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.IsAttachedToPrimaryTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackOobTube::IsAttachedToPrimaryTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAttachedToPrimaryTrack");

	Params::DelMarTrackOobTube_IsAttachedToPrimaryTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.IsAttachedToSecondaryTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackOobTube::IsAttachedToSecondaryTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAttachedToSecondaryTrack");

	Params::DelMarTrackOobTube_IsAttachedToSecondaryTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.IsSplinePointOffset
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackOobTube::IsSplinePointOffset(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSplinePointOffset");

	Params::DelMarTrackOobTube_IsSplinePointOffset Parms{};

	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetAttachedTrack
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADelMarTrack*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrack* UDelMarTrackOobTubeProxy::GetAttachedTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAttachedTrack");

	Params::DelMarTrackOobTubeProxy_GetAttachedTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetDefaultSubsectionCount
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackOobTubeProxy::GetDefaultSubsectionCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultSubsectionCount");

	Params::DelMarTrackOobTubeProxy_GetDefaultSubsectionCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetDefaultTransitionMeshLength
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTrackOobTubeProxy::GetDefaultTransitionMeshLength() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultTransitionMeshLength");

	Params::DelMarTrackOobTubeProxy_GetDefaultTransitionMeshLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetMinimumMeshScale
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTrackOobTubeProxy::GetMinimumMeshScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinimumMeshScale");

	Params::DelMarTrackOobTubeProxy_GetMinimumMeshScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetOobTubeActor
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDelMarTrackOobTubeProxy::GetOobTubeActor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOobTubeActor");

	Params::DelMarTrackOobTubeProxy_GetOobTubeActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetSmallestSubsectionLength
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTrackOobTubeProxy::GetSmallestSubsectionLength() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSmallestSubsectionLength");

	Params::DelMarTrackOobTubeProxy_GetSmallestSubsectionLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetSplineComponent
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineComponent* UDelMarTrackOobTubeProxy::GetSplineComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplineComponent");

	Params::DelMarTrackOobTubeProxy_GetSplineComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetSplineMetadata
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDelMarTrackOobTubePointMetaData ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDelMarTrackOobTubePointMetaData UDelMarTrackOobTubeProxy::GetSplineMetadata(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplineMetadata");

	Params::DelMarTrackOobTubeProxy_GetSplineMetadata Parms{};

	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetSplineVisualizationOffset
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTrackOobTubeProxy::GetSplineVisualizationOffset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplineVisualizationOffset");

	Params::DelMarTrackOobTubeProxy_GetSplineVisualizationOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeCollectionProxy.GetOobTubeProxy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   OobTubeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDelMarTrackOobTubeProxy*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarTrackOobTubeProxy* UDelMarTrackOobTubeCollectionProxy::GetOobTubeProxy(int32 OobTubeIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOobTubeProxy");

	Params::DelMarTrackOobTubeCollectionProxy_GetOobTubeProxy Parms{};

	Parms.OobTubeIndex = OobTubeIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeCollectionProxy.RegisterOobTube
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           OobTubeActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTrackOobTubeCollectionProxy::RegisterOobTube(class AActor* OobTubeActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegisterOobTube");

	Params::DelMarTrackOobTubeCollectionProxy_RegisterOobTube Parms{};

	Parms.OobTubeActor = OobTubeActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeCollectionProxy.GetNumOobTubeProxies
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackOobTubeCollectionProxy::GetNumOobTubeProxies() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumOobTubeProxies");

	Params::DelMarTrackOobTubeCollectionProxy_GetNumOobTubeProxies Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPaletteTrackType.AddSegmentClassActorToStyle
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     StyleTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           SegmentClass                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTrackPaletteTrackType::AddSegmentClassActorToStyle(const struct FGameplayTag& StyleTag, class UClass* SegmentClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddSegmentClassActorToStyle");

	Params::DelMarTrackPaletteTrackType_AddSegmentClassActorToStyle Parms{};

	Parms.StyleTag = std::move(StyleTag);
	Parms.SegmentClass = SegmentClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackPerformanceScrubber.ClientStartScrub
// (Net, NetReliable, Native, Event, Protected, NetClient)

void ADelMarTrackPerformanceScrubber::ClientStartScrub()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStartScrub");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackPerformanceScrubber.ClientStopScrub
// (Net, NetReliable, Native, Event, Protected, NetClient)

void ADelMarTrackPerformanceScrubber::ClientStopScrub()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStopScrub");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackPerformanceScrubber.ReceiveRuntimeTrackScrubbingSpeed
// (Final, Native, Protected)

void ADelMarTrackPerformanceScrubber::ReceiveRuntimeTrackScrubbingSpeed()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveRuntimeTrackScrubbingSpeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackPerformanceScrubber.ReceiveRuntimeTrackScrubbingStart
// (Final, Native, Protected)

void ADelMarTrackPerformanceScrubber::ReceiveRuntimeTrackScrubbingStart()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveRuntimeTrackScrubbingStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackPerformanceScrubber.TimelineFinishedCallback
// (Final, Native, Protected)

void ADelMarTrackPerformanceScrubber::TimelineFinishedCallback()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TimelineFinishedCallback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackPerformanceScrubber.TimelineTickCallback
// (Final, Native, Protected)

void ADelMarTrackPerformanceScrubber::TimelineTickCallback()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TimelineTickCallback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackPerformanceScrubber.TimelineTickFloatCallback
// (Final, Native, Protected)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackPerformanceScrubber::TimelineTickFloatCallback(float Progress)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TimelineTickFloatCallback");

	Params::DelMarTrackPerformanceScrubber_TimelineTickFloatCallback Parms{};

	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackPerformanceScrubber.UpdateSplines
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ADelMarTrackPerformanceScrubber::UpdateSplines()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateSplines");

	Params::DelMarTrackPerformanceScrubber_UpdateSplines Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.SetActiveTrack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADelMarTrackBase*                 Track                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrackSegmentIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTrackPositionComponent::SetActiveTrack(class ADelMarTrackBase* Track, int32 TrackSegmentIndex, bool bForce)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActiveTrack");

	Params::DelMarTrackPositionComponent_SetActiveTrack Parms{};

	Parms.Track = Track;
	Parms.TrackSegmentIndex = TrackSegmentIndex;
	Parms.bForce = bForce;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveSegmentIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackPositionComponent::GetActiveSegmentIndex() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveSegmentIndex");

	Params::DelMarTrackPositionComponent_GetActiveSegmentIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrackBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrackBase* UDelMarTrackPositionComponent::GetActiveTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveTrack");

	Params::DelMarTrackPositionComponent_GetActiveTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveTrackDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetActiveTrackDistance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveTrackDistance");

	Params::DelMarTrackPositionComponent_GetActiveTrackDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveTrackPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrackPosition                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTrackPosition UDelMarTrackPositionComponent::GetActiveTrackPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveTrackPosition");

	Params::DelMarTrackPositionComponent_GetActiveTrackPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveTrackRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetActiveTrackRadius() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveTrackRadius");

	Params::DelMarTrackPositionComponent_GetActiveTrackRadius Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetDistanceAlongSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDistanceAlongSpline");

	Params::DelMarTrackPositionComponent_GetDistanceAlongSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetLastKnowGoodSplineLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetLastKnowGoodSplineLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastKnowGoodSplineLocation");

	Params::DelMarTrackPositionComponent_GetLastKnowGoodSplineLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetPrimaryDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetPrimaryDistance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPrimaryDistance");

	Params::DelMarTrackPositionComponent_GetPrimaryDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetPrimaryTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrackBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrackBase* UDelMarTrackPositionComponent::GetPrimaryTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPrimaryTrack");

	Params::DelMarTrackPositionComponent_GetPrimaryTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetPrimaryWorldLocationAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetPrimaryWorldLocationAlongSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPrimaryWorldLocationAlongSpline");

	Params::DelMarTrackPositionComponent_GetPrimaryWorldLocationAlongSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetRawClosestSplineLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetRawClosestSplineLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRawClosestSplineLocation");

	Params::DelMarTrackPositionComponent_GetRawClosestSplineLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetRawDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetRawDistanceAlongSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRawDistanceAlongSpline");

	Params::DelMarTrackPositionComponent_GetRawDistanceAlongSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetTrackRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrackBase*                 InTrack                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDistanceAlongTrack                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetTrackRadius(const class ADelMarTrackBase* InTrack, float InDistanceAlongTrack) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTrackRadius");

	Params::DelMarTrackPositionComponent_GetTrackRadius Parms{};

	Parms.InTrack = InTrack;
	Parms.InDistanceAlongTrack = InDistanceAlongTrack;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldDirectionAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetWorldDirectionAlongSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldDirectionAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldDirectionAlongSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldLocationAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetWorldLocationAlongSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldLocationAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldLocationAlongSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldRightVectorAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetWorldRightVectorAlongSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldRightVectorAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldRightVectorAlongSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldTransformAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UDelMarTrackPositionComponent::GetWorldTransformAlongSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldTransformAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldTransformAlongSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldUpVectorAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetWorldUpVectorAlongSpline() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldUpVectorAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldUpVectorAlongSpline Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.HasValidPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackPositionComponent::HasValidPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasValidPosition");

	Params::DelMarTrackPositionComponent_HasValidPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.IsOnPrimaryTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackPositionComponent::IsOnPrimaryTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOnPrimaryTrack");

	Params::DelMarTrackPositionComponent_IsOnPrimaryTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.IsTouchingTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackPositionComponent::IsTouchingTrack() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsTouchingTrack");

	Params::DelMarTrackPositionComponent_IsTouchingTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPrefabSegment.GetSockets
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ADelMarTrackPrefabSegment::GetSockets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSockets");

	Params::DelMarTrackPrefabSegment_GetSockets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.FindClosestLocationForSegmentToWorldPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldPlaneOrigin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPlaneNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SegmentIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClosestLocationToWorldPlaneResultReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FClosestLocationToWorldPlaneResult UDelMarTrackSplineComponent::FindClosestLocationForSegmentToWorldPlane(const struct FVector& WorldPlaneOrigin, const struct FVector& WorldPlaneNormal, const int32 SegmentIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindClosestLocationForSegmentToWorldPlane");

	Params::DelMarTrackSplineComponent_FindClosestLocationForSegmentToWorldPlane Parms{};

	Parms.WorldPlaneOrigin = std::move(WorldPlaneOrigin);
	Parms.WorldPlaneNormal = std::move(WorldPlaneNormal);
	Parms.SegmentIndex = SegmentIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.FindClosestLocationToWorldPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldPlaneOrigin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPlaneNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClosestLocationToWorldPlaneResultReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FClosestLocationToWorldPlaneResult UDelMarTrackSplineComponent::FindClosestLocationToWorldPlane(const struct FVector& WorldPlaneOrigin, const struct FVector& WorldPlaneNormal, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindClosestLocationToWorldPlane");

	Params::DelMarTrackSplineComponent_FindClosestLocationToWorldPlane Parms{};

	Parms.WorldPlaneOrigin = std::move(WorldPlaneOrigin);
	Parms.WorldPlaneNormal = std::move(WorldPlaneNormal);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.FindInputKeyForNeighboringSegmentClosestToWorldPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldPlaneOrigin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPlaneNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SegmentIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutClosestSegmentIndex                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClosestLocationToWorldPlaneResultReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FClosestLocationToWorldPlaneResult UDelMarTrackSplineComponent::FindInputKeyForNeighboringSegmentClosestToWorldPlane(const struct FVector& WorldPlaneOrigin, const struct FVector& WorldPlaneNormal, const int32 SegmentIndex, int32* OutClosestSegmentIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindInputKeyForNeighboringSegmentClosestToWorldPlane");

	Params::DelMarTrackSplineComponent_FindInputKeyForNeighboringSegmentClosestToWorldPlane Parms{};

	Parms.WorldPlaneOrigin = std::move(WorldPlaneOrigin);
	Parms.WorldPlaneNormal = std::move(WorldPlaneNormal);
	Parms.SegmentIndex = SegmentIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutClosestSegmentIndex != nullptr)
		*OutClosestSegmentIndex = Parms.OutClosestSegmentIndex;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetForwardDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackSplineComponent::GetForwardDistance(float Start, float End) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetForwardDistance");

	Params::DelMarTrackSplineComponent_GetForwardDistance Parms{};

	Parms.Start = Start;
	Parms.End = End;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetLoopDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTotalDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackSplineComponent::GetLoopDistance(float InTotalDistance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLoopDistance");

	Params::DelMarTrackSplineComponent_GetLoopDistance Parms{};

	Parms.InTotalDistance = InTotalDistance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetNextSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplinePoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetNextSplinePoint(int32 InSplinePoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNextSplinePoint");

	Params::DelMarTrackSplineComponent_GetNextSplinePoint Parms{};

	Parms.InSplinePoint = InSplinePoint;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetNextSplineSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplineSegmentIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetNextSplineSegment(int32 InSplineSegmentIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNextSplineSegment");

	Params::DelMarTrackSplineComponent_GetNextSplineSegment Parms{};

	Parms.InSplineSegmentIndex = InSplineSegmentIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetPreviousSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplinePoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetPreviousSplinePoint(int32 InSplinePoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPreviousSplinePoint");

	Params::DelMarTrackSplineComponent_GetPreviousSplinePoint Parms{};

	Parms.InSplinePoint = InSplinePoint;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetPreviousSplineSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplineSegmentIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetPreviousSplineSegment(int32 InSplineSegmentIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPreviousSplineSegment");

	Params::DelMarTrackSplineComponent_GetPreviousSplineSegment Parms{};

	Parms.InSplineSegmentIndex = InSplineSegmentIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetRotationalMinimalFrames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FDelMarRotationalMinimalFrame>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FDelMarRotationalMinimalFrame> UDelMarTrackSplineComponent::GetRotationalMinimalFrames() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationalMinimalFrames");

	Params::DelMarTrackSplineComponent_GetRotationalMinimalFrames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetRotationalMinimalUpVectorAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackSplineComponent::GetRotationalMinimalUpVectorAtDistanceAlongSpline(float DistanceAlongSpline, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationalMinimalUpVectorAtDistanceAlongSpline");

	Params::DelMarTrackSplineComponent_GetRotationalMinimalUpVectorAtDistanceAlongSpline Parms{};

	Parms.DistanceAlongSpline = DistanceAlongSpline;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetRotationalMinimalUpVectorAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplinePoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackSplineComponent::GetRotationalMinimalUpVectorAtSplinePoint(int32 SplinePoint, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationalMinimalUpVectorAtSplinePoint");

	Params::DelMarTrackSplineComponent_GetRotationalMinimalUpVectorAtSplinePoint Parms{};

	Parms.SplinePoint = SplinePoint;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetSplinePointAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetSplinePointAtDistanceAlongSpline(float DistanceAlongSpline) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplinePointAtDistanceAlongSpline");

	Params::DelMarTrackSplineComponent_GetSplinePointAtDistanceAlongSpline Parms{};

	Parms.DistanceAlongSpline = DistanceAlongSpline;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetSplinePointClosestToDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetSplinePointClosestToDistanceAlongSpline(float DistanceAlongSpline) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplinePointClosestToDistanceAlongSpline");

	Params::DelMarTrackSplineComponent_GetSplinePointClosestToDistanceAlongSpline Parms{};

	Parms.DistanceAlongSpline = DistanceAlongSpline;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetSplinePointClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetSplinePointClosestToWorldLocation(const struct FVector& WorldLocation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplinePointClosestToWorldLocation");

	Params::DelMarTrackSplineComponent_GetSplinePointClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.IsDistanceAheadOfOtherDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OtherDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackSplineComponent::IsDistanceAheadOfOtherDistance(float Distance, float OtherDistance, float BaseDistance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDistanceAheadOfOtherDistance");

	Params::DelMarTrackSplineComponent_IsDistanceAheadOfOtherDistance Parms{};

	Parms.Distance = Distance;
	Parms.OtherDistance = OtherDistance;
	Parms.BaseDistance = BaseDistance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.IsDistanceBehindOtherDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OtherDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackSplineComponent::IsDistanceBehindOtherDistance(float Distance, float OtherDistance, float BaseDistance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDistanceBehindOtherDistance");

	Params::DelMarTrackSplineComponent_IsDistanceBehindOtherDistance Parms{};

	Parms.Distance = Distance;
	Parms.OtherDistance = OtherDistance;
	Parms.BaseDistance = BaseDistance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.IsDistanceWithinRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackSplineComponent::IsDistanceWithinRange(float InDistance, float StartDistance, float EndDistance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDistanceWithinRange");

	Params::DelMarTrackSplineComponent_IsDistanceWithinRange Parms{};

	Parms.InDistance = InDistance;
	Parms.StartDistance = StartDistance;
	Parms.EndDistance = EndDistance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

