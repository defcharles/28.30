#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JunoProceduralWorld

#include "Basic.hpp"

#include "JunoProceduralWorld_structs.hpp"
#include "MassEntity_structs.hpp"
#include "MassEntity_classes.hpp"
#include "FortniteGame_classes.hpp"
#include "ModularGameplay_classes.hpp"
#include "DataRegistry_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "LagerRuntime_classes.hpp"
#include "PlayspaceSystem_classes.hpp"
#include "JunoGameNative_structs.hpp"
#include "JunoGameNative_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "MassSignals_classes.hpp"
#include "MassActors_classes.hpp"
#include "InstancedActors_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "MassRepresentation_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "JunoProceduralLandscape_classes.hpp"
#include "PCG_classes.hpp"
#include "GameFeatures_classes.hpp"


namespace SDK
{

// Class JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoProceduralWorldBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyLandscapeTileSettings(class ALandscape* LandscapeTile, float LODBlendRange, bool bUseCompressedHeightmapStorage, bool bDisableRuntimeGrassMapGeneration);
	static struct FVector CalcPOISizeExtent(EJunoPOISize Size);
	static void CompareTagSets(const TSet<class FName>& Source, const TSet<class FName>& Target, EJunoCompareTagSetsResult* Result);
	static struct FJunoRandomTableKeysIterator CreateJunoRandomTableKeysIterator(const struct FRandomStream& RandomStream, const TArray<class FName>& Keys);
	static void CreateJunoWPLevelFromActors(const class FString& LevelPackageName, const TArray<class AActor*>& Actors, TSoftObjectPtr<class UWorld>* CreatedLevel, bool bUseWorldPartition, class FName GridName, float LoadingRange, int32 WorldPartitionGridCellSize, const struct FVector2D& WorldPartitionGridCellOrigin, class UHLODLayer* DefaultHLODLayer, EWorldPartitionServerStreamingMode ServerStreamingMode, EWorldPartitionServerStreamingOutMode ServerStreamingOutMode);
	static TArray<class FName> DeterministicShuffleKeys(const struct FRandomStream& RandomSource, const TArray<class FName>& Array);
	static void DisableLandscapeEditLayers(class ALandscape* Landscape);
	static void EnableLandscapeNaniteSkirts(class ALandscape* Landscape, bool bEnable, float SkirtDepth);
	static void FindAllResourcesInFolder(const class FString& Folder, class UClass* AssetClass, TArray<struct FSoftObjectPath>* OutPaths);
	static void FindNextMatchingPOIResource(const struct FJunoRandomTableKeysIterator& Iterator, const class UDataTable* DataTable, EJunoPOISize SlotPOISize, const TArray<class FName>& SlotTags, struct FPCGJunoWorldTilePOI* FoundPOI, EJunoFindNextMatchingPOIResourceResult* Result, bool bRemoveFromIterator);
	static void FindNextMatchingPOIResourceEx(const struct FJunoRandomTableKeysIterator& Iterator, const class UDataTable* DataTable, EJunoPOISize Size, EJunoBiome Biome, struct FPCGJunoWorldTilePOI* FoundPOI, EJunoFindNextMatchingPOIResourceResult* Result);
	static class UJunoWorldRegistryManager* GetJunoWorldRegistry(const class UObject* WorldContextObject);
	static void JunoCreateLevel(const struct FJunoCreateLevelParams& Params_0, TSoftObjectPtr<class UWorld>* CreatedLevel, EJunoCreateLevelResult* Result);
	static void RunParallelCommandlets(const class FText& DialogueTitle, const TArray<class FString>& Commands, int32 MaxProcesses);
	static bool SaveCurrentLevelAs(const class FString& NewPackageName);
	static void SetBoxBrushSize(class AActor* Volume, const struct FVector& Size);
	static void SetGridCellSize(class AActor* WorldContextObject, class FName GridName, float CellSize, float LoadingRange, const struct FVector2D& Origin);
	static struct FBox UnionActorBounds(const TArray<class AActor*>& Actors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoProceduralWorldBlueprintLibrary">();
	}
	static class UJunoProceduralWorldBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoProceduralWorldBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoProceduralWorldBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoProceduralWorldBlueprintLibrary");
static_assert(sizeof(UJunoProceduralWorldBlueprintLibrary) == 0x000028, "Wrong size on UJunoProceduralWorldBlueprintLibrary");

// Class JunoProceduralWorld.LandmassFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULandmassFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetControlPointLayerWidthRatio(class ULandscapeSplineControlPoint* InControlPoint);
	static struct FVector GetControlPointLocation(class ULandscapeSplineControlPoint* InControlPoint);
	static struct FRotator GetControlPointRotation(class ULandscapeSplineControlPoint* InControlPoint);
	static float GetControlPointSideFalloff(class ULandscapeSplineControlPoint* InControlPoint);
	static float GetControlPointWidth(class ULandscapeSplineControlPoint* InControlPoint);
	static struct FVector2D GetLandscapeGradientAtLocation(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location);
	static float GetLandscapeHeightAtLocation(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location, bool* bIsValidLocation);
	static void LevelInstanceSetAndUpdateWorldAsset(class ALevelInstance* LevelInstance, const TSoftObjectPtr<class UWorld>& WorldAsset);
	static struct FVector ProjectLocationOnLandscape(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location, bool* bIsValidLocation);
	static void SetControlPointLayerWidthRatio(class ULandscapeSplineControlPoint* InControlPoint, float InLayerWidthRatio);
	static void SetControlPointLocation(class ULandscapeSplineControlPoint* InControlPoint, const struct FVector& InLocation);
	static void SetControlPointRotation(class ULandscapeSplineControlPoint* InControlPoint, const struct FRotator& InRotation);
	static void SetControlPointSideFalloff(class ULandscapeSplineControlPoint* InControlPoint, float InSideFalloff);
	static void SetControlPointWidth(class ULandscapeSplineControlPoint* InControlPoint, float InWidth);
	static void SetStaticMeshAffectDistanceField(class UStaticMeshComponent* Mesh, bool bNewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandmassFunctionLibrary">();
	}
	static class ULandmassFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandmassFunctionLibrary>();
	}
};
static_assert(alignof(ULandmassFunctionLibrary) == 0x000008, "Wrong alignment on ULandmassFunctionLibrary");
static_assert(sizeof(ULandmassFunctionLibrary) == 0x000028, "Wrong size on ULandmassFunctionLibrary");

// Class JunoProceduralWorld.JunoBridgePOISelectorComponent
// 0x0028 (0x00C8 - 0x00A0)
class UJunoBridgePOISelectorComponent final : public UGameFrameworkComponent
{
public:
	struct FJunoBridgePOISelectorParams           Params_0;                                          // 0x00A0(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataRegistryType                      DataRegistryType;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0xC];                                       // 0x00BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginBridgeSelection(const struct FJunoBridgePOISelectorParams& Param_Params_0);
	void DoSelection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBridgePOISelectorComponent">();
	}
	static class UJunoBridgePOISelectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBridgePOISelectorComponent>();
	}
};
static_assert(alignof(UJunoBridgePOISelectorComponent) == 0x000008, "Wrong alignment on UJunoBridgePOISelectorComponent");
static_assert(sizeof(UJunoBridgePOISelectorComponent) == 0x0000C8, "Wrong size on UJunoBridgePOISelectorComponent");
static_assert(offsetof(UJunoBridgePOISelectorComponent, Params_0) == 0x0000A0, "Member 'UJunoBridgePOISelectorComponent::Params_0' has a wrong offset!");
static_assert(offsetof(UJunoBridgePOISelectorComponent, DataRegistryType) == 0x0000B8, "Member 'UJunoBridgePOISelectorComponent::DataRegistryType' has a wrong offset!");

// Class JunoProceduralWorld.JunoCaveGeneratorDataMergerInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoCaveGeneratorDataMergerInterface final : public IInterface
{
public:
	void MergeCaveData(struct FJunoCaveGeneratorData* CaveData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveGeneratorDataMergerInterface">();
	}
	static class IJunoCaveGeneratorDataMergerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoCaveGeneratorDataMergerInterface>();
	}
};
static_assert(alignof(IJunoCaveGeneratorDataMergerInterface) == 0x000008, "Wrong alignment on IJunoCaveGeneratorDataMergerInterface");
static_assert(sizeof(IJunoCaveGeneratorDataMergerInterface) == 0x000028, "Wrong size on IJunoCaveGeneratorDataMergerInterface");

// Class JunoProceduralWorld.JunoTileGridPersistenceFeatureData
// 0x00F8 (0x0138 - 0x0040)
class UJunoTileGridPersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoTileGridSaveData                  TileSaveData;                                      // 0x0048(0x00F0)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTileGridPersistenceFeatureData">();
	}
	static class UJunoTileGridPersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTileGridPersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoTileGridPersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoTileGridPersistenceFeatureData");
static_assert(sizeof(UJunoTileGridPersistenceFeatureData) == 0x000138, "Wrong size on UJunoTileGridPersistenceFeatureData");
static_assert(offsetof(UJunoTileGridPersistenceFeatureData, TileSaveData) == 0x000048, "Member 'UJunoTileGridPersistenceFeatureData::TileSaveData' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoPathfindSettings
// 0x0028 (0x0178 - 0x0150)
class UPCGJunoPathfindSettings final : public UPCGSettings
{
public:
	class FName                                   ProceduralRouteTag;                                // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           InputPins;                                         // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutputPins;                                        // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoPathfindSettings">();
	}
	static class UPCGJunoPathfindSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoPathfindSettings>();
	}
};
static_assert(alignof(UPCGJunoPathfindSettings) == 0x000008, "Wrong alignment on UPCGJunoPathfindSettings");
static_assert(sizeof(UPCGJunoPathfindSettings) == 0x000178, "Wrong size on UPCGJunoPathfindSettings");
static_assert(offsetof(UPCGJunoPathfindSettings, ProceduralRouteTag) == 0x000150, "Member 'UPCGJunoPathfindSettings::ProceduralRouteTag' has a wrong offset!");
static_assert(offsetof(UPCGJunoPathfindSettings, InputPins) == 0x000158, "Member 'UPCGJunoPathfindSettings::InputPins' has a wrong offset!");
static_assert(offsetof(UPCGJunoPathfindSettings, OutputPins) == 0x000168, "Member 'UPCGJunoPathfindSettings::OutputPins' has a wrong offset!");

// Class JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent
// 0x00B0 (0x01A8 - 0x00F8)
class UJunoCaveGeneratorPlayspaceComponent final : public UFortPlayspaceComponent
{
public:
	struct FDataRegistryType                      CaveGeneratorRegistry;                             // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataRegistryType                      CaveGeneratorShellsRegistry;                       // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataRegistryType                      CaveGeneratorRulesRegistry;                        // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataRegistryType                      CaveGeneratorThemesRegistry;                       // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataRegistryType                      CaveGeneratorTypesRegistry;                        // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSplitDataRegistries;                           // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataRegistryType                      POIDataRegistry;                                   // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoCaveGeneratorData                 MergedData;                                        // 0x0118(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x50];                                     // 0x0150(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWasDataMerged;                                    // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GenerateCaveData(const struct FJunoCaveGeneratorData& ResourceData, const struct FDataRegistryType& POIDataRegistry_0, const struct FRandomStream& RandomStream, const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, const struct FBox& Bounds, const TSubclassOf<class AJunoTeleporter>& SurfaceTeleporterClass, TArray<struct FJunoGeneratedCaveShellData>* Shells, TArray<struct FJunoPOIData>* POIs);
	static void GetMergedCaveDataRegistryData(const struct FDataRegistryType& CaveGeneratorDataRegistry, struct FJunoCaveGeneratorData* ResourceData, EJunoGetMergedCaveDataRegistryDataResult* Result);
	static void GetMergedMultiCaveDataRegistryData(const struct FDataRegistryType& ShellRegistry, const struct FDataRegistryType& ThemeRegistry, const struct FDataRegistryType& TypeRegistry, const struct FDataRegistryType& RuleRegistry, struct FJunoCaveGeneratorData* ResourceData, EJunoGetMergedCaveDataRegistryDataResult* Result);
	static class UJunoCaveGeneratorPlayspaceComponent* GetRootCaveGeneratorComponent(class UObject* WorldContextObject);
	static bool IsNativeCaveGeneratorEnabled();
	static void SortCaveGeneratorRules(const TArray<struct FJunoCaveGeneratorRule>& Rules, TArray<struct FJunoCaveGeneratorRule>* SortedRules);
	static void SortCaveGeneratorShells(const TArray<struct FJunoCaveGeneratorShellData>& Shells, TArray<struct FJunoCaveGeneratorShellData>* SortedShells);
	static void SortCaveGeneratorThemes(const TArray<struct FJunoCaveGeneratorThemeEntry>& Themes, TArray<struct FJunoCaveGeneratorThemeEntry>* SortedThemes);
	static void SortCaveGeneratorTypes(const TArray<struct FJunoCaveGeneratorTypeData>& Types, TArray<struct FJunoCaveGeneratorTypeData>* SortedTypes);

	void GenerateCave(class AActor* WorldActor, const struct FRandomStream& RandomStream, const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, const struct FBox& Bounds, const TSubclassOf<class AJunoTeleporter>& SurfaceTeleporterClass);
	void SetMergedData(const struct FJunoCaveGeneratorData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveGeneratorPlayspaceComponent">();
	}
	static class UJunoCaveGeneratorPlayspaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCaveGeneratorPlayspaceComponent>();
	}
};
static_assert(alignof(UJunoCaveGeneratorPlayspaceComponent) == 0x000008, "Wrong alignment on UJunoCaveGeneratorPlayspaceComponent");
static_assert(sizeof(UJunoCaveGeneratorPlayspaceComponent) == 0x0001A8, "Wrong size on UJunoCaveGeneratorPlayspaceComponent");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, CaveGeneratorRegistry) == 0x0000F8, "Member 'UJunoCaveGeneratorPlayspaceComponent::CaveGeneratorRegistry' has a wrong offset!");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, CaveGeneratorShellsRegistry) == 0x0000FC, "Member 'UJunoCaveGeneratorPlayspaceComponent::CaveGeneratorShellsRegistry' has a wrong offset!");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, CaveGeneratorRulesRegistry) == 0x000100, "Member 'UJunoCaveGeneratorPlayspaceComponent::CaveGeneratorRulesRegistry' has a wrong offset!");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, CaveGeneratorThemesRegistry) == 0x000104, "Member 'UJunoCaveGeneratorPlayspaceComponent::CaveGeneratorThemesRegistry' has a wrong offset!");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, CaveGeneratorTypesRegistry) == 0x000108, "Member 'UJunoCaveGeneratorPlayspaceComponent::CaveGeneratorTypesRegistry' has a wrong offset!");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, bUseSplitDataRegistries) == 0x00010C, "Member 'UJunoCaveGeneratorPlayspaceComponent::bUseSplitDataRegistries' has a wrong offset!");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, POIDataRegistry) == 0x000110, "Member 'UJunoCaveGeneratorPlayspaceComponent::POIDataRegistry' has a wrong offset!");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, MergedData) == 0x000118, "Member 'UJunoCaveGeneratorPlayspaceComponent::MergedData' has a wrong offset!");
static_assert(offsetof(UJunoCaveGeneratorPlayspaceComponent, bWasDataMerged) == 0x0001A0, "Member 'UJunoCaveGeneratorPlayspaceComponent::bWasDataMerged' has a wrong offset!");

// Class JunoProceduralWorld.JunoLivingWorldStaticPointProvider
// 0x0058 (0x03E0 - 0x0388)
class AJunoLivingWorldStaticPointProvider : public AFortAthenaLivingWorldStaticPointProvider
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoLivingWorldPointProviderEventLimiter EventLimiter;                                      // 0x0398(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  SavedActorGuid;                                    // 0x03B8(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x18];                                     // 0x03C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AppendFiltersTags(const struct FGameplayTagContainer& Container);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLivingWorldStaticPointProvider">();
	}
	static class AJunoLivingWorldStaticPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoLivingWorldStaticPointProvider>();
	}
};
static_assert(alignof(AJunoLivingWorldStaticPointProvider) == 0x000008, "Wrong alignment on AJunoLivingWorldStaticPointProvider");
static_assert(sizeof(AJunoLivingWorldStaticPointProvider) == 0x0003E0, "Wrong size on AJunoLivingWorldStaticPointProvider");
static_assert(offsetof(AJunoLivingWorldStaticPointProvider, EventLimiter) == 0x000398, "Member 'AJunoLivingWorldStaticPointProvider::EventLimiter' has a wrong offset!");
static_assert(offsetof(AJunoLivingWorldStaticPointProvider, SavedActorGuid) == 0x0003B8, "Member 'AJunoLivingWorldStaticPointProvider::SavedActorGuid' has a wrong offset!");

// Class JunoProceduralWorld.PCGSetAudioBankSettings
// 0x0008 (0x0158 - 0x0150)
class UPCGSetAudioBankSettings final : public UPCGSettings
{
public:
	class FName                                   AttributeNameForResolvedAudioBankPath;             // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForSpawnedActorPtr;                   // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGSetAudioBankSettings">();
	}
	static class UPCGSetAudioBankSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGSetAudioBankSettings>();
	}
};
static_assert(alignof(UPCGSetAudioBankSettings) == 0x000008, "Wrong alignment on UPCGSetAudioBankSettings");
static_assert(sizeof(UPCGSetAudioBankSettings) == 0x000158, "Wrong size on UPCGSetAudioBankSettings");
static_assert(offsetof(UPCGSetAudioBankSettings, AttributeNameForResolvedAudioBankPath) == 0x000150, "Member 'UPCGSetAudioBankSettings::AttributeNameForResolvedAudioBankPath' has a wrong offset!");
static_assert(offsetof(UPCGSetAudioBankSettings, AttributeNameForSpawnedActorPtr) == 0x000154, "Member 'UPCGSetAudioBankSettings::AttributeNameForSpawnedActorPtr' has a wrong offset!");

// Class JunoProceduralWorld.JunoCaveLivingWorldStaticPointProvider
// 0x0050 (0x0430 - 0x03E0)
class AJunoCaveLivingWorldStaticPointProvider final : public AJunoLivingWorldStaticPointProvider
{
public:
	class FName                                   CaveShellID;                                       // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoCaveConditionalTags>       ConditionalTags;                                   // 0x03E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FScalableFloat                         AssignLeashVolume;                                 // 0x03F8(0x0028)(Edit, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCaveShellSpawnEntry>    CaveShellEntry;                                    // 0x0420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeverEnable;                                      // 0x0428(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetCaveShellInstanceData(struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveLivingWorldStaticPointProvider">();
	}
	static class AJunoCaveLivingWorldStaticPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoCaveLivingWorldStaticPointProvider>();
	}
};
static_assert(alignof(AJunoCaveLivingWorldStaticPointProvider) == 0x000008, "Wrong alignment on AJunoCaveLivingWorldStaticPointProvider");
static_assert(sizeof(AJunoCaveLivingWorldStaticPointProvider) == 0x000430, "Wrong size on AJunoCaveLivingWorldStaticPointProvider");
static_assert(offsetof(AJunoCaveLivingWorldStaticPointProvider, CaveShellID) == 0x0003E0, "Member 'AJunoCaveLivingWorldStaticPointProvider::CaveShellID' has a wrong offset!");
static_assert(offsetof(AJunoCaveLivingWorldStaticPointProvider, ConditionalTags) == 0x0003E8, "Member 'AJunoCaveLivingWorldStaticPointProvider::ConditionalTags' has a wrong offset!");
static_assert(offsetof(AJunoCaveLivingWorldStaticPointProvider, AssignLeashVolume) == 0x0003F8, "Member 'AJunoCaveLivingWorldStaticPointProvider::AssignLeashVolume' has a wrong offset!");
static_assert(offsetof(AJunoCaveLivingWorldStaticPointProvider, CaveShellEntry) == 0x000420, "Member 'AJunoCaveLivingWorldStaticPointProvider::CaveShellEntry' has a wrong offset!");
static_assert(offsetof(AJunoCaveLivingWorldStaticPointProvider, bNeverEnable) == 0x000428, "Member 'AJunoCaveLivingWorldStaticPointProvider::bNeverEnable' has a wrong offset!");

// Class JunoProceduralWorld.JunoStreamingGameplayVolume
// 0x0080 (0x03B0 - 0x0330)
class AJunoStreamingGameplayVolume : public AGameplayVolume
{
public:
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SavedActorGuid;                                    // 0x0350(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnedByLevelSaveRecord;                         // 0x0360(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoundsExtent;                                      // 0x0368(0x0018)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BoundsOffset;                                      // 0x0380(0x0018)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          LevelsToLoad;                                      // 0x03A0(0x0010)(Edit, Net, ZeroConstructor, SaveGame, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void Load();
	void SetBounds(const struct FVector& Offset, const struct FVector& Extent);
	void Unload();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoStreamingGameplayVolume">();
	}
	static class AJunoStreamingGameplayVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoStreamingGameplayVolume>();
	}
};
static_assert(alignof(AJunoStreamingGameplayVolume) == 0x000008, "Wrong alignment on AJunoStreamingGameplayVolume");
static_assert(sizeof(AJunoStreamingGameplayVolume) == 0x0003B0, "Wrong size on AJunoStreamingGameplayVolume");
static_assert(offsetof(AJunoStreamingGameplayVolume, SavedActorGuid) == 0x000350, "Member 'AJunoStreamingGameplayVolume::SavedActorGuid' has a wrong offset!");
static_assert(offsetof(AJunoStreamingGameplayVolume, bSpawnedByLevelSaveRecord) == 0x000360, "Member 'AJunoStreamingGameplayVolume::bSpawnedByLevelSaveRecord' has a wrong offset!");
static_assert(offsetof(AJunoStreamingGameplayVolume, BoundsExtent) == 0x000368, "Member 'AJunoStreamingGameplayVolume::BoundsExtent' has a wrong offset!");
static_assert(offsetof(AJunoStreamingGameplayVolume, BoundsOffset) == 0x000380, "Member 'AJunoStreamingGameplayVolume::BoundsOffset' has a wrong offset!");
static_assert(offsetof(AJunoStreamingGameplayVolume, LevelsToLoad) == 0x0003A0, "Member 'AJunoStreamingGameplayVolume::LevelsToLoad' has a wrong offset!");

// Class JunoProceduralWorld.JunoTileSubsystem
// 0x0108 (0x0138 - 0x0030)
class UJunoTileSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoPlayspacePersistenceFeatureHelper* TileGridPersistenceFeatureHelper;                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoWorldTileSelectionBase*            TileSelectionInterfaceObject;                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class AActor*>              OutOfBoundsActors;                                 // 0x0048(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0xA0];                                      // 0x0098(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePossessedPawnChanged(class APawn* OldPawn, class APawn* Pawn);
	void OnCellActivate(const class UJunoDynamicRuntimeCell* Cell);
	void OnCellDeactivate(const class UJunoDynamicRuntimeCell* Cell);
	void OnCellLoad(const class UJunoDynamicRuntimeCell* Cell);
	void OnCellUnload(const class UJunoDynamicRuntimeCell* Cell);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTileSubsystem">();
	}
	static class UJunoTileSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTileSubsystem>();
	}
};
static_assert(alignof(UJunoTileSubsystem) == 0x000008, "Wrong alignment on UJunoTileSubsystem");
static_assert(sizeof(UJunoTileSubsystem) == 0x000138, "Wrong size on UJunoTileSubsystem");
static_assert(offsetof(UJunoTileSubsystem, TileGridPersistenceFeatureHelper) == 0x000038, "Member 'UJunoTileSubsystem::TileGridPersistenceFeatureHelper' has a wrong offset!");
static_assert(offsetof(UJunoTileSubsystem, TileSelectionInterfaceObject) == 0x000040, "Member 'UJunoTileSubsystem::TileSelectionInterfaceObject' has a wrong offset!");
static_assert(offsetof(UJunoTileSubsystem, OutOfBoundsActors) == 0x000048, "Member 'UJunoTileSubsystem::OutOfBoundsActors' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoSpawnLivingWorldStaticPointSettings
// 0x0088 (0x01D8 - 0x0150)
class UPCGJunoSpawnLivingWorldStaticPointSettings final : public UPCGSettings
{
public:
	struct FGameplayTagContainer                  FiltersTags;                                       // 0x0150(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FPCGJunoSpawnLivingWorldStaticPointTag> ConditionalTags;                                   // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPCGJunoSpawnLivingWorldStaticPointTagConditionSet> ConditionalTagsSets;                               // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bExclusiveConditionalTags;                         // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   StaticPointClass;                                  // 0x0198(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PointClusterClass;                                 // 0x01B8(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoSpawnLivingWorldStaticPointSettings">();
	}
	static class UPCGJunoSpawnLivingWorldStaticPointSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoSpawnLivingWorldStaticPointSettings>();
	}
};
static_assert(alignof(UPCGJunoSpawnLivingWorldStaticPointSettings) == 0x000008, "Wrong alignment on UPCGJunoSpawnLivingWorldStaticPointSettings");
static_assert(sizeof(UPCGJunoSpawnLivingWorldStaticPointSettings) == 0x0001D8, "Wrong size on UPCGJunoSpawnLivingWorldStaticPointSettings");
static_assert(offsetof(UPCGJunoSpawnLivingWorldStaticPointSettings, FiltersTags) == 0x000150, "Member 'UPCGJunoSpawnLivingWorldStaticPointSettings::FiltersTags' has a wrong offset!");
static_assert(offsetof(UPCGJunoSpawnLivingWorldStaticPointSettings, ConditionalTags) == 0x000170, "Member 'UPCGJunoSpawnLivingWorldStaticPointSettings::ConditionalTags' has a wrong offset!");
static_assert(offsetof(UPCGJunoSpawnLivingWorldStaticPointSettings, ConditionalTagsSets) == 0x000180, "Member 'UPCGJunoSpawnLivingWorldStaticPointSettings::ConditionalTagsSets' has a wrong offset!");
static_assert(offsetof(UPCGJunoSpawnLivingWorldStaticPointSettings, bExclusiveConditionalTags) == 0x000190, "Member 'UPCGJunoSpawnLivingWorldStaticPointSettings::bExclusiveConditionalTags' has a wrong offset!");
static_assert(offsetof(UPCGJunoSpawnLivingWorldStaticPointSettings, StaticPointClass) == 0x000198, "Member 'UPCGJunoSpawnLivingWorldStaticPointSettings::StaticPointClass' has a wrong offset!");
static_assert(offsetof(UPCGJunoSpawnLivingWorldStaticPointSettings, PointClusterClass) == 0x0001B8, "Member 'UPCGJunoSpawnLivingWorldStaticPointSettings::PointClusterClass' has a wrong offset!");

// Class JunoProceduralWorld.JunoCaveShellGameplayVolume
// 0x00B8 (0x0468 - 0x03B0)
class AJunoCaveShellGameplayVolume final : public AJunoStreamingGameplayVolume
{
public:
	struct FJunoCaveShellInstanceData             InstanceData;                                      // 0x03B0(0x0078)(SaveGame, NativeAccessSpecifierPublic)
	class FName                                   ShellID;                                           // 0x0428(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  CaveGuid;                                          // 0x042C(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AJunoTeleporter*>                Teleporters;                                       // 0x0440(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FJunoWorldTileStreamingLevel>   LevelsToInject;                                    // 0x0450(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         PersistenceVersion;                                // 0x0460(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveShellGameplayVolume">();
	}
	static class AJunoCaveShellGameplayVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoCaveShellGameplayVolume>();
	}
};
static_assert(alignof(AJunoCaveShellGameplayVolume) == 0x000008, "Wrong alignment on AJunoCaveShellGameplayVolume");
static_assert(sizeof(AJunoCaveShellGameplayVolume) == 0x000468, "Wrong size on AJunoCaveShellGameplayVolume");
static_assert(offsetof(AJunoCaveShellGameplayVolume, InstanceData) == 0x0003B0, "Member 'AJunoCaveShellGameplayVolume::InstanceData' has a wrong offset!");
static_assert(offsetof(AJunoCaveShellGameplayVolume, ShellID) == 0x000428, "Member 'AJunoCaveShellGameplayVolume::ShellID' has a wrong offset!");
static_assert(offsetof(AJunoCaveShellGameplayVolume, CaveGuid) == 0x00042C, "Member 'AJunoCaveShellGameplayVolume::CaveGuid' has a wrong offset!");
static_assert(offsetof(AJunoCaveShellGameplayVolume, Teleporters) == 0x000440, "Member 'AJunoCaveShellGameplayVolume::Teleporters' has a wrong offset!");
static_assert(offsetof(AJunoCaveShellGameplayVolume, LevelsToInject) == 0x000450, "Member 'AJunoCaveShellGameplayVolume::LevelsToInject' has a wrong offset!");
static_assert(offsetof(AJunoCaveShellGameplayVolume, PersistenceVersion) == 0x000460, "Member 'AJunoCaveShellGameplayVolume::PersistenceVersion' has a wrong offset!");

// Class JunoProceduralWorld.JunoCaveBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoCaveBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CalculateCaveShellDistance(const struct FJunoCave& Cave, const class FName ShellID_A, const class FName ShellID_B, int32* Distance, EJunoCalculateCaveDistanceResult* Result);
	static void CreateCaveInstanceData(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const TArray<struct FJunoGeneratedCaveShellData>& CaveShellData, EJunoCreateCaveResult* Result);
	static void CreateCaveInstanceDataForSurfaceData(const class AActor* POISlotActor, const struct FJunoCaveSurfaceData& SurfaceData, const TArray<struct FJunoGeneratedCaveShellData>& CaveShellData, EJunoCreateCaveResult* Result);
	static int32 CreateExitsUsedMaskFromArray(const TArray<int32>& ExitsUsed);
	static TArray<int32> ExitsUsedMaskToArray(int32 ExitsUsedMask);
	static void GetBestCaveShellFromArea(const class UObject* WorldContextObject, const struct FBox& Area, struct FJunoCave* Cave, struct FGuid* CaveGuid, class FName* ShellID, EJunoGetBestCaveResult* Result);
	static void GetCaveDataCollectionsFromRegistry(const struct FDataRegistryType& DataRegistry, TArray<TSoftObjectPtr<class UJunoCaveDataCollectionBase>>* Array, EJunoGetCaveDataCollectionsFromRegistryResult* Result);
	static struct FJunoCaveShellInstanceData GetCaveShellInstanceData(const class AActor* CaveShellChildActor, class FName ShellID, bool* Success);
	static void GetCaveShellInstanceDataFromActor(const class AActor* CaveShellChildActor, class FName ShellID, struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result);
	static void GetCaveShellInstanceDataFromArea(const class UObject* WorldContextObject, const struct FBox& Area, class FName ShellID, struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result);
	static const class AJunoCaveShellGameplayVolume* GetCaveShellVolumeFromArea(const class UObject* WorldContextObject, const struct FBox& Area, class FName ShellID);
	static void GetCaveSurfaceDataForEntrance(const class AActor* Actor, const struct FGuid& EntranceGuid, struct FJunoCaveSurfaceData* CaveSurfaceData, int32* CaveIndex, EJunoGetCaveSurfaceDataForEntranceResult* Result, bool bWorldTeleporterTransforms);
	static bool IsBitSet(int32 BitMask, int32 Bit);
	static bool NeedsCaveShellInstanceData(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid);
	static void QueryCaveDataStateFromActor(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, EJunoQueryCaveDataResult* Result, struct FBox* WorldTileBounds, TArray<struct FJunoCaveTeleporterLink>* Teleporters);
	static void QueryCaveDataStateFromSurfaceData(const class AActor* POISlotActor, const struct FJunoCaveSurfaceData& SurfaceData, EJunoQueryCaveDataResult* Result, struct FBox* WorldTileBounds, TArray<struct FJunoCaveTeleporterLink>* Teleporters);
	static EJunoQueryCaveDataResult QueryCaveShellInstanceDataState(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid);
	static void QueryCaveSurfaceDataState(const class AActor* Actor, EJunoQueryCaveSurfaceDataStateResult* Result);
	static void SetCaveSurfaceData(const class AActor* Actor, const TArray<struct FJunoCaveSurfaceData>& CaveSurfaceData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveBlueprintLibrary">();
	}
	static class UJunoCaveBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCaveBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoCaveBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoCaveBlueprintLibrary");
static_assert(sizeof(UJunoCaveBlueprintLibrary) == 0x000028, "Wrong size on UJunoCaveBlueprintLibrary");

// Class JunoProceduralWorld.JunoTerrainSystemAssets
// 0x0020 (0x0050 - 0x0030)
class UJunoTerrainSystemAssets final : public UPrimaryDataAsset
{
public:
	class UJunoLandscapeCustomMaterial*           WaterNavigationMaterial;                           // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJunoLandscapeCustomMaterial*           WaterIdentificationMaterial;                       // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJunoLandscapeCustomMaterial*           RiverIdentificationMaterial;                       // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJunoLandscapeCustomMaterial*           LakeIdentificationMaterial;                        // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTerrainSystemAssets">();
	}
	static class UJunoTerrainSystemAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTerrainSystemAssets>();
	}
};
static_assert(alignof(UJunoTerrainSystemAssets) == 0x000008, "Wrong alignment on UJunoTerrainSystemAssets");
static_assert(sizeof(UJunoTerrainSystemAssets) == 0x000050, "Wrong size on UJunoTerrainSystemAssets");
static_assert(offsetof(UJunoTerrainSystemAssets, WaterNavigationMaterial) == 0x000030, "Member 'UJunoTerrainSystemAssets::WaterNavigationMaterial' has a wrong offset!");
static_assert(offsetof(UJunoTerrainSystemAssets, WaterIdentificationMaterial) == 0x000038, "Member 'UJunoTerrainSystemAssets::WaterIdentificationMaterial' has a wrong offset!");
static_assert(offsetof(UJunoTerrainSystemAssets, RiverIdentificationMaterial) == 0x000040, "Member 'UJunoTerrainSystemAssets::RiverIdentificationMaterial' has a wrong offset!");
static_assert(offsetof(UJunoTerrainSystemAssets, LakeIdentificationMaterial) == 0x000048, "Member 'UJunoTerrainSystemAssets::LakeIdentificationMaterial' has a wrong offset!");

// Class JunoProceduralWorld.PCGAddLandscapeLayerWeightsSettings
// 0x0000 (0x0150 - 0x0150)
class UPCGAddLandscapeLayerWeightsSettings final : public UPCGSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGAddLandscapeLayerWeightsSettings">();
	}
	static class UPCGAddLandscapeLayerWeightsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGAddLandscapeLayerWeightsSettings>();
	}
};
static_assert(alignof(UPCGAddLandscapeLayerWeightsSettings) == 0x000008, "Wrong alignment on UPCGAddLandscapeLayerWeightsSettings");
static_assert(sizeof(UPCGAddLandscapeLayerWeightsSettings) == 0x000150, "Wrong size on UPCGAddLandscapeLayerWeightsSettings");

// Class JunoProceduralWorld.JunoCaveVolumePlayspaceComponent
// 0x0000 (0x00F8 - 0x00F8)
class UJunoCaveVolumePlayspaceComponent final : public UFortPlayspaceComponent
{
public:
	void NotifyActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void NotifyActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnPlayerEnteringCaveVolume(class AFortPlayerPawnAthena* PlayerPawn);
	void OnPlayerLeavingCaveVolume(class AFortPlayerPawnAthena* PlayerPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveVolumePlayspaceComponent">();
	}
	static class UJunoCaveVolumePlayspaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCaveVolumePlayspaceComponent>();
	}
};
static_assert(alignof(UJunoCaveVolumePlayspaceComponent) == 0x000008, "Wrong alignment on UJunoCaveVolumePlayspaceComponent");
static_assert(sizeof(UJunoCaveVolumePlayspaceComponent) == 0x0000F8, "Wrong size on UJunoCaveVolumePlayspaceComponent");

// Class JunoProceduralWorld.JunoCheatManager_ProceduralWorld
// 0x0000 (0x0028 - 0x0028)
class UJunoCheatManager_ProceduralWorld final : public UChildCheatManager
{
public:
	void JunoDumpMapTileImages();
	void JunoGoActor(const class FString& ActorClassName);
	void JunoGoBiome(class FName Biome);
	void JunoGoNearActor(const class FString& ActorClassName);
	void JunoLogStreamingVolumesDebugInfo();
	void JunoPOIVolumeDump();
	void JunoPOIVolumeDumpAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCheatManager_ProceduralWorld">();
	}
	static class UJunoCheatManager_ProceduralWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCheatManager_ProceduralWorld>();
	}
};
static_assert(alignof(UJunoCheatManager_ProceduralWorld) == 0x000008, "Wrong alignment on UJunoCheatManager_ProceduralWorld");
static_assert(sizeof(UJunoCheatManager_ProceduralWorld) == 0x000028, "Wrong size on UJunoCheatManager_ProceduralWorld");

// Class JunoProceduralWorld.PCGResolveBiomePOISettings
// 0x0018 (0x0168 - 0x0150)
class UPCGResolveBiomePOISettings final : public UPCGSettings
{
public:
	class FName                                   AttributeNameForBiomeDataTable;                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedActorPath;                 // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedPOIPath;                   // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForBoundsMultiplier;                  // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForRepresentation;                    // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedRowName;                   // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGResolveBiomePOISettings">();
	}
	static class UPCGResolveBiomePOISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGResolveBiomePOISettings>();
	}
};
static_assert(alignof(UPCGResolveBiomePOISettings) == 0x000008, "Wrong alignment on UPCGResolveBiomePOISettings");
static_assert(sizeof(UPCGResolveBiomePOISettings) == 0x000168, "Wrong size on UPCGResolveBiomePOISettings");
static_assert(offsetof(UPCGResolveBiomePOISettings, AttributeNameForBiomeDataTable) == 0x000150, "Member 'UPCGResolveBiomePOISettings::AttributeNameForBiomeDataTable' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomePOISettings, AttributeNameForResolvedActorPath) == 0x000154, "Member 'UPCGResolveBiomePOISettings::AttributeNameForResolvedActorPath' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomePOISettings, AttributeNameForResolvedPOIPath) == 0x000158, "Member 'UPCGResolveBiomePOISettings::AttributeNameForResolvedPOIPath' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomePOISettings, AttributeNameForBoundsMultiplier) == 0x00015C, "Member 'UPCGResolveBiomePOISettings::AttributeNameForBoundsMultiplier' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomePOISettings, AttributeNameForRepresentation) == 0x000160, "Member 'UPCGResolveBiomePOISettings::AttributeNameForRepresentation' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomePOISettings, AttributeNameForResolvedRowName) == 0x000164, "Member 'UPCGResolveBiomePOISettings::AttributeNameForResolvedRowName' has a wrong offset!");

// Class JunoProceduralWorld.JunoClientInstancedActorSpawnerSubsystem
// 0x0000 (0x00F0 - 0x00F0)
class UJunoClientInstancedActorSpawnerSubsystem final : public UMassActorSpawnerSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoClientInstancedActorSpawnerSubsystem">();
	}
	static class UJunoClientInstancedActorSpawnerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoClientInstancedActorSpawnerSubsystem>();
	}
};
static_assert(alignof(UJunoClientInstancedActorSpawnerSubsystem) == 0x000008, "Wrong alignment on UJunoClientInstancedActorSpawnerSubsystem");
static_assert(sizeof(UJunoClientInstancedActorSpawnerSubsystem) == 0x0000F0, "Wrong size on UJunoClientInstancedActorSpawnerSubsystem");

// Class JunoProceduralWorld.JunoDynamicRuntimeCell
// 0x0048 (0x00E0 - 0x0098)
class UJunoDynamicRuntimeCell final : public UWorldPartitionRuntimeLevelStreamingCell
{
public:
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevel*                                 DynamicCellLevel;                                  // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           DynamicDataLayers;                                 // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDynamicRuntimeCell">();
	}
	static class UJunoDynamicRuntimeCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDynamicRuntimeCell>();
	}
};
static_assert(alignof(UJunoDynamicRuntimeCell) == 0x000008, "Wrong alignment on UJunoDynamicRuntimeCell");
static_assert(sizeof(UJunoDynamicRuntimeCell) == 0x0000E0, "Wrong size on UJunoDynamicRuntimeCell");
static_assert(offsetof(UJunoDynamicRuntimeCell, DynamicCellLevel) == 0x0000B0, "Member 'UJunoDynamicRuntimeCell::DynamicCellLevel' has a wrong offset!");
static_assert(offsetof(UJunoDynamicRuntimeCell, DynamicDataLayers) == 0x0000B8, "Member 'UJunoDynamicRuntimeCell::DynamicDataLayers' has a wrong offset!");

// Class JunoProceduralWorld.JunoTileGridPersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoTileGridPersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTileGridPersistenceFeatureDataInterface">();
	}
	static class IJunoTileGridPersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoTileGridPersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoTileGridPersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoTileGridPersistenceFeatureDataInterface");
static_assert(sizeof(IJunoTileGridPersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoTileGridPersistenceFeatureDataInterface");

// Class JunoProceduralWorld.JunoDynamicRuntimeSpatialHash
// 0x00F0 (0x01D8 - 0x00E8)
class UJunoDynamicRuntimeSpatialHash final : public UWorldPartitionRuntimeSpatialHash
{
public:
	TMulticastInlineDelegate<void(class UJunoDynamicRuntimeCell* Cell)> OnCellLoad;                                        // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UJunoDynamicRuntimeCell* Cell)> OnCellUnload;                                      // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UJunoDynamicRuntimeCell* Cell)> OnCellActivate;                                    // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UJunoDynamicRuntimeCell* Cell)> OnCellDeactivate;                                  // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0xB0];                                     // 0x0128(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoDynamicRuntimeSpatialHash">();
	}
	static class UJunoDynamicRuntimeSpatialHash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoDynamicRuntimeSpatialHash>();
	}
};
static_assert(alignof(UJunoDynamicRuntimeSpatialHash) == 0x000008, "Wrong alignment on UJunoDynamicRuntimeSpatialHash");
static_assert(sizeof(UJunoDynamicRuntimeSpatialHash) == 0x0001D8, "Wrong size on UJunoDynamicRuntimeSpatialHash");
static_assert(offsetof(UJunoDynamicRuntimeSpatialHash, OnCellLoad) == 0x0000E8, "Member 'UJunoDynamicRuntimeSpatialHash::OnCellLoad' has a wrong offset!");
static_assert(offsetof(UJunoDynamicRuntimeSpatialHash, OnCellUnload) == 0x0000F8, "Member 'UJunoDynamicRuntimeSpatialHash::OnCellUnload' has a wrong offset!");
static_assert(offsetof(UJunoDynamicRuntimeSpatialHash, OnCellActivate) == 0x000108, "Member 'UJunoDynamicRuntimeSpatialHash::OnCellActivate' has a wrong offset!");
static_assert(offsetof(UJunoDynamicRuntimeSpatialHash, OnCellDeactivate) == 0x000118, "Member 'UJunoDynamicRuntimeSpatialHash::OnCellDeactivate' has a wrong offset!");

// Class JunoProceduralWorld.JunoGenerateTileInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoGenerateTileInterface final : public IInterface
{
public:
	void GenerateTile(const struct FJunoGenerateTileParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGenerateTileInterface">();
	}
	static class IJunoGenerateTileInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoGenerateTileInterface>();
	}
};
static_assert(alignof(IJunoGenerateTileInterface) == 0x000008, "Wrong alignment on IJunoGenerateTileInterface");
static_assert(sizeof(IJunoGenerateTileInterface) == 0x000028, "Wrong size on IJunoGenerateTileInterface");

// Class JunoProceduralWorld.PCGSetLevelInstanceLevelSettings
// 0x0008 (0x0158 - 0x0150)
class UPCGSetLevelInstanceLevelSettings final : public UPCGSettings
{
public:
	class FName                                   AttributeNameForResolvedPOIPath;                   // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForSpawnedActorPtr;                   // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGSetLevelInstanceLevelSettings">();
	}
	static class UPCGSetLevelInstanceLevelSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGSetLevelInstanceLevelSettings>();
	}
};
static_assert(alignof(UPCGSetLevelInstanceLevelSettings) == 0x000008, "Wrong alignment on UPCGSetLevelInstanceLevelSettings");
static_assert(sizeof(UPCGSetLevelInstanceLevelSettings) == 0x000158, "Wrong size on UPCGSetLevelInstanceLevelSettings");
static_assert(offsetof(UPCGSetLevelInstanceLevelSettings, AttributeNameForResolvedPOIPath) == 0x000150, "Member 'UPCGSetLevelInstanceLevelSettings::AttributeNameForResolvedPOIPath' has a wrong offset!");
static_assert(offsetof(UPCGSetLevelInstanceLevelSettings, AttributeNameForSpawnedActorPtr) == 0x000154, "Member 'UPCGSetLevelInstanceLevelSettings::AttributeNameForSpawnedActorPtr' has a wrong offset!");

// Class JunoProceduralWorld.JunoGenerateTileCommandlet
// 0x0008 (0x0088 - 0x0080)
class UJunoGenerateTileCommandlet final : public UCommandlet
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishedGenerating();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGenerateTileCommandlet">();
	}
	static class UJunoGenerateTileCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGenerateTileCommandlet>();
	}
};
static_assert(alignof(UJunoGenerateTileCommandlet) == 0x000008, "Wrong alignment on UJunoGenerateTileCommandlet");
static_assert(sizeof(UJunoGenerateTileCommandlet) == 0x000088, "Wrong size on UJunoGenerateTileCommandlet");

// Class JunoProceduralWorld.JunoInstancedActorComponent
// 0x0010 (0x00B0 - 0x00A0)
class UJunoInstancedActorComponent : public UActorComponent
{
public:
	struct FJunoActorInstanceHandle               InstanceHandle;                                    // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_InstanceHandle();

	bool HasMassEntity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorComponent">();
	}
	static class UJunoInstancedActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorComponent>();
	}
};
static_assert(alignof(UJunoInstancedActorComponent) == 0x000008, "Wrong alignment on UJunoInstancedActorComponent");
static_assert(sizeof(UJunoInstancedActorComponent) == 0x0000B0, "Wrong size on UJunoInstancedActorComponent");
static_assert(offsetof(UJunoInstancedActorComponent, InstanceHandle) == 0x0000A0, "Member 'UJunoInstancedActorComponent::InstanceHandle' has a wrong offset!");

// Class JunoProceduralWorld.PCGResolveBiomeSettings
// 0x0048 (0x0198 - 0x0150)
class UPCGResolveBiomeSettings final : public UPCGSettings
{
public:
	struct FPCGJunoBiomeEntry                     DefaultBiome;                                      // 0x0150(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FPCGJunoBiomeEntry>             Biomes;                                            // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedBiome;                     // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedBiomeEnum;                 // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedBiomeDataTable;            // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGResolveBiomeSettings">();
	}
	static class UPCGResolveBiomeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGResolveBiomeSettings>();
	}
};
static_assert(alignof(UPCGResolveBiomeSettings) == 0x000008, "Wrong alignment on UPCGResolveBiomeSettings");
static_assert(sizeof(UPCGResolveBiomeSettings) == 0x000198, "Wrong size on UPCGResolveBiomeSettings");
static_assert(offsetof(UPCGResolveBiomeSettings, DefaultBiome) == 0x000150, "Member 'UPCGResolveBiomeSettings::DefaultBiome' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeSettings, Biomes) == 0x000178, "Member 'UPCGResolveBiomeSettings::Biomes' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeSettings, AttributeNameForResolvedBiome) == 0x000188, "Member 'UPCGResolveBiomeSettings::AttributeNameForResolvedBiome' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeSettings, AttributeNameForResolvedBiomeEnum) == 0x00018C, "Member 'UPCGResolveBiomeSettings::AttributeNameForResolvedBiomeEnum' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeSettings, AttributeNameForResolvedBiomeDataTable) == 0x000190, "Member 'UPCGResolveBiomeSettings::AttributeNameForResolvedBiomeDataTable' has a wrong offset!");

// Class JunoProceduralWorld.JunoInstancedActorData
// 0x04D8 (0x0500 - 0x0028)
class UJunoInstancedActorData final : public UInstancedActorsData
{
public:
	uint16                                        ID;                                                // 0x0028(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJunoInstancedActorTagSet              Tags;                                              // 0x0038(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     InstanceTransforms;                                // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint16                                        NumValidInstances;                                 // 0x0080(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Bounds;                                            // 0x0088(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        NumInstances;                                      // 0x00C0(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMassEntityHandle>              Entities;                                          // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x30];                                      // 0x00D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoInstancedActorVisualizationInfo> InstanceVisualizations;                            // 0x0108(0x0010)(Edit, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x28];                                     // 0x0118(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoCompressedTransforms              CompressedInstanceTransforms;                      // 0x0140(0x0230)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoInstancedActorDeltaList           InstanceDeltas;                                    // 0x0380(0x0178)(Net, Transient, SaveGame, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AJunoInstancedActorManager* GetManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorData">();
	}
	static class UJunoInstancedActorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorData>();
	}
};
static_assert(alignof(UJunoInstancedActorData) == 0x000010, "Wrong alignment on UJunoInstancedActorData");
static_assert(sizeof(UJunoInstancedActorData) == 0x000500, "Wrong size on UJunoInstancedActorData");
static_assert(offsetof(UJunoInstancedActorData, ID) == 0x000028, "Member 'UJunoInstancedActorData::ID' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, ActorClass) == 0x000030, "Member 'UJunoInstancedActorData::ActorClass' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, Tags) == 0x000038, "Member 'UJunoInstancedActorData::Tags' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, InstanceTransforms) == 0x000070, "Member 'UJunoInstancedActorData::InstanceTransforms' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, NumValidInstances) == 0x000080, "Member 'UJunoInstancedActorData::NumValidInstances' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, Bounds) == 0x000088, "Member 'UJunoInstancedActorData::Bounds' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, NumInstances) == 0x0000C0, "Member 'UJunoInstancedActorData::NumInstances' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, Entities) == 0x0000C8, "Member 'UJunoInstancedActorData::Entities' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, InstanceVisualizations) == 0x000108, "Member 'UJunoInstancedActorData::InstanceVisualizations' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, CompressedInstanceTransforms) == 0x000140, "Member 'UJunoInstancedActorData::CompressedInstanceTransforms' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorData, InstanceDeltas) == 0x000380, "Member 'UJunoInstancedActorData::InstanceDeltas' has a wrong offset!");

// Class JunoProceduralWorld.JunoInstancedActorInitializerProcessor
// 0x02A0 (0x0360 - 0x00C0)
class UJunoInstancedActorInitializerProcessor final : public UMassProcessor
{
public:
	uint8                                         Pad_C0[0x2A0];                                     // 0x00C0(0x02A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorInitializerProcessor">();
	}
	static class UJunoInstancedActorInitializerProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorInitializerProcessor>();
	}
};
static_assert(alignof(UJunoInstancedActorInitializerProcessor) == 0x000008, "Wrong alignment on UJunoInstancedActorInitializerProcessor");
static_assert(sizeof(UJunoInstancedActorInitializerProcessor) == 0x000360, "Wrong size on UJunoInstancedActorInitializerProcessor");

// Class JunoProceduralWorld.JunoWorldTileSaveData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoWorldTileSaveData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileSaveData_Container">();
	}
	static class UJunoWorldTileSaveData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileSaveData_Container>();
	}
};
static_assert(alignof(UJunoWorldTileSaveData_Container) == 0x000008, "Wrong alignment on UJunoWorldTileSaveData_Container");
static_assert(sizeof(UJunoWorldTileSaveData_Container) == 0x0001E0, "Wrong size on UJunoWorldTileSaveData_Container");

// Class JunoProceduralWorld.JunoInstancedActorManager
// 0x0148 (0x03D8 - 0x0290)
class AJunoInstancedActorManager final : public AInstancedActorsManager
{
public:
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UJunoInstancedActorSubsystem*           InstancedActorSubsystem;                           // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoInstancedActorManagerHandle       ManagerHandle;                                     // 0x02B8(0x0004)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x2C];                                     // 0x02BC(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SavedActorGuid;                                    // 0x02E8(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPersistentDataRestored;                           // 0x02F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasSpawnedEntities;                               // 0x02F9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        NextInstanceDataID;                                // 0x02FA(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJunoInstancedActorData*>        PerActorClassInstanceData;                         // 0x0300(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FBox                                   InstanceBounds;                                    // 0x0310(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x40];                                     // 0x0348(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UInstancedStaticMeshComponent*, int32> ISMComponentToInstanceDataMap;                     // 0x0388(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorManager">();
	}
	static class AJunoInstancedActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoInstancedActorManager>();
	}
};
static_assert(alignof(AJunoInstancedActorManager) == 0x000008, "Wrong alignment on AJunoInstancedActorManager");
static_assert(sizeof(AJunoInstancedActorManager) == 0x0003D8, "Wrong size on AJunoInstancedActorManager");
static_assert(offsetof(AJunoInstancedActorManager, InstancedActorSubsystem) == 0x0002B0, "Member 'AJunoInstancedActorManager::InstancedActorSubsystem' has a wrong offset!");
static_assert(offsetof(AJunoInstancedActorManager, ManagerHandle) == 0x0002B8, "Member 'AJunoInstancedActorManager::ManagerHandle' has a wrong offset!");
static_assert(offsetof(AJunoInstancedActorManager, SavedActorGuid) == 0x0002E8, "Member 'AJunoInstancedActorManager::SavedActorGuid' has a wrong offset!");
static_assert(offsetof(AJunoInstancedActorManager, bPersistentDataRestored) == 0x0002F8, "Member 'AJunoInstancedActorManager::bPersistentDataRestored' has a wrong offset!");
static_assert(offsetof(AJunoInstancedActorManager, bHasSpawnedEntities) == 0x0002F9, "Member 'AJunoInstancedActorManager::bHasSpawnedEntities' has a wrong offset!");
static_assert(offsetof(AJunoInstancedActorManager, NextInstanceDataID) == 0x0002FA, "Member 'AJunoInstancedActorManager::NextInstanceDataID' has a wrong offset!");
static_assert(offsetof(AJunoInstancedActorManager, PerActorClassInstanceData) == 0x000300, "Member 'AJunoInstancedActorManager::PerActorClassInstanceData' has a wrong offset!");
static_assert(offsetof(AJunoInstancedActorManager, InstanceBounds) == 0x000310, "Member 'AJunoInstancedActorManager::InstanceBounds' has a wrong offset!");
static_assert(offsetof(AJunoInstancedActorManager, ISMComponentToInstanceDataMap) == 0x000388, "Member 'AJunoInstancedActorManager::ISMComponentToInstanceDataMap' has a wrong offset!");

// Class JunoProceduralWorld.JunoInstancedActorModifierBase
// 0x0050 (0x0078 - 0x0028)
class UJunoInstancedActorModifierBase : public UObject
{
public:
	struct FGameplayTagQuery                      InstanceTagsQuery;                                 // 0x0028(0x0048)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorModifierBase">();
	}
	static class UJunoInstancedActorModifierBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorModifierBase>();
	}
};
static_assert(alignof(UJunoInstancedActorModifierBase) == 0x000008, "Wrong alignment on UJunoInstancedActorModifierBase");
static_assert(sizeof(UJunoInstancedActorModifierBase) == 0x000078, "Wrong size on UJunoInstancedActorModifierBase");
static_assert(offsetof(UJunoInstancedActorModifierBase, InstanceTagsQuery) == 0x000028, "Member 'UJunoInstancedActorModifierBase::InstanceTagsQuery' has a wrong offset!");

// Class JunoProceduralWorld.JunoRemoveInstancedActorsModifier
// 0x0000 (0x0078 - 0x0078)
class UJunoRemoveInstancedActorsModifier final : public UJunoInstancedActorModifierBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRemoveInstancedActorsModifier">();
	}
	static class UJunoRemoveInstancedActorsModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRemoveInstancedActorsModifier>();
	}
};
static_assert(alignof(UJunoRemoveInstancedActorsModifier) == 0x000008, "Wrong alignment on UJunoRemoveInstancedActorsModifier");
static_assert(sizeof(UJunoRemoveInstancedActorsModifier) == 0x000078, "Wrong size on UJunoRemoveInstancedActorsModifier");

// Class JunoProceduralWorld.JunoInstancedActorModifierVolume
// 0x0008 (0x0298 - 0x0290)
class AJunoInstancedActorModifierVolume : public AActor
{
public:
	class UJunoInstancedActorModifierVolumeComponent* ModifierVolumeComponent;                           // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorModifierVolume">();
	}
	static class AJunoInstancedActorModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoInstancedActorModifierVolume>();
	}
};
static_assert(alignof(AJunoInstancedActorModifierVolume) == 0x000008, "Wrong alignment on AJunoInstancedActorModifierVolume");
static_assert(sizeof(AJunoInstancedActorModifierVolume) == 0x000298, "Wrong size on AJunoInstancedActorModifierVolume");
static_assert(offsetof(AJunoInstancedActorModifierVolume, ModifierVolumeComponent) == 0x000290, "Member 'AJunoInstancedActorModifierVolume::ModifierVolumeComponent' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTileSelectionBase
// 0x0020 (0x0050 - 0x0030)
class UJunoWorldTileSelectionBase : public UPrimaryDataAsset
{
public:
	float                                         TileExtent;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldGridCount;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WorldSize;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresDebugArea;                                // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          RandomStream;                                      // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableBiomeSwaps;                                 // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBorderPermutations;                         // 0x004D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChooseDebugTile(const class UObject* WorldContextObject, const struct FVector& Position, struct FPCGJunoWorldTile* OutSelectedTile);
	void ChooseOutOfBoundsTile(const class UObject* WorldContextObject, struct FPCGJunoWorldTile* OutSelectedTile);
	bool ChooseStartTile(const class UObject* WorldContextObject, struct FVector* StartTileLocation);
	void ChooseTile(const class UObject* WorldContextObject, const struct FVector& Position, struct FPCGJunoWorldTile* OutSelectedTile);
	struct FVector GetDebugLevelLocation(const class UObject* WorldContextObject);
	void Setup(const class UObject* WorldContextObject);
	bool UpdateTile(const class UObject* WorldContextObject, const struct FPCGJunoWorldTile& CurrentTile, struct FPCGJunoWorldTile* OutUpdatedTile);
	bool UseReservedArea(const class UObject* WorldContextObject, const class FName& AreaName, const TMap<class FName, struct FBox2D>& AreaTiles, TArray<struct FPCGJunoWorldTile>* OutNewTiles);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileSelectionBase">();
	}
	static class UJunoWorldTileSelectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileSelectionBase>();
	}
};
static_assert(alignof(UJunoWorldTileSelectionBase) == 0x000008, "Wrong alignment on UJunoWorldTileSelectionBase");
static_assert(sizeof(UJunoWorldTileSelectionBase) == 0x000050, "Wrong size on UJunoWorldTileSelectionBase");
static_assert(offsetof(UJunoWorldTileSelectionBase, TileExtent) == 0x000030, "Member 'UJunoWorldTileSelectionBase::TileExtent' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBase, WorldGridCount) == 0x000034, "Member 'UJunoWorldTileSelectionBase::WorldGridCount' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBase, WorldSize) == 0x000038, "Member 'UJunoWorldTileSelectionBase::WorldSize' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBase, bRequiresDebugArea) == 0x000040, "Member 'UJunoWorldTileSelectionBase::bRequiresDebugArea' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBase, RandomStream) == 0x000044, "Member 'UJunoWorldTileSelectionBase::RandomStream' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBase, bEnableBiomeSwaps) == 0x00004C, "Member 'UJunoWorldTileSelectionBase::bEnableBiomeSwaps' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBase, bEnableBorderPermutations) == 0x00004D, "Member 'UJunoWorldTileSelectionBase::bEnableBorderPermutations' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTileSelectionBeryl
// 0x0110 (0x0160 - 0x0050)
class UJunoWorldTileSelectionBeryl final : public UJunoWorldTileSelectionBase
{
public:
	struct FDataRegistryType                      TileRegistryType;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJunoBiome>                            ScatteredLandBiomes;                               // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<EJunoBiome>                            StartTileRequiredBiomes;                           // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         WaterLevel;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileNoiseFrequency;                                // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBigAlpineBiomes;                                // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BigAlpineMaxSize;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EJunoBiome>                            ScatteredAlpineBiomes;                             // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         NumSmallAlpineBiomes;                              // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfReservedAreas;                             // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, EJunoBiome>                 AreasToUpdate;                                     // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x70];                                      // 0x00F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileSelectionBeryl">();
	}
	static class UJunoWorldTileSelectionBeryl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileSelectionBeryl>();
	}
};
static_assert(alignof(UJunoWorldTileSelectionBeryl) == 0x000008, "Wrong alignment on UJunoWorldTileSelectionBeryl");
static_assert(sizeof(UJunoWorldTileSelectionBeryl) == 0x000160, "Wrong size on UJunoWorldTileSelectionBeryl");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, TileRegistryType) == 0x000050, "Member 'UJunoWorldTileSelectionBeryl::TileRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, ScatteredLandBiomes) == 0x000058, "Member 'UJunoWorldTileSelectionBeryl::ScatteredLandBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, StartTileRequiredBiomes) == 0x000068, "Member 'UJunoWorldTileSelectionBeryl::StartTileRequiredBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, WaterLevel) == 0x000078, "Member 'UJunoWorldTileSelectionBeryl::WaterLevel' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, TileNoiseFrequency) == 0x00007C, "Member 'UJunoWorldTileSelectionBeryl::TileNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, NumBigAlpineBiomes) == 0x000080, "Member 'UJunoWorldTileSelectionBeryl::NumBigAlpineBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, BigAlpineMaxSize) == 0x000084, "Member 'UJunoWorldTileSelectionBeryl::BigAlpineMaxSize' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, ScatteredAlpineBiomes) == 0x000088, "Member 'UJunoWorldTileSelectionBeryl::ScatteredAlpineBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, NumSmallAlpineBiomes) == 0x000098, "Member 'UJunoWorldTileSelectionBeryl::NumSmallAlpineBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, NumberOfReservedAreas) == 0x00009C, "Member 'UJunoWorldTileSelectionBeryl::NumberOfReservedAreas' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionBeryl, AreasToUpdate) == 0x0000A0, "Member 'UJunoWorldTileSelectionBeryl::AreasToUpdate' has a wrong offset!");

// Class JunoProceduralWorld.JunoInstancedActorRemovalModifierVolume
// 0x0000 (0x0298 - 0x0298)
class AJunoInstancedActorRemovalModifierVolume final : public AJunoInstancedActorModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorRemovalModifierVolume">();
	}
	static class AJunoInstancedActorRemovalModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoInstancedActorRemovalModifierVolume>();
	}
};
static_assert(alignof(AJunoInstancedActorRemovalModifierVolume) == 0x000008, "Wrong alignment on AJunoInstancedActorRemovalModifierVolume");
static_assert(sizeof(AJunoInstancedActorRemovalModifierVolume) == 0x000298, "Wrong size on AJunoInstancedActorRemovalModifierVolume");

// Class JunoProceduralWorld.JunoInstancedActorModifierVolumeComponent
// 0x0080 (0x0580 - 0x0500)
class UJunoInstancedActorModifierVolumeComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EJunoIAVolumeShape                            Shape;                                             // 0x0508(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Extent;                                            // 0x0510(0x0018)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0528(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJunoInstancedActorModifierBase*> Modifiers;                                         // 0x0530(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOwnLevelsInstances;                         // 0x0540(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          LevelsToIgnore;                                    // 0x0548(0x0010)(Edit, Net, ZeroConstructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawOnlyIfSelected;                               // 0x055C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55D[0x3];                                      // 0x055D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineThickness;                                     // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJunoInstancedActorModifierVolumeHandle ModifierVolumeHandle;                              // 0x0564(0x0004)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AJunoInstancedActorManager>> ModifiedManagers;                                  // 0x0568(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorModifierVolumeComponent">();
	}
	static class UJunoInstancedActorModifierVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorModifierVolumeComponent>();
	}
};
static_assert(alignof(UJunoInstancedActorModifierVolumeComponent) == 0x000010, "Wrong alignment on UJunoInstancedActorModifierVolumeComponent");
static_assert(sizeof(UJunoInstancedActorModifierVolumeComponent) == 0x000580, "Wrong size on UJunoInstancedActorModifierVolumeComponent");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, Shape) == 0x000508, "Member 'UJunoInstancedActorModifierVolumeComponent::Shape' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, Extent) == 0x000510, "Member 'UJunoInstancedActorModifierVolumeComponent::Extent' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, Radius) == 0x000528, "Member 'UJunoInstancedActorModifierVolumeComponent::Radius' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, Modifiers) == 0x000530, "Member 'UJunoInstancedActorModifierVolumeComponent::Modifiers' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, bIgnoreOwnLevelsInstances) == 0x000540, "Member 'UJunoInstancedActorModifierVolumeComponent::bIgnoreOwnLevelsInstances' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, LevelsToIgnore) == 0x000548, "Member 'UJunoInstancedActorModifierVolumeComponent::LevelsToIgnore' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, Color) == 0x000558, "Member 'UJunoInstancedActorModifierVolumeComponent::Color' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, bDrawOnlyIfSelected) == 0x00055C, "Member 'UJunoInstancedActorModifierVolumeComponent::bDrawOnlyIfSelected' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, LineThickness) == 0x000560, "Member 'UJunoInstancedActorModifierVolumeComponent::LineThickness' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, ModifierVolumeHandle) == 0x000564, "Member 'UJunoInstancedActorModifierVolumeComponent::ModifierVolumeHandle' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorModifierVolumeComponent, ModifiedManagers) == 0x000568, "Member 'UJunoInstancedActorModifierVolumeComponent::ModifiedManagers' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTilePersistenceFeatureDataInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoWorldTilePersistenceFeatureDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTilePersistenceFeatureDataInterface">();
	}
	static class IJunoWorldTilePersistenceFeatureDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoWorldTilePersistenceFeatureDataInterface>();
	}
};
static_assert(alignof(IJunoWorldTilePersistenceFeatureDataInterface) == 0x000008, "Wrong alignment on IJunoWorldTilePersistenceFeatureDataInterface");
static_assert(sizeof(IJunoWorldTilePersistenceFeatureDataInterface) == 0x000028, "Wrong size on IJunoWorldTilePersistenceFeatureDataInterface");

// Class JunoProceduralWorld.JunoRemoveInstancesModifierVolumeComponent
// 0x0000 (0x0580 - 0x0580)
class UJunoRemoveInstancesModifierVolumeComponent final : public UJunoInstancedActorModifierVolumeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRemoveInstancesModifierVolumeComponent">();
	}
	static class UJunoRemoveInstancesModifierVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRemoveInstancesModifierVolumeComponent>();
	}
};
static_assert(alignof(UJunoRemoveInstancesModifierVolumeComponent) == 0x000010, "Wrong alignment on UJunoRemoveInstancesModifierVolumeComponent");
static_assert(sizeof(UJunoRemoveInstancesModifierVolumeComponent) == 0x000580, "Wrong size on UJunoRemoveInstancesModifierVolumeComponent");

// Class JunoProceduralWorld.JunoInstancedActorRepresentationActorManagement
// 0x0000 (0x0028 - 0x0028)
class UJunoInstancedActorRepresentationActorManagement final : public UMassRepresentationActorManagement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorRepresentationActorManagement">();
	}
	static class UJunoInstancedActorRepresentationActorManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorRepresentationActorManagement>();
	}
};
static_assert(alignof(UJunoInstancedActorRepresentationActorManagement) == 0x000008, "Wrong alignment on UJunoInstancedActorRepresentationActorManagement");
static_assert(sizeof(UJunoInstancedActorRepresentationActorManagement) == 0x000028, "Wrong size on UJunoInstancedActorRepresentationActorManagement");

// Class JunoProceduralWorld.JunoInstancedActorRepresentationSubsystem
// 0x0000 (0x00D0 - 0x00D0)
class UJunoInstancedActorRepresentationSubsystem final : public UMassRepresentationSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorRepresentationSubsystem">();
	}
	static class UJunoInstancedActorRepresentationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorRepresentationSubsystem>();
	}
};
static_assert(alignof(UJunoInstancedActorRepresentationSubsystem) == 0x000008, "Wrong alignment on UJunoInstancedActorRepresentationSubsystem");
static_assert(sizeof(UJunoInstancedActorRepresentationSubsystem) == 0x0000D0, "Wrong size on UJunoInstancedActorRepresentationSubsystem");

// Class JunoProceduralWorld.JunoInstancedActorProjectSettings
// 0x0018 (0x0048 - 0x0030)
class UJunoInstancedActorProjectSettings final : public UDeveloperSettings
{
public:
	int32                                         GridSize;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataRegistryType                      NamedSettingsRegistryType;                         // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataRegistryType                      ActorClassSettingsRegistryType;                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultBaseSettingsName;                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnforcedSettingsName;                              // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorProjectSettings">();
	}
	static class UJunoInstancedActorProjectSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorProjectSettings>();
	}
};
static_assert(alignof(UJunoInstancedActorProjectSettings) == 0x000008, "Wrong alignment on UJunoInstancedActorProjectSettings");
static_assert(sizeof(UJunoInstancedActorProjectSettings) == 0x000048, "Wrong size on UJunoInstancedActorProjectSettings");
static_assert(offsetof(UJunoInstancedActorProjectSettings, GridSize) == 0x000030, "Member 'UJunoInstancedActorProjectSettings::GridSize' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorProjectSettings, NamedSettingsRegistryType) == 0x000034, "Member 'UJunoInstancedActorProjectSettings::NamedSettingsRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorProjectSettings, ActorClassSettingsRegistryType) == 0x000038, "Member 'UJunoInstancedActorProjectSettings::ActorClassSettingsRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorProjectSettings, DefaultBaseSettingsName) == 0x00003C, "Member 'UJunoInstancedActorProjectSettings::DefaultBaseSettingsName' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorProjectSettings, EnforcedSettingsName) == 0x000040, "Member 'UJunoInstancedActorProjectSettings::EnforcedSettingsName' has a wrong offset!");

// Class JunoProceduralWorld.JunoInstancedActorSubsystem
// 0x02C0 (0x0300 - 0x0040)
class UJunoInstancedActorSubsystem final : public UTickableWorldSubsystem
{
public:
	class UJunoInstancedActorProjectSettings*     ProjectSettings;                                   // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataRegistrySubsystem*                 DataRegistrySubsystem;                             // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorPartitionSubsystem*               ActorPartitionSubsystem;                           // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x250];                                     // 0x0058(0x0250)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 ExemplarActorWorld;                                // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UObject>, class AActor*> ExemplarActors;                                    // 0x02B0(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorSubsystem">();
	}
	static class UJunoInstancedActorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorSubsystem>();
	}
};
static_assert(alignof(UJunoInstancedActorSubsystem) == 0x000008, "Wrong alignment on UJunoInstancedActorSubsystem");
static_assert(sizeof(UJunoInstancedActorSubsystem) == 0x000300, "Wrong size on UJunoInstancedActorSubsystem");
static_assert(offsetof(UJunoInstancedActorSubsystem, ProjectSettings) == 0x000040, "Member 'UJunoInstancedActorSubsystem::ProjectSettings' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorSubsystem, DataRegistrySubsystem) == 0x000048, "Member 'UJunoInstancedActorSubsystem::DataRegistrySubsystem' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorSubsystem, ActorPartitionSubsystem) == 0x000050, "Member 'UJunoInstancedActorSubsystem::ActorPartitionSubsystem' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorSubsystem, ExemplarActorWorld) == 0x0002A8, "Member 'UJunoInstancedActorSubsystem::ExemplarActorWorld' has a wrong offset!");
static_assert(offsetof(UJunoInstancedActorSubsystem, ExemplarActors) == 0x0002B0, "Member 'UJunoInstancedActorSubsystem::ExemplarActors' has a wrong offset!");

// Class JunoProceduralWorld.JunoInstancedActorVisualizationSwitcherProcessor
// 0x02A0 (0x0360 - 0x00C0)
class UJunoInstancedActorVisualizationSwitcherProcessor final : public UMassProcessor
{
public:
	uint8                                         Pad_C0[0x2A0];                                     // 0x00C0(0x02A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorVisualizationSwitcherProcessor">();
	}
	static class UJunoInstancedActorVisualizationSwitcherProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorVisualizationSwitcherProcessor>();
	}
};
static_assert(alignof(UJunoInstancedActorVisualizationSwitcherProcessor) == 0x000008, "Wrong alignment on UJunoInstancedActorVisualizationSwitcherProcessor");
static_assert(sizeof(UJunoInstancedActorVisualizationSwitcherProcessor) == 0x000360, "Wrong size on UJunoInstancedActorVisualizationSwitcherProcessor");

// Class JunoProceduralWorld.JunoInstancedActorVisualizationTrait
// 0x0000 (0x0120 - 0x0120)
class UJunoInstancedActorVisualizationTrait final : public UMassStationaryDistanceVisualizationTrait
{
public:
	TWeakObjectPtr<class UJunoInstancedActorData> InstanceData;                                      // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoInstancedActorVisualizationTrait">();
	}
	static class UJunoInstancedActorVisualizationTrait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoInstancedActorVisualizationTrait>();
	}
};
static_assert(alignof(UJunoInstancedActorVisualizationTrait) == 0x000010, "Wrong alignment on UJunoInstancedActorVisualizationTrait");
static_assert(sizeof(UJunoInstancedActorVisualizationTrait) == 0x000120, "Wrong size on UJunoInstancedActorVisualizationTrait");
static_assert(offsetof(UJunoInstancedActorVisualizationTrait, InstanceData) == 0x000118, "Member 'UJunoInstancedActorVisualizationTrait::InstanceData' has a wrong offset!");

// Class JunoProceduralWorld.JunoLifecycleComponent
// 0x0060 (0x0110 - 0x00B0)
class UJunoLifecycleComponent final : public UJunoInstancedActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoLifecyclePhase>            LifecyclePhases;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAutoAddFinalLifecyclePhase;                       // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatLifecyclePhases;                            // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(uint8 PreviousLifecyclePhase, uint8 NewLifecyclePhase)> OnLifecyclePhaseChangedDelegate;                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLifecycleCompletedDelegate;                      // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x00F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartingPhaseIndex;                                // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         CurrentPhaseIndex;                                 // 0x0101(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_102[0xE];                                      // 0x0102(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCurrentPhaseOverrides();
	void OnRep_CurrentPhaseIndex(uint8 PreviousLifecyclePhaseIndex);
	bool SetCurrentPhaseByIndex(uint8 NewCurrentPhaseIndex, float TimeElapsedInNewPhase, bool bUpdateMass);

	bool BP_GetCurrentPhase(struct FJunoLifecyclePhase* OutCurrentPhase) const;
	uint8 GetCurrentPhaseIndex() const;
	float GetCurrentPhaseTimeElapsed() const;
	bool HasCompletedLifecycle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLifecycleComponent">();
	}
	static class UJunoLifecycleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLifecycleComponent>();
	}
};
static_assert(alignof(UJunoLifecycleComponent) == 0x000008, "Wrong alignment on UJunoLifecycleComponent");
static_assert(sizeof(UJunoLifecycleComponent) == 0x000110, "Wrong size on UJunoLifecycleComponent");
static_assert(offsetof(UJunoLifecycleComponent, LifecyclePhases) == 0x0000C0, "Member 'UJunoLifecycleComponent::LifecyclePhases' has a wrong offset!");
static_assert(offsetof(UJunoLifecycleComponent, bAutoAddFinalLifecyclePhase) == 0x0000D0, "Member 'UJunoLifecycleComponent::bAutoAddFinalLifecyclePhase' has a wrong offset!");
static_assert(offsetof(UJunoLifecycleComponent, bRepeatLifecyclePhases) == 0x0000D1, "Member 'UJunoLifecycleComponent::bRepeatLifecyclePhases' has a wrong offset!");
static_assert(offsetof(UJunoLifecycleComponent, OnLifecyclePhaseChangedDelegate) == 0x0000D8, "Member 'UJunoLifecycleComponent::OnLifecyclePhaseChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoLifecycleComponent, OnLifecycleCompletedDelegate) == 0x0000E8, "Member 'UJunoLifecycleComponent::OnLifecycleCompletedDelegate' has a wrong offset!");
static_assert(offsetof(UJunoLifecycleComponent, MeshComponent) == 0x0000F8, "Member 'UJunoLifecycleComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UJunoLifecycleComponent, StartingPhaseIndex) == 0x000100, "Member 'UJunoLifecycleComponent::StartingPhaseIndex' has a wrong offset!");
static_assert(offsetof(UJunoLifecycleComponent, CurrentPhaseIndex) == 0x000101, "Member 'UJunoLifecycleComponent::CurrentPhaseIndex' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldRegistryManager
// 0x0028 (0x0120 - 0x00F8)
class UJunoWorldRegistryManager final : public UFortPlayspaceComponent
{
public:
	uint8                                         Pad_F8[0x28];                                      // 0x00F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AJunoWorldTile* GetTileForLocation(const class UObject* WorldContextObject, const struct FVector& WorldLocation);

	struct FJunoWorldRegistryEntry GetClosestEntryUsingTagQuery(EJunoWorldRegistryType EntryType, const struct FGameplayTagQuery& TagQuery, const struct FVector& QueryLocation);

	void GetBiomeAtLocation(const struct FVector& Location, struct FJunoBiomeInfoQueryResult* OutResult) const;
	bool GetNormalizedTileLocation(const class UObject* WorldContextObject, const struct FVector& WorldLocation, struct FVector* OutResult) const;
	TSoftObjectPtr<class UTexture2D> GetTileMiniMapTexture(const class UObject* WorldContextObject, const struct FVector& WorldLocation) const;
	void GetWaterDirectionInformationAtLocation(const struct FVector& Location, bool bIncludeNearMisses, bool* OutInWater, TArray<struct FJunoWaterLocationResult>* OutResult) const;
	void GetWaterInformationInDirection(const struct FVector& Location, const struct FVector& Direction, struct FJunoWaterLocationResult* OutResult) const;
	void GetWorldAnalyticsInfo(const class UObject* WorldContextObject, const struct FVector& WorldLocation, struct FJunoWorldAnalyticsInfoResult* WorldAnalyticsInfo) const;
	struct FBoxSphereBounds GetWorldBounds() const;
	void GetWorldDebugInfoText(const class AFortPlayerPawn* PlayerPawn, struct FJunoDebugWorldInfoResult* WorldDebugInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldRegistryManager">();
	}
	static class UJunoWorldRegistryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldRegistryManager>();
	}
};
static_assert(alignof(UJunoWorldRegistryManager) == 0x000008, "Wrong alignment on UJunoWorldRegistryManager");
static_assert(sizeof(UJunoWorldRegistryManager) == 0x000120, "Wrong size on UJunoWorldRegistryManager");

// Class JunoProceduralWorld.JunoLifecycleProcessor
// 0x02A0 (0x0360 - 0x00C0)
class UJunoLifecycleProcessor final : public UMassProcessor
{
public:
	uint8                                         Pad_C0[0x2A0];                                     // 0x00C0(0x02A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLifecycleProcessor">();
	}
	static class UJunoLifecycleProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLifecycleProcessor>();
	}
};
static_assert(alignof(UJunoLifecycleProcessor) == 0x000008, "Wrong alignment on UJunoLifecycleProcessor");
static_assert(sizeof(UJunoLifecycleProcessor) == 0x000360, "Wrong size on UJunoLifecycleProcessor");

// Class JunoProceduralWorld.JunoLifecycleVisualizationProcessor
// 0x02A0 (0x0360 - 0x00C0)
class UJunoLifecycleVisualizationProcessor final : public UMassProcessor
{
public:
	uint8                                         Pad_C0[0x2A0];                                     // 0x00C0(0x02A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLifecycleVisualizationProcessor">();
	}
	static class UJunoLifecycleVisualizationProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLifecycleVisualizationProcessor>();
	}
};
static_assert(alignof(UJunoLifecycleVisualizationProcessor) == 0x000008, "Wrong alignment on UJunoLifecycleVisualizationProcessor");
static_assert(sizeof(UJunoLifecycleVisualizationProcessor) == 0x000360, "Wrong size on UJunoLifecycleVisualizationProcessor");

// Class JunoProceduralWorld.JunoLightWeightBuildingProp
// 0x0000 (0x0290 - 0x0290)
class AJunoLightWeightBuildingProp final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLightWeightBuildingProp">();
	}
	static class AJunoLightWeightBuildingProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoLightWeightBuildingProp>();
	}
};
static_assert(alignof(AJunoLightWeightBuildingProp) == 0x000008, "Wrong alignment on AJunoLightWeightBuildingProp");
static_assert(sizeof(AJunoLightWeightBuildingProp) == 0x000290, "Wrong size on AJunoLightWeightBuildingProp");

// Class JunoProceduralWorld.JunoLightWeightBuildingGameplayActor
// 0x0000 (0x0290 - 0x0290)
class AJunoLightWeightBuildingGameplayActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLightWeightBuildingGameplayActor">();
	}
	static class AJunoLightWeightBuildingGameplayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoLightWeightBuildingGameplayActor>();
	}
};
static_assert(alignof(AJunoLightWeightBuildingGameplayActor) == 0x000008, "Wrong alignment on AJunoLightWeightBuildingGameplayActor");
static_assert(sizeof(AJunoLightWeightBuildingGameplayActor) == 0x000290, "Wrong size on AJunoLightWeightBuildingGameplayActor");

// Class JunoProceduralWorld.JunoLightWeightFortStaticMeshActor
// 0x0000 (0x0290 - 0x0290)
class AJunoLightWeightFortStaticMeshActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLightWeightFortStaticMeshActor">();
	}
	static class AJunoLightWeightFortStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoLightWeightFortStaticMeshActor>();
	}
};
static_assert(alignof(AJunoLightWeightFortStaticMeshActor) == 0x000008, "Wrong alignment on AJunoLightWeightFortStaticMeshActor");
static_assert(sizeof(AJunoLightWeightFortStaticMeshActor) == 0x000290, "Wrong size on AJunoLightWeightFortStaticMeshActor");

// Class JunoProceduralWorld.JunoMassEntityClientDebugProcessor
// 0x0000 (0x00C0 - 0x00C0)
class UJunoMassEntityClientDebugProcessor final : public UMassProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMassEntityClientDebugProcessor">();
	}
	static class UJunoMassEntityClientDebugProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMassEntityClientDebugProcessor>();
	}
};
static_assert(alignof(UJunoMassEntityClientDebugProcessor) == 0x000008, "Wrong alignment on UJunoMassEntityClientDebugProcessor");
static_assert(sizeof(UJunoMassEntityClientDebugProcessor) == 0x0000C0, "Wrong size on UJunoMassEntityClientDebugProcessor");

// Class JunoProceduralWorld.JunoMassHydrationSignalProcessorBase
// 0x0000 (0x0420 - 0x0420)
class UJunoMassHydrationSignalProcessorBase : public UMassSignalProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMassHydrationSignalProcessorBase">();
	}
	static class UJunoMassHydrationSignalProcessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMassHydrationSignalProcessorBase>();
	}
};
static_assert(alignof(UJunoMassHydrationSignalProcessorBase) == 0x000008, "Wrong alignment on UJunoMassHydrationSignalProcessorBase");
static_assert(sizeof(UJunoMassHydrationSignalProcessorBase) == 0x000420, "Wrong size on UJunoMassHydrationSignalProcessorBase");

// Class JunoProceduralWorld.JunoMassHydrationSignalProcessor
// 0x0000 (0x0420 - 0x0420)
class UJunoMassHydrationSignalProcessor final : public UJunoMassHydrationSignalProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMassHydrationSignalProcessor">();
	}
	static class UJunoMassHydrationSignalProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMassHydrationSignalProcessor>();
	}
};
static_assert(alignof(UJunoMassHydrationSignalProcessor) == 0x000008, "Wrong alignment on UJunoMassHydrationSignalProcessor");
static_assert(sizeof(UJunoMassHydrationSignalProcessor) == 0x000420, "Wrong size on UJunoMassHydrationSignalProcessor");

// Class JunoProceduralWorld.JunoMassDehydrationSignalProcessor
// 0x0000 (0x0420 - 0x0420)
class UJunoMassDehydrationSignalProcessor final : public UJunoMassHydrationSignalProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMassDehydrationSignalProcessor">();
	}
	static class UJunoMassDehydrationSignalProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMassDehydrationSignalProcessor>();
	}
};
static_assert(alignof(UJunoMassDehydrationSignalProcessor) == 0x000008, "Wrong alignment on UJunoMassDehydrationSignalProcessor");
static_assert(sizeof(UJunoMassDehydrationSignalProcessor) == 0x000420, "Wrong size on UJunoMassDehydrationSignalProcessor");

// Class JunoProceduralWorld.JunoTerrainGenerationSystem
// 0x05B0 (0x05F0 - 0x0040)
class UJunoTerrainGenerationSystem final : public UTickableWorldSubsystem
{
public:
	TSet<class ALandscapeProxy*>                  TrackedLandscapes;                                 // 0x0040(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class UJunoLandscapeComponent*>          TrackedLandscapeComponents;                        // 0x0090(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UJunoLandscapeManager*                  JunoLandscapeManager;                              // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UJunoLandscapeLayersData*> PluginLayerData;                                   // 0x00E8(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x178];                                    // 0x0138(0x0178)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoTerrainGenerationConfiguration    VisualsConfiguration;                              // 0x02B0(0x0058)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoTerrainGenerationConfiguration    HeightmapConfiguration;                            // 0x0308(0x0058)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoTerrainGenerationConfiguration    GrassConfiguration;                                // 0x0360(0x0058)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoTerrainGenerationConfiguration    CollisionConfiguration;                            // 0x03B8(0x0058)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoTerrainGenerationConfiguration    WeightmapConfiguration;                            // 0x0410(0x0058)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJunoTerrainGenerationConfiguration    WaterConfiguration;                                // 0x0468(0x0058)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           WeightmapsToGather;                                // 0x04C0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	bool                                          bEnablePhysicsAndGrassStripping;                   // 0x04D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ExcludePhysicsAndGrassStrippingPlatforms;          // 0x04D8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	bool                                          bEnablePCGCacheStripping;                          // 0x04E8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ExcludePCGCacheStrippingPlatforms;                 // 0x04F0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class UJunoLandscapeCustomMaterial*           WaterNavigationMaterial;                           // 0x0500(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoLandscapeCustomMaterial*           WaterIdentificationMaterial;                       // 0x0508(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoLandscapeDynamicCustomMaterial*    WaterIdentificationMaterialDynamic;                // 0x0510(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoLandscapeDynamicCustomMaterial*    WaterNavigationMaterialDynamic;                    // 0x0518(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoLandscapeCustomMaterial*           RiverIdentificationMaterial;                       // 0x0520(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJunoLandscapeCustomMaterial*           LakeIdentificationMaterial;                        // 0x0528(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 WaterBodyIdentificationTexture;                    // 0x0530(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 WaterIdentificationFinal;                          // 0x0538(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0xB0];                                     // 0x0540(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void FixupAllJunoLandscapeWeightmapLayers();
	static void FixupWorldLandscapeWeightmapLayers(const class UObject* WorldContextObject);
	static void ForceSaveForMissingLayers();
	static void ValidateSavedTiles();

	void GenerateServerPrecachedData();
	void OnCellActivate(const class UJunoDynamicRuntimeCell* Cell);
	void OnCellDeactivate(const class UJunoDynamicRuntimeCell* Cell);
	void OnCellLoad(const class UJunoDynamicRuntimeCell* Cell);
	void OnCellUnload(const class UJunoDynamicRuntimeCell* Cell);
	void OnProxyDestroyed(class AActor* DestroyedActor);

	TArray<struct FJunoTerrainWaterInformation> GetInterpolatedOceanInformation(const struct FVector& Location, bool* OutLocationIsOcean) const;
	TArray<struct FJunoTerrainWaterInformation> GetInterpolatedWaterInformation(const struct FVector& Location, bool* OutLocationIsWater) const;
	struct FJunoTerrainWaterInformation GetWaterInformationAtLocation(const struct FVector& Location) const;
	struct FJunoTerrainWaterInformation GetWaterInformationInDirection(const struct FVector& Location, const struct FVector& Direction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTerrainGenerationSystem">();
	}
	static class UJunoTerrainGenerationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTerrainGenerationSystem>();
	}
};
static_assert(alignof(UJunoTerrainGenerationSystem) == 0x000008, "Wrong alignment on UJunoTerrainGenerationSystem");
static_assert(sizeof(UJunoTerrainGenerationSystem) == 0x0005F0, "Wrong size on UJunoTerrainGenerationSystem");
static_assert(offsetof(UJunoTerrainGenerationSystem, TrackedLandscapes) == 0x000040, "Member 'UJunoTerrainGenerationSystem::TrackedLandscapes' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, TrackedLandscapeComponents) == 0x000090, "Member 'UJunoTerrainGenerationSystem::TrackedLandscapeComponents' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, JunoLandscapeManager) == 0x0000E0, "Member 'UJunoTerrainGenerationSystem::JunoLandscapeManager' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, PluginLayerData) == 0x0000E8, "Member 'UJunoTerrainGenerationSystem::PluginLayerData' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, VisualsConfiguration) == 0x0002B0, "Member 'UJunoTerrainGenerationSystem::VisualsConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, HeightmapConfiguration) == 0x000308, "Member 'UJunoTerrainGenerationSystem::HeightmapConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, GrassConfiguration) == 0x000360, "Member 'UJunoTerrainGenerationSystem::GrassConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, CollisionConfiguration) == 0x0003B8, "Member 'UJunoTerrainGenerationSystem::CollisionConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WeightmapConfiguration) == 0x000410, "Member 'UJunoTerrainGenerationSystem::WeightmapConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WaterConfiguration) == 0x000468, "Member 'UJunoTerrainGenerationSystem::WaterConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WeightmapsToGather) == 0x0004C0, "Member 'UJunoTerrainGenerationSystem::WeightmapsToGather' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, bEnablePhysicsAndGrassStripping) == 0x0004D0, "Member 'UJunoTerrainGenerationSystem::bEnablePhysicsAndGrassStripping' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, ExcludePhysicsAndGrassStrippingPlatforms) == 0x0004D8, "Member 'UJunoTerrainGenerationSystem::ExcludePhysicsAndGrassStrippingPlatforms' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, bEnablePCGCacheStripping) == 0x0004E8, "Member 'UJunoTerrainGenerationSystem::bEnablePCGCacheStripping' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, ExcludePCGCacheStrippingPlatforms) == 0x0004F0, "Member 'UJunoTerrainGenerationSystem::ExcludePCGCacheStrippingPlatforms' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WaterNavigationMaterial) == 0x000500, "Member 'UJunoTerrainGenerationSystem::WaterNavigationMaterial' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WaterIdentificationMaterial) == 0x000508, "Member 'UJunoTerrainGenerationSystem::WaterIdentificationMaterial' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WaterIdentificationMaterialDynamic) == 0x000510, "Member 'UJunoTerrainGenerationSystem::WaterIdentificationMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WaterNavigationMaterialDynamic) == 0x000518, "Member 'UJunoTerrainGenerationSystem::WaterNavigationMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, RiverIdentificationMaterial) == 0x000520, "Member 'UJunoTerrainGenerationSystem::RiverIdentificationMaterial' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, LakeIdentificationMaterial) == 0x000528, "Member 'UJunoTerrainGenerationSystem::LakeIdentificationMaterial' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WaterBodyIdentificationTexture) == 0x000530, "Member 'UJunoTerrainGenerationSystem::WaterBodyIdentificationTexture' has a wrong offset!");
static_assert(offsetof(UJunoTerrainGenerationSystem, WaterIdentificationFinal) == 0x000538, "Member 'UJunoTerrainGenerationSystem::WaterIdentificationFinal' has a wrong offset!");

// Class JunoProceduralWorld.JunoMassStationaryLODBatchProcessor
// 0x0570 (0x0630 - 0x00C0)
class alignas(0x10) UJunoMassStationaryLODBatchProcessor final : public UMassProcessor
{
public:
	uint8                                         Pad_C0[0x540];                                     // 0x00C0(0x0540)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DelayPerBulkLOD[0x4];                              // 0x0600(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x10];                                     // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMassStationaryLODBatchProcessor">();
	}
	static class UJunoMassStationaryLODBatchProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoMassStationaryLODBatchProcessor>();
	}
};
static_assert(alignof(UJunoMassStationaryLODBatchProcessor) == 0x000010, "Wrong alignment on UJunoMassStationaryLODBatchProcessor");
static_assert(sizeof(UJunoMassStationaryLODBatchProcessor) == 0x000630, "Wrong size on UJunoMassStationaryLODBatchProcessor");
static_assert(offsetof(UJunoMassStationaryLODBatchProcessor, DelayPerBulkLOD) == 0x000600, "Member 'UJunoMassStationaryLODBatchProcessor::DelayPerBulkLOD' has a wrong offset!");

// Class JunoProceduralWorld.JunoMinimapGenerator
// 0x0010 (0x02A0 - 0x0290)
class AJunoMinimapGenerator final : public AActor
{
public:
	TMulticastInlineDelegate<void(class UTexture2D* TextureAsset)> OnTexture2DPackageCreatedDelegate;                 // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UPackage* CreatePackageAndSaveTexture2D(class UTextureRenderTarget2D* RenderTarget, const class FString& PackageName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoMinimapGenerator">();
	}
	static class AJunoMinimapGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoMinimapGenerator>();
	}
};
static_assert(alignof(AJunoMinimapGenerator) == 0x000008, "Wrong alignment on AJunoMinimapGenerator");
static_assert(sizeof(AJunoMinimapGenerator) == 0x0002A0, "Wrong size on AJunoMinimapGenerator");
static_assert(offsetof(AJunoMinimapGenerator, OnTexture2DPackageCreatedDelegate) == 0x000290, "Member 'AJunoMinimapGenerator::OnTexture2DPackageCreatedDelegate' has a wrong offset!");

// Class JunoProceduralWorld.JunoProceduralWorldDeveloperSettings
// 0x0000 (0x0030 - 0x0030)
class UJunoProceduralWorldDeveloperSettings final : public UDeveloperSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoProceduralWorldDeveloperSettings">();
	}
	static class UJunoProceduralWorldDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoProceduralWorldDeveloperSettings>();
	}
};
static_assert(alignof(UJunoProceduralWorldDeveloperSettings) == 0x000008, "Wrong alignment on UJunoProceduralWorldDeveloperSettings");
static_assert(sizeof(UJunoProceduralWorldDeveloperSettings) == 0x000030, "Wrong size on UJunoProceduralWorldDeveloperSettings");

// Class JunoProceduralWorld.JunoOutOfBoundsTile
// 0x0000 (0x0290 - 0x0290)
class AJunoOutOfBoundsTile final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoOutOfBoundsTile">();
	}
	static class AJunoOutOfBoundsTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoOutOfBoundsTile>();
	}
};
static_assert(alignof(AJunoOutOfBoundsTile) == 0x000008, "Wrong alignment on AJunoOutOfBoundsTile");
static_assert(sizeof(AJunoOutOfBoundsTile) == 0x000290, "Wrong size on AJunoOutOfBoundsTile");

// Class JunoProceduralWorld.JunoPawnComponent_StreamingSourcesProvider
// 0x0068 (0x0118 - 0x00B0)
class UJunoPawnComponent_StreamingSourcesProvider final : public UJunoPawnComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AboveGroundLocation;                               // 0x00B8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               AboveGroundRotation;                               // 0x00D0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                BelowGroundLocation;                               // 0x00E8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               BelowGroundRotation;                               // 0x0100(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPawnComponent_StreamingSourcesProvider">();
	}
	static class UJunoPawnComponent_StreamingSourcesProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPawnComponent_StreamingSourcesProvider>();
	}
};
static_assert(alignof(UJunoPawnComponent_StreamingSourcesProvider) == 0x000008, "Wrong alignment on UJunoPawnComponent_StreamingSourcesProvider");
static_assert(sizeof(UJunoPawnComponent_StreamingSourcesProvider) == 0x000118, "Wrong size on UJunoPawnComponent_StreamingSourcesProvider");
static_assert(offsetof(UJunoPawnComponent_StreamingSourcesProvider, AboveGroundLocation) == 0x0000B8, "Member 'UJunoPawnComponent_StreamingSourcesProvider::AboveGroundLocation' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_StreamingSourcesProvider, AboveGroundRotation) == 0x0000D0, "Member 'UJunoPawnComponent_StreamingSourcesProvider::AboveGroundRotation' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_StreamingSourcesProvider, BelowGroundLocation) == 0x0000E8, "Member 'UJunoPawnComponent_StreamingSourcesProvider::BelowGroundLocation' has a wrong offset!");
static_assert(offsetof(UJunoPawnComponent_StreamingSourcesProvider, BelowGroundRotation) == 0x000100, "Member 'UJunoPawnComponent_StreamingSourcesProvider::BelowGroundRotation' has a wrong offset!");

// Class JunoProceduralWorld.JunoPCGVolume
// 0x0070 (0x0300 - 0x0290)
class AJunoPCGVolume final : public AActor
{
public:
	TMap<class FName, struct FJunoCompressedPointList> CompressedData;                                    // 0x0290(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCompressedDataValid;                            // 0x02E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          SceneRootComponent;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPCGComponent*                          GeneratorComponent;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPCGComponent*                          SpawnerComponent;                                  // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 CalcCompressedObjectCount() const;
	int32 CalculateCompressedDataSize() const;
	bool IsGeneratorBusy() const;
	bool IsSpawnerBusy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPCGVolume">();
	}
	static class AJunoPCGVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPCGVolume>();
	}
};
static_assert(alignof(AJunoPCGVolume) == 0x000008, "Wrong alignment on AJunoPCGVolume");
static_assert(sizeof(AJunoPCGVolume) == 0x000300, "Wrong size on AJunoPCGVolume");
static_assert(offsetof(AJunoPCGVolume, CompressedData) == 0x000290, "Member 'AJunoPCGVolume::CompressedData' has a wrong offset!");
static_assert(offsetof(AJunoPCGVolume, bIsCompressedDataValid) == 0x0002E0, "Member 'AJunoPCGVolume::bIsCompressedDataValid' has a wrong offset!");
static_assert(offsetof(AJunoPCGVolume, SceneRootComponent) == 0x0002E8, "Member 'AJunoPCGVolume::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AJunoPCGVolume, GeneratorComponent) == 0x0002F0, "Member 'AJunoPCGVolume::GeneratorComponent' has a wrong offset!");
static_assert(offsetof(AJunoPCGVolume, SpawnerComponent) == 0x0002F8, "Member 'AJunoPCGVolume::SpawnerComponent' has a wrong offset!");

// Class JunoProceduralWorld.JunoPOIPreselectorComponent
// 0x00F0 (0x0190 - 0x00A0)
class alignas(0x10) UJunoPOIPreselectorComponent final : public UGameFrameworkComponent
{
public:
	TArray<struct FJunoPOIManagerSlot>            WorldTileSlots;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPCGJunoWorldTilePOI>           DebugSpawnPOIs;                                    // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDataRegistryType                      POIDataRegistry;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AJunoWorldTile*                         WorldTile;                                         // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x98];                                      // 0x00F8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginPreselection();
	void OnSpawnPositionSet(const struct FUniqueNetIdRepl& ID, const struct FVector& Location);
	void OnWorldTileContentsAvailable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPOIPreselectorComponent">();
	}
	static class UJunoPOIPreselectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPOIPreselectorComponent>();
	}
};
static_assert(alignof(UJunoPOIPreselectorComponent) == 0x000010, "Wrong alignment on UJunoPOIPreselectorComponent");
static_assert(sizeof(UJunoPOIPreselectorComponent) == 0x000190, "Wrong size on UJunoPOIPreselectorComponent");
static_assert(offsetof(UJunoPOIPreselectorComponent, WorldTileSlots) == 0x0000A0, "Member 'UJunoPOIPreselectorComponent::WorldTileSlots' has a wrong offset!");
static_assert(offsetof(UJunoPOIPreselectorComponent, DebugSpawnPOIs) == 0x0000D8, "Member 'UJunoPOIPreselectorComponent::DebugSpawnPOIs' has a wrong offset!");
static_assert(offsetof(UJunoPOIPreselectorComponent, POIDataRegistry) == 0x0000E8, "Member 'UJunoPOIPreselectorComponent::POIDataRegistry' has a wrong offset!");
static_assert(offsetof(UJunoPOIPreselectorComponent, WorldTile) == 0x0000F0, "Member 'UJunoPOIPreselectorComponent::WorldTile' has a wrong offset!");

// Class JunoProceduralWorld.JunoStreamingGameplayVolumeDebugger
// 0x0000 (0x0040 - 0x0040)
class UJunoStreamingGameplayVolumeDebugger final : public UTickableWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoStreamingGameplayVolumeDebugger">();
	}
	static class UJunoStreamingGameplayVolumeDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoStreamingGameplayVolumeDebugger>();
	}
};
static_assert(alignof(UJunoStreamingGameplayVolumeDebugger) == 0x000008, "Wrong alignment on UJunoStreamingGameplayVolumeDebugger");
static_assert(sizeof(UJunoStreamingGameplayVolumeDebugger) == 0x000040, "Wrong size on UJunoStreamingGameplayVolumeDebugger");

// Class JunoProceduralWorld.JunoCaveGeneratorInterface
// 0x0000 (0x0028 - 0x0028)
class IJunoCaveGeneratorInterface final : public IInterface
{
public:
	void GenerateCave(const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, int32 CaveIndex, const struct FBox& Bounds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveGeneratorInterface">();
	}
	static class IJunoCaveGeneratorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJunoCaveGeneratorInterface>();
	}
};
static_assert(alignof(IJunoCaveGeneratorInterface) == 0x000008, "Wrong alignment on IJunoCaveGeneratorInterface");
static_assert(sizeof(IJunoCaveGeneratorInterface) == 0x000028, "Wrong size on IJunoCaveGeneratorInterface");

// Class JunoProceduralWorld.JunoPOISelectorComponent
// 0x00B8 (0x0158 - 0x00A0)
class UJunoPOISelectorComponent final : public UGameFrameworkComponent
{
public:
	struct FDataRegistryType                      DataRegistryType;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CosmeticEncounterTags;                             // 0x00A8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJunoPOISelectorTeleporterClass> TeleporterClasses;                                 // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FJunoPOISelectorParams                 Params_0;                                          // 0x00D8(0x0030)(Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJunoPOIPreselectorComponent> PreSelectorComponent;                              // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoCaveSurfaceData                   CaveSurfaceData;                                   // 0x0118(0x0030)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 CaveGridResolution();
	static bool IsNativePOISelectorEnabled();
	static bool IsPOIPreselectorActorReady(const class AActor* Actor);

	void BeginPOISelection(const struct FJunoPOISelectorParams& Param_Params_0);
	void DoSelection();
	void TriggerCaveGeneration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPOISelectorComponent">();
	}
	static class UJunoPOISelectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPOISelectorComponent>();
	}
};
static_assert(alignof(UJunoPOISelectorComponent) == 0x000008, "Wrong alignment on UJunoPOISelectorComponent");
static_assert(sizeof(UJunoPOISelectorComponent) == 0x000158, "Wrong size on UJunoPOISelectorComponent");
static_assert(offsetof(UJunoPOISelectorComponent, DataRegistryType) == 0x0000A0, "Member 'UJunoPOISelectorComponent::DataRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoPOISelectorComponent, CosmeticEncounterTags) == 0x0000A8, "Member 'UJunoPOISelectorComponent::CosmeticEncounterTags' has a wrong offset!");
static_assert(offsetof(UJunoPOISelectorComponent, TeleporterClasses) == 0x0000C8, "Member 'UJunoPOISelectorComponent::TeleporterClasses' has a wrong offset!");
static_assert(offsetof(UJunoPOISelectorComponent, Params_0) == 0x0000D8, "Member 'UJunoPOISelectorComponent::Params_0' has a wrong offset!");
static_assert(offsetof(UJunoPOISelectorComponent, PreSelectorComponent) == 0x000108, "Member 'UJunoPOISelectorComponent::PreSelectorComponent' has a wrong offset!");
static_assert(offsetof(UJunoPOISelectorComponent, CaveSurfaceData) == 0x000118, "Member 'UJunoPOISelectorComponent::CaveSurfaceData' has a wrong offset!");

// Class JunoProceduralWorld.JunoProceduralWorldSettings
// 0x00E8 (0x01E0 - 0x00F8)
class UJunoProceduralWorldSettings final : public UFortPlayspaceComponent
{
public:
	bool                                          bEnableTiledWorldsInPIE;                           // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoLevelInstanceMode                        Caves_LevelInstanceMode;                           // 0x00F9(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoLevelInstanceMode                        POI_LevelInstanceMode;                             // 0x00FA(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePOI_HLODs;                                  // 0x00FB(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPOIsPerTile;                                    // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InjectedPOI_GridName;                              // 0x0100(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InjectedPOI_HLODGridName;                          // 0x0104(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InjectedCave_GridName;                             // 0x0108(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InjectedCave_HLODGridName;                         // 0x010C(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         POIStreamingPriority;                              // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaveStreamingPriority;                             // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TileSize;                                          // 0x0118(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WorldSize;                                         // 0x0120(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             WorldOriginTileOffset;                             // 0x0128(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DynamicGridLevels;                                 // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicGridWorldMaxExtent;                         // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicGridLoadingRange;                           // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetTerrain;                                     // 0x0148(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJunoWorldTileSelectionBase> TileSelectionClass;                                // 0x0160(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJunoWorldTile>             WorldTileClass;                                    // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     OutOfBoundsTileActor;                              // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerrainElevationMinimum;                           // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerrainElevationMaximum;                           // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJunoCaveShellGameplayVolume> CaveVolumeClass;                                   // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJunoPOIGameplayVolume>     POIVolumeClass;                                    // 0x0188(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              POIResourcesTable;                                 // 0x0190(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataRegistryType                      POIRegistryType;                                   // 0x01B0(0x0004)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataRegistryType                      TileSelectorRegistryType;                          // 0x01B4(0x0004)(Edit, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  TestOverlayLevel;                                  // 0x01B8(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TileSelectorOverride;                              // 0x01D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoProceduralWorldSettings">();
	}
	static class UJunoProceduralWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoProceduralWorldSettings>();
	}
};
static_assert(alignof(UJunoProceduralWorldSettings) == 0x000008, "Wrong alignment on UJunoProceduralWorldSettings");
static_assert(sizeof(UJunoProceduralWorldSettings) == 0x0001E0, "Wrong size on UJunoProceduralWorldSettings");
static_assert(offsetof(UJunoProceduralWorldSettings, bEnableTiledWorldsInPIE) == 0x0000F8, "Member 'UJunoProceduralWorldSettings::bEnableTiledWorldsInPIE' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, Caves_LevelInstanceMode) == 0x0000F9, "Member 'UJunoProceduralWorldSettings::Caves_LevelInstanceMode' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, POI_LevelInstanceMode) == 0x0000FA, "Member 'UJunoProceduralWorldSettings::POI_LevelInstanceMode' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, bEnablePOI_HLODs) == 0x0000FB, "Member 'UJunoProceduralWorldSettings::bEnablePOI_HLODs' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, MaxPOIsPerTile) == 0x0000FC, "Member 'UJunoProceduralWorldSettings::MaxPOIsPerTile' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, InjectedPOI_GridName) == 0x000100, "Member 'UJunoProceduralWorldSettings::InjectedPOI_GridName' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, InjectedPOI_HLODGridName) == 0x000104, "Member 'UJunoProceduralWorldSettings::InjectedPOI_HLODGridName' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, InjectedCave_GridName) == 0x000108, "Member 'UJunoProceduralWorldSettings::InjectedCave_GridName' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, InjectedCave_HLODGridName) == 0x00010C, "Member 'UJunoProceduralWorldSettings::InjectedCave_HLODGridName' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, POIStreamingPriority) == 0x000110, "Member 'UJunoProceduralWorldSettings::POIStreamingPriority' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, CaveStreamingPriority) == 0x000114, "Member 'UJunoProceduralWorldSettings::CaveStreamingPriority' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, TileSize) == 0x000118, "Member 'UJunoProceduralWorldSettings::TileSize' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, WorldSize) == 0x000120, "Member 'UJunoProceduralWorldSettings::WorldSize' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, WorldOriginTileOffset) == 0x000128, "Member 'UJunoProceduralWorldSettings::WorldOriginTileOffset' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, DynamicGridLevels) == 0x000138, "Member 'UJunoProceduralWorldSettings::DynamicGridLevels' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, DynamicGridWorldMaxExtent) == 0x000140, "Member 'UJunoProceduralWorldSettings::DynamicGridWorldMaxExtent' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, DynamicGridLoadingRange) == 0x000144, "Member 'UJunoProceduralWorldSettings::DynamicGridLoadingRange' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, OffsetTerrain) == 0x000148, "Member 'UJunoProceduralWorldSettings::OffsetTerrain' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, TileSelectionClass) == 0x000160, "Member 'UJunoProceduralWorldSettings::TileSelectionClass' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, WorldTileClass) == 0x000168, "Member 'UJunoProceduralWorldSettings::WorldTileClass' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, OutOfBoundsTileActor) == 0x000170, "Member 'UJunoProceduralWorldSettings::OutOfBoundsTileActor' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, TerrainElevationMinimum) == 0x000178, "Member 'UJunoProceduralWorldSettings::TerrainElevationMinimum' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, TerrainElevationMaximum) == 0x00017C, "Member 'UJunoProceduralWorldSettings::TerrainElevationMaximum' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, CaveVolumeClass) == 0x000180, "Member 'UJunoProceduralWorldSettings::CaveVolumeClass' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, POIVolumeClass) == 0x000188, "Member 'UJunoProceduralWorldSettings::POIVolumeClass' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, POIResourcesTable) == 0x000190, "Member 'UJunoProceduralWorldSettings::POIResourcesTable' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, POIRegistryType) == 0x0001B0, "Member 'UJunoProceduralWorldSettings::POIRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, TileSelectorRegistryType) == 0x0001B4, "Member 'UJunoProceduralWorldSettings::TileSelectorRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, TestOverlayLevel) == 0x0001B8, "Member 'UJunoProceduralWorldSettings::TestOverlayLevel' has a wrong offset!");
static_assert(offsetof(UJunoProceduralWorldSettings, TileSelectorOverride) == 0x0001D8, "Member 'UJunoProceduralWorldSettings::TileSelectorOverride' has a wrong offset!");

// Class JunoProceduralWorld.JunoServerInstancedActorSpawnerSubsystem
// 0x0028 (0x0118 - 0x00F0)
class UJunoServerInstancedActorSpawnerSubsystem final : public UMassActorSpawnerSubsystem
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TransientActorBeingSpawned;                        // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoActorInstanceHandle               TransientActorSpawningInstance;                    // 0x0108(0x0010)(Transient, NoDestructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoServerInstancedActorSpawnerSubsystem">();
	}
	static class UJunoServerInstancedActorSpawnerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoServerInstancedActorSpawnerSubsystem>();
	}
};
static_assert(alignof(UJunoServerInstancedActorSpawnerSubsystem) == 0x000008, "Wrong alignment on UJunoServerInstancedActorSpawnerSubsystem");
static_assert(sizeof(UJunoServerInstancedActorSpawnerSubsystem) == 0x000118, "Wrong size on UJunoServerInstancedActorSpawnerSubsystem");
static_assert(offsetof(UJunoServerInstancedActorSpawnerSubsystem, TransientActorBeingSpawned) == 0x000100, "Member 'UJunoServerInstancedActorSpawnerSubsystem::TransientActorBeingSpawned' has a wrong offset!");
static_assert(offsetof(UJunoServerInstancedActorSpawnerSubsystem, TransientActorSpawningInstance) == 0x000108, "Member 'UJunoServerInstancedActorSpawnerSubsystem::TransientActorSpawningInstance' has a wrong offset!");

// Class JunoProceduralWorld.JunoStaticMeshPoolSubsystem
// 0x0008 (0x0038 - 0x0030)
class UJunoStaticMeshPoolSubsystem final : public UWorldSubsystem
{
public:
	class AJunoStaticMeshPoolActor*               StaticMeshPoolActor;                               // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoStaticMeshPoolSubsystem">();
	}
	static class UJunoStaticMeshPoolSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoStaticMeshPoolSubsystem>();
	}
};
static_assert(alignof(UJunoStaticMeshPoolSubsystem) == 0x000008, "Wrong alignment on UJunoStaticMeshPoolSubsystem");
static_assert(sizeof(UJunoStaticMeshPoolSubsystem) == 0x000038, "Wrong size on UJunoStaticMeshPoolSubsystem");
static_assert(offsetof(UJunoStaticMeshPoolSubsystem, StaticMeshPoolActor) == 0x000030, "Member 'UJunoStaticMeshPoolSubsystem::StaticMeshPoolActor' has a wrong offset!");

// Class JunoProceduralWorld.JunoStreamingPlayspace
// 0x0000 (0x0808 - 0x0808)
class AJunoStreamingPlayspace final : public AJunoPersistentPlayspace
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoStreamingPlayspace">();
	}
	static class AJunoStreamingPlayspace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoStreamingPlayspace>();
	}
};
static_assert(alignof(AJunoStreamingPlayspace) == 0x000008, "Wrong alignment on AJunoStreamingPlayspace");
static_assert(sizeof(AJunoStreamingPlayspace) == 0x000808, "Wrong size on AJunoStreamingPlayspace");

// Class JunoProceduralWorld.JunoTerrainMaterialCollector
// 0x0070 (0x0098 - 0x0028)
class UJunoTerrainMaterialCollector final : public UJunoLandscapeExternalMaterialsCollector
{
public:
	TArray<class FName>                           Biomes;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BorderNames;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                SwappableBiomeNames;                               // 0x0048(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTerrainMaterialCollector">();
	}
	static class UJunoTerrainMaterialCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTerrainMaterialCollector>();
	}
};
static_assert(alignof(UJunoTerrainMaterialCollector) == 0x000008, "Wrong alignment on UJunoTerrainMaterialCollector");
static_assert(sizeof(UJunoTerrainMaterialCollector) == 0x000098, "Wrong size on UJunoTerrainMaterialCollector");
static_assert(offsetof(UJunoTerrainMaterialCollector, Biomes) == 0x000028, "Member 'UJunoTerrainMaterialCollector::Biomes' has a wrong offset!");
static_assert(offsetof(UJunoTerrainMaterialCollector, BorderNames) == 0x000038, "Member 'UJunoTerrainMaterialCollector::BorderNames' has a wrong offset!");
static_assert(offsetof(UJunoTerrainMaterialCollector, SwappableBiomeNames) == 0x000048, "Member 'UJunoTerrainMaterialCollector::SwappableBiomeNames' has a wrong offset!");

// Class JunoProceduralWorld.JunoTileGridPersistenceFeatureDataActor
// 0x00F8 (0x03C8 - 0x02D0)
class AJunoTileGridPersistenceFeatureDataActor final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoTileGridPersistentData            Data;                                              // 0x02D8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FJunoReservedAreaPersistentData> ReservedAreas;                                     // 0x0328(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FJunoPOICellDistributionPersistentData> PerCellRarePOICounts;                              // 0x0378(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTileGridPersistenceFeatureDataActor">();
	}
	static class AJunoTileGridPersistenceFeatureDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoTileGridPersistenceFeatureDataActor>();
	}
};
static_assert(alignof(AJunoTileGridPersistenceFeatureDataActor) == 0x000008, "Wrong alignment on AJunoTileGridPersistenceFeatureDataActor");
static_assert(sizeof(AJunoTileGridPersistenceFeatureDataActor) == 0x0003C8, "Wrong size on AJunoTileGridPersistenceFeatureDataActor");
static_assert(offsetof(AJunoTileGridPersistenceFeatureDataActor, Data) == 0x0002D8, "Member 'AJunoTileGridPersistenceFeatureDataActor::Data' has a wrong offset!");
static_assert(offsetof(AJunoTileGridPersistenceFeatureDataActor, ReservedAreas) == 0x000328, "Member 'AJunoTileGridPersistenceFeatureDataActor::ReservedAreas' has a wrong offset!");
static_assert(offsetof(AJunoTileGridPersistenceFeatureDataActor, PerCellRarePOICounts) == 0x000378, "Member 'AJunoTileGridPersistenceFeatureDataActor::PerCellRarePOICounts' has a wrong offset!");

// Class JunoProceduralWorld.JunoTileGridPersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoTileGridPersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTileGridPersistenceFeatureModule">();
	}
	static class UJunoTileGridPersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTileGridPersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoTileGridPersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoTileGridPersistenceFeatureModule");
static_assert(sizeof(UJunoTileGridPersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoTileGridPersistenceFeatureModule");

// Class JunoProceduralWorld.JunoTileGridPersistenceFeatureData_Container
// 0x0000 (0x01E0 - 0x01E0)
class UJunoTileGridPersistenceFeatureData_Container final : public UJunoBasePFWPersistenceFeatureDataContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTileGridPersistenceFeatureData_Container">();
	}
	static class UJunoTileGridPersistenceFeatureData_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoTileGridPersistenceFeatureData_Container>();
	}
};
static_assert(alignof(UJunoTileGridPersistenceFeatureData_Container) == 0x000008, "Wrong alignment on UJunoTileGridPersistenceFeatureData_Container");
static_assert(sizeof(UJunoTileGridPersistenceFeatureData_Container) == 0x0001E0, "Wrong size on UJunoTileGridPersistenceFeatureData_Container");

// Class JunoProceduralWorld.JunoWaterSplineInjector
// 0x0000 (0x00A0 - 0x00A0)
class UJunoWaterSplineInjector final : public UActorComponent
{
public:
	void ForceWaterUpdate();
	void InjectSplineGuideIntoWaterBody(const struct FJunoWaterSplineInjectorParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWaterSplineInjector">();
	}
	static class UJunoWaterSplineInjector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWaterSplineInjector>();
	}
};
static_assert(alignof(UJunoWaterSplineInjector) == 0x000008, "Wrong alignment on UJunoWaterSplineInjector");
static_assert(sizeof(UJunoWaterSplineInjector) == 0x0000A0, "Wrong size on UJunoWaterSplineInjector");

// Class JunoProceduralWorld.JunoWorldLocalEnvironmentComponent
// 0x0130 (0x01D0 - 0x00A0)
class UJunoWorldLocalEnvironmentComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoBiomeInfoQueryResult              LocalBiome;                                        // 0x00A8(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FJunoBiomeInfoQueryResult              ServerBiome;                                       // 0x00D0(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FJunoWaterLocationResult>       WaterDirectionInformation;                         // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FJunoWaterLocationResult               LookDirectionWaterInformation;                     // 0x0108(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldUpdateWaterLocation;                        // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* Actor, struct FJunoBiomeInfoQueryResult& PreviousEnvironmentResult, struct FJunoBiomeInfoQueryResult& NewEnvironmentResult)> OnJunoEnvironmentChanged;                          // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x38];                                     // 0x0170(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  CaveGuid;                                          // 0x01A8(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UJunoWorldRegistryManager> WeakRegistryManager;                               // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ServerBiome();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldLocalEnvironmentComponent">();
	}
	static class UJunoWorldLocalEnvironmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldLocalEnvironmentComponent>();
	}
};
static_assert(alignof(UJunoWorldLocalEnvironmentComponent) == 0x000008, "Wrong alignment on UJunoWorldLocalEnvironmentComponent");
static_assert(sizeof(UJunoWorldLocalEnvironmentComponent) == 0x0001D0, "Wrong size on UJunoWorldLocalEnvironmentComponent");
static_assert(offsetof(UJunoWorldLocalEnvironmentComponent, LocalBiome) == 0x0000A8, "Member 'UJunoWorldLocalEnvironmentComponent::LocalBiome' has a wrong offset!");
static_assert(offsetof(UJunoWorldLocalEnvironmentComponent, ServerBiome) == 0x0000D0, "Member 'UJunoWorldLocalEnvironmentComponent::ServerBiome' has a wrong offset!");
static_assert(offsetof(UJunoWorldLocalEnvironmentComponent, WaterDirectionInformation) == 0x0000F8, "Member 'UJunoWorldLocalEnvironmentComponent::WaterDirectionInformation' has a wrong offset!");
static_assert(offsetof(UJunoWorldLocalEnvironmentComponent, LookDirectionWaterInformation) == 0x000108, "Member 'UJunoWorldLocalEnvironmentComponent::LookDirectionWaterInformation' has a wrong offset!");
static_assert(offsetof(UJunoWorldLocalEnvironmentComponent, bShouldUpdateWaterLocation) == 0x000158, "Member 'UJunoWorldLocalEnvironmentComponent::bShouldUpdateWaterLocation' has a wrong offset!");
static_assert(offsetof(UJunoWorldLocalEnvironmentComponent, OnJunoEnvironmentChanged) == 0x000160, "Member 'UJunoWorldLocalEnvironmentComponent::OnJunoEnvironmentChanged' has a wrong offset!");
static_assert(offsetof(UJunoWorldLocalEnvironmentComponent, CaveGuid) == 0x0001A8, "Member 'UJunoWorldLocalEnvironmentComponent::CaveGuid' has a wrong offset!");
static_assert(offsetof(UJunoWorldLocalEnvironmentComponent, WeakRegistryManager) == 0x0001B8, "Member 'UJunoWorldLocalEnvironmentComponent::WeakRegistryManager' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTilePlayspaceComponent
// 0x0000 (0x00F8 - 0x00F8)
class UJunoWorldTilePlayspaceComponent final : public UFortPlayspaceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTilePlayspaceComponent">();
	}
	static class UJunoWorldTilePlayspaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTilePlayspaceComponent>();
	}
};
static_assert(alignof(UJunoWorldTilePlayspaceComponent) == 0x000008, "Wrong alignment on UJunoWorldTilePlayspaceComponent");
static_assert(sizeof(UJunoWorldTilePlayspaceComponent) == 0x0000F8, "Wrong size on UJunoWorldTilePlayspaceComponent");

// Class JunoProceduralWorld.JunoWorldTile
// 0x0280 (0x0630 - 0x03B0)
class AJunoWorldTile final : public AJunoStreamingGameplayVolume
{
public:
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPCGJunoWorldTile                      TileInformation;                                   // 0x03B8(0x00F8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, SaveGame, NativeAccessSpecifierPublic)
	struct FJunoWorldTileStreamingLevelFastArray  InjectedLevels;                                    // 0x04B0(0x0120)(Net, NativeAccessSpecifierPublic)
	TArray<class URuntimeSpatialHashExternalStreamingObject*> InjectedObjects;                                   // 0x05D0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         InjectedLevelCount;                                // 0x05E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldPartition*                        InjectedObjectsWorldPartition;                     // 0x05E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x40];                                     // 0x05F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ArePositionsInSameWorldTile(class UObject* WorldContextObject, const struct FVector& LocationA, const struct FVector& LocationB);
	static void GetJunoWorldTileBounds(class AActor* ActorInWorldTile, struct FBox* TileBounds, EJunoGetWorldTileBoundsResult* Result);
	static void GetJunoWorldTileTransform(class AActor* ActorInWorldTile, struct FTransform* Transform, EJunoGetWorldTileTransformResult* Result);

	void ClientOnAllLevelsLoaded();
	void OnUnloadBegin(class ULevel* Level);

	bool IsTestLevelWorldTile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTile">();
	}
	static class AJunoWorldTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoWorldTile>();
	}
};
static_assert(alignof(AJunoWorldTile) == 0x000008, "Wrong alignment on AJunoWorldTile");
static_assert(sizeof(AJunoWorldTile) == 0x000630, "Wrong size on AJunoWorldTile");
static_assert(offsetof(AJunoWorldTile, TileInformation) == 0x0003B8, "Member 'AJunoWorldTile::TileInformation' has a wrong offset!");
static_assert(offsetof(AJunoWorldTile, InjectedLevels) == 0x0004B0, "Member 'AJunoWorldTile::InjectedLevels' has a wrong offset!");
static_assert(offsetof(AJunoWorldTile, InjectedObjects) == 0x0005D0, "Member 'AJunoWorldTile::InjectedObjects' has a wrong offset!");
static_assert(offsetof(AJunoWorldTile, InjectedLevelCount) == 0x0005E0, "Member 'AJunoWorldTile::InjectedLevelCount' has a wrong offset!");
static_assert(offsetof(AJunoWorldTile, InjectedObjectsWorldPartition) == 0x0005E8, "Member 'AJunoWorldTile::InjectedObjectsWorldPartition' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTileDebugger
// 0x0000 (0x0040 - 0x0040)
class UJunoWorldTileDebugger final : public UTickableWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileDebugger">();
	}
	static class UJunoWorldTileDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileDebugger>();
	}
};
static_assert(alignof(UJunoWorldTileDebugger) == 0x000008, "Wrong alignment on UJunoWorldTileDebugger");
static_assert(sizeof(UJunoWorldTileDebugger) == 0x000040, "Wrong size on UJunoWorldTileDebugger");

// Class JunoProceduralWorld.JunoTestPOIMarker
// 0x0008 (0x0298 - 0x0290)
class AJunoTestPOIMarker final : public AActor
{
public:
	float                                         DebugBoxSize;                                      // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoTestPOIMarker">();
	}
	static class AJunoTestPOIMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoTestPOIMarker>();
	}
};
static_assert(alignof(AJunoTestPOIMarker) == 0x000008, "Wrong alignment on AJunoTestPOIMarker");
static_assert(sizeof(AJunoTestPOIMarker) == 0x000298, "Wrong size on AJunoTestPOIMarker");
static_assert(offsetof(AJunoTestPOIMarker, DebugBoxSize) == 0x000290, "Member 'AJunoTestPOIMarker::DebugBoxSize' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTileControllerComponent
// 0x0000 (0x00A8 - 0x00A8)
class UJunoWorldTileControllerComponent final : public UFortControllerComponent
{
public:
	void ClientCheckWorldTileState(const TArray<struct FJunoDebugWorldTileState>& WorldTileState);
	void ServerCheckWorldTileState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileControllerComponent">();
	}
	static class UJunoWorldTileControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileControllerComponent>();
	}
};
static_assert(alignof(UJunoWorldTileControllerComponent) == 0x000008, "Wrong alignment on UJunoWorldTileControllerComponent");
static_assert(sizeof(UJunoWorldTileControllerComponent) == 0x0000A8, "Wrong size on UJunoWorldTileControllerComponent");

// Class JunoProceduralWorld.JunoCaveDataCollectionBase
// 0x0000 (0x0030 - 0x0030)
class UJunoCaveDataCollectionBase final : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveDataCollectionBase">();
	}
	static class UJunoCaveDataCollectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCaveDataCollectionBase>();
	}
};
static_assert(alignof(UJunoCaveDataCollectionBase) == 0x000008, "Wrong alignment on UJunoCaveDataCollectionBase");
static_assert(sizeof(UJunoCaveDataCollectionBase) == 0x000030, "Wrong size on UJunoCaveDataCollectionBase");

// Class JunoProceduralWorld.JunoWorldTileLandscapeSpatialHash
// 0x0000 (0x00E8 - 0x00E8)
class UJunoWorldTileLandscapeSpatialHash final : public UWorldPartitionRuntimeSpatialHash
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileLandscapeSpatialHash">();
	}
	static class UJunoWorldTileLandscapeSpatialHash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileLandscapeSpatialHash>();
	}
};
static_assert(alignof(UJunoWorldTileLandscapeSpatialHash) == 0x000008, "Wrong alignment on UJunoWorldTileLandscapeSpatialHash");
static_assert(sizeof(UJunoWorldTileLandscapeSpatialHash) == 0x0000E8, "Wrong size on UJunoWorldTileLandscapeSpatialHash");

// Class JunoProceduralWorld.JunoWorldTilePersistenceFeatureModule
// 0x0000 (0x00E0 - 0x00E0)
class UJunoWorldTilePersistenceFeatureModule final : public UPersistenceFrameworkModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTilePersistenceFeatureModule">();
	}
	static class UJunoWorldTilePersistenceFeatureModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTilePersistenceFeatureModule>();
	}
};
static_assert(alignof(UJunoWorldTilePersistenceFeatureModule) == 0x000008, "Wrong alignment on UJunoWorldTilePersistenceFeatureModule");
static_assert(sizeof(UJunoWorldTilePersistenceFeatureModule) == 0x0000E0, "Wrong size on UJunoWorldTilePersistenceFeatureModule");

// Class JunoProceduralWorld.JunoWorldTileSelectionForced
// 0x0010 (0x0060 - 0x0050)
class UJunoWorldTileSelectionForced final : public UJunoWorldTileSelectionBase
{
public:
	int32                                         RandomTileSeed;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             WorldTilesDataTable;                               // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileSelectionForced">();
	}
	static class UJunoWorldTileSelectionForced* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileSelectionForced>();
	}
};
static_assert(alignof(UJunoWorldTileSelectionForced) == 0x000008, "Wrong alignment on UJunoWorldTileSelectionForced");
static_assert(sizeof(UJunoWorldTileSelectionForced) == 0x000060, "Wrong size on UJunoWorldTileSelectionForced");
static_assert(offsetof(UJunoWorldTileSelectionForced, RandomTileSeed) == 0x000050, "Member 'UJunoWorldTileSelectionForced::RandomTileSeed' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionForced, WorldTilesDataTable) == 0x000058, "Member 'UJunoWorldTileSelectionForced::WorldTilesDataTable' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTileSelectionAgatha
// 0x0038 (0x0088 - 0x0050)
class UJunoWorldTileSelectionAgatha final : public UJunoWorldTileSelectionBase
{
public:
	class UDataTable*                             WorldTilesDataTable;                               // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EJunoBiome>                            ScatteredLandBiomes;                               // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WaterLevel;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileNoiseFrequency;                                // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDarklandsIslands;                          // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x14];                                      // 0x0074(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateCornersForUI(const class UObject* WorldContextObject, TArray<EJunoBiome>* Corners);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileSelectionAgatha">();
	}
	static class UJunoWorldTileSelectionAgatha* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileSelectionAgatha>();
	}
};
static_assert(alignof(UJunoWorldTileSelectionAgatha) == 0x000008, "Wrong alignment on UJunoWorldTileSelectionAgatha");
static_assert(sizeof(UJunoWorldTileSelectionAgatha) == 0x000088, "Wrong size on UJunoWorldTileSelectionAgatha");
static_assert(offsetof(UJunoWorldTileSelectionAgatha, WorldTilesDataTable) == 0x000050, "Member 'UJunoWorldTileSelectionAgatha::WorldTilesDataTable' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionAgatha, ScatteredLandBiomes) == 0x000058, "Member 'UJunoWorldTileSelectionAgatha::ScatteredLandBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionAgatha, WaterLevel) == 0x000068, "Member 'UJunoWorldTileSelectionAgatha::WaterLevel' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionAgatha, TileNoiseFrequency) == 0x00006C, "Member 'UJunoWorldTileSelectionAgatha::TileNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionAgatha, NumberOfDarklandsIslands) == 0x000070, "Member 'UJunoWorldTileSelectionAgatha::NumberOfDarklandsIslands' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTileSelectionCynthia
// 0x0110 (0x0160 - 0x0050)
class UJunoWorldTileSelectionCynthia final : public UJunoWorldTileSelectionBase
{
public:
	struct FDataRegistryType                      TileRegistryType;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJunoBiome>                            ScatteredLandBiomes;                               // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<EJunoBiome>                            StartTileRequiredBiomes;                           // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         WaterLevel;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileNoiseFrequency;                                // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfAlpineRanges;                              // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlpineRangeLength;                                 // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EJunoBiome>                            ScatteredAlpineBiomes;                             // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         NumberOfReservedAreas;                             // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitReservedAreasToPerimeter;                    // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, EJunoBiome>                 AreasToUpdate;                                     // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x70];                                      // 0x00F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileSelectionCynthia">();
	}
	static class UJunoWorldTileSelectionCynthia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTileSelectionCynthia>();
	}
};
static_assert(alignof(UJunoWorldTileSelectionCynthia) == 0x000008, "Wrong alignment on UJunoWorldTileSelectionCynthia");
static_assert(sizeof(UJunoWorldTileSelectionCynthia) == 0x000160, "Wrong size on UJunoWorldTileSelectionCynthia");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, TileRegistryType) == 0x000050, "Member 'UJunoWorldTileSelectionCynthia::TileRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, ScatteredLandBiomes) == 0x000058, "Member 'UJunoWorldTileSelectionCynthia::ScatteredLandBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, StartTileRequiredBiomes) == 0x000068, "Member 'UJunoWorldTileSelectionCynthia::StartTileRequiredBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, WaterLevel) == 0x000078, "Member 'UJunoWorldTileSelectionCynthia::WaterLevel' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, TileNoiseFrequency) == 0x00007C, "Member 'UJunoWorldTileSelectionCynthia::TileNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, NumberOfAlpineRanges) == 0x000080, "Member 'UJunoWorldTileSelectionCynthia::NumberOfAlpineRanges' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, AlpineRangeLength) == 0x000084, "Member 'UJunoWorldTileSelectionCynthia::AlpineRangeLength' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, ScatteredAlpineBiomes) == 0x000088, "Member 'UJunoWorldTileSelectionCynthia::ScatteredAlpineBiomes' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, NumberOfReservedAreas) == 0x000098, "Member 'UJunoWorldTileSelectionCynthia::NumberOfReservedAreas' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, bLimitReservedAreasToPerimeter) == 0x00009C, "Member 'UJunoWorldTileSelectionCynthia::bLimitReservedAreasToPerimeter' has a wrong offset!");
static_assert(offsetof(UJunoWorldTileSelectionCynthia, AreasToUpdate) == 0x0000A0, "Member 'UJunoWorldTileSelectionCynthia::AreasToUpdate' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldWeatherLocationComponent
// 0x0000 (0x00B8 - 0x00B8)
class UJunoWorldWeatherLocationComponent final : public UJunoWeatherLocationComponent
{
public:
	void HandleEnvironmentChanged(const class AActor* Actor, const struct FJunoBiomeInfoQueryResult& PreviousEnvironmentResult, const struct FJunoBiomeInfoQueryResult& NewEnvironmentResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldWeatherLocationComponent">();
	}
	static class UJunoWorldWeatherLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldWeatherLocationComponent>();
	}
};
static_assert(alignof(UJunoWorldWeatherLocationComponent) == 0x000008, "Wrong alignment on UJunoWorldWeatherLocationComponent");
static_assert(sizeof(UJunoWorldWeatherLocationComponent) == 0x0000B8, "Wrong size on UJunoWorldWeatherLocationComponent");

// Class JunoProceduralWorld.LandmassPathfinder
// 0x0260 (0x0288 - 0x0028)
class ULandmassPathfinder final : public UObject
{
public:
	class ALandscapeProxy*                        LandscapeProxy;                                    // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALandmassProceduralRoute*               RouteSystem;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULandmassPathfinder*>            BackStopPaths;                                     // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ALandmassProceduralRoute*               BlockingRoute;                                     // 0x0048(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x158];                                     // 0x0050(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPCGSpatialData>         PCGSampler;                                        // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FVector& LocationStart, const struct FVector& LocationEnd)> PathfinderSpawnWarpingActorDelegate;               // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FPathfinderHistory                     PathfinderHistory;                                 // 0x01D0(0x0048)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxNodesPerCell;                                   // 0x0218(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsePCGSamplerIfAvailable;                         // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisualizeHeuristicSteps;                          // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisualizeBacktracedPathOfHeuristicSteps;          // 0x0222(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisualizeValidLocationSearching;                  // 0x0223(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0x64];                                     // 0x0224(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EPushFrontierResult AdditionalPushFrontierResultCondition(EPushFrontierResult ResultFromLastPush, const struct FLandmassPathfinderRules& InCurrentRules, const struct FVector& InHome, const struct FVector& InDestination, const struct FVector& InCurrentLocation, int32 InCurrentPushSteps, float InCurrentCost, bool* bShouldUseBestNodeInsteadOfMostRecentNode);
	void ExecutePathfinderSync(const struct FVector& A, const struct FVector& B, TArray<struct FVector>* Locations, TArray<float>* Costs);
	bool FindNearestValidLocation(const struct FVector& InLocation, struct FVector* OutValidLocation, bool bShouldProject);
	bool Initialize(class ALandscapeProxy* LandscapeProxy_0, class ALandmassProceduralRoute* InRoute, const struct FLandmassPathfinderRules& Rules, const TArray<class ULandmassPathfinder*>& InBackStopPaths, class ALandmassProceduralRoute* InBlockingRoute);
	bool IsTargetLocationValid(const struct FVector& TargetLocation);
	void K2_GetPriorityList(TArray<struct FVector>* Locations, TArray<float>* Costs);
	EPushFrontierResult K2_StepPathfinder(TArray<struct FVector>* OutLocations, TArray<float>* OutCosts, TArray<bool>* bOutIsSnapped, TArray<EPathfinderNodeState>* OutNodeStates);
	void OnInitialize(class ALandscapeProxy* InLandscapeProxy, class ALandmassProceduralRoute* InRoute, const struct FLandmassPathfinderRules& Rules, class ALandmassProceduralRoute* InBlockingRoute);
	void OnStartPathfinder(const struct FVector& A, const struct FVector& B);
	void SetDestination(const struct FVector& Location);
	void SetDestinationActuallyReached(const struct FVector& Location);
	void StartPathfinder(const struct FVector& A, const struct FVector& B, const bool bFindNearestValidLocationForA, const bool bFindNearestValidLocationForB);

	bool GetIsInitialized() const;
	struct FBox GetLandscapeBox() const;
	struct FVector ProjectLocation(const struct FVector& Location, bool* bOutIsValidLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandmassPathfinder">();
	}
	static class ULandmassPathfinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandmassPathfinder>();
	}
};
static_assert(alignof(ULandmassPathfinder) == 0x000008, "Wrong alignment on ULandmassPathfinder");
static_assert(sizeof(ULandmassPathfinder) == 0x000288, "Wrong size on ULandmassPathfinder");
static_assert(offsetof(ULandmassPathfinder, LandscapeProxy) == 0x000028, "Member 'ULandmassPathfinder::LandscapeProxy' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, RouteSystem) == 0x000030, "Member 'ULandmassPathfinder::RouteSystem' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, BackStopPaths) == 0x000038, "Member 'ULandmassPathfinder::BackStopPaths' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, BlockingRoute) == 0x000048, "Member 'ULandmassPathfinder::BlockingRoute' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, PCGSampler) == 0x0001A8, "Member 'ULandmassPathfinder::PCGSampler' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, PathfinderSpawnWarpingActorDelegate) == 0x0001C0, "Member 'ULandmassPathfinder::PathfinderSpawnWarpingActorDelegate' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, PathfinderHistory) == 0x0001D0, "Member 'ULandmassPathfinder::PathfinderHistory' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, MaxNodesPerCell) == 0x000218, "Member 'ULandmassPathfinder::MaxNodesPerCell' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, bUsePCGSamplerIfAvailable) == 0x000220, "Member 'ULandmassPathfinder::bUsePCGSamplerIfAvailable' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, bVisualizeHeuristicSteps) == 0x000221, "Member 'ULandmassPathfinder::bVisualizeHeuristicSteps' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, bVisualizeBacktracedPathOfHeuristicSteps) == 0x000222, "Member 'ULandmassPathfinder::bVisualizeBacktracedPathOfHeuristicSteps' has a wrong offset!");
static_assert(offsetof(ULandmassPathfinder, bVisualizeValidLocationSearching) == 0x000223, "Member 'ULandmassPathfinder::bVisualizeValidLocationSearching' has a wrong offset!");

// Class JunoProceduralWorld.PathfinderGuideSetsDataAsset
// 0x0010 (0x0040 - 0x0030)
class UPathfinderGuideSetsDataAsset final : public UDataAsset
{
public:
	TArray<struct FPathfinderGuideSet>            GuideSets;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool LoadCurveSetAndAddSplineComponentsToActor(class AActor* InActor, int32 Index_0);
	void SaveCurveSetFromSplintComponents(const TArray<class USplineComponent*>& SourceComponents, int32 Index_0);

	struct FPathfinderGuideSet GetRandomGuideSet() const;
	struct FPathfinderGuideSet GetRandomGuideSetFromSeed(int32 Seed) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathfinderGuideSetsDataAsset">();
	}
	static class UPathfinderGuideSetsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathfinderGuideSetsDataAsset>();
	}
};
static_assert(alignof(UPathfinderGuideSetsDataAsset) == 0x000008, "Wrong alignment on UPathfinderGuideSetsDataAsset");
static_assert(sizeof(UPathfinderGuideSetsDataAsset) == 0x000040, "Wrong size on UPathfinderGuideSetsDataAsset");
static_assert(offsetof(UPathfinderGuideSetsDataAsset, GuideSets) == 0x000030, "Member 'UPathfinderGuideSetsDataAsset::GuideSets' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoActorBoundsToPointSettings
// 0x0000 (0x0150 - 0x0150)
class UPCGJunoActorBoundsToPointSettings final : public UPCGSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoActorBoundsToPointSettings">();
	}
	static class UPCGJunoActorBoundsToPointSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoActorBoundsToPointSettings>();
	}
};
static_assert(alignof(UPCGJunoActorBoundsToPointSettings) == 0x000008, "Wrong alignment on UPCGJunoActorBoundsToPointSettings");
static_assert(sizeof(UPCGJunoActorBoundsToPointSettings) == 0x000150, "Wrong size on UPCGJunoActorBoundsToPointSettings");

// Class JunoProceduralWorld.PCGJunoFindFoundationSettings
// 0x0008 (0x0158 - 0x0150)
class UPCGJunoFindFoundationSettings final : public UPCGSettings
{
public:
	float                                         DistanceToSample;                                  // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoFindFoundationSettings">();
	}
	static class UPCGJunoFindFoundationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoFindFoundationSettings>();
	}
};
static_assert(alignof(UPCGJunoFindFoundationSettings) == 0x000008, "Wrong alignment on UPCGJunoFindFoundationSettings");
static_assert(sizeof(UPCGJunoFindFoundationSettings) == 0x000158, "Wrong size on UPCGJunoFindFoundationSettings");
static_assert(offsetof(UPCGJunoFindFoundationSettings, DistanceToSample) == 0x000150, "Member 'UPCGJunoFindFoundationSettings::DistanceToSample' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoMaskData
// 0x0058 (0x0090 - 0x0038)
class UPCGJunoMaskData final : public UPCGData
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoMaskData">();
	}
	static class UPCGJunoMaskData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoMaskData>();
	}
};
static_assert(alignof(UPCGJunoMaskData) == 0x000008, "Wrong alignment on UPCGJunoMaskData");
static_assert(sizeof(UPCGJunoMaskData) == 0x000090, "Wrong size on UPCGJunoMaskData");

// Class JunoProceduralWorld.PCGJunoCreateMaskDataNodeSettings
// 0x0008 (0x0158 - 0x0150)
class UPCGJunoCreateMaskDataNodeSettings final : public UPCGSettings
{
public:
	bool                                          bIs2D;                                             // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Resolution;                                        // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoCreateMaskDataNodeSettings">();
	}
	static class UPCGJunoCreateMaskDataNodeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoCreateMaskDataNodeSettings>();
	}
};
static_assert(alignof(UPCGJunoCreateMaskDataNodeSettings) == 0x000008, "Wrong alignment on UPCGJunoCreateMaskDataNodeSettings");
static_assert(sizeof(UPCGJunoCreateMaskDataNodeSettings) == 0x000158, "Wrong size on UPCGJunoCreateMaskDataNodeSettings");
static_assert(offsetof(UPCGJunoCreateMaskDataNodeSettings, bIs2D) == 0x000150, "Member 'UPCGJunoCreateMaskDataNodeSettings::bIs2D' has a wrong offset!");
static_assert(offsetof(UPCGJunoCreateMaskDataNodeSettings, Resolution) == 0x000154, "Member 'UPCGJunoCreateMaskDataNodeSettings::Resolution' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoApplyMaskNodeSettings
// 0x0008 (0x0158 - 0x0150)
class UPCGJunoApplyMaskNodeSettings final : public UPCGSettings
{
public:
	EPCGJunoApplyMaskNodeMode                     Mode;                                              // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoApplyMaskNodeSettings">();
	}
	static class UPCGJunoApplyMaskNodeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoApplyMaskNodeSettings>();
	}
};
static_assert(alignof(UPCGJunoApplyMaskNodeSettings) == 0x000008, "Wrong alignment on UPCGJunoApplyMaskNodeSettings");
static_assert(sizeof(UPCGJunoApplyMaskNodeSettings) == 0x000158, "Wrong size on UPCGJunoApplyMaskNodeSettings");
static_assert(offsetof(UPCGJunoApplyMaskNodeSettings, Mode) == 0x000150, "Member 'UPCGJunoApplyMaskNodeSettings::Mode' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoUnionMasksNodeSettings
// 0x0008 (0x0158 - 0x0150)
class UPCGJunoUnionMasksNodeSettings final : public UPCGSettings
{
public:
	bool                                          bIs2D;                                             // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Resolution;                                        // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoUnionMasksNodeSettings">();
	}
	static class UPCGJunoUnionMasksNodeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoUnionMasksNodeSettings>();
	}
};
static_assert(alignof(UPCGJunoUnionMasksNodeSettings) == 0x000008, "Wrong alignment on UPCGJunoUnionMasksNodeSettings");
static_assert(sizeof(UPCGJunoUnionMasksNodeSettings) == 0x000158, "Wrong size on UPCGJunoUnionMasksNodeSettings");
static_assert(offsetof(UPCGJunoUnionMasksNodeSettings, bIs2D) == 0x000150, "Member 'UPCGJunoUnionMasksNodeSettings::bIs2D' has a wrong offset!");
static_assert(offsetof(UPCGJunoUnionMasksNodeSettings, Resolution) == 0x000154, "Member 'UPCGJunoUnionMasksNodeSettings::Resolution' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoProjectPositionSettings
// 0x0008 (0x0158 - 0x0150)
class UPCGJunoProjectPositionSettings final : public UPCGSettings
{
public:
	bool                                          bProjectLandscapeMetadata;                         // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectPositions;                                 // 0x0151(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectRotations;                                 // 0x0152(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_153[0x5];                                      // 0x0153(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoProjectPositionSettings">();
	}
	static class UPCGJunoProjectPositionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoProjectPositionSettings>();
	}
};
static_assert(alignof(UPCGJunoProjectPositionSettings) == 0x000008, "Wrong alignment on UPCGJunoProjectPositionSettings");
static_assert(sizeof(UPCGJunoProjectPositionSettings) == 0x000158, "Wrong size on UPCGJunoProjectPositionSettings");
static_assert(offsetof(UPCGJunoProjectPositionSettings, bProjectLandscapeMetadata) == 0x000150, "Member 'UPCGJunoProjectPositionSettings::bProjectLandscapeMetadata' has a wrong offset!");
static_assert(offsetof(UPCGJunoProjectPositionSettings, bProjectPositions) == 0x000151, "Member 'UPCGJunoProjectPositionSettings::bProjectPositions' has a wrong offset!");
static_assert(offsetof(UPCGJunoProjectPositionSettings, bProjectRotations) == 0x000152, "Member 'UPCGJunoProjectPositionSettings::bProjectRotations' has a wrong offset!");

// Class JunoProceduralWorld.JunoProjectPositionTestShape
// 0x0000 (0x0080 - 0x0080)
class UJunoProjectPositionTestShape final : public UPCGSpatialData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoProjectPositionTestShape">();
	}
	static class UJunoProjectPositionTestShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoProjectPositionTestShape>();
	}
};
static_assert(alignof(UJunoProjectPositionTestShape) == 0x000008, "Wrong alignment on UJunoProjectPositionTestShape");
static_assert(sizeof(UJunoProjectPositionTestShape) == 0x000080, "Wrong size on UJunoProjectPositionTestShape");

// Class JunoProceduralWorld.PCGJunoStoreDataSettings
// 0x0010 (0x0160 - 0x0150)
class UPCGJunoStoreDataSettings final : public UPCGSettings
{
public:
	TArray<struct FPCGJunoStoreDataPin>           ExpectedPins;                                      // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoStoreDataSettings">();
	}
	static class UPCGJunoStoreDataSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoStoreDataSettings>();
	}
};
static_assert(alignof(UPCGJunoStoreDataSettings) == 0x000008, "Wrong alignment on UPCGJunoStoreDataSettings");
static_assert(sizeof(UPCGJunoStoreDataSettings) == 0x000160, "Wrong size on UPCGJunoStoreDataSettings");
static_assert(offsetof(UPCGJunoStoreDataSettings, ExpectedPins) == 0x000150, "Member 'UPCGJunoStoreDataSettings::ExpectedPins' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoLoadDataSettings
// 0x0038 (0x0188 - 0x0150)
class UPCGJunoLoadDataSettings final : public UPCGSettings
{
public:
	TArray<class FName>                           Pins;                                              // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EJunoPCGVolumeSource                          Source;                                            // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AdditionalExtents;                                 // 0x0168(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   tag;                                               // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoLoadDataSettings">();
	}
	static class UPCGJunoLoadDataSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoLoadDataSettings>();
	}
};
static_assert(alignof(UPCGJunoLoadDataSettings) == 0x000008, "Wrong alignment on UPCGJunoLoadDataSettings");
static_assert(sizeof(UPCGJunoLoadDataSettings) == 0x000188, "Wrong size on UPCGJunoLoadDataSettings");
static_assert(offsetof(UPCGJunoLoadDataSettings, Pins) == 0x000150, "Member 'UPCGJunoLoadDataSettings::Pins' has a wrong offset!");
static_assert(offsetof(UPCGJunoLoadDataSettings, Source) == 0x000160, "Member 'UPCGJunoLoadDataSettings::Source' has a wrong offset!");
static_assert(offsetof(UPCGJunoLoadDataSettings, AdditionalExtents) == 0x000168, "Member 'UPCGJunoLoadDataSettings::AdditionalExtents' has a wrong offset!");
static_assert(offsetof(UPCGJunoLoadDataSettings, tag) == 0x000180, "Member 'UPCGJunoLoadDataSettings::tag' has a wrong offset!");

// Class JunoProceduralWorld.ProceduralRiverGenRulesAsset
// 0x0058 (0x0088 - 0x0030)
class UProceduralRiverGenRulesAsset final : public UDataAsset
{
public:
	TMap<ELandmassRiverTier, struct FProceduralRiverGenRules> RuleSet;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         RiverGridGridSize;                                 // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RasterizeToRiverGridExtent;                        // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRiverGenRulesAsset">();
	}
	static class UProceduralRiverGenRulesAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralRiverGenRulesAsset>();
	}
};
static_assert(alignof(UProceduralRiverGenRulesAsset) == 0x000008, "Wrong alignment on UProceduralRiverGenRulesAsset");
static_assert(sizeof(UProceduralRiverGenRulesAsset) == 0x000088, "Wrong size on UProceduralRiverGenRulesAsset");
static_assert(offsetof(UProceduralRiverGenRulesAsset, RuleSet) == 0x000030, "Member 'UProceduralRiverGenRulesAsset::RuleSet' has a wrong offset!");
static_assert(offsetof(UProceduralRiverGenRulesAsset, RiverGridGridSize) == 0x000080, "Member 'UProceduralRiverGenRulesAsset::RiverGridGridSize' has a wrong offset!");
static_assert(offsetof(UProceduralRiverGenRulesAsset, RasterizeToRiverGridExtent) == 0x000084, "Member 'UProceduralRiverGenRulesAsset::RasterizeToRiverGridExtent' has a wrong offset!");

// Class JunoProceduralWorld.JunoCaveVolume
// 0x0000 (0x0298 - 0x0298)
class AJunoCaveVolume final : public ATriggerBox
{
public:
	void OnPlayerEnteringCaveVolume(class AFortPlayerPawnAthena* PlayerPawn);
	void OnPlayerLeavingCaveVolume(class AFortPlayerPawnAthena* PlayerPawn);
	void RetrievePointProviders(TArray<class AJunoCaveLivingWorldStaticPointProvider*>* OutPointProviders);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveVolume">();
	}
	static class AJunoCaveVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoCaveVolume>();
	}
};
static_assert(alignof(AJunoCaveVolume) == 0x000008, "Wrong alignment on AJunoCaveVolume");
static_assert(sizeof(AJunoCaveVolume) == 0x000298, "Wrong size on AJunoCaveVolume");

// Class JunoProceduralWorld.JunoGameFeatureAction_AddTileSet
// 0x0030 (0x0058 - 0x0028)
class UJunoGameFeatureAction_AddTileSet final : public UGameFeatureAction
{
public:
	TSoftObjectPtr<class UJunoLandscapeLayersData> JunoLandscapeLayers;                               // 0x0028(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         TerrainDirectories;                                // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoGameFeatureAction_AddTileSet">();
	}
	static class UJunoGameFeatureAction_AddTileSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoGameFeatureAction_AddTileSet>();
	}
};
static_assert(alignof(UJunoGameFeatureAction_AddTileSet) == 0x000008, "Wrong alignment on UJunoGameFeatureAction_AddTileSet");
static_assert(sizeof(UJunoGameFeatureAction_AddTileSet) == 0x000058, "Wrong size on UJunoGameFeatureAction_AddTileSet");
static_assert(offsetof(UJunoGameFeatureAction_AddTileSet, JunoLandscapeLayers) == 0x000028, "Member 'UJunoGameFeatureAction_AddTileSet::JunoLandscapeLayers' has a wrong offset!");
static_assert(offsetof(UJunoGameFeatureAction_AddTileSet, TerrainDirectories) == 0x000048, "Member 'UJunoGameFeatureAction_AddTileSet::TerrainDirectories' has a wrong offset!");

// Class JunoProceduralWorld.JunoLevelInstance
// 0x0010 (0x07B8 - 0x07A8)
class AJunoLevelInstance final : public ABuildingLevelInstance
{
public:
	TMulticastInlineDelegate<void(class AJunoLevelInstance* JunoLevelInstance)> OnLevelLoaded;                                     // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	TArray<class AActor*> GetActorsInLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLevelInstance">();
	}
	static class AJunoLevelInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoLevelInstance>();
	}
};
static_assert(alignof(AJunoLevelInstance) == 0x000008, "Wrong alignment on AJunoLevelInstance");
static_assert(sizeof(AJunoLevelInstance) == 0x0007B8, "Wrong size on AJunoLevelInstance");
static_assert(offsetof(AJunoLevelInstance, OnLevelLoaded) == 0x0007A8, "Member 'AJunoLevelInstance::OnLevelLoaded' has a wrong offset!");

// Class JunoProceduralWorld.JunoLivingWorldStaticPointProviderCluster
// 0x0160 (0x03F0 - 0x0290)
class AJunoLivingWorldStaticPointProviderCluster final : public AActor
{
public:
	TArray<struct FJunoLivingWorldStaticPointProviderClusterEntry> Entries;                                           // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLWMClusterPointInfo>           PointInfos;                                        // 0x02A0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PartitionnerCellSize;                              // 0x02B0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x4];                                      // 0x02D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HysteresisSize;                                    // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPlayerQueryRange;                               // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x10C];                                    // 0x02E4(0x010C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrentPlaylistLoaded(class FName PlaylistName, const struct FGameplayTagContainer& PlaylistContextTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLivingWorldStaticPointProviderCluster">();
	}
	static class AJunoLivingWorldStaticPointProviderCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoLivingWorldStaticPointProviderCluster>();
	}
};
static_assert(alignof(AJunoLivingWorldStaticPointProviderCluster) == 0x000008, "Wrong alignment on AJunoLivingWorldStaticPointProviderCluster");
static_assert(sizeof(AJunoLivingWorldStaticPointProviderCluster) == 0x0003F0, "Wrong size on AJunoLivingWorldStaticPointProviderCluster");
static_assert(offsetof(AJunoLivingWorldStaticPointProviderCluster, Entries) == 0x000290, "Member 'AJunoLivingWorldStaticPointProviderCluster::Entries' has a wrong offset!");
static_assert(offsetof(AJunoLivingWorldStaticPointProviderCluster, PointInfos) == 0x0002A0, "Member 'AJunoLivingWorldStaticPointProviderCluster::PointInfos' has a wrong offset!");
static_assert(offsetof(AJunoLivingWorldStaticPointProviderCluster, PartitionnerCellSize) == 0x0002B0, "Member 'AJunoLivingWorldStaticPointProviderCluster::PartitionnerCellSize' has a wrong offset!");
static_assert(offsetof(AJunoLivingWorldStaticPointProviderCluster, HysteresisSize) == 0x0002DC, "Member 'AJunoLivingWorldStaticPointProviderCluster::HysteresisSize' has a wrong offset!");
static_assert(offsetof(AJunoLivingWorldStaticPointProviderCluster, MaxPlayerQueryRange) == 0x0002E0, "Member 'AJunoLivingWorldStaticPointProviderCluster::MaxPlayerQueryRange' has a wrong offset!");

// Class JunoProceduralWorld.JunoPOIGameplayVolume
// 0x0090 (0x0440 - 0x03B0)
class AJunoPOIGameplayVolume final : public AJunoStreamingGameplayVolume
{
public:
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoPOIInstanceData                   InstanceData;                                      // 0x03B8(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	struct FGuid                                  POIGuid;                                           // 0x03D0(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EncounterCapabilities;                             // 0x03E0(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	int32                                         EncounterVariantCount;                             // 0x0400(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              EncounterCategoryTable;                            // 0x0408(0x0020)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJunoWorldTileStreamingLevel>   LevelsToInject;                                    // 0x0428(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   RegistryItemName;                                  // 0x0438(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PersistenceVersion;                                // 0x043C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPOIGameplayVolume">();
	}
	static class AJunoPOIGameplayVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPOIGameplayVolume>();
	}
};
static_assert(alignof(AJunoPOIGameplayVolume) == 0x000008, "Wrong alignment on AJunoPOIGameplayVolume");
static_assert(sizeof(AJunoPOIGameplayVolume) == 0x000440, "Wrong size on AJunoPOIGameplayVolume");
static_assert(offsetof(AJunoPOIGameplayVolume, InstanceData) == 0x0003B8, "Member 'AJunoPOIGameplayVolume::InstanceData' has a wrong offset!");
static_assert(offsetof(AJunoPOIGameplayVolume, POIGuid) == 0x0003D0, "Member 'AJunoPOIGameplayVolume::POIGuid' has a wrong offset!");
static_assert(offsetof(AJunoPOIGameplayVolume, EncounterCapabilities) == 0x0003E0, "Member 'AJunoPOIGameplayVolume::EncounterCapabilities' has a wrong offset!");
static_assert(offsetof(AJunoPOIGameplayVolume, EncounterVariantCount) == 0x000400, "Member 'AJunoPOIGameplayVolume::EncounterVariantCount' has a wrong offset!");
static_assert(offsetof(AJunoPOIGameplayVolume, EncounterCategoryTable) == 0x000408, "Member 'AJunoPOIGameplayVolume::EncounterCategoryTable' has a wrong offset!");
static_assert(offsetof(AJunoPOIGameplayVolume, LevelsToInject) == 0x000428, "Member 'AJunoPOIGameplayVolume::LevelsToInject' has a wrong offset!");
static_assert(offsetof(AJunoPOIGameplayVolume, RegistryItemName) == 0x000438, "Member 'AJunoPOIGameplayVolume::RegistryItemName' has a wrong offset!");
static_assert(offsetof(AJunoPOIGameplayVolume, PersistenceVersion) == 0x00043C, "Member 'AJunoPOIGameplayVolume::PersistenceVersion' has a wrong offset!");

// Class JunoProceduralWorld.JunoPOISlot
// 0x0048 (0x02D8 - 0x0290)
class AJunoPOISlot final : public AActor
{
public:
	TSoftObjectPtr<class UDataTable>              PotentialPOIs;                                     // 0x0290(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJunoPOISize                                  SlotSize;                                          // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              TerrainHeightTexture;                              // 0x02B8(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPOISlot">();
	}
	static class AJunoPOISlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoPOISlot>();
	}
};
static_assert(alignof(AJunoPOISlot) == 0x000008, "Wrong alignment on AJunoPOISlot");
static_assert(sizeof(AJunoPOISlot) == 0x0002D8, "Wrong size on AJunoPOISlot");
static_assert(offsetof(AJunoPOISlot, PotentialPOIs) == 0x000290, "Member 'AJunoPOISlot::PotentialPOIs' has a wrong offset!");
static_assert(offsetof(AJunoPOISlot, SlotSize) == 0x0002B0, "Member 'AJunoPOISlot::SlotSize' has a wrong offset!");
static_assert(offsetof(AJunoPOISlot, TerrainHeightTexture) == 0x0002B8, "Member 'AJunoPOISlot::TerrainHeightTexture' has a wrong offset!");

// Class JunoProceduralWorld.JunoPOIBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UJunoPOIBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CreateCavePOI(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, const struct FJunoPOIData& Data, EGeneratePOIResult* Result);
	static void CreatePOI(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, const struct FJunoPOIData& Data, EGeneratePOIResult* Result);
	static void CreateRarePOIs(const class AActor* Actor, const struct FRandomStream& RandomStream, const struct FDataRegistryType& DataRegistry, TArray<struct FJunoPOIManagerSlot>& PotentialSlots, TArray<struct FJunoPOIManagerSlot>* UsedSlots, EGeneratePOIResult* Result);
	static void FindBestPOISlots(const TArray<struct FJunoPOIManagerSlot>& PotentialSlots, const TArray<struct FJunoPOIManagerSlot>& AdditionalCompareSlots, int32 DesiredNumber, double DesiredMinDistance, TArray<struct FJunoPOIManagerSlot>* Result, TArray<struct FJunoPOIManagerSlot>* Remainder, const struct FBox& WorldTileBounds, EJunoBiome Biome, bool bEnforceMinDistance);
	static void GetMatchingPOIsFromDataRegistry(const struct FDataRegistryType& DataRegistry, const TSet<class FName>& Tags, const TSet<EJunoPOISize>& Sizes, const TSet<EJunoBiome>& Biomes, const TArray<struct FPCGJunoWorldTilePOI>& Array, EJunoGetMatchingPOIsFromDataRegistryResult* Result, EJunoWorldTilePOIType Type);
	static void MarkCavePOISlotUnused(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, EJunoMarkSlotPOIUnusedResult* Result);
	static void MarkPOISlotUnused(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, EJunoMarkSlotPOIUnusedResult* Result);
	static void QueryCavePOIState(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, EQueryPOIStateResult* Result, struct FBox* WorldTileBounds);
	static void QueryPOIState(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, EQueryPOIStateResult* Result, struct FJunoPOISlotMetaData* POISlotMetaData, struct FBox* WorldTileBounds);
	static void SetPOISlotMetaDatas(const class AActor* POISlotActor, const TArray<struct FJunoPOIManagerSlot>& POISlots, const struct FJunoPOISlotMetaData& POISlotMetaData, EJunoSetSlotPOIMetaDataResult* Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoPOIBlueprintLibrary">();
	}
	static class UJunoPOIBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoPOIBlueprintLibrary>();
	}
};
static_assert(alignof(UJunoPOIBlueprintLibrary) == 0x000008, "Wrong alignment on UJunoPOIBlueprintLibrary");
static_assert(sizeof(UJunoPOIBlueprintLibrary) == 0x000028, "Wrong size on UJunoPOIBlueprintLibrary");

// Class JunoProceduralWorld.JunoProceduralFoundation
// 0x0000 (0x1030 - 0x1030)
class AJunoProceduralFoundation final : public ABuildingFoundation
{
public:
	void AddAdditionalWorld(TSoftObjectPtr<class UWorld>& World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoProceduralFoundation">();
	}
	static class AJunoProceduralFoundation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoProceduralFoundation>();
	}
};
static_assert(alignof(AJunoProceduralFoundation) == 0x000010, "Wrong alignment on AJunoProceduralFoundation");
static_assert(sizeof(AJunoProceduralFoundation) == 0x001030, "Wrong size on AJunoProceduralFoundation");

// Class JunoProceduralWorld.JunoRoadAINavigationCluster
// 0x0020 (0x02B0 - 0x0290)
class AJunoRoadAINavigationCluster final : public AActor
{
public:
	TArray<struct FJunoRoadAINavigationClusterEntry> Entries;                                           // 0x0290(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRoadPatrolPathInfo>            PatrolInfos;                                       // 0x02A0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnCurrentPlaylistLoaded(class FName PlaylistName, const struct FGameplayTagContainer& PlaylistContextTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRoadAINavigationCluster">();
	}
	static class AJunoRoadAINavigationCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoRoadAINavigationCluster>();
	}
};
static_assert(alignof(AJunoRoadAINavigationCluster) == 0x000008, "Wrong alignment on AJunoRoadAINavigationCluster");
static_assert(sizeof(AJunoRoadAINavigationCluster) == 0x0002B0, "Wrong size on AJunoRoadAINavigationCluster");
static_assert(offsetof(AJunoRoadAINavigationCluster, Entries) == 0x000290, "Member 'AJunoRoadAINavigationCluster::Entries' has a wrong offset!");
static_assert(offsetof(AJunoRoadAINavigationCluster, PatrolInfos) == 0x0002A0, "Member 'AJunoRoadAINavigationCluster::PatrolInfos' has a wrong offset!");

// Class JunoProceduralWorld.JunoStaticMeshPoolActor
// 0x0018 (0x02A8 - 0x0290)
class AJunoStaticMeshPoolActor final : public AActor
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoStaticMeshPoolActor">();
	}
	static class AJunoStaticMeshPoolActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoStaticMeshPoolActor>();
	}
};
static_assert(alignof(AJunoStaticMeshPoolActor) == 0x000008, "Wrong alignment on AJunoStaticMeshPoolActor");
static_assert(sizeof(AJunoStaticMeshPoolActor) == 0x0002A8, "Wrong size on AJunoStaticMeshPoolActor");

// Class JunoProceduralWorld.JunoWorldTileContentsPersistentData
// 0x0120 (0x03F0 - 0x02D0)
class AJunoWorldTileContentsPersistentData final : public AJunoPersistenceFeatureDataActor
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FJunoCave>          Caves;                                             // 0x02D8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class AJunoPOIGameplayVolume*> POIs;                                              // 0x0328(0x0050)(SaveGame, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FJunoWorldTileStreamingLevel>   InjectedLevels;                                    // 0x0378(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FJunoPOISlotMetaData> POISlotMetaDatas;                                  // 0x0388(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FJunoCaveSurfaceData>           CaveSurfaceData;                                   // 0x03D8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	bool                                          bIsCaveSurfaceDataValid;                           // 0x03E8(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTileContentsPersistentData">();
	}
	static class AJunoWorldTileContentsPersistentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoWorldTileContentsPersistentData>();
	}
};
static_assert(alignof(AJunoWorldTileContentsPersistentData) == 0x000008, "Wrong alignment on AJunoWorldTileContentsPersistentData");
static_assert(sizeof(AJunoWorldTileContentsPersistentData) == 0x0003F0, "Wrong size on AJunoWorldTileContentsPersistentData");
static_assert(offsetof(AJunoWorldTileContentsPersistentData, Caves) == 0x0002D8, "Member 'AJunoWorldTileContentsPersistentData::Caves' has a wrong offset!");
static_assert(offsetof(AJunoWorldTileContentsPersistentData, POIs) == 0x000328, "Member 'AJunoWorldTileContentsPersistentData::POIs' has a wrong offset!");
static_assert(offsetof(AJunoWorldTileContentsPersistentData, InjectedLevels) == 0x000378, "Member 'AJunoWorldTileContentsPersistentData::InjectedLevels' has a wrong offset!");
static_assert(offsetof(AJunoWorldTileContentsPersistentData, POISlotMetaDatas) == 0x000388, "Member 'AJunoWorldTileContentsPersistentData::POISlotMetaDatas' has a wrong offset!");
static_assert(offsetof(AJunoWorldTileContentsPersistentData, CaveSurfaceData) == 0x0003D8, "Member 'AJunoWorldTileContentsPersistentData::CaveSurfaceData' has a wrong offset!");
static_assert(offsetof(AJunoWorldTileContentsPersistentData, bIsCaveSurfaceDataValid) == 0x0003E8, "Member 'AJunoWorldTileContentsPersistentData::bIsCaveSurfaceDataValid' has a wrong offset!");

// Class JunoProceduralWorld.JunoLivingWorldCaveSpawnLimiterComponent
// 0x0078 (0x0118 - 0x00A0)
class UJunoLivingWorldCaveSpawnLimiterComponent final : public UActorComponent
{
public:
	struct FCaveShellSpawnLimitData               SpawnLimitData;                                    // 0x00A0(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLivingWorldCaveSpawnLimiterComponent">();
	}
	static class UJunoLivingWorldCaveSpawnLimiterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLivingWorldCaveSpawnLimiterComponent>();
	}
};
static_assert(alignof(UJunoLivingWorldCaveSpawnLimiterComponent) == 0x000008, "Wrong alignment on UJunoLivingWorldCaveSpawnLimiterComponent");
static_assert(sizeof(UJunoLivingWorldCaveSpawnLimiterComponent) == 0x000118, "Wrong size on UJunoLivingWorldCaveSpawnLimiterComponent");
static_assert(offsetof(UJunoLivingWorldCaveSpawnLimiterComponent, SpawnLimitData) == 0x0000A0, "Member 'UJunoLivingWorldCaveSpawnLimiterComponent::SpawnLimitData' has a wrong offset!");

// Class JunoProceduralWorld.CaveShellSpawnEntry
// 0x0038 (0x0060 - 0x0028)
class UCaveShellSpawnEntry final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaveShellSpawnEntry">();
	}
	static class UCaveShellSpawnEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaveShellSpawnEntry>();
	}
};
static_assert(alignof(UCaveShellSpawnEntry) == 0x000008, "Wrong alignment on UCaveShellSpawnEntry");
static_assert(sizeof(UCaveShellSpawnEntry) == 0x000060, "Wrong size on UCaveShellSpawnEntry");

// Class JunoProceduralWorld.JunoLivingWorldCaveSpawnManager
// 0x0050 (0x00F0 - 0x00A0)
class UJunoLivingWorldCaveSpawnManager final : public UGameStateComponent
{
public:
	TMap<struct FCaveShellID, class UCaveShellSpawnEntry*> Entries;                                           // 0x00A0(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLivingWorldCaveSpawnManager">();
	}
	static class UJunoLivingWorldCaveSpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLivingWorldCaveSpawnManager>();
	}
};
static_assert(alignof(UJunoLivingWorldCaveSpawnManager) == 0x000008, "Wrong alignment on UJunoLivingWorldCaveSpawnManager");
static_assert(sizeof(UJunoLivingWorldCaveSpawnManager) == 0x0000F0, "Wrong size on UJunoLivingWorldCaveSpawnManager");
static_assert(offsetof(UJunoLivingWorldCaveSpawnManager, Entries) == 0x0000A0, "Member 'UJunoLivingWorldCaveSpawnManager::Entries' has a wrong offset!");

// Class JunoProceduralWorld.JunoLivingWorldStaticPointProviderClusterRenderComponent
// 0x0020 (0x0570 - 0x0550)
class UJunoLivingWorldStaticPointProviderClusterRenderComponent final : public UDebugDrawComponent
{
public:
	uint8                                         Pad_550[0x20];                                     // 0x0550(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLivingWorldStaticPointProviderClusterRenderComponent">();
	}
	static class UJunoLivingWorldStaticPointProviderClusterRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLivingWorldStaticPointProviderClusterRenderComponent>();
	}
};
static_assert(alignof(UJunoLivingWorldStaticPointProviderClusterRenderComponent) == 0x000010, "Wrong alignment on UJunoLivingWorldStaticPointProviderClusterRenderComponent");
static_assert(sizeof(UJunoLivingWorldStaticPointProviderClusterRenderComponent) == 0x000570, "Wrong size on UJunoLivingWorldStaticPointProviderClusterRenderComponent");

// Class JunoProceduralWorld.JunoRoadAINavigationClusterRenderComponent
// 0x0000 (0x0550 - 0x0550)
class UJunoRoadAINavigationClusterRenderComponent final : public UDebugDrawComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoRoadAINavigationClusterRenderComponent">();
	}
	static class UJunoRoadAINavigationClusterRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoRoadAINavigationClusterRenderComponent>();
	}
};
static_assert(alignof(UJunoRoadAINavigationClusterRenderComponent) == 0x000010, "Wrong alignment on UJunoRoadAINavigationClusterRenderComponent");
static_assert(sizeof(UJunoRoadAINavigationClusterRenderComponent) == 0x000550, "Wrong size on UJunoRoadAINavigationClusterRenderComponent");

// Class JunoProceduralWorld.JunoProceduralWorldSystem
// 0x0000 (0x0030 - 0x0030)
class UJunoProceduralWorldSystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoProceduralWorldSystem">();
	}
	static class UJunoProceduralWorldSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoProceduralWorldSystem>();
	}
};
static_assert(alignof(UJunoProceduralWorldSystem) == 0x000008, "Wrong alignment on UJunoProceduralWorldSystem");
static_assert(sizeof(UJunoProceduralWorldSystem) == 0x000030, "Wrong size on UJunoProceduralWorldSystem");

// Class JunoProceduralWorld.LandmassCluster
// 0x0030 (0x0058 - 0x0028)
class ULandmassCluster final : public UObject
{
public:
	bool                                          bInitialized;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x17];                                      // 0x0029(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         Actors;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeDentrogram(const TArray<class AActor*>& InActors, const TArray<struct FDendrogramLeafAttributes>& InAttributes);
	bool K2_AddConnection(class AActor* LeafActorA, class AActor* LeafActorB);

	const TArray<struct FDendrogramClusterOutput> GetClustersAtLevel(int32 InLevel) const;
	int32 GetLeafCount() const;
	int32 GetTopLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandmassCluster">();
	}
	static class ULandmassCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandmassCluster>();
	}
};
static_assert(alignof(ULandmassCluster) == 0x000008, "Wrong alignment on ULandmassCluster");
static_assert(sizeof(ULandmassCluster) == 0x000058, "Wrong size on ULandmassCluster");
static_assert(offsetof(ULandmassCluster, bInitialized) == 0x000028, "Member 'ULandmassCluster::bInitialized' has a wrong offset!");
static_assert(offsetof(ULandmassCluster, Actors) == 0x000040, "Member 'ULandmassCluster::Actors' has a wrong offset!");

// Class JunoProceduralWorld.LandmassProceduralRoadGenRules
// 0x0058 (0x0088 - 0x0030)
class ULandmassProceduralRoadGenRules final : public UDataAsset
{
public:
	TMap<ELandmassRoadTier, struct FProceduralRoadGenRules> RuleSet;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         RoadGridGridSize;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RasterizeToRoadGridExtent;                         // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandmassProceduralRoadGenRules">();
	}
	static class ULandmassProceduralRoadGenRules* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandmassProceduralRoadGenRules>();
	}
};
static_assert(alignof(ULandmassProceduralRoadGenRules) == 0x000008, "Wrong alignment on ULandmassProceduralRoadGenRules");
static_assert(sizeof(ULandmassProceduralRoadGenRules) == 0x000088, "Wrong size on ULandmassProceduralRoadGenRules");
static_assert(offsetof(ULandmassProceduralRoadGenRules, RuleSet) == 0x000030, "Member 'ULandmassProceduralRoadGenRules::RuleSet' has a wrong offset!");
static_assert(offsetof(ULandmassProceduralRoadGenRules, RoadGridGridSize) == 0x000080, "Member 'ULandmassProceduralRoadGenRules::RoadGridGridSize' has a wrong offset!");
static_assert(offsetof(ULandmassProceduralRoadGenRules, RasterizeToRoadGridExtent) == 0x000084, "Member 'ULandmassProceduralRoadGenRules::RasterizeToRoadGridExtent' has a wrong offset!");

// Class JunoProceduralWorld.ProceduralRouteDefinition
// 0x0008 (0x0030 - 0x0028)
class UProceduralRouteDefinition : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, float* OutDistanceSqr) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRouteDefinition">();
	}
	static class UProceduralRouteDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralRouteDefinition>();
	}
};
static_assert(alignof(UProceduralRouteDefinition) == 0x000008, "Wrong alignment on UProceduralRouteDefinition");
static_assert(sizeof(UProceduralRouteDefinition) == 0x000030, "Wrong size on UProceduralRouteDefinition");

// Class JunoProceduralWorld.LandmassProceduralRoute
// 0x00C8 (0x0358 - 0x0290)
class ALandmassProceduralRoute : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EditorTickIsEnabled;                               // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPCGSpatialData>         PCGSampler;                                        // 0x029C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunFromPCG;                                       // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ALandscapeProxy*                        LandscapeProxy;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickFrequency;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProceduralRouteJunoTileInfo           JunoTileInfo;                                      // 0x02B4(0x000C)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TSubclassOf<class ULandmassPathfinder>        Pathfinder;                                        // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AWaterBody*>                     Lakes;                                             // 0x02C8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ALandmassProceduralRoute* ProceduralRoute)> OnGenerationFinishedMulticastDelegate;             // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x20];                                     // 0x02F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UProceduralRouteDefinition*>     PendingRoutesToAddToRouteGrid;                     // 0x0318(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x20];                                     // 0x0328(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ULandmassCluster*                       LandmassCluster;                                   // 0x0348(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDebugInfo;                                  // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAvoidancePrimitive(const struct FRouteAvoidancePrimitive& InPrimitive);
	bool AddConnection(class AActor* LeafActorA, class AActor* LeafActorB);
	bool AddControlPoint(const struct FVector& WorldPosition);
	void BeginGeneratePCG(const TArray<struct FLandmassPCGRouteInput>& Inputs);
	bool ClearCreatedLandscapeSplines();
	void CustomTick(float DeltaSeconds);
	bool FinishRoute(int32* OutRouteIndex);
	bool GenerateCluster();
	void InitLandmassCluster(const TArray<class AActor*>& InActors, const TArray<struct FDendrogramLeafAttributes>& InLeafAttributes);
	void InitLandmassClusterLeavesOnly(const TArray<struct FDendrogramLeafAttributes>& InLeafAttributes);
	void OnGenerationFinished();
	bool PutIntoDormancy();
	void RasterizeAllPendingRoutesToRouteGrid();
	bool ResetAllAndInitialize(bool bResetAllLandscapeSplines);
	void SetCurrentRouteGenerationState(ERouteGenerationState InState);
	void SetEditorTickEnabled(bool bEnabled);
	void SetWidthAtPointIndex(int32 Index_0, float NewWidth);
	void SetWidthForLastAddedPoint(float NewWidth);
	void StartRoute();
	bool WakeUpDormantRoute();

	ERouteGenerationState GetCurrentRouteGenerationState() const;
	class ULandmassCluster* GetLandmassCluster() const;
	TArray<class UProceduralRouteDefinition*> GetRouteDefinitions() const;
	bool IsInsideAnyLake(const struct FVector& Location, float Tolerance) const;
	bool IsInsideAnyLakeAccurate(const struct FVector& Location) const;
	bool IsInsideLake(const struct FVector& Location, const class AWaterBody* InLake, float Dilation) const;
	bool IsInsideOcean(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandmassProceduralRoute">();
	}
	static class ALandmassProceduralRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandmassProceduralRoute>();
	}
};
static_assert(alignof(ALandmassProceduralRoute) == 0x000008, "Wrong alignment on ALandmassProceduralRoute");
static_assert(sizeof(ALandmassProceduralRoute) == 0x000358, "Wrong size on ALandmassProceduralRoute");
static_assert(offsetof(ALandmassProceduralRoute, EditorTickIsEnabled) == 0x000298, "Member 'ALandmassProceduralRoute::EditorTickIsEnabled' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, PCGSampler) == 0x00029C, "Member 'ALandmassProceduralRoute::PCGSampler' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, bRunFromPCG) == 0x0002A4, "Member 'ALandmassProceduralRoute::bRunFromPCG' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, LandscapeProxy) == 0x0002A8, "Member 'ALandmassProceduralRoute::LandscapeProxy' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, TickFrequency) == 0x0002B0, "Member 'ALandmassProceduralRoute::TickFrequency' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, JunoTileInfo) == 0x0002B4, "Member 'ALandmassProceduralRoute::JunoTileInfo' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, Pathfinder) == 0x0002C0, "Member 'ALandmassProceduralRoute::Pathfinder' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, Lakes) == 0x0002C8, "Member 'ALandmassProceduralRoute::Lakes' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, OnGenerationFinishedMulticastDelegate) == 0x0002E8, "Member 'ALandmassProceduralRoute::OnGenerationFinishedMulticastDelegate' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, PendingRoutesToAddToRouteGrid) == 0x000318, "Member 'ALandmassProceduralRoute::PendingRoutesToAddToRouteGrid' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, LandmassCluster) == 0x000348, "Member 'ALandmassProceduralRoute::LandmassCluster' has a wrong offset!");
static_assert(offsetof(ALandmassProceduralRoute, bEnableDebugInfo) == 0x000350, "Member 'ALandmassProceduralRoute::bEnableDebugInfo' has a wrong offset!");

// Class JunoProceduralWorld.ProceduralRiverDefinition
// 0x0018 (0x0048 - 0x0030)
class UProceduralRiverDefinition final : public UProceduralRouteDefinition
{
public:
	class UProceduralRiverGenRulesAsset*          GenRulesAsset;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELandmassRiverTier                            RiverTier;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AWaterBody*                             WaterBody;                                         // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class AWaterBody* GetWaterBodyActor() const;
	class UWaterSplineComponent* GetWaterSpline() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRiverDefinition">();
	}
	static class UProceduralRiverDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralRiverDefinition>();
	}
};
static_assert(alignof(UProceduralRiverDefinition) == 0x000008, "Wrong alignment on UProceduralRiverDefinition");
static_assert(sizeof(UProceduralRiverDefinition) == 0x000048, "Wrong size on UProceduralRiverDefinition");
static_assert(offsetof(UProceduralRiverDefinition, GenRulesAsset) == 0x000030, "Member 'UProceduralRiverDefinition::GenRulesAsset' has a wrong offset!");
static_assert(offsetof(UProceduralRiverDefinition, RiverTier) == 0x000038, "Member 'UProceduralRiverDefinition::RiverTier' has a wrong offset!");
static_assert(offsetof(UProceduralRiverDefinition, WaterBody) == 0x000040, "Member 'UProceduralRiverDefinition::WaterBody' has a wrong offset!");

// Class JunoProceduralWorld.ProceduralRivers
// 0x0778 (0x0AD0 - 0x0358)
class AProceduralRivers final : public ALandmassProceduralRoute
{
public:
	TSubclassOf<class AWaterBody>                 WaterClass;                                        // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProceduralRiverGenRulesAsset*          GenRulesAsset;                                     // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FProceduralRiverAnchor>         AnchorsInput;                                      // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UProceduralRiverDefinition*>     OutRivers;                                         // 0x0378(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UProceduralRiverDefinition*             CurrentRoute;                                      // 0x0388(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebug;                                      // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x73F];                                    // 0x0391(0x073F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetAudioIntensityAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline);
	static float GetDepthAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline);
	static float GetHalfWidthAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline);
	static const class FName GetProceduralRiverActorTag();
	static float GetVelocityScalarAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline);

	float GetRiverMergeSearchNeighborGridSize();
	void HaltRiverGeneration();
	bool InitializeNeighborGrid();
	void RebuildLastRiver();
	void SetRiverTier(ELandmassRiverTier InRiverTier);
	void StartRiverGeneration();
	struct FVector SurfaceLocationOverride(const struct FVector& InLocation, bool* bOutIsOverriden);
	void VisualizeAnchors();

	TArray<struct FProceduralRiverAnchor> GetAvailableSourceAnchors() const;
	TArray<struct FProceduralRiverAnchor> GetAvailableTargetAnchors() const;
	bool GetGenerationRules(const ELandmassRiverTier InRiverTier, struct FProceduralRiverGenRules* OutRules) const;
	TArray<class UProceduralRiverDefinition*> GetRiverDefinitions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRivers">();
	}
	static class AProceduralRivers* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralRivers>();
	}
};
static_assert(alignof(AProceduralRivers) == 0x000008, "Wrong alignment on AProceduralRivers");
static_assert(sizeof(AProceduralRivers) == 0x000AD0, "Wrong size on AProceduralRivers");
static_assert(offsetof(AProceduralRivers, WaterClass) == 0x000358, "Member 'AProceduralRivers::WaterClass' has a wrong offset!");
static_assert(offsetof(AProceduralRivers, GenRulesAsset) == 0x000360, "Member 'AProceduralRivers::GenRulesAsset' has a wrong offset!");
static_assert(offsetof(AProceduralRivers, AnchorsInput) == 0x000368, "Member 'AProceduralRivers::AnchorsInput' has a wrong offset!");
static_assert(offsetof(AProceduralRivers, OutRivers) == 0x000378, "Member 'AProceduralRivers::OutRivers' has a wrong offset!");
static_assert(offsetof(AProceduralRivers, CurrentRoute) == 0x000388, "Member 'AProceduralRivers::CurrentRoute' has a wrong offset!");
static_assert(offsetof(AProceduralRivers, bEnableDebug) == 0x000390, "Member 'AProceduralRivers::bEnableDebug' has a wrong offset!");

// Class JunoProceduralWorld.ProceduralRoadDefinition
// 0x00A0 (0x00D0 - 0x0030)
class UProceduralRoadDefinition final : public UProceduralRouteDefinition
{
public:
	class ULandmassProceduralRoadGenRules*        GenRulesAsset;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELandmassRoadTier                             RoadTier;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInterpSegment>                 OutInterpSegments;                                 // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LUTGridSize;                                       // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 LUT;                                               // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LUTResolution;                                     // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRoadDefinition">();
	}
	static class UProceduralRoadDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralRoadDefinition>();
	}
};
static_assert(alignof(UProceduralRoadDefinition) == 0x000010, "Wrong alignment on UProceduralRoadDefinition");
static_assert(sizeof(UProceduralRoadDefinition) == 0x0000D0, "Wrong size on UProceduralRoadDefinition");
static_assert(offsetof(UProceduralRoadDefinition, GenRulesAsset) == 0x000030, "Member 'UProceduralRoadDefinition::GenRulesAsset' has a wrong offset!");
static_assert(offsetof(UProceduralRoadDefinition, RoadTier) == 0x000038, "Member 'UProceduralRoadDefinition::RoadTier' has a wrong offset!");
static_assert(offsetof(UProceduralRoadDefinition, Transform) == 0x000040, "Member 'UProceduralRoadDefinition::Transform' has a wrong offset!");
static_assert(offsetof(UProceduralRoadDefinition, OutInterpSegments) == 0x0000A0, "Member 'UProceduralRoadDefinition::OutInterpSegments' has a wrong offset!");
static_assert(offsetof(UProceduralRoadDefinition, Length) == 0x0000B0, "Member 'UProceduralRoadDefinition::Length' has a wrong offset!");
static_assert(offsetof(UProceduralRoadDefinition, LUTGridSize) == 0x0000B4, "Member 'UProceduralRoadDefinition::LUTGridSize' has a wrong offset!");
static_assert(offsetof(UProceduralRoadDefinition, LUT) == 0x0000B8, "Member 'UProceduralRoadDefinition::LUT' has a wrong offset!");
static_assert(offsetof(UProceduralRoadDefinition, LUTResolution) == 0x0000C8, "Member 'UProceduralRoadDefinition::LUTResolution' has a wrong offset!");

// Class JunoProceduralWorld.ProceduralRoads
// 0x0348 (0x06A0 - 0x0358)
class AProceduralRoads final : public ALandmassProceduralRoute
{
public:
	bool                                          bDoesAffectLandscape;                              // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULandscapeSplinesComponent*             SplinesComponent;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SplineLayerIndex;                                  // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULandmassProceduralRoadGenRules*        GenRulesAsset;                                     // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UProceduralRoadDefinition*>      OutRoads;                                          // 0x0378(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UProceduralRoadDefinition*              CurrentRoute;                                      // 0x0388(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x60];                                     // 0x0390(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULandscapeSplineControlPoint*>   SelectedSplineControlPoints;                       // 0x03F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x278];                                    // 0x0400(0x0278)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULandscapeSplineControlPoint*>   ControlPoints;                                     // 0x0678(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULandscapeSplineSegment*>        Segments;                                          // 0x0688(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSegmentInterpResult EvaluateRouteAtLength(const class UProceduralRoadDefinition* InRoute, float InLength, bool bTransformToWorld);
	static class FName GetProceduralRoadActorTag();
	static class FName GetProceduralRoadLoopAnchorTag(int32 LoopIndex);

	void DisableOverrideGenRules();
	void EnableOverrideGenRules(const struct FProceduralRoadGenRules& InOverrideGenRules);
	TArray<class ULandscapeSplineControlPoint*> GetAllControlPoints();
	bool InitializeNeighborGrid();
	TArray<struct FVector> K2_GetRoadGridDataAtLocation(const struct FVector& InLocation);
	void RemoveHardTurnControlPoint();
	void SetRoadTier(ELandmassRoadTier InRoadTier);
	void UpdateLandscapeSplines();

	bool GetGenerationRules(const ELandmassRoadTier InRoadTier, struct FProceduralRoadGenRules* OutRules) const;
	TArray<class UProceduralRoadDefinition*> GetRoadDefinitions() const;
	float GetRoadMergeSearchNeighborGridSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRoads">();
	}
	static class AProceduralRoads* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralRoads>();
	}
};
static_assert(alignof(AProceduralRoads) == 0x000008, "Wrong alignment on AProceduralRoads");
static_assert(sizeof(AProceduralRoads) == 0x0006A0, "Wrong size on AProceduralRoads");
static_assert(offsetof(AProceduralRoads, bDoesAffectLandscape) == 0x000358, "Member 'AProceduralRoads::bDoesAffectLandscape' has a wrong offset!");
static_assert(offsetof(AProceduralRoads, SplinesComponent) == 0x000360, "Member 'AProceduralRoads::SplinesComponent' has a wrong offset!");
static_assert(offsetof(AProceduralRoads, SplineLayerIndex) == 0x000368, "Member 'AProceduralRoads::SplineLayerIndex' has a wrong offset!");
static_assert(offsetof(AProceduralRoads, GenRulesAsset) == 0x000370, "Member 'AProceduralRoads::GenRulesAsset' has a wrong offset!");
static_assert(offsetof(AProceduralRoads, OutRoads) == 0x000378, "Member 'AProceduralRoads::OutRoads' has a wrong offset!");
static_assert(offsetof(AProceduralRoads, CurrentRoute) == 0x000388, "Member 'AProceduralRoads::CurrentRoute' has a wrong offset!");
static_assert(offsetof(AProceduralRoads, SelectedSplineControlPoints) == 0x0003F0, "Member 'AProceduralRoads::SelectedSplineControlPoints' has a wrong offset!");
static_assert(offsetof(AProceduralRoads, ControlPoints) == 0x000678, "Member 'AProceduralRoads::ControlPoints' has a wrong offset!");
static_assert(offsetof(AProceduralRoads, Segments) == 0x000688, "Member 'AProceduralRoads::Segments' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoFractalNoise2DSettings
// 0x00B0 (0x0200 - 0x0150)
class UPCGJunoFractalNoise2DSettings final : public UPCGSettings
{
public:
	struct FVector2D                              TilingFactor;                                      // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Contrast;                                          // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Iterations;                                        // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGJunoFractalNoise2DMode                    Mode;                                              // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeName;                                     // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoronoiIDAttributeName;                            // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoronoiOrientSamplesToCellEdge;                   // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        VoronoiDistortion;                                 // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VoronoiDistortionTiling;                           // 0x0188(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TiledVoronoiResolution;                            // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGJunoFractalDensityMode                    DensityMode;                                       // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x01A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomizedOffset;                                  // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeBlendDistance;                                 // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeNoiseBrightness;                               // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeNoiseContrast;                                 // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeBlendCurve;                                    // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeBlendCurveOffset;                              // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeBlendNoise;                                    // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EdgeBlendFadeOut;                                  // 0x01D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              EdgeBlendNoiseTilingFactor;                        // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPCGJunoFractalNoise2DEdgeMode                EdgeNoiseMode;                                     // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EdgeNoiseIterations;                               // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EdgeBlendCellCount;                                // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoFractalNoise2DSettings">();
	}
	static class UPCGJunoFractalNoise2DSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoFractalNoise2DSettings>();
	}
};
static_assert(alignof(UPCGJunoFractalNoise2DSettings) == 0x000008, "Wrong alignment on UPCGJunoFractalNoise2DSettings");
static_assert(sizeof(UPCGJunoFractalNoise2DSettings) == 0x000200, "Wrong size on UPCGJunoFractalNoise2DSettings");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, TilingFactor) == 0x000150, "Member 'UPCGJunoFractalNoise2DSettings::TilingFactor' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, Brightness) == 0x000160, "Member 'UPCGJunoFractalNoise2DSettings::Brightness' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, Contrast) == 0x000164, "Member 'UPCGJunoFractalNoise2DSettings::Contrast' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, Iterations) == 0x000168, "Member 'UPCGJunoFractalNoise2DSettings::Iterations' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, Mode) == 0x00016C, "Member 'UPCGJunoFractalNoise2DSettings::Mode' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, AttributeName) == 0x000170, "Member 'UPCGJunoFractalNoise2DSettings::AttributeName' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, VoronoiIDAttributeName) == 0x000174, "Member 'UPCGJunoFractalNoise2DSettings::VoronoiIDAttributeName' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, bVoronoiOrientSamplesToCellEdge) == 0x000178, "Member 'UPCGJunoFractalNoise2DSettings::bVoronoiOrientSamplesToCellEdge' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, VoronoiDistortion) == 0x000180, "Member 'UPCGJunoFractalNoise2DSettings::VoronoiDistortion' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, VoronoiDistortionTiling) == 0x000188, "Member 'UPCGJunoFractalNoise2DSettings::VoronoiDistortionTiling' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, TiledVoronoiResolution) == 0x000198, "Member 'UPCGJunoFractalNoise2DSettings::TiledVoronoiResolution' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, DensityMode) == 0x00019C, "Member 'UPCGJunoFractalNoise2DSettings::DensityMode' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, Offset) == 0x0001A0, "Member 'UPCGJunoFractalNoise2DSettings::Offset' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, RandomizedOffset) == 0x0001B0, "Member 'UPCGJunoFractalNoise2DSettings::RandomizedOffset' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeBlendDistance) == 0x0001C0, "Member 'UPCGJunoFractalNoise2DSettings::EdgeBlendDistance' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeNoiseBrightness) == 0x0001C4, "Member 'UPCGJunoFractalNoise2DSettings::EdgeNoiseBrightness' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeNoiseContrast) == 0x0001C8, "Member 'UPCGJunoFractalNoise2DSettings::EdgeNoiseContrast' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeBlendCurve) == 0x0001CC, "Member 'UPCGJunoFractalNoise2DSettings::EdgeBlendCurve' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeBlendCurveOffset) == 0x0001D0, "Member 'UPCGJunoFractalNoise2DSettings::EdgeBlendCurveOffset' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeBlendNoise) == 0x0001D4, "Member 'UPCGJunoFractalNoise2DSettings::EdgeBlendNoise' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeBlendFadeOut) == 0x0001D8, "Member 'UPCGJunoFractalNoise2DSettings::EdgeBlendFadeOut' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeBlendNoiseTilingFactor) == 0x0001E0, "Member 'UPCGJunoFractalNoise2DSettings::EdgeBlendNoiseTilingFactor' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeNoiseMode) == 0x0001F0, "Member 'UPCGJunoFractalNoise2DSettings::EdgeNoiseMode' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeNoiseIterations) == 0x0001F4, "Member 'UPCGJunoFractalNoise2DSettings::EdgeNoiseIterations' has a wrong offset!");
static_assert(offsetof(UPCGJunoFractalNoise2DSettings, EdgeBlendCellCount) == 0x0001F8, "Member 'UPCGJunoFractalNoise2DSettings::EdgeBlendCellCount' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoReadProceduralSplinesSettings
// 0x0018 (0x0168 - 0x0150)
class UPCGJunoReadProceduralSplinesSettings final : public UPCGSettings
{
public:
	class FName                                   ProceduralRouteTag;                                // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OutputPins;                                        // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoReadProceduralSplinesSettings">();
	}
	static class UPCGJunoReadProceduralSplinesSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoReadProceduralSplinesSettings>();
	}
};
static_assert(alignof(UPCGJunoReadProceduralSplinesSettings) == 0x000008, "Wrong alignment on UPCGJunoReadProceduralSplinesSettings");
static_assert(sizeof(UPCGJunoReadProceduralSplinesSettings) == 0x000168, "Wrong size on UPCGJunoReadProceduralSplinesSettings");
static_assert(offsetof(UPCGJunoReadProceduralSplinesSettings, ProceduralRouteTag) == 0x000150, "Member 'UPCGJunoReadProceduralSplinesSettings::ProceduralRouteTag' has a wrong offset!");
static_assert(offsetof(UPCGJunoReadProceduralSplinesSettings, OutputPins) == 0x000158, "Member 'UPCGJunoReadProceduralSplinesSettings::OutputPins' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoReadLandscapeSplinesSettings
// 0x0020 (0x0170 - 0x0150)
class UPCGJunoReadLandscapeSplinesSettings final : public UPCGSettings
{
public:
	struct FVector                                ExtraSearchExtents;                                // 0x0150(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerformBoundsCheck;                               // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoReadLandscapeSplinesSettings">();
	}
	static class UPCGJunoReadLandscapeSplinesSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoReadLandscapeSplinesSettings>();
	}
};
static_assert(alignof(UPCGJunoReadLandscapeSplinesSettings) == 0x000008, "Wrong alignment on UPCGJunoReadLandscapeSplinesSettings");
static_assert(sizeof(UPCGJunoReadLandscapeSplinesSettings) == 0x000170, "Wrong size on UPCGJunoReadLandscapeSplinesSettings");
static_assert(offsetof(UPCGJunoReadLandscapeSplinesSettings, ExtraSearchExtents) == 0x000150, "Member 'UPCGJunoReadLandscapeSplinesSettings::ExtraSearchExtents' has a wrong offset!");
static_assert(offsetof(UPCGJunoReadLandscapeSplinesSettings, bPerformBoundsCheck) == 0x000168, "Member 'UPCGJunoReadLandscapeSplinesSettings::bPerformBoundsCheck' has a wrong offset!");

// Class JunoProceduralWorld.PCGJunoRoadAINavigationSettings
// 0x0068 (0x01B8 - 0x0150)
class UPCGJunoRoadAINavigationSettings final : public UPCGSettings
{
public:
	TSoftClassPtr<class UClass>                   RoadClusterClass;                                  // 0x0150(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PatrolPathClass;                                   // 0x0170(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PatrolPointClass;                                  // 0x0190(0x0020)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepLength;                                        // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDeviationTolerance;                            // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGJunoRoadAINavigationSettings">();
	}
	static class UPCGJunoRoadAINavigationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGJunoRoadAINavigationSettings>();
	}
};
static_assert(alignof(UPCGJunoRoadAINavigationSettings) == 0x000008, "Wrong alignment on UPCGJunoRoadAINavigationSettings");
static_assert(sizeof(UPCGJunoRoadAINavigationSettings) == 0x0001B8, "Wrong size on UPCGJunoRoadAINavigationSettings");
static_assert(offsetof(UPCGJunoRoadAINavigationSettings, RoadClusterClass) == 0x000150, "Member 'UPCGJunoRoadAINavigationSettings::RoadClusterClass' has a wrong offset!");
static_assert(offsetof(UPCGJunoRoadAINavigationSettings, PatrolPathClass) == 0x000170, "Member 'UPCGJunoRoadAINavigationSettings::PatrolPathClass' has a wrong offset!");
static_assert(offsetof(UPCGJunoRoadAINavigationSettings, PatrolPointClass) == 0x000190, "Member 'UPCGJunoRoadAINavigationSettings::PatrolPointClass' has a wrong offset!");
static_assert(offsetof(UPCGJunoRoadAINavigationSettings, StepLength) == 0x0001B0, "Member 'UPCGJunoRoadAINavigationSettings::StepLength' has a wrong offset!");
static_assert(offsetof(UPCGJunoRoadAINavigationSettings, LineDeviationTolerance) == 0x0001B4, "Member 'UPCGJunoRoadAINavigationSettings::LineDeviationTolerance' has a wrong offset!");

// Class JunoProceduralWorld.PCGResolveAudioBankSettings
// 0x0010 (0x0160 - 0x0150)
class UPCGResolveAudioBankSettings final : public UPCGSettings
{
public:
	class FName                                   AttributeNameForBiomeDataTable;                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedActorPath;                 // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedAudioBankPath;             // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGResolveAudioBankSettings">();
	}
	static class UPCGResolveAudioBankSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGResolveAudioBankSettings>();
	}
};
static_assert(alignof(UPCGResolveAudioBankSettings) == 0x000008, "Wrong alignment on UPCGResolveAudioBankSettings");
static_assert(sizeof(UPCGResolveAudioBankSettings) == 0x000160, "Wrong size on UPCGResolveAudioBankSettings");
static_assert(offsetof(UPCGResolveAudioBankSettings, AttributeNameForBiomeDataTable) == 0x000150, "Member 'UPCGResolveAudioBankSettings::AttributeNameForBiomeDataTable' has a wrong offset!");
static_assert(offsetof(UPCGResolveAudioBankSettings, AttributeNameForResolvedActorPath) == 0x000154, "Member 'UPCGResolveAudioBankSettings::AttributeNameForResolvedActorPath' has a wrong offset!");
static_assert(offsetof(UPCGResolveAudioBankSettings, AttributeNameForResolvedAudioBankPath) == 0x000158, "Member 'UPCGResolveAudioBankSettings::AttributeNameForResolvedAudioBankPath' has a wrong offset!");

// Class JunoProceduralWorld.PCGResolveBiomeIngredientsSettings
// 0x0020 (0x0170 - 0x0150)
class UPCGResolveBiomeIngredientsSettings final : public UPCGSettings
{
public:
	class FName                                   AttributeNameForBiomeTypeFilter;                   // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForBiomeDataTable;                    // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForBiomeLayer;                        // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedActorPath;                 // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForRepresentation;                    // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedRowName;                   // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBlendToVertical;                             // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyRandomLeanAmount;                            // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGResolveBiomeIngredientsSettings">();
	}
	static class UPCGResolveBiomeIngredientsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGResolveBiomeIngredientsSettings>();
	}
};
static_assert(alignof(UPCGResolveBiomeIngredientsSettings) == 0x000008, "Wrong alignment on UPCGResolveBiomeIngredientsSettings");
static_assert(sizeof(UPCGResolveBiomeIngredientsSettings) == 0x000170, "Wrong size on UPCGResolveBiomeIngredientsSettings");
static_assert(offsetof(UPCGResolveBiomeIngredientsSettings, AttributeNameForBiomeTypeFilter) == 0x000150, "Member 'UPCGResolveBiomeIngredientsSettings::AttributeNameForBiomeTypeFilter' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeIngredientsSettings, AttributeNameForBiomeDataTable) == 0x000154, "Member 'UPCGResolveBiomeIngredientsSettings::AttributeNameForBiomeDataTable' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeIngredientsSettings, AttributeNameForBiomeLayer) == 0x000158, "Member 'UPCGResolveBiomeIngredientsSettings::AttributeNameForBiomeLayer' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeIngredientsSettings, AttributeNameForResolvedActorPath) == 0x00015C, "Member 'UPCGResolveBiomeIngredientsSettings::AttributeNameForResolvedActorPath' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeIngredientsSettings, AttributeNameForRepresentation) == 0x000160, "Member 'UPCGResolveBiomeIngredientsSettings::AttributeNameForRepresentation' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeIngredientsSettings, AttributeNameForResolvedRowName) == 0x000164, "Member 'UPCGResolveBiomeIngredientsSettings::AttributeNameForResolvedRowName' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeIngredientsSettings, bApplyBlendToVertical) == 0x000168, "Member 'UPCGResolveBiomeIngredientsSettings::bApplyBlendToVertical' has a wrong offset!");
static_assert(offsetof(UPCGResolveBiomeIngredientsSettings, bApplyRandomLeanAmount) == 0x000169, "Member 'UPCGResolveBiomeIngredientsSettings::bApplyRandomLeanAmount' has a wrong offset!");

// Class JunoProceduralWorld.PCGResolvePOISlotsSettings
// 0x0018 (0x0168 - 0x0150)
class UPCGResolvePOISlotsSettings final : public UPCGSettings
{
public:
	class FName                                   AttributeNameForBiomeDataTable;                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForPotentialPIOsDataTable;            // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedActorPath;                 // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedPOIPath;                   // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedSlotSize;                  // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedTerrainHeightPatch;        // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGResolvePOISlotsSettings">();
	}
	static class UPCGResolvePOISlotsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGResolvePOISlotsSettings>();
	}
};
static_assert(alignof(UPCGResolvePOISlotsSettings) == 0x000008, "Wrong alignment on UPCGResolvePOISlotsSettings");
static_assert(sizeof(UPCGResolvePOISlotsSettings) == 0x000168, "Wrong size on UPCGResolvePOISlotsSettings");
static_assert(offsetof(UPCGResolvePOISlotsSettings, AttributeNameForBiomeDataTable) == 0x000150, "Member 'UPCGResolvePOISlotsSettings::AttributeNameForBiomeDataTable' has a wrong offset!");
static_assert(offsetof(UPCGResolvePOISlotsSettings, AttributeNameForPotentialPIOsDataTable) == 0x000154, "Member 'UPCGResolvePOISlotsSettings::AttributeNameForPotentialPIOsDataTable' has a wrong offset!");
static_assert(offsetof(UPCGResolvePOISlotsSettings, AttributeNameForResolvedActorPath) == 0x000158, "Member 'UPCGResolvePOISlotsSettings::AttributeNameForResolvedActorPath' has a wrong offset!");
static_assert(offsetof(UPCGResolvePOISlotsSettings, AttributeNameForResolvedPOIPath) == 0x00015C, "Member 'UPCGResolvePOISlotsSettings::AttributeNameForResolvedPOIPath' has a wrong offset!");
static_assert(offsetof(UPCGResolvePOISlotsSettings, AttributeNameForResolvedSlotSize) == 0x000160, "Member 'UPCGResolvePOISlotsSettings::AttributeNameForResolvedSlotSize' has a wrong offset!");
static_assert(offsetof(UPCGResolvePOISlotsSettings, AttributeNameForResolvedTerrainHeightPatch) == 0x000164, "Member 'UPCGResolvePOISlotsSettings::AttributeNameForResolvedTerrainHeightPatch' has a wrong offset!");

// Class JunoProceduralWorld.PCGSetFoundationLevelSettings
// 0x0008 (0x0158 - 0x0150)
class UPCGSetFoundationLevelSettings final : public UPCGSettings
{
public:
	class FName                                   AttributeNameForResolvedPOIPath;                   // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForSpawnedActorPtr;                   // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGSetFoundationLevelSettings">();
	}
	static class UPCGSetFoundationLevelSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGSetFoundationLevelSettings>();
	}
};
static_assert(alignof(UPCGSetFoundationLevelSettings) == 0x000008, "Wrong alignment on UPCGSetFoundationLevelSettings");
static_assert(sizeof(UPCGSetFoundationLevelSettings) == 0x000158, "Wrong size on UPCGSetFoundationLevelSettings");
static_assert(offsetof(UPCGSetFoundationLevelSettings, AttributeNameForResolvedPOIPath) == 0x000150, "Member 'UPCGSetFoundationLevelSettings::AttributeNameForResolvedPOIPath' has a wrong offset!");
static_assert(offsetof(UPCGSetFoundationLevelSettings, AttributeNameForSpawnedActorPtr) == 0x000154, "Member 'UPCGSetFoundationLevelSettings::AttributeNameForSpawnedActorPtr' has a wrong offset!");

// Class JunoProceduralWorld.PCGSetPOISlotPropertiesSettings
// 0x0018 (0x0168 - 0x0150)
class UPCGSetPOISlotPropertiesSettings final : public UPCGSettings
{
public:
	class FName                                   AttributeNameForSpawnedActorPtr;                   // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForPotentialPIOsDataTable;            // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedPOIPath;                   // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedSlotSize;                  // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForResolvedTerrainHeightPatch;        // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGSetPOISlotPropertiesSettings">();
	}
	static class UPCGSetPOISlotPropertiesSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGSetPOISlotPropertiesSettings>();
	}
};
static_assert(alignof(UPCGSetPOISlotPropertiesSettings) == 0x000008, "Wrong alignment on UPCGSetPOISlotPropertiesSettings");
static_assert(sizeof(UPCGSetPOISlotPropertiesSettings) == 0x000168, "Wrong size on UPCGSetPOISlotPropertiesSettings");
static_assert(offsetof(UPCGSetPOISlotPropertiesSettings, AttributeNameForSpawnedActorPtr) == 0x000150, "Member 'UPCGSetPOISlotPropertiesSettings::AttributeNameForSpawnedActorPtr' has a wrong offset!");
static_assert(offsetof(UPCGSetPOISlotPropertiesSettings, AttributeNameForPotentialPIOsDataTable) == 0x000154, "Member 'UPCGSetPOISlotPropertiesSettings::AttributeNameForPotentialPIOsDataTable' has a wrong offset!");
static_assert(offsetof(UPCGSetPOISlotPropertiesSettings, AttributeNameForResolvedPOIPath) == 0x000158, "Member 'UPCGSetPOISlotPropertiesSettings::AttributeNameForResolvedPOIPath' has a wrong offset!");
static_assert(offsetof(UPCGSetPOISlotPropertiesSettings, AttributeNameForResolvedSlotSize) == 0x00015C, "Member 'UPCGSetPOISlotPropertiesSettings::AttributeNameForResolvedSlotSize' has a wrong offset!");
static_assert(offsetof(UPCGSetPOISlotPropertiesSettings, AttributeNameForResolvedTerrainHeightPatch) == 0x000160, "Member 'UPCGSetPOISlotPropertiesSettings::AttributeNameForResolvedTerrainHeightPatch' has a wrong offset!");

// Class JunoProceduralWorld.PCGSpawnActorForPathSettings
// 0x0048 (0x0198 - 0x0150)
class UPCGSpawnActorForPathSettings final : public UPCGSettings
{
public:
	bool                                          bUseLightWeightInstances;                          // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  InstanceTags;                                      // 0x0158(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           TagsToAddOnActors;                                 // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAddSpawnedActorAttribute;                         // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttributeNameForSpawnedActorPtr;                   // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PathAttributeName;                                 // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeNameForRepresentation;                    // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGSpawnActorForPathSettings">();
	}
	static class UPCGSpawnActorForPathSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGSpawnActorForPathSettings>();
	}
};
static_assert(alignof(UPCGSpawnActorForPathSettings) == 0x000008, "Wrong alignment on UPCGSpawnActorForPathSettings");
static_assert(sizeof(UPCGSpawnActorForPathSettings) == 0x000198, "Wrong size on UPCGSpawnActorForPathSettings");
static_assert(offsetof(UPCGSpawnActorForPathSettings, bUseLightWeightInstances) == 0x000150, "Member 'UPCGSpawnActorForPathSettings::bUseLightWeightInstances' has a wrong offset!");
static_assert(offsetof(UPCGSpawnActorForPathSettings, InstanceTags) == 0x000158, "Member 'UPCGSpawnActorForPathSettings::InstanceTags' has a wrong offset!");
static_assert(offsetof(UPCGSpawnActorForPathSettings, TagsToAddOnActors) == 0x000178, "Member 'UPCGSpawnActorForPathSettings::TagsToAddOnActors' has a wrong offset!");
static_assert(offsetof(UPCGSpawnActorForPathSettings, bAddSpawnedActorAttribute) == 0x000188, "Member 'UPCGSpawnActorForPathSettings::bAddSpawnedActorAttribute' has a wrong offset!");
static_assert(offsetof(UPCGSpawnActorForPathSettings, AttributeNameForSpawnedActorPtr) == 0x00018C, "Member 'UPCGSpawnActorForPathSettings::AttributeNameForSpawnedActorPtr' has a wrong offset!");
static_assert(offsetof(UPCGSpawnActorForPathSettings, PathAttributeName) == 0x000190, "Member 'UPCGSpawnActorForPathSettings::PathAttributeName' has a wrong offset!");
static_assert(offsetof(UPCGSpawnActorForPathSettings, AttributeNameForRepresentation) == 0x000194, "Member 'UPCGSpawnActorForPathSettings::AttributeNameForRepresentation' has a wrong offset!");

// Class JunoProceduralWorld.PCGManageLightweightInstances
// 0x0050 (0x00D8 - 0x0088)
class UPCGManageLightweightInstances final : public UPCGManagedActors
{
public:
	TSet<struct FActorInstanceHandle>             GeneratedLWIs;                                     // 0x0088(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGManageLightweightInstances">();
	}
	static class UPCGManageLightweightInstances* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGManageLightweightInstances>();
	}
};
static_assert(alignof(UPCGManageLightweightInstances) == 0x000008, "Wrong alignment on UPCGManageLightweightInstances");
static_assert(sizeof(UPCGManageLightweightInstances) == 0x0000D8, "Wrong size on UPCGManageLightweightInstances");
static_assert(offsetof(UPCGManageLightweightInstances, GeneratedLWIs) == 0x000088, "Member 'UPCGManageLightweightInstances::GeneratedLWIs' has a wrong offset!");

// Class JunoProceduralWorld.PCGManagedActorInstances
// 0x0050 (0x00D8 - 0x0088)
class UPCGManagedActorInstances final : public UPCGManagedActors
{
public:
	TSet<struct FJunoActorInstanceHandle>         GeneratedInstances;                                // 0x0088(0x0050)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGManagedActorInstances">();
	}
	static class UPCGManagedActorInstances* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGManagedActorInstances>();
	}
};
static_assert(alignof(UPCGManagedActorInstances) == 0x000008, "Wrong alignment on UPCGManagedActorInstances");
static_assert(sizeof(UPCGManagedActorInstances) == 0x0000D8, "Wrong size on UPCGManagedActorInstances");
static_assert(offsetof(UPCGManagedActorInstances, GeneratedInstances) == 0x000088, "Member 'UPCGManagedActorInstances::GeneratedInstances' has a wrong offset!");

// Class JunoProceduralWorld.PCGSpawnJunoBiomeSettings
// 0x0038 (0x0188 - 0x0150)
class UPCGSpawnJunoBiomeSettings final : public UPCGSettings
{
public:
	struct FPCGJunoBiomeEntry                     DefaultBiome;                                      // 0x0150(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FPCGJunoBiomeEntry>             Biomes;                                            // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCGSpawnJunoBiomeSettings">();
	}
	static class UPCGSpawnJunoBiomeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCGSpawnJunoBiomeSettings>();
	}
};
static_assert(alignof(UPCGSpawnJunoBiomeSettings) == 0x000008, "Wrong alignment on UPCGSpawnJunoBiomeSettings");
static_assert(sizeof(UPCGSpawnJunoBiomeSettings) == 0x000188, "Wrong size on UPCGSpawnJunoBiomeSettings");
static_assert(offsetof(UPCGSpawnJunoBiomeSettings, DefaultBiome) == 0x000150, "Member 'UPCGSpawnJunoBiomeSettings::DefaultBiome' has a wrong offset!");
static_assert(offsetof(UPCGSpawnJunoBiomeSettings, Biomes) == 0x000178, "Member 'UPCGSpawnJunoBiomeSettings::Biomes' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldTilePersistenceFeatureData
// 0x0118 (0x0158 - 0x0040)
class UJunoWorldTilePersistenceFeatureData final : public UJunoBasePFWPersistenceFeatureData
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FJunoCave>          Caves;                                             // 0x0050(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class AJunoPOIGameplayVolume*> POIs;                                              // 0x00A0(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FJunoWorldTileSaveData                 SaveData;                                          // 0x00F0(0x0068)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldTilePersistenceFeatureData">();
	}
	static class UJunoWorldTilePersistenceFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldTilePersistenceFeatureData>();
	}
};
static_assert(alignof(UJunoWorldTilePersistenceFeatureData) == 0x000008, "Wrong alignment on UJunoWorldTilePersistenceFeatureData");
static_assert(sizeof(UJunoWorldTilePersistenceFeatureData) == 0x000158, "Wrong size on UJunoWorldTilePersistenceFeatureData");
static_assert(offsetof(UJunoWorldTilePersistenceFeatureData, Caves) == 0x000050, "Member 'UJunoWorldTilePersistenceFeatureData::Caves' has a wrong offset!");
static_assert(offsetof(UJunoWorldTilePersistenceFeatureData, POIs) == 0x0000A0, "Member 'UJunoWorldTilePersistenceFeatureData::POIs' has a wrong offset!");
static_assert(offsetof(UJunoWorldTilePersistenceFeatureData, SaveData) == 0x0000F0, "Member 'UJunoWorldTilePersistenceFeatureData::SaveData' has a wrong offset!");

// Class JunoProceduralWorld.JunoLivingWorldLightStaticPointProvider
// 0x0040 (0x01A0 - 0x0160)
class UJunoLivingWorldLightStaticPointProvider final : public UFortAthenaLivingWorldLightStaticPointProvider
{
public:
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoLivingWorldPointProviderEventLimiter EventLimiter;                                      // 0x0168(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  SavedActorGuid;                                    // 0x0188(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AppendFiltersTags(const struct FGameplayTagContainer& Container);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoLivingWorldLightStaticPointProvider">();
	}
	static class UJunoLivingWorldLightStaticPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoLivingWorldLightStaticPointProvider>();
	}
};
static_assert(alignof(UJunoLivingWorldLightStaticPointProvider) == 0x000010, "Wrong alignment on UJunoLivingWorldLightStaticPointProvider");
static_assert(sizeof(UJunoLivingWorldLightStaticPointProvider) == 0x0001A0, "Wrong size on UJunoLivingWorldLightStaticPointProvider");
static_assert(offsetof(UJunoLivingWorldLightStaticPointProvider, EventLimiter) == 0x000168, "Member 'UJunoLivingWorldLightStaticPointProvider::EventLimiter' has a wrong offset!");
static_assert(offsetof(UJunoLivingWorldLightStaticPointProvider, SavedActorGuid) == 0x000188, "Member 'UJunoLivingWorldLightStaticPointProvider::SavedActorGuid' has a wrong offset!");

// Class JunoProceduralWorld.JunoWorldRegistryActorComponent
// 0x0048 (0x00E8 - 0x00A0)
class UJunoWorldRegistryActorComponent final : public UGameFrameworkComponent
{
public:
	struct FGameplayTagContainer                  WorldRegistryEntryTags;                            // 0x00A0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	EJunoWorldRegistryType                        WorldRegistryType;                                 // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  VisitedTags;                                       // 0x00C8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldRegistryActorComponent">();
	}
	static class UJunoWorldRegistryActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldRegistryActorComponent>();
	}
};
static_assert(alignof(UJunoWorldRegistryActorComponent) == 0x000008, "Wrong alignment on UJunoWorldRegistryActorComponent");
static_assert(sizeof(UJunoWorldRegistryActorComponent) == 0x0000E8, "Wrong size on UJunoWorldRegistryActorComponent");
static_assert(offsetof(UJunoWorldRegistryActorComponent, WorldRegistryEntryTags) == 0x0000A0, "Member 'UJunoWorldRegistryActorComponent::WorldRegistryEntryTags' has a wrong offset!");
static_assert(offsetof(UJunoWorldRegistryActorComponent, WorldRegistryType) == 0x0000C0, "Member 'UJunoWorldRegistryActorComponent::WorldRegistryType' has a wrong offset!");
static_assert(offsetof(UJunoWorldRegistryActorComponent, VisitedTags) == 0x0000C8, "Member 'UJunoWorldRegistryActorComponent::VisitedTags' has a wrong offset!");

}

