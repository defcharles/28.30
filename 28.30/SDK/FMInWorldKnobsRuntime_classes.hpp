#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FMInWorldKnobsRuntime

#include "Basic.hpp"

#include "FortniteGame_classes.hpp"
#include "FMDeviceCablesRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "FMInWorldKnobsRuntime_structs.hpp"
#include "FabricRuntime_structs.hpp"
#include "FabricRuntime_classes.hpp"


namespace SDK
{

// Class FMInWorldKnobsRuntime.FabricChildActorTickSubsystem
// 0x0018 (0x00E8 - 0x00D0)
class UFabricChildActorTickSubsystem final : public UFortManagedTickSubsystem
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UFabricChildActorComponent>> ChildActorComponentsPendingSpawn;                  // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FabricChildActorTickSubsystem">();
	}
	static class UFabricChildActorTickSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFabricChildActorTickSubsystem>();
	}
};
static_assert(alignof(UFabricChildActorTickSubsystem) == 0x000008, "Wrong alignment on UFabricChildActorTickSubsystem");
static_assert(sizeof(UFabricChildActorTickSubsystem) == 0x0000E8, "Wrong size on UFabricChildActorTickSubsystem");
static_assert(offsetof(UFabricChildActorTickSubsystem, ChildActorComponentsPendingSpawn) == 0x0000D8, "Member 'UFabricChildActorTickSubsystem::ChildActorComponentsPendingSpawn' has a wrong offset!");

// Class FMInWorldKnobsRuntime.FabricChildActorComponent
// 0x0080 (0x02F0 - 0x0270)
class UFabricChildActorComponent : public UChildActorComponent
{
public:
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMDeviceCableModulatorPortComponent*   InWorldKnobModulatorPort;                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseScreenGrid;                                    // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScreenGridPosition;                                // 0x0290(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FModulatorPortSaveData                 ModulatorPortSaveData;                             // 0x02A0(0x0020)(Edit, DisableEditOnTemplate, SaveGame, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x20];                                     // 0x02C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     CableManagerClassForModulatorPorts;                // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFMDeviceCableModulatorPortComponent* CreateModulatorPortIfNeeded();
	void OnModulatorPortConnected(class UFMDeviceCablePortComponent* ConnectedPort);
	void OnModulatorPortDisconnected(class UFMDeviceCablePortComponent* DisconnectedPort);

	class AFabricButtonBase* GetChildActorAsFabricButton() const;
	TScriptInterface<class IFabricInteractable> GetChildActorAsFabricInteractable() const;
	class AFMInWorldKnobActorBase* GetChildActorAsInWorldKnobActorBase() const;
	class FString GetKnobOptionKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FabricChildActorComponent">();
	}
	static class UFabricChildActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFabricChildActorComponent>();
	}
};
static_assert(alignof(UFabricChildActorComponent) == 0x000010, "Wrong alignment on UFabricChildActorComponent");
static_assert(sizeof(UFabricChildActorComponent) == 0x0002F0, "Wrong size on UFabricChildActorComponent");
static_assert(offsetof(UFabricChildActorComponent, InWorldKnobModulatorPort) == 0x000280, "Member 'UFabricChildActorComponent::InWorldKnobModulatorPort' has a wrong offset!");
static_assert(offsetof(UFabricChildActorComponent, bUseScreenGrid) == 0x000288, "Member 'UFabricChildActorComponent::bUseScreenGrid' has a wrong offset!");
static_assert(offsetof(UFabricChildActorComponent, ScreenGridPosition) == 0x000290, "Member 'UFabricChildActorComponent::ScreenGridPosition' has a wrong offset!");
static_assert(offsetof(UFabricChildActorComponent, ModulatorPortSaveData) == 0x0002A0, "Member 'UFabricChildActorComponent::ModulatorPortSaveData' has a wrong offset!");
static_assert(offsetof(UFabricChildActorComponent, CableManagerClassForModulatorPorts) == 0x0002E0, "Member 'UFabricChildActorComponent::CableManagerClassForModulatorPorts' has a wrong offset!");

// Class FMInWorldKnobsRuntime.FabricScreenComponent
// 0x00A0 (0x02C0 - 0x0220)
class UFabricScreenComponent final : public USceneComponent
{
public:
	TMulticastInlineDelegate<void()>              OnWidgetCreated;                                   // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFabricWidget* FabricWidget)> OnWidgetAdded;                                     // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UFabricScreenWidget>     ScreenWidget;                                      // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       ScreenWidgetComponent;                             // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UFMInWorldKnobActorCopyComponent*, struct FScreenWidgetLayoutInfo> CopyComponentsToWidget;                            // 0x0268(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class UWidgetComponent* InScreenWidgetComponent, int32 InWidth, int32 InHeight, class UFabricScreenLayoutDataAsset* ScreenLayout);
	void OnCopiedKnobActorSet(class UFMInWorldKnobActorCopyComponent* CopyComponent, class AFMInWorldKnobActorBase* NewKnobActor);
	void SetScreenSize(int32 InWidth, int32 InHeight);

	struct FVector ConvertGridPositionToUnrealLocation(const struct FVector2D& GridPosition) const;
	struct FVector2D ConvertUnrealLocationToGridPosition(const struct FVector& UnrealPosition) const;
	int32 GetScreenGridHeight() const;
	int32 GetScreenGridWidth() const;
	struct FVector SnapUnrealLocationToScreenGrid(const struct FVector& UnrealPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FabricScreenComponent">();
	}
	static class UFabricScreenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFabricScreenComponent>();
	}
};
static_assert(alignof(UFabricScreenComponent) == 0x000010, "Wrong alignment on UFabricScreenComponent");
static_assert(sizeof(UFabricScreenComponent) == 0x0002C0, "Wrong size on UFabricScreenComponent");
static_assert(offsetof(UFabricScreenComponent, OnWidgetCreated) == 0x000220, "Member 'UFabricScreenComponent::OnWidgetCreated' has a wrong offset!");
static_assert(offsetof(UFabricScreenComponent, OnWidgetAdded) == 0x000230, "Member 'UFabricScreenComponent::OnWidgetAdded' has a wrong offset!");
static_assert(offsetof(UFabricScreenComponent, ScreenWidget) == 0x000258, "Member 'UFabricScreenComponent::ScreenWidget' has a wrong offset!");
static_assert(offsetof(UFabricScreenComponent, ScreenWidgetComponent) == 0x000260, "Member 'UFabricScreenComponent::ScreenWidgetComponent' has a wrong offset!");
static_assert(offsetof(UFabricScreenComponent, CopyComponentsToWidget) == 0x000268, "Member 'UFabricScreenComponent::CopyComponentsToWidget' has a wrong offset!");

// Class FMInWorldKnobsRuntime.FabricScreenLayoutDataAsset
// 0x0018 (0x0048 - 0x0030)
class UFabricScreenLayoutDataAsset final : public UDataAsset
{
public:
	TArray<struct FFabricScreenLayout>            Layout;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UFabricScreenWidget>        FabricScreenWidgetClass;                           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FabricScreenLayoutDataAsset">();
	}
	static class UFabricScreenLayoutDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFabricScreenLayoutDataAsset>();
	}
};
static_assert(alignof(UFabricScreenLayoutDataAsset) == 0x000008, "Wrong alignment on UFabricScreenLayoutDataAsset");
static_assert(sizeof(UFabricScreenLayoutDataAsset) == 0x000048, "Wrong size on UFabricScreenLayoutDataAsset");
static_assert(offsetof(UFabricScreenLayoutDataAsset, Layout) == 0x000030, "Member 'UFabricScreenLayoutDataAsset::Layout' has a wrong offset!");
static_assert(offsetof(UFabricScreenLayoutDataAsset, FabricScreenWidgetClass) == 0x000040, "Member 'UFabricScreenLayoutDataAsset::FabricScreenWidgetClass' has a wrong offset!");

// Class FMInWorldKnobsRuntime.FabricUserOptionPresetAsset
// 0x0010 (0x0040 - 0x0030)
class UFabricUserOptionPresetAsset final : public UDataAsset
{
public:
	struct FFabricUserOptionPresetCollection      UserOptionPreset;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FabricUserOptionPresetAsset">();
	}
	static class UFabricUserOptionPresetAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFabricUserOptionPresetAsset>();
	}
};
static_assert(alignof(UFabricUserOptionPresetAsset) == 0x000008, "Wrong alignment on UFabricUserOptionPresetAsset");
static_assert(sizeof(UFabricUserOptionPresetAsset) == 0x000040, "Wrong size on UFabricUserOptionPresetAsset");
static_assert(offsetof(UFabricUserOptionPresetAsset, UserOptionPreset) == 0x000030, "Member 'UFabricUserOptionPresetAsset::UserOptionPreset' has a wrong offset!");

// Class FMInWorldKnobsRuntime.FabricUserOptionSaveModulatable
// 0x0030 (0x0358 - 0x0328)
class UFabricUserOptionSaveModulatable final : public UFabricModulatable
{
public:
	uint8                                         Pad_328[0x30];                                     // 0x0328(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FabricUserOptionSaveModulatable">();
	}
	static class UFabricUserOptionSaveModulatable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFabricUserOptionSaveModulatable>();
	}
};
static_assert(alignof(UFabricUserOptionSaveModulatable) == 0x000008, "Wrong alignment on UFabricUserOptionSaveModulatable");
static_assert(sizeof(UFabricUserOptionSaveModulatable) == 0x000358, "Wrong size on UFabricUserOptionSaveModulatable");

// Class FMInWorldKnobsRuntime.FabricUserOptionSaveComponent
// 0x0168 (0x0208 - 0x00A0)
class UFabricUserOptionSaveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         UserOptionsToSave;                                 // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxSaveSlots;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SaveIndexParam;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFabricUserOptionPresetAsset*>   PresetAssets;                                      // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FString                                 PresetIndexParam;                                  // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ApplyIndexImmediatelyToggleParam;                  // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnActiveOverridesChanged;                          // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABuildingActor*                         Owner;                                             // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFabricUserOptionSaveModulatable*       UserOptionSaveModulatable;                         // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFabricUserOptionSaveData>      Presets;                                           // 0x0128(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFabricUserOptionSaveData>      Saves;                                             // 0x0138(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TSet<class FString>                           FloatUserOptions;                                  // 0x0148(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         ActiveSaveIndex;                                   // 0x0198(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ActivePresetIndex;                                 // 0x019C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0[0x68];                                     // 0x01A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsApplyingOverrides();
	void OnAnyOptionUpdated();
	void SetMusicClock(class UMusicClockComponent* MusicClockComponent);
	void SetPreset(int32 PresetIndex);
	void SetSaveSlot(int32 SaveSlotIndex);

	class FString GetOverrideForParam(const class FString& Param) const;
	bool HasOverrideForParam(const class FString& Param) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FabricUserOptionSaveComponent">();
	}
	static class UFabricUserOptionSaveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFabricUserOptionSaveComponent>();
	}
};
static_assert(alignof(UFabricUserOptionSaveComponent) == 0x000008, "Wrong alignment on UFabricUserOptionSaveComponent");
static_assert(sizeof(UFabricUserOptionSaveComponent) == 0x000208, "Wrong size on UFabricUserOptionSaveComponent");
static_assert(offsetof(UFabricUserOptionSaveComponent, UserOptionsToSave) == 0x0000A8, "Member 'UFabricUserOptionSaveComponent::UserOptionsToSave' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, MaxSaveSlots) == 0x0000B8, "Member 'UFabricUserOptionSaveComponent::MaxSaveSlots' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, SaveIndexParam) == 0x0000C0, "Member 'UFabricUserOptionSaveComponent::SaveIndexParam' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, PresetAssets) == 0x0000D0, "Member 'UFabricUserOptionSaveComponent::PresetAssets' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, PresetIndexParam) == 0x0000E0, "Member 'UFabricUserOptionSaveComponent::PresetIndexParam' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, ApplyIndexImmediatelyToggleParam) == 0x0000F0, "Member 'UFabricUserOptionSaveComponent::ApplyIndexImmediatelyToggleParam' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, OnActiveOverridesChanged) == 0x000100, "Member 'UFabricUserOptionSaveComponent::OnActiveOverridesChanged' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, Owner) == 0x000110, "Member 'UFabricUserOptionSaveComponent::Owner' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, UserOptionSaveModulatable) == 0x000118, "Member 'UFabricUserOptionSaveComponent::UserOptionSaveModulatable' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, Presets) == 0x000128, "Member 'UFabricUserOptionSaveComponent::Presets' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, Saves) == 0x000138, "Member 'UFabricUserOptionSaveComponent::Saves' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, FloatUserOptions) == 0x000148, "Member 'UFabricUserOptionSaveComponent::FloatUserOptions' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, ActiveSaveIndex) == 0x000198, "Member 'UFabricUserOptionSaveComponent::ActiveSaveIndex' has a wrong offset!");
static_assert(offsetof(UFabricUserOptionSaveComponent, ActivePresetIndex) == 0x00019C, "Member 'UFabricUserOptionSaveComponent::ActivePresetIndex' has a wrong offset!");

// Class FMInWorldKnobsRuntime.FMInWorldCableOptionsComponent
// 0x0080 (0x0120 - 0x00A0)
class UFMInWorldCableOptionsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x80];                                      // 0x00A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnyOptionChanged();
	void OnCableConnected(class UFMDeviceCablePortComponent* SourcePort, class UFMDeviceCablePortComponent* ConnectedPort);
	void OnCableDisconncted(class UFMDeviceCablePortComponent* SourcePort, class UFMDeviceCablePortComponent* DisconnectedPort);
	void OnOptionsLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMInWorldCableOptionsComponent">();
	}
	static class UFMInWorldCableOptionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMInWorldCableOptionsComponent>();
	}
};
static_assert(alignof(UFMInWorldCableOptionsComponent) == 0x000008, "Wrong alignment on UFMInWorldCableOptionsComponent");
static_assert(sizeof(UFMInWorldCableOptionsComponent) == 0x000120, "Wrong size on UFMInWorldCableOptionsComponent");

// Class FMInWorldKnobsRuntime.FMInWorldKnobActorBase
// 0x0120 (0x03B0 - 0x0290)
class AFMInWorldKnobActorBase final : public AActor
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& Value, class UObject* ModulatorObject)> OnModulatedPropertyValueChanged;                   // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value, class UPlaylistUserOptionBase* Option)> OnKnobRuntimeValueChanged;                         // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value, class UPlaylistUserOptionBase* Option, class APlayerController* PlayerController)> OnKnobSerializedValueChanged;                      // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bConnected, class UObject* ModulatorObject)> OnFloatProviderConnectionChanged;                  // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 OptionKey;                                         // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   OverriddenTitle;                                   // 0x02F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanBeModulated;                                   // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKnobEnabled;                                      // 0x0311(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKnobDisplayOnly;                                  // 0x0312(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_313[0x5];                                      // 0x0313(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ModulatorPortParent;                               // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMDeviceCableModulatorPortComponent*   ModulatorPort;                                     // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaylistUserOptionBase*                MyUserOption;                                      // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UFabricFloatProviderBase>> CurrentFloatProviders;                             // 0x0338(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UFabricFloatProviderBase> ActiveFloatProvider;                               // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        HitComponent;                                      // 0x0350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APlayerController>       InteractingController;                             // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFabricInteractableType                       InteractableType;                                  // 0x0360(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UFabricInteractableViewModel> WidgetViewModel;                                   // 0x0364(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           OverrideLabels;                                    // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TArray<class FText>                           OptionLabels;                                      // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TArray<class FString>                         OptionValues;                                      // 0x0390(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPrivate)
	int32                                         SerializedOptionIndex;                             // 0x03A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentOptionIndex;                                // 0x03A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClampedKnobValue;                                  // 0x03A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTrackingInput;                                    // 0x03AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsVisibilityBound;                                // 0x03AD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AE[0x2];                                      // 0x03AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyAttributesFromOtherKnob(class AFMInWorldKnobActorBase* OtherKnob);
	void CopyAttributesFromOtherKnobInternal(class AFMInWorldKnobActorBase* OtherKnob);
	void EnsureProperCollision();
	class FText GetCurrentValueLabel();
	void HitComponentUpdated(class USceneComponent* NewHitComponent);
	void KnobValueChanged(int32 NewIndex, bool SnapToSelection, class APlayerController* PlayerController);
	void OnFloatProviderFloatUpdated(float NewFloat);
	void OnKnobIsVisible(bool bInIsVisible);
	void OnReceiveFloatProvidersFromPort(const TArray<class UFabricFloatProviderBase*>& FloatProvider);
	void ReceiveOnWidgetViewModelSet();
	void ResetToDefaultValue(class APlayerController* PlayerController);
	void SetCurrentKnobPosition(float KnobPosition);
	void SetKnobDisplayOnly(bool bDisplayOnly);
	void SetKnobEnabled(bool bEnabled);
	void SetNumberOptions(int32 NumberOptions);
	void SetOverrideOptionLabels(const TArray<class FText>& Labels);
	void SetSelectedIndex(int32 Index_0, bool SnapToSelection);
	void SetTitle(const class FText& Title);
	void SetWidgetViewModel(class UFabricInteractableViewModel* ViewModel);
	void StartTrackingInput(class APlayerController* PlayerController);
	void StopTrackingInput();
	void UpdateDisplayOnlyVisuals(bool bDisplayOnly);
	void UpdateEnabledVisuals(bool bEnabled);
	void UpdateFocusVisuals(bool bFocused);
	void UpdateInteractableVisuals(bool bInteractable);

	bool GetConsumeInteractionFromChildInteractable(class APlayerController* PlayerController) const;
	class UClass* GetCopyClassInternal() const;
	TSubclassOf<class UUserWidget> GetCopyWidgetClassInternal() const;
	int32 GetCurrentOptionIndex() const;
	bool GetCurrentValueAsBool() const;
	uint8 GetCurrentValueAsEnum() const;
	float GetCurrentValueAsFloat() const;
	int32 GetCurrentValueAsInt() const;
	class FName GetCurrentValueAsName() const;
	class FString GetCurrentValueAsString() const;
	class USceneComponent* GetHitComponent() const;
	class APlayerController* GetInteractingController() const;
	int32 GetNumberOptions() const;
	class UFabricInteractableViewModel* GetWidgetViewModel() const;
	bool HasActiveFloatProvider() const;
	bool IsOverriddenByPort() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMInWorldKnobActorBase">();
	}
	static class AFMInWorldKnobActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFMInWorldKnobActorBase>();
	}
};
static_assert(alignof(AFMInWorldKnobActorBase) == 0x000008, "Wrong alignment on AFMInWorldKnobActorBase");
static_assert(sizeof(AFMInWorldKnobActorBase) == 0x0003B0, "Wrong size on AFMInWorldKnobActorBase");
static_assert(offsetof(AFMInWorldKnobActorBase, OnModulatedPropertyValueChanged) == 0x0002A8, "Member 'AFMInWorldKnobActorBase::OnModulatedPropertyValueChanged' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, OnKnobRuntimeValueChanged) == 0x0002B8, "Member 'AFMInWorldKnobActorBase::OnKnobRuntimeValueChanged' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, OnKnobSerializedValueChanged) == 0x0002C8, "Member 'AFMInWorldKnobActorBase::OnKnobSerializedValueChanged' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, OnFloatProviderConnectionChanged) == 0x0002D8, "Member 'AFMInWorldKnobActorBase::OnFloatProviderConnectionChanged' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, OptionKey) == 0x0002E8, "Member 'AFMInWorldKnobActorBase::OptionKey' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, OverriddenTitle) == 0x0002F8, "Member 'AFMInWorldKnobActorBase::OverriddenTitle' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, bCanBeModulated) == 0x000310, "Member 'AFMInWorldKnobActorBase::bCanBeModulated' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, bKnobEnabled) == 0x000311, "Member 'AFMInWorldKnobActorBase::bKnobEnabled' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, bKnobDisplayOnly) == 0x000312, "Member 'AFMInWorldKnobActorBase::bKnobDisplayOnly' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, ModulatorPortParent) == 0x000318, "Member 'AFMInWorldKnobActorBase::ModulatorPortParent' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, ModulatorPort) == 0x000320, "Member 'AFMInWorldKnobActorBase::ModulatorPort' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, MyUserOption) == 0x000328, "Member 'AFMInWorldKnobActorBase::MyUserOption' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, CurrentFloatProviders) == 0x000338, "Member 'AFMInWorldKnobActorBase::CurrentFloatProviders' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, ActiveFloatProvider) == 0x000348, "Member 'AFMInWorldKnobActorBase::ActiveFloatProvider' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, HitComponent) == 0x000350, "Member 'AFMInWorldKnobActorBase::HitComponent' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, InteractingController) == 0x000358, "Member 'AFMInWorldKnobActorBase::InteractingController' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, InteractableType) == 0x000360, "Member 'AFMInWorldKnobActorBase::InteractableType' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, WidgetViewModel) == 0x000364, "Member 'AFMInWorldKnobActorBase::WidgetViewModel' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, OverrideLabels) == 0x000370, "Member 'AFMInWorldKnobActorBase::OverrideLabels' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, OptionLabels) == 0x000380, "Member 'AFMInWorldKnobActorBase::OptionLabels' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, OptionValues) == 0x000390, "Member 'AFMInWorldKnobActorBase::OptionValues' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, SerializedOptionIndex) == 0x0003A0, "Member 'AFMInWorldKnobActorBase::SerializedOptionIndex' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, CurrentOptionIndex) == 0x0003A4, "Member 'AFMInWorldKnobActorBase::CurrentOptionIndex' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, ClampedKnobValue) == 0x0003A8, "Member 'AFMInWorldKnobActorBase::ClampedKnobValue' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, bTrackingInput) == 0x0003AC, "Member 'AFMInWorldKnobActorBase::bTrackingInput' has a wrong offset!");
static_assert(offsetof(AFMInWorldKnobActorBase, bIsVisibilityBound) == 0x0003AD, "Member 'AFMInWorldKnobActorBase::bIsVisibilityBound' has a wrong offset!");

// Class FMInWorldKnobsRuntime.FMInWorldKnobActorCopyComponent
// 0x0110 (0x0400 - 0x02F0)
class UFMInWorldKnobActorCopyComponent final : public UFabricChildActorComponent
{
public:
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& Value, class UObject* ModulatorObject)> OnModulatedPropertyValueChanged;                   // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value, class UPlaylistUserOptionBase* Option)> OnKnobRuntimeValueChanged;                         // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value, class UPlaylistUserOptionBase* Option, class APlayerController* PlayerController)> OnKnobSerializedValueChanged;                      // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bConnected, class UObject* ModulatorObject)> OnFloatProviderConnectionChanged;                  // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFMInWorldKnobActorCopyComponent* CopyComponent, class AFMInWorldKnobActorBase* NewKnobActor)> OnKnobActorSet;                                    // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AFMInWorldKnobActorBase>    DefaultKnobActorClass;                             // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFMInWorldKnobActorBase*                InWorldKnobActor;                                  // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 OptionKey;                                         // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   OverriddenTitle;                                   // 0x0370(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanBeModulated;                                   // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKnobEnabled;                                      // 0x0389(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38A[0x6];                                      // 0x038A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlaylistUserOptionBase*                OuterUserOption;                                   // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x30];                                     // 0x0398(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlaylistUserOptionBase*                CopiedUserOption;                                  // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x30];                                     // 0x03D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCopiedInWorldKnob();
	void OnInWorldKnobFloatProviderConnectionChanged(bool bConnected, class UObject* ModulatorObject);
	void OnInWorldKnobModulatedPropertyValueChanged(const class FString& Value, class UObject* ModulatorObject);
	void OnInWorldKnobRuntimeValueChanged(const class FString& Value, class UPlaylistUserOptionBase* Option);
	void OnInWorldKnobSerializedValueChanged(const class FString& Value, class UPlaylistUserOptionBase* Option, class APlayerController* PlayerController);
	void SetCopiedInWorldKnob(class UObject* InWorldKnobObject);

	class FString GetCurrentKnobValueBP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMInWorldKnobActorCopyComponent">();
	}
	static class UFMInWorldKnobActorCopyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMInWorldKnobActorCopyComponent>();
	}
};
static_assert(alignof(UFMInWorldKnobActorCopyComponent) == 0x000010, "Wrong alignment on UFMInWorldKnobActorCopyComponent");
static_assert(sizeof(UFMInWorldKnobActorCopyComponent) == 0x000400, "Wrong size on UFMInWorldKnobActorCopyComponent");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, OnModulatedPropertyValueChanged) == 0x000300, "Member 'UFMInWorldKnobActorCopyComponent::OnModulatedPropertyValueChanged' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, OnKnobRuntimeValueChanged) == 0x000310, "Member 'UFMInWorldKnobActorCopyComponent::OnKnobRuntimeValueChanged' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, OnKnobSerializedValueChanged) == 0x000320, "Member 'UFMInWorldKnobActorCopyComponent::OnKnobSerializedValueChanged' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, OnFloatProviderConnectionChanged) == 0x000330, "Member 'UFMInWorldKnobActorCopyComponent::OnFloatProviderConnectionChanged' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, OnKnobActorSet) == 0x000340, "Member 'UFMInWorldKnobActorCopyComponent::OnKnobActorSet' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, DefaultKnobActorClass) == 0x000350, "Member 'UFMInWorldKnobActorCopyComponent::DefaultKnobActorClass' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, InWorldKnobActor) == 0x000358, "Member 'UFMInWorldKnobActorCopyComponent::InWorldKnobActor' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, OptionKey) == 0x000360, "Member 'UFMInWorldKnobActorCopyComponent::OptionKey' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, OverriddenTitle) == 0x000370, "Member 'UFMInWorldKnobActorCopyComponent::OverriddenTitle' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, bCanBeModulated) == 0x000388, "Member 'UFMInWorldKnobActorCopyComponent::bCanBeModulated' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, bKnobEnabled) == 0x000389, "Member 'UFMInWorldKnobActorCopyComponent::bKnobEnabled' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, OuterUserOption) == 0x000390, "Member 'UFMInWorldKnobActorCopyComponent::OuterUserOption' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobActorCopyComponent, CopiedUserOption) == 0x0003C8, "Member 'UFMInWorldKnobActorCopyComponent::CopiedUserOption' has a wrong offset!");

// Class FMInWorldKnobsRuntime.InWorldKnobInterface
// 0x0000 (0x0028 - 0x0028)
class IInWorldKnobInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InWorldKnobInterface">();
	}
	static class IInWorldKnobInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInWorldKnobInterface>();
	}
};
static_assert(alignof(IInWorldKnobInterface) == 0x000008, "Wrong alignment on IInWorldKnobInterface");
static_assert(sizeof(IInWorldKnobInterface) == 0x000028, "Wrong size on IInWorldKnobInterface");

// Class FMInWorldKnobsRuntime.FMInWorldKnobOptionsComponent
// 0x0208 (0x02A8 - 0x00A0)
class UFMInWorldKnobOptionsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnInitialKnobValuesLoaded;                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllKnobsLoaded;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAnyKnobRuntimeValueChanged;                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAnyKnobSerializedValueChanged;                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<class UObject*>                          InWorldKnobInterfaceObjects;                       // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        ReplicatedInWorldKnobInterfaceObjects;             // 0x0138(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        ReplicatedFabricInteractableObjects;               // 0x0148(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UFMDeviceCableModulatorPortComponent*> ReplicatedModulatorPorts;                          // 0x0158(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class ABuildingActor*                         BuildingActorOwner;                                // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 OwnerClass;                                        // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFabricUserOptionSaveComponent*         SaveComponent;                                     // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UPlaylistUserOptionBase*> PropertiesEditedByUserOptions;                     // 0x0180(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, class UObject*>           OptionKeyToInWorldKnobObject;                      // 0x01D0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, class UFMDeviceCableModulatorPortComponent*> OptionKeyToModulatorPort;                          // 0x0220(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UFabricModulatable*>             PendingFabricModulatables;                         // 0x0270(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ActorSaveRequestTimer;                             // 0x0280(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x20];                                     // 0x0288(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActorHasValidControllerBP(class AActor* Actor, class AFortPlayerPawn** OutFortPlayerPawn, class APlayerController** OutPlayerController);
	void OnAnyOptionUpdated();
	void OnInWorldKnobRuntimeOptionChanged(const class FString& Value, class UPlaylistUserOptionBase* Option);
	void OnInWorldKnobSerializedOptionChanged(const class FString& Value, class UPlaylistUserOptionBase* Option, class APlayerController* PlayerController);
	void OnOptionsLoaded();
	void OnRep_ReplicatedFabricInteractableObjects();
	void OnRep_ReplicatedInWorldKnobInterfaceObjects();
	void OnRep_ReplicatedModulatorPorts();
	void OnSaveOverridesChanged();

	bool AreAllKnobsLoadedForNotify() const;
	bool CanMakeUserOptionChanges() const;
	bool OwnsInWorldKnobObject(class UObject* InWorldKnobObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMInWorldKnobOptionsComponent">();
	}
	static class UFMInWorldKnobOptionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMInWorldKnobOptionsComponent>();
	}
};
static_assert(alignof(UFMInWorldKnobOptionsComponent) == 0x000008, "Wrong alignment on UFMInWorldKnobOptionsComponent");
static_assert(sizeof(UFMInWorldKnobOptionsComponent) == 0x0002A8, "Wrong size on UFMInWorldKnobOptionsComponent");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, OnInitialKnobValuesLoaded) == 0x0000A8, "Member 'UFMInWorldKnobOptionsComponent::OnInitialKnobValuesLoaded' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, OnAllKnobsLoaded) == 0x0000B8, "Member 'UFMInWorldKnobOptionsComponent::OnAllKnobsLoaded' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, OnAnyKnobRuntimeValueChanged) == 0x0000C8, "Member 'UFMInWorldKnobOptionsComponent::OnAnyKnobRuntimeValueChanged' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, OnAnyKnobSerializedValueChanged) == 0x0000D8, "Member 'UFMInWorldKnobOptionsComponent::OnAnyKnobSerializedValueChanged' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, InWorldKnobInterfaceObjects) == 0x0000E8, "Member 'UFMInWorldKnobOptionsComponent::InWorldKnobInterfaceObjects' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, ReplicatedInWorldKnobInterfaceObjects) == 0x000138, "Member 'UFMInWorldKnobOptionsComponent::ReplicatedInWorldKnobInterfaceObjects' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, ReplicatedFabricInteractableObjects) == 0x000148, "Member 'UFMInWorldKnobOptionsComponent::ReplicatedFabricInteractableObjects' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, ReplicatedModulatorPorts) == 0x000158, "Member 'UFMInWorldKnobOptionsComponent::ReplicatedModulatorPorts' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, BuildingActorOwner) == 0x000168, "Member 'UFMInWorldKnobOptionsComponent::BuildingActorOwner' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, OwnerClass) == 0x000170, "Member 'UFMInWorldKnobOptionsComponent::OwnerClass' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, SaveComponent) == 0x000178, "Member 'UFMInWorldKnobOptionsComponent::SaveComponent' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, PropertiesEditedByUserOptions) == 0x000180, "Member 'UFMInWorldKnobOptionsComponent::PropertiesEditedByUserOptions' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, OptionKeyToInWorldKnobObject) == 0x0001D0, "Member 'UFMInWorldKnobOptionsComponent::OptionKeyToInWorldKnobObject' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, OptionKeyToModulatorPort) == 0x000220, "Member 'UFMInWorldKnobOptionsComponent::OptionKeyToModulatorPort' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, PendingFabricModulatables) == 0x000270, "Member 'UFMInWorldKnobOptionsComponent::PendingFabricModulatables' has a wrong offset!");
static_assert(offsetof(UFMInWorldKnobOptionsComponent, ActorSaveRequestTimer) == 0x000280, "Member 'UFMInWorldKnobOptionsComponent::ActorSaveRequestTimer' has a wrong offset!");

// Class FMInWorldKnobsRuntime.PlaylistUserOptionFMOutgoingCableConnection
// 0x0030 (0x0200 - 0x01D0)
class UPlaylistUserOptionFMOutgoingCableConnection final : public UPlaylistUserOptionBase
{
public:
	struct FFMOutgoingCableConnection             DefaultValue;                                      // 0x01D0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaylistUserOptionFMOutgoingCableConnection">();
	}
	static class UPlaylistUserOptionFMOutgoingCableConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaylistUserOptionFMOutgoingCableConnection>();
	}
};
static_assert(alignof(UPlaylistUserOptionFMOutgoingCableConnection) == 0x000008, "Wrong alignment on UPlaylistUserOptionFMOutgoingCableConnection");
static_assert(sizeof(UPlaylistUserOptionFMOutgoingCableConnection) == 0x000200, "Wrong size on UPlaylistUserOptionFMOutgoingCableConnection");
static_assert(offsetof(UPlaylistUserOptionFMOutgoingCableConnection, DefaultValue) == 0x0001D0, "Member 'UPlaylistUserOptionFMOutgoingCableConnection::DefaultValue' has a wrong offset!");

}

