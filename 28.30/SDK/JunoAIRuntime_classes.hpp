#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JunoAIRuntime

#include "Basic.hpp"

#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "FortniteAI_structs.hpp"
#include "FortniteAI_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "JunoAIRuntime_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "JunoGameNative_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "FortniteAIServer_classes.hpp"
#include "LagerRuntime_structs.hpp"
#include "LagerRuntime_classes.hpp"
#include "WorldConditions_structs.hpp"
#include "WorldConditions_classes.hpp"


namespace SDK
{

// Class JunoAIRuntime.JunoAIBotController
// 0x0200 (0x1950 - 0x1750)
class AJunoAIBotController final : public AFortAthenaAIBotController
{
public:
	class UJunoAIInventoryComponent*              JunoAIInventoryComponent;                          // 0x1750(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FItemAndCount>                  DefaultItemsToAdd;                                 // 0x1758(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1768[0x89];                                    // 0x1768(0x0089)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequiresPersistentInventory;                      // 0x17F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17F2[0x6];                                     // 0x17F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         EnableDurabilityOnInventory;                       // 0x17F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         UseRoleCheckForDurability;                         // 0x1820(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      RequiredRoleForDurability;                         // 0x1848(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bUseFocusedActorEyeLocationForFocalPoint;          // 0x1890(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseValidItemsPerType;                             // 0x1891(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1892[0x6];                                     // 0x1892(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         EffectivenessMultiplierForWeaponSelectionOnPickedOrAddedItem; // 0x1898(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FValidItemSlotConfiguration> ValidItemsTablePerType;                            // 0x18C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UFortItemDefinition*                    AutomaticallyEquippedWeaponOnDurabilityBreak;      // 0x1910(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         DurabilityMultiplier;                              // 0x1918(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           TagToApplyWhenAddingFallbackItemForDurabilityBreak; // 0x1940(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1944[0xC];                                     // 0x1944(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIBotController">();
	}
	static class AJunoAIBotController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJunoAIBotController>();
	}
};
static_assert(alignof(AJunoAIBotController) == 0x000010, "Wrong alignment on AJunoAIBotController");
static_assert(sizeof(AJunoAIBotController) == 0x001950, "Wrong size on AJunoAIBotController");
static_assert(offsetof(AJunoAIBotController, JunoAIInventoryComponent) == 0x001750, "Member 'AJunoAIBotController::JunoAIInventoryComponent' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, DefaultItemsToAdd) == 0x001758, "Member 'AJunoAIBotController::DefaultItemsToAdd' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, bRequiresPersistentInventory) == 0x0017F1, "Member 'AJunoAIBotController::bRequiresPersistentInventory' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, EnableDurabilityOnInventory) == 0x0017F8, "Member 'AJunoAIBotController::EnableDurabilityOnInventory' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, UseRoleCheckForDurability) == 0x001820, "Member 'AJunoAIBotController::UseRoleCheckForDurability' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, RequiredRoleForDurability) == 0x001848, "Member 'AJunoAIBotController::RequiredRoleForDurability' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, bUseFocusedActorEyeLocationForFocalPoint) == 0x001890, "Member 'AJunoAIBotController::bUseFocusedActorEyeLocationForFocalPoint' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, bUseValidItemsPerType) == 0x001891, "Member 'AJunoAIBotController::bUseValidItemsPerType' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, EffectivenessMultiplierForWeaponSelectionOnPickedOrAddedItem) == 0x001898, "Member 'AJunoAIBotController::EffectivenessMultiplierForWeaponSelectionOnPickedOrAddedItem' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, ValidItemsTablePerType) == 0x0018C0, "Member 'AJunoAIBotController::ValidItemsTablePerType' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, AutomaticallyEquippedWeaponOnDurabilityBreak) == 0x001910, "Member 'AJunoAIBotController::AutomaticallyEquippedWeaponOnDurabilityBreak' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, DurabilityMultiplier) == 0x001918, "Member 'AJunoAIBotController::DurabilityMultiplier' has a wrong offset!");
static_assert(offsetof(AJunoAIBotController, TagToApplyWhenAddingFallbackItemForDurabilityBreak) == 0x001940, "Member 'AJunoAIBotController::TagToApplyWhenAddingFallbackItemForDurabilityBreak' has a wrong offset!");

// Class JunoAIRuntime.JunoAIBotEvaluator_FallbackBehavior
// 0x0080 (0x0228 - 0x01A8)
class UJunoAIBotEvaluator_FallbackBehavior final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	uint8                                         Pad_1A8[0x18];                                     // 0x01A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x01C0(0x0048)(Edit, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     NavigationQueryFilterClass;                        // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFallbackToPointWithNoCustomNavigationQueryFilter; // 0x0210(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BestTargetActorName;                               // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x4];                                      // 0x0218(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnableKeyName;                                     // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIBotEvaluator_FallbackBehavior">();
	}
	static class UJunoAIBotEvaluator_FallbackBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIBotEvaluator_FallbackBehavior>();
	}
};
static_assert(alignof(UJunoAIBotEvaluator_FallbackBehavior) == 0x000008, "Wrong alignment on UJunoAIBotEvaluator_FallbackBehavior");
static_assert(sizeof(UJunoAIBotEvaluator_FallbackBehavior) == 0x000228, "Wrong size on UJunoAIBotEvaluator_FallbackBehavior");
static_assert(offsetof(UJunoAIBotEvaluator_FallbackBehavior, EQSRequest) == 0x0001C0, "Member 'UJunoAIBotEvaluator_FallbackBehavior::EQSRequest' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_FallbackBehavior, NavigationQueryFilterClass) == 0x000208, "Member 'UJunoAIBotEvaluator_FallbackBehavior::NavigationQueryFilterClass' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_FallbackBehavior, bFallbackToPointWithNoCustomNavigationQueryFilter) == 0x000210, "Member 'UJunoAIBotEvaluator_FallbackBehavior::bFallbackToPointWithNoCustomNavigationQueryFilter' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_FallbackBehavior, BestTargetActorName) == 0x000214, "Member 'UJunoAIBotEvaluator_FallbackBehavior::BestTargetActorName' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_FallbackBehavior, EnableKeyName) == 0x00021C, "Member 'UJunoAIBotEvaluator_FallbackBehavior::EnableKeyName' has a wrong offset!");

// Class JunoAIRuntime.JunoAIBotEvaluator_FTUENPC
// 0x00C0 (0x0168 - 0x00A8)
class UJunoAIBotEvaluator_FTUENPC final : public UFortAthenaAIBotEvaluator
{
public:
	uint8                                         Pad_A8[0x24];                                      // 0x00A8(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TeleportDestinationKeyName;                        // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x4];                                       // 0x00D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ShouldTeleportKeyName;                             // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoAIFTUERuntimeConfiguration        FTUERuntimeConfiguration;                          // 0x00E0(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIBotEvaluator_FTUENPC">();
	}
	static class UJunoAIBotEvaluator_FTUENPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIBotEvaluator_FTUENPC>();
	}
};
static_assert(alignof(UJunoAIBotEvaluator_FTUENPC) == 0x000008, "Wrong alignment on UJunoAIBotEvaluator_FTUENPC");
static_assert(sizeof(UJunoAIBotEvaluator_FTUENPC) == 0x000168, "Wrong size on UJunoAIBotEvaluator_FTUENPC");
static_assert(offsetof(UJunoAIBotEvaluator_FTUENPC, TeleportDestinationKeyName) == 0x0000CC, "Member 'UJunoAIBotEvaluator_FTUENPC::TeleportDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_FTUENPC, ShouldTeleportKeyName) == 0x0000D4, "Member 'UJunoAIBotEvaluator_FTUENPC::ShouldTeleportKeyName' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_FTUENPC, FTUERuntimeConfiguration) == 0x0000E0, "Member 'UJunoAIBotEvaluator_FTUENPC::FTUERuntimeConfiguration' has a wrong offset!");

// Class JunoAIRuntime.JunoAIBotEvaluator_HardRemovalStart
// 0x0088 (0x0230 - 0x01A8)
class UJunoAIBotEvaluator_HardRemovalStart final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	uint8                                         Pad_1A8[0x18];                                     // 0x01A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x01C0(0x0048)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RequestHardRemovalOnSuccess;                       // 0x0208(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIBotEvaluator_HardRemovalStart">();
	}
	static class UJunoAIBotEvaluator_HardRemovalStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIBotEvaluator_HardRemovalStart>();
	}
};
static_assert(alignof(UJunoAIBotEvaluator_HardRemovalStart) == 0x000008, "Wrong alignment on UJunoAIBotEvaluator_HardRemovalStart");
static_assert(sizeof(UJunoAIBotEvaluator_HardRemovalStart) == 0x000230, "Wrong size on UJunoAIBotEvaluator_HardRemovalStart");
static_assert(offsetof(UJunoAIBotEvaluator_HardRemovalStart, EQSRequest) == 0x0001C0, "Member 'UJunoAIBotEvaluator_HardRemovalStart::EQSRequest' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_HardRemovalStart, RequestHardRemovalOnSuccess) == 0x000208, "Member 'UJunoAIBotEvaluator_HardRemovalStart::RequestHardRemovalOnSuccess' has a wrong offset!");

// Class JunoAIRuntime.JunoAIBotEvaluator_OffhandWeapon
// 0x0068 (0x0110 - 0x00A8)
class UJunoAIBotEvaluator_OffhandWeapon final : public UFortAthenaAIBotEvaluator
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TorchWeaponTag;                                    // 0x00C0(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           MinTemperatureStateToAlwaysEquipTorch;             // 0x00C4(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           TemperatureStateUsedToDecideSpecialTimeTorchUsage; // 0x00C8(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDeltaFromHotTemperatureToEquipTorch;            // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ExecutionStatusesToCheckedToHolsterKeyNames;       // 0x00D0(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BoolsToCheckToHolsterKeyNames;                     // 0x00F0(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIBotEvaluator_OffhandWeapon">();
	}
	static class UJunoAIBotEvaluator_OffhandWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIBotEvaluator_OffhandWeapon>();
	}
};
static_assert(alignof(UJunoAIBotEvaluator_OffhandWeapon) == 0x000008, "Wrong alignment on UJunoAIBotEvaluator_OffhandWeapon");
static_assert(sizeof(UJunoAIBotEvaluator_OffhandWeapon) == 0x000110, "Wrong size on UJunoAIBotEvaluator_OffhandWeapon");
static_assert(offsetof(UJunoAIBotEvaluator_OffhandWeapon, TorchWeaponTag) == 0x0000C0, "Member 'UJunoAIBotEvaluator_OffhandWeapon::TorchWeaponTag' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_OffhandWeapon, MinTemperatureStateToAlwaysEquipTorch) == 0x0000C4, "Member 'UJunoAIBotEvaluator_OffhandWeapon::MinTemperatureStateToAlwaysEquipTorch' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_OffhandWeapon, TemperatureStateUsedToDecideSpecialTimeTorchUsage) == 0x0000C8, "Member 'UJunoAIBotEvaluator_OffhandWeapon::TemperatureStateUsedToDecideSpecialTimeTorchUsage' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_OffhandWeapon, MaxDeltaFromHotTemperatureToEquipTorch) == 0x0000CC, "Member 'UJunoAIBotEvaluator_OffhandWeapon::MaxDeltaFromHotTemperatureToEquipTorch' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_OffhandWeapon, ExecutionStatusesToCheckedToHolsterKeyNames) == 0x0000D0, "Member 'UJunoAIBotEvaluator_OffhandWeapon::ExecutionStatusesToCheckedToHolsterKeyNames' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_OffhandWeapon, BoolsToCheckToHolsterKeyNames) == 0x0000F0, "Member 'UJunoAIBotEvaluator_OffhandWeapon::BoolsToCheckToHolsterKeyNames' has a wrong offset!");

// Class JunoAIRuntime.JunoAIBotEvaluator_UnderThunderBehavior
// 0x0110 (0x02B8 - 0x01A8)
class UJunoAIBotEvaluator_UnderThunderBehavior final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	uint8                                         Pad_1A8[0x30];                                     // 0x01A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         IsEnabled;                                         // 0x01D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         UseTagForShelterCheck;                             // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TagToCheckForSheltered;                            // 0x0228(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ShelterQueryTypes;                                 // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxShelterDistance;                                // 0x0240(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinDistanceFromShelterLocationToKeepItValid;       // 0x0268(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ShelterCollidingActorRequiresAnyTag;               // 0x0290(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TagToApplyForShelteredNPC;                         // 0x02B0(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TagToApplyForNonShelteredNPC;                      // 0x02B4(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIBotEvaluator_UnderThunderBehavior">();
	}
	static class UJunoAIBotEvaluator_UnderThunderBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIBotEvaluator_UnderThunderBehavior>();
	}
};
static_assert(alignof(UJunoAIBotEvaluator_UnderThunderBehavior) == 0x000008, "Wrong alignment on UJunoAIBotEvaluator_UnderThunderBehavior");
static_assert(sizeof(UJunoAIBotEvaluator_UnderThunderBehavior) == 0x0002B8, "Wrong size on UJunoAIBotEvaluator_UnderThunderBehavior");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, IsEnabled) == 0x0001D8, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::IsEnabled' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, UseTagForShelterCheck) == 0x000200, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::UseTagForShelterCheck' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, TagToCheckForSheltered) == 0x000228, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::TagToCheckForSheltered' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, ShelterQueryTypes) == 0x000230, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::ShelterQueryTypes' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, MaxShelterDistance) == 0x000240, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::MaxShelterDistance' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, MinDistanceFromShelterLocationToKeepItValid) == 0x000268, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::MinDistanceFromShelterLocationToKeepItValid' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, ShelterCollidingActorRequiresAnyTag) == 0x000290, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::ShelterCollidingActorRequiresAnyTag' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, TagToApplyForShelteredNPC) == 0x0002B0, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::TagToApplyForShelteredNPC' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnderThunderBehavior, TagToApplyForNonShelteredNPC) == 0x0002B4, "Member 'UJunoAIBotEvaluator_UnderThunderBehavior::TagToApplyForNonShelteredNPC' has a wrong offset!");

// Class JunoAIRuntime.JunoAIBotEvaluator_UnstuckFailsafe
// 0x0110 (0x01B8 - 0x00A8)
class UJunoAIBotEvaluator_UnstuckFailsafe final : public UFortAthenaAIBotEvaluator
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TeleportDestinationKeyName;                        // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ShouldTeleportKeyName;                             // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoAIUnstuckFailsafeConfiguration    Configuration;                                     // 0x00D0(0x00E8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIBotEvaluator_UnstuckFailsafe">();
	}
	static class UJunoAIBotEvaluator_UnstuckFailsafe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIBotEvaluator_UnstuckFailsafe>();
	}
};
static_assert(alignof(UJunoAIBotEvaluator_UnstuckFailsafe) == 0x000008, "Wrong alignment on UJunoAIBotEvaluator_UnstuckFailsafe");
static_assert(sizeof(UJunoAIBotEvaluator_UnstuckFailsafe) == 0x0001B8, "Wrong size on UJunoAIBotEvaluator_UnstuckFailsafe");
static_assert(offsetof(UJunoAIBotEvaluator_UnstuckFailsafe, TeleportDestinationKeyName) == 0x0000C0, "Member 'UJunoAIBotEvaluator_UnstuckFailsafe::TeleportDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnstuckFailsafe, ShouldTeleportKeyName) == 0x0000C4, "Member 'UJunoAIBotEvaluator_UnstuckFailsafe::ShouldTeleportKeyName' has a wrong offset!");
static_assert(offsetof(UJunoAIBotEvaluator_UnstuckFailsafe, Configuration) == 0x0000D0, "Member 'UJunoAIBotEvaluator_UnstuckFailsafe::Configuration' has a wrong offset!");

// Class JunoAIRuntime.JunoAICampPawnComponent
// 0x0280 (0x0328 - 0x00A8)
class UJunoAICampPawnComponent final : public UFortPawnComponent
{
public:
	TMulticastInlineDelegate<void(struct FGameplayTagContainer& NewSoftRemovedReason)> OnJunoAICampPawnComponentChangedSoftRemovedReason; // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0xF0];                                      // 0x00B8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortAthenaAIBotSkillSet>> PreFTUESkillSetClasses;                            // 0x01A8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x50];                                     // 0x01B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class FText>        AIRoleToDisplayText;                               // 0x0208(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UFortAthenaAIBotSkillSet>> FTUESkillSetClasses;                               // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  FTUETagsToAdd;                                     // 0x0268(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         FTUEOverrideTileGenerationRadius;                  // 0x0288(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         FTUEOverrideTileRemovalRadius;                     // 0x02B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeToGoInHardRemovalStartStateBeforeHardRemovalInRealSeconds; // 0x02D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeForVisitorsToGoInHardRemovalStartStateBeforeHardRemovalInRealSeconds; // 0x0300(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	const class FText ConvertAIRoleToDisplayText(const struct FGameplayTag& AIRole) const;
	const struct FGameplayTag GetAIRole() const;
	const class FText GetAIRoleDisplayText() const;
	const struct FGameplayTagContainer GetSoftRemovedReasons() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAICampPawnComponent">();
	}
	static class UJunoAICampPawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAICampPawnComponent>();
	}
};
static_assert(alignof(UJunoAICampPawnComponent) == 0x000008, "Wrong alignment on UJunoAICampPawnComponent");
static_assert(sizeof(UJunoAICampPawnComponent) == 0x000328, "Wrong size on UJunoAICampPawnComponent");
static_assert(offsetof(UJunoAICampPawnComponent, OnJunoAICampPawnComponentChangedSoftRemovedReason) == 0x0000A8, "Member 'UJunoAICampPawnComponent::OnJunoAICampPawnComponentChangedSoftRemovedReason' has a wrong offset!");
static_assert(offsetof(UJunoAICampPawnComponent, PreFTUESkillSetClasses) == 0x0001A8, "Member 'UJunoAICampPawnComponent::PreFTUESkillSetClasses' has a wrong offset!");
static_assert(offsetof(UJunoAICampPawnComponent, AIRoleToDisplayText) == 0x000208, "Member 'UJunoAICampPawnComponent::AIRoleToDisplayText' has a wrong offset!");
static_assert(offsetof(UJunoAICampPawnComponent, FTUESkillSetClasses) == 0x000258, "Member 'UJunoAICampPawnComponent::FTUESkillSetClasses' has a wrong offset!");
static_assert(offsetof(UJunoAICampPawnComponent, FTUETagsToAdd) == 0x000268, "Member 'UJunoAICampPawnComponent::FTUETagsToAdd' has a wrong offset!");
static_assert(offsetof(UJunoAICampPawnComponent, FTUEOverrideTileGenerationRadius) == 0x000288, "Member 'UJunoAICampPawnComponent::FTUEOverrideTileGenerationRadius' has a wrong offset!");
static_assert(offsetof(UJunoAICampPawnComponent, FTUEOverrideTileRemovalRadius) == 0x0002B0, "Member 'UJunoAICampPawnComponent::FTUEOverrideTileRemovalRadius' has a wrong offset!");
static_assert(offsetof(UJunoAICampPawnComponent, TimeToGoInHardRemovalStartStateBeforeHardRemovalInRealSeconds) == 0x0002D8, "Member 'UJunoAICampPawnComponent::TimeToGoInHardRemovalStartStateBeforeHardRemovalInRealSeconds' has a wrong offset!");
static_assert(offsetof(UJunoAICampPawnComponent, TimeForVisitorsToGoInHardRemovalStartStateBeforeHardRemovalInRealSeconds) == 0x000300, "Member 'UJunoAICampPawnComponent::TimeForVisitorsToGoInHardRemovalStartStateBeforeHardRemovalInRealSeconds' has a wrong offset!");

// Class JunoAIRuntime.JunoAIInventoryComponent
// 0x0010 (0x0328 - 0x0318)
class UJunoAIInventoryComponent final : public UJunoInventoryComponent
{
public:
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIInventoryComponent">();
	}
	static class UJunoAIInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIInventoryComponent>();
	}
};
static_assert(alignof(UJunoAIInventoryComponent) == 0x000008, "Wrong alignment on UJunoAIInventoryComponent");
static_assert(sizeof(UJunoAIInventoryComponent) == 0x000328, "Wrong size on UJunoAIInventoryComponent");

// Class JunoAIRuntime.JunoAIMerchantComponent
// 0x0050 (0x00F8 - 0x00A8)
class UJunoAIMerchantComponent final : public UFortPawnComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIMerchantComponent">();
	}
	static class UJunoAIMerchantComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIMerchantComponent>();
	}
};
static_assert(alignof(UJunoAIMerchantComponent) == 0x000008, "Wrong alignment on UJunoAIMerchantComponent");
static_assert(sizeof(UJunoAIMerchantComponent) == 0x0000F8, "Wrong size on UJunoAIMerchantComponent");

// Class JunoAIRuntime.JunoAIRuntimeAnalytics
// 0x0000 (0x0028 - 0x0028)
class UJunoAIRuntimeAnalytics final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIRuntimeAnalytics">();
	}
	static class UJunoAIRuntimeAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIRuntimeAnalytics>();
	}
};
static_assert(alignof(UJunoAIRuntimeAnalytics) == 0x000008, "Wrong alignment on UJunoAIRuntimeAnalytics");
static_assert(sizeof(UJunoAIRuntimeAnalytics) == 0x000028, "Wrong size on UJunoAIRuntimeAnalytics");

// Class JunoAIRuntime.JunoBTTask_FTUENPC
// 0x0008 (0x00F0 - 0x00E8)
class UJunoBTTask_FTUENPC final : public UFortBTTask_ExecuteGameplayAbility
{
public:
	class FName                                   FTUENPCStatusKeyName;                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ShouldTeleportKeyName;                             // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBTTask_FTUENPC">();
	}
	static class UJunoBTTask_FTUENPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBTTask_FTUENPC>();
	}
};
static_assert(alignof(UJunoBTTask_FTUENPC) == 0x000008, "Wrong alignment on UJunoBTTask_FTUENPC");
static_assert(sizeof(UJunoBTTask_FTUENPC) == 0x0000F0, "Wrong size on UJunoBTTask_FTUENPC");
static_assert(offsetof(UJunoBTTask_FTUENPC, FTUENPCStatusKeyName) == 0x0000E8, "Member 'UJunoBTTask_FTUENPC::FTUENPCStatusKeyName' has a wrong offset!");
static_assert(offsetof(UJunoBTTask_FTUENPC, ShouldTeleportKeyName) == 0x0000EC, "Member 'UJunoBTTask_FTUENPC::ShouldTeleportKeyName' has a wrong offset!");

// Class JunoAIRuntime.JunoBTTask_ReactToVerb
// 0x0008 (0x0088 - 0x0080)
class UJunoBTTask_ReactToVerb final : public UFortAthenaBTTask_ReactToVerb
{
public:
	class FName                                   MoodReactionTagKeyName;                            // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBTTask_ReactToVerb">();
	}
	static class UJunoBTTask_ReactToVerb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBTTask_ReactToVerb>();
	}
};
static_assert(alignof(UJunoBTTask_ReactToVerb) == 0x000008, "Wrong alignment on UJunoBTTask_ReactToVerb");
static_assert(sizeof(UJunoBTTask_ReactToVerb) == 0x000088, "Wrong size on UJunoBTTask_ReactToVerb");
static_assert(offsetof(UJunoBTTask_ReactToVerb, MoodReactionTagKeyName) == 0x000080, "Member 'UJunoBTTask_ReactToVerb::MoodReactionTagKeyName' has a wrong offset!");

// Class JunoAIRuntime.JunoBTTask_RunMoodReaction
// 0x0010 (0x0080 - 0x0070)
class UJunoBTTask_RunMoodReaction final : public UBTTaskNode
{
public:
	TArray<struct FRandomizedMoodReactionConfig>  PossibleMoodReactions;                             // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoBTTask_RunMoodReaction">();
	}
	static class UJunoBTTask_RunMoodReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoBTTask_RunMoodReaction>();
	}
};
static_assert(alignof(UJunoBTTask_RunMoodReaction) == 0x000008, "Wrong alignment on UJunoBTTask_RunMoodReaction");
static_assert(sizeof(UJunoBTTask_RunMoodReaction) == 0x000080, "Wrong size on UJunoBTTask_RunMoodReaction");
static_assert(offsetof(UJunoBTTask_RunMoodReaction, PossibleMoodReactions) == 0x000070, "Member 'UJunoBTTask_RunMoodReaction::PossibleMoodReactions' has a wrong offset!");

// Class JunoAIRuntime.FJunoAICampManagementVisitorWorldConditionSchema
// 0x0000 (0x0040 - 0x0040)
class UFJunoAICampManagementVisitorWorldConditionSchema final : public UJunoCampWorldConditionSchema
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FJunoAICampManagementVisitorWorldConditionSchema">();
	}
	static class UFJunoAICampManagementVisitorWorldConditionSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFJunoAICampManagementVisitorWorldConditionSchema>();
	}
};
static_assert(alignof(UFJunoAICampManagementVisitorWorldConditionSchema) == 0x000008, "Wrong alignment on UFJunoAICampManagementVisitorWorldConditionSchema");
static_assert(sizeof(UFJunoAICampManagementVisitorWorldConditionSchema) == 0x000040, "Wrong size on UFJunoAICampManagementVisitorWorldConditionSchema");

// Class JunoAIRuntime.JunoAICampManagementRewardsWorldConditionSchema
// 0x0000 (0x0040 - 0x0040)
class UJunoAICampManagementRewardsWorldConditionSchema final : public UJunoCampWorldConditionSchema
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAICampManagementRewardsWorldConditionSchema">();
	}
	static class UJunoAICampManagementRewardsWorldConditionSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAICampManagementRewardsWorldConditionSchema>();
	}
};
static_assert(alignof(UJunoAICampManagementRewardsWorldConditionSchema) == 0x000008, "Wrong alignment on UJunoAICampManagementRewardsWorldConditionSchema");
static_assert(sizeof(UJunoAICampManagementRewardsWorldConditionSchema) == 0x000040, "Wrong size on UJunoAICampManagementRewardsWorldConditionSchema");

// Class JunoAIRuntime.JunoCampAIManagementComponent
// 0x0728 (0x07C8 - 0x00A0)
class UJunoCampAIManagementComponent final : public UJunoCampComponentBase
{
public:
	uint8                                         Pad_A0[0x118];                                     // 0x00A0(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IFortAthenaLivingWorldPointProviderInterface>> PointProviders;                                    // 0x01B8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UFortAthenaLivingWorldEncounterInstance* Encounter;                                         // 0x01C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJunoAICampManagementVisitorsConfigurationDigested VisitorsConfigurationDigested;                     // 0x01D0(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FJunoAICampManagementVisitorsPickingConfiguration CachedVisitorsPickingConfigurationAtCurrentAwesomenessLevel; // 0x01E8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJunoAICampManagementLWMConfiguration  LWMConfiguration;                                  // 0x0210(0x03A0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FJunoAICampManagementVisitorsConfiguration VisitorsConfiguration;                             // 0x05B0(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FDataTableRowHandle>       AwesomenessLevelToVisitorsPickingConfiguration;    // 0x05E0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UDataTable*>                AwesomenessLevelToNPCRewards;                      // 0x0630(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FScalableFloat                         InitialIngameHoursDelayBeforeFirstRewardRoll;      // 0x0680(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinimumIngameHoursBetweenRewardRolls;              // 0x06A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PassiveResourceGatheringTime;                      // 0x06D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MultiplierForSimulatedGeneration;                  // 0x06F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaximumAllocableSOPerAIForSimulation;              // 0x0720(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FNavAgentSelector                      SupportedAgents;                                   // 0x0748(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_74C[0x4];                                      // 0x074C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ShouldCheckWCForRemoteRecruitment;                 // 0x0750(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RequireNPCToBeInVisitorsListForRemoteRecruitment;  // 0x0778(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SpawnDelayFromCampSpawn;                           // 0x07A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCampAIManagementComponent">();
	}
	static class UJunoCampAIManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCampAIManagementComponent>();
	}
};
static_assert(alignof(UJunoCampAIManagementComponent) == 0x000008, "Wrong alignment on UJunoCampAIManagementComponent");
static_assert(sizeof(UJunoCampAIManagementComponent) == 0x0007C8, "Wrong size on UJunoCampAIManagementComponent");
static_assert(offsetof(UJunoCampAIManagementComponent, PointProviders) == 0x0001B8, "Member 'UJunoCampAIManagementComponent::PointProviders' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, Encounter) == 0x0001C8, "Member 'UJunoCampAIManagementComponent::Encounter' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, VisitorsConfigurationDigested) == 0x0001D0, "Member 'UJunoCampAIManagementComponent::VisitorsConfigurationDigested' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, CachedVisitorsPickingConfigurationAtCurrentAwesomenessLevel) == 0x0001E8, "Member 'UJunoCampAIManagementComponent::CachedVisitorsPickingConfigurationAtCurrentAwesomenessLevel' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, LWMConfiguration) == 0x000210, "Member 'UJunoCampAIManagementComponent::LWMConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, VisitorsConfiguration) == 0x0005B0, "Member 'UJunoCampAIManagementComponent::VisitorsConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, AwesomenessLevelToVisitorsPickingConfiguration) == 0x0005E0, "Member 'UJunoCampAIManagementComponent::AwesomenessLevelToVisitorsPickingConfiguration' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, AwesomenessLevelToNPCRewards) == 0x000630, "Member 'UJunoCampAIManagementComponent::AwesomenessLevelToNPCRewards' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, InitialIngameHoursDelayBeforeFirstRewardRoll) == 0x000680, "Member 'UJunoCampAIManagementComponent::InitialIngameHoursDelayBeforeFirstRewardRoll' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, MinimumIngameHoursBetweenRewardRolls) == 0x0006A8, "Member 'UJunoCampAIManagementComponent::MinimumIngameHoursBetweenRewardRolls' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, PassiveResourceGatheringTime) == 0x0006D0, "Member 'UJunoCampAIManagementComponent::PassiveResourceGatheringTime' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, MultiplierForSimulatedGeneration) == 0x0006F8, "Member 'UJunoCampAIManagementComponent::MultiplierForSimulatedGeneration' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, MaximumAllocableSOPerAIForSimulation) == 0x000720, "Member 'UJunoCampAIManagementComponent::MaximumAllocableSOPerAIForSimulation' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, SupportedAgents) == 0x000748, "Member 'UJunoCampAIManagementComponent::SupportedAgents' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, ShouldCheckWCForRemoteRecruitment) == 0x000750, "Member 'UJunoCampAIManagementComponent::ShouldCheckWCForRemoteRecruitment' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, RequireNPCToBeInVisitorsListForRemoteRecruitment) == 0x000778, "Member 'UJunoCampAIManagementComponent::RequireNPCToBeInVisitorsListForRemoteRecruitment' has a wrong offset!");
static_assert(offsetof(UJunoCampAIManagementComponent, SpawnDelayFromCampSpawn) == 0x0007A0, "Member 'UJunoCampAIManagementComponent::SpawnDelayFromCampSpawn' has a wrong offset!");

// Class JunoAIRuntime.JunoCaveLivingWorldEventData
// 0x0058 (0x01A8 - 0x0150)
class UJunoCaveLivingWorldEventData final : public UFortAthenaLivingWorldEventData
{
public:
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         CaveRoomDistanceMin;                               // 0x0158(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CaveRoomDistanceMax;                               // 0x0180(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoCaveLivingWorldEventData">();
	}
	static class UJunoCaveLivingWorldEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoCaveLivingWorldEventData>();
	}
};
static_assert(alignof(UJunoCaveLivingWorldEventData) == 0x000008, "Wrong alignment on UJunoCaveLivingWorldEventData");
static_assert(sizeof(UJunoCaveLivingWorldEventData) == 0x0001A8, "Wrong size on UJunoCaveLivingWorldEventData");
static_assert(offsetof(UJunoCaveLivingWorldEventData, CaveRoomDistanceMin) == 0x000158, "Member 'UJunoCaveLivingWorldEventData::CaveRoomDistanceMin' has a wrong offset!");
static_assert(offsetof(UJunoCaveLivingWorldEventData, CaveRoomDistanceMax) == 0x000180, "Member 'UJunoCaveLivingWorldEventData::CaveRoomDistanceMax' has a wrong offset!");

// Class JunoAIRuntime.JunoAIFTUEEndWorldConditionSchema
// 0x0000 (0x0038 - 0x0038)
class UJunoAIFTUEEndWorldConditionSchema final : public UWorldConditionSchema
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIFTUEEndWorldConditionSchema">();
	}
	static class UJunoAIFTUEEndWorldConditionSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIFTUEEndWorldConditionSchema>();
	}
};
static_assert(alignof(UJunoAIFTUEEndWorldConditionSchema) == 0x000008, "Wrong alignment on UJunoAIFTUEEndWorldConditionSchema");
static_assert(sizeof(UJunoAIFTUEEndWorldConditionSchema) == 0x000038, "Wrong size on UJunoAIFTUEEndWorldConditionSchema");

// Class JunoAIRuntime.PlayspaceComponent_Root_JunoAIManagement
// 0x0E60 (0x0F58 - 0x00F8)
class UPlayspaceComponent_Root_JunoAIManagement final : public UFortPlayspaceComponent
{
public:
	struct FJunoAIFollowerLWMConfiguration        LWMConfiguration;                                  // 0x00F8(0x03A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FJunoAITemporaryGlobalEncounterLWMConfiguration TemporaryGlobalEncounterLWMConfiguration;          // 0x0498(0x0398)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FJunoAIFTUEConfiguration               FTUEConfiguration;                                 // 0x0830(0x0480)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxNoInteractionTimeBeforeSoftRemovalInJunoGameTimeHours; // 0x0CB0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeBeforeSoftRemovedAIBecomesHardRemovedInJunoGameTimeHours; // 0x0CD8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeToRemoveStaleFollowersFromDisconnectedPlayersInRealHours; // 0x0D00(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         SecondsToWaitBeforeRemovingStaleFollowers;         // 0x0D28(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         GlobalRecruitableNPCsCap;                          // 0x0D50(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D78[0x20];                                     // 0x0D78(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJunoAIFollowerManagedData>     ManagedFollowers;                                  // 0x0D98(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TScriptInterface<class IFortAthenaLivingWorldPointProviderInterface> TemporaryGlobalEncounterPointProvider;             // 0x0DA8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaLivingWorldEncounterInstance* TemporaryGlobalEncounter;                          // 0x0DB8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IFortAthenaLivingWorldPointProviderInterface> FTUEEncounterPointProvider;                        // 0x0DC0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaLivingWorldEncounterInstance* FTUEEncounter;                                     // 0x0DD0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWorldConditionQueryState              FTUEEndQueryState;                                 // 0x0DD8(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E08[0xB0];                                     // 0x0E08(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FJunoAIWorldNPCSpawningData> WorldAssignedNPCs;                                 // 0x0EB8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F08[0x50];                                     // 0x0F08(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleFTUENPCSpawned(const class AActor* FTUENPC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceComponent_Root_JunoAIManagement">();
	}
	static class UPlayspaceComponent_Root_JunoAIManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceComponent_Root_JunoAIManagement>();
	}
};
static_assert(alignof(UPlayspaceComponent_Root_JunoAIManagement) == 0x000008, "Wrong alignment on UPlayspaceComponent_Root_JunoAIManagement");
static_assert(sizeof(UPlayspaceComponent_Root_JunoAIManagement) == 0x000F58, "Wrong size on UPlayspaceComponent_Root_JunoAIManagement");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, LWMConfiguration) == 0x0000F8, "Member 'UPlayspaceComponent_Root_JunoAIManagement::LWMConfiguration' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, TemporaryGlobalEncounterLWMConfiguration) == 0x000498, "Member 'UPlayspaceComponent_Root_JunoAIManagement::TemporaryGlobalEncounterLWMConfiguration' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, FTUEConfiguration) == 0x000830, "Member 'UPlayspaceComponent_Root_JunoAIManagement::FTUEConfiguration' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, MaxNoInteractionTimeBeforeSoftRemovalInJunoGameTimeHours) == 0x000CB0, "Member 'UPlayspaceComponent_Root_JunoAIManagement::MaxNoInteractionTimeBeforeSoftRemovalInJunoGameTimeHours' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, TimeBeforeSoftRemovedAIBecomesHardRemovedInJunoGameTimeHours) == 0x000CD8, "Member 'UPlayspaceComponent_Root_JunoAIManagement::TimeBeforeSoftRemovedAIBecomesHardRemovedInJunoGameTimeHours' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, TimeToRemoveStaleFollowersFromDisconnectedPlayersInRealHours) == 0x000D00, "Member 'UPlayspaceComponent_Root_JunoAIManagement::TimeToRemoveStaleFollowersFromDisconnectedPlayersInRealHours' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, SecondsToWaitBeforeRemovingStaleFollowers) == 0x000D28, "Member 'UPlayspaceComponent_Root_JunoAIManagement::SecondsToWaitBeforeRemovingStaleFollowers' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, GlobalRecruitableNPCsCap) == 0x000D50, "Member 'UPlayspaceComponent_Root_JunoAIManagement::GlobalRecruitableNPCsCap' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, ManagedFollowers) == 0x000D98, "Member 'UPlayspaceComponent_Root_JunoAIManagement::ManagedFollowers' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, TemporaryGlobalEncounterPointProvider) == 0x000DA8, "Member 'UPlayspaceComponent_Root_JunoAIManagement::TemporaryGlobalEncounterPointProvider' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, TemporaryGlobalEncounter) == 0x000DB8, "Member 'UPlayspaceComponent_Root_JunoAIManagement::TemporaryGlobalEncounter' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, FTUEEncounterPointProvider) == 0x000DC0, "Member 'UPlayspaceComponent_Root_JunoAIManagement::FTUEEncounterPointProvider' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, FTUEEncounter) == 0x000DD0, "Member 'UPlayspaceComponent_Root_JunoAIManagement::FTUEEncounter' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, FTUEEndQueryState) == 0x000DD8, "Member 'UPlayspaceComponent_Root_JunoAIManagement::FTUEEndQueryState' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_Root_JunoAIManagement, WorldAssignedNPCs) == 0x000EB8, "Member 'UPlayspaceComponent_Root_JunoAIManagement::WorldAssignedNPCs' has a wrong offset!");

// Class JunoAIRuntime.JunoAISafetyBubbleComponent
// 0x00A8 (0x0148 - 0x00A0)
class UJunoAISafetyBubbleComponent final : public UActorComponent
{
public:
	TArray<struct FFortAthenaLivingWorldEventTagDensityRegistration> TagsData;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         InGameHoursDuration;                               // 0x00B0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SafetyBubbleRadius;                                // 0x00D8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x48];                                     // 0x0100(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTimeOfDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAISafetyBubbleComponent">();
	}
	static class UJunoAISafetyBubbleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAISafetyBubbleComponent>();
	}
};
static_assert(alignof(UJunoAISafetyBubbleComponent) == 0x000008, "Wrong alignment on UJunoAISafetyBubbleComponent");
static_assert(sizeof(UJunoAISafetyBubbleComponent) == 0x000148, "Wrong size on UJunoAISafetyBubbleComponent");
static_assert(offsetof(UJunoAISafetyBubbleComponent, TagsData) == 0x0000A0, "Member 'UJunoAISafetyBubbleComponent::TagsData' has a wrong offset!");
static_assert(offsetof(UJunoAISafetyBubbleComponent, InGameHoursDuration) == 0x0000B0, "Member 'UJunoAISafetyBubbleComponent::InGameHoursDuration' has a wrong offset!");
static_assert(offsetof(UJunoAISafetyBubbleComponent, SafetyBubbleRadius) == 0x0000D8, "Member 'UJunoAISafetyBubbleComponent::SafetyBubbleRadius' has a wrong offset!");

// Class JunoAIRuntime.EnvQueryTest_JunoIsNearBuilding
// 0x00A0 (0x0298 - 0x01F8)
class UEnvQueryTest_JunoIsNearBuilding final : public UEnvQueryTest
{
public:
	struct FEnvOverlapData                        OverlapData;                                       // 0x01F8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               GenerateOnlyInsideClusterBounds;                   // 0x0228(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MinimumBuildingClusterVolume;                      // 0x0260(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_JunoIsNearBuilding">();
	}
	static class UEnvQueryTest_JunoIsNearBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_JunoIsNearBuilding>();
	}
};
static_assert(alignof(UEnvQueryTest_JunoIsNearBuilding) == 0x000008, "Wrong alignment on UEnvQueryTest_JunoIsNearBuilding");
static_assert(sizeof(UEnvQueryTest_JunoIsNearBuilding) == 0x000298, "Wrong size on UEnvQueryTest_JunoIsNearBuilding");
static_assert(offsetof(UEnvQueryTest_JunoIsNearBuilding, OverlapData) == 0x0001F8, "Member 'UEnvQueryTest_JunoIsNearBuilding::OverlapData' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_JunoIsNearBuilding, GenerateOnlyInsideClusterBounds) == 0x000228, "Member 'UEnvQueryTest_JunoIsNearBuilding::GenerateOnlyInsideClusterBounds' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_JunoIsNearBuilding, MinimumBuildingClusterVolume) == 0x000260, "Member 'UEnvQueryTest_JunoIsNearBuilding::MinimumBuildingClusterVolume' has a wrong offset!");

// Class JunoAIRuntime.EnvQueryTest_JunoIsUnderCeiling
// 0x0068 (0x0260 - 0x01F8)
class UEnvQueryTest_JunoIsUnderCeiling final : public UEnvQueryTest
{
public:
	struct FEnvOverlapData                        SweepData;                                         // 0x01F8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SweepHeight;                                       // 0x0228(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_JunoIsUnderCeiling">();
	}
	static class UEnvQueryTest_JunoIsUnderCeiling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_JunoIsUnderCeiling>();
	}
};
static_assert(alignof(UEnvQueryTest_JunoIsUnderCeiling) == 0x000008, "Wrong alignment on UEnvQueryTest_JunoIsUnderCeiling");
static_assert(sizeof(UEnvQueryTest_JunoIsUnderCeiling) == 0x000260, "Wrong size on UEnvQueryTest_JunoIsUnderCeiling");
static_assert(offsetof(UEnvQueryTest_JunoIsUnderCeiling, SweepData) == 0x0001F8, "Member 'UEnvQueryTest_JunoIsUnderCeiling::SweepData' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_JunoIsUnderCeiling, SweepHeight) == 0x000228, "Member 'UEnvQueryTest_JunoIsUnderCeiling::SweepHeight' has a wrong offset!");

// Class JunoAIRuntime.JunoAIBotEvaluator_ReactToVerb
// 0x0010 (0x0400 - 0x03F0)
class UJunoAIBotEvaluator_ReactToVerb final : public UFortAthenaAIBotEvaluator_ReactToVerb
{
public:
	class FName                                   MoodReactionTagKeyName;                            // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0xC];                                      // 0x03F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAIBotEvaluator_ReactToVerb">();
	}
	static class UJunoAIBotEvaluator_ReactToVerb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAIBotEvaluator_ReactToVerb>();
	}
};
static_assert(alignof(UJunoAIBotEvaluator_ReactToVerb) == 0x000010, "Wrong alignment on UJunoAIBotEvaluator_ReactToVerb");
static_assert(sizeof(UJunoAIBotEvaluator_ReactToVerb) == 0x000400, "Wrong size on UJunoAIBotEvaluator_ReactToVerb");
static_assert(offsetof(UJunoAIBotEvaluator_ReactToVerb, MoodReactionTagKeyName) == 0x0003F0, "Member 'UJunoAIBotEvaluator_ReactToVerb::MoodReactionTagKeyName' has a wrong offset!");

// Class JunoAIRuntime.JunoAICheatManager
// 0x0000 (0x0028 - 0x0028)
class UJunoAICheatManager final : public UChildCheatManager
{
public:
	void JunoEnableFriendlyCreatures(bool bEnable);
	void JunoEnableFriendlyNPCs(bool bEnable);
	void JunoEnableHostileCreatures(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoAICheatManager">();
	}
	static class UJunoAICheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoAICheatManager>();
	}
};
static_assert(alignof(UJunoAICheatManager) == 0x000008, "Wrong alignment on UJunoAICheatManager");
static_assert(sizeof(UJunoAICheatManager) == 0x000028, "Wrong size on UJunoAICheatManager");

// Class JunoAIRuntime.PlayspaceComponent_JunoAISafetyBubble
// 0x0010 (0x0108 - 0x00F8)
class UPlayspaceComponent_JunoAISafetyBubble final : public UFortPlayspaceComponent
{
public:
	TSubclassOf<class UJunoAISafetyBubbleComponent> SafetyBubbleComponent;                             // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPreventSafetyBubbleInCamp;                        // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceComponent_JunoAISafetyBubble">();
	}
	static class UPlayspaceComponent_JunoAISafetyBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceComponent_JunoAISafetyBubble>();
	}
};
static_assert(alignof(UPlayspaceComponent_JunoAISafetyBubble) == 0x000008, "Wrong alignment on UPlayspaceComponent_JunoAISafetyBubble");
static_assert(sizeof(UPlayspaceComponent_JunoAISafetyBubble) == 0x000108, "Wrong size on UPlayspaceComponent_JunoAISafetyBubble");
static_assert(offsetof(UPlayspaceComponent_JunoAISafetyBubble, SafetyBubbleComponent) == 0x0000F8, "Member 'UPlayspaceComponent_JunoAISafetyBubble::SafetyBubbleComponent' has a wrong offset!");
static_assert(offsetof(UPlayspaceComponent_JunoAISafetyBubble, bPreventSafetyBubbleInCamp) == 0x000100, "Member 'UPlayspaceComponent_JunoAISafetyBubble::bPreventSafetyBubbleInCamp' has a wrong offset!");

// Class JunoAIRuntime.AITask_JunoMoveTo
// 0x0018 (0x0130 - 0x0118)
class UAITask_JunoMoveTo final : public UAITask_MoveTo
{
public:
	struct FJunoMoveConfig                        MoveConfig;                                        // 0x0118(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  BlockedByActor;                                    // 0x0124(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITask_JunoMoveTo">();
	}
	static class UAITask_JunoMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITask_JunoMoveTo>();
	}
};
static_assert(alignof(UAITask_JunoMoveTo) == 0x000008, "Wrong alignment on UAITask_JunoMoveTo");
static_assert(sizeof(UAITask_JunoMoveTo) == 0x000130, "Wrong size on UAITask_JunoMoveTo");
static_assert(offsetof(UAITask_JunoMoveTo, MoveConfig) == 0x000118, "Member 'UAITask_JunoMoveTo::MoveConfig' has a wrong offset!");
static_assert(offsetof(UAITask_JunoMoveTo, BlockedByActor) == 0x000124, "Member 'UAITask_JunoMoveTo::BlockedByActor' has a wrong offset!");

// Class JunoAIRuntime.BTTask_JunoMoveTo
// 0x00B8 (0x0178 - 0x00C0)
class UBTTask_JunoMoveTo final : public UFortAthenaBTTask_MoveTo
{
public:
	uint8                                         bOnUnreachableGoalFindBlockingBuilding : 1;        // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAssignFoundBlockingBuildingAsTarget : 1;          // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BlockingBuildingTraceDistance;                     // 0x00C8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         BlockingBuildingTraceCooldown;                     // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BlockedByBuildingKeySelector;                      // 0x0118(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 LastBlockingBuildingTraceTimeKeySelector;          // 0x0140(0x0028)(Edit, NativeAccessSpecifierPublic)
	EPathObstacleAction                           PathObstacleAction;                                // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bApplyCostLimit : 1;                               // 0x016C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathingCostLimitFactor;                            // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathingMinimumCostLimit;                           // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_JunoMoveTo">();
	}
	static class UBTTask_JunoMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_JunoMoveTo>();
	}
};
static_assert(alignof(UBTTask_JunoMoveTo) == 0x000008, "Wrong alignment on UBTTask_JunoMoveTo");
static_assert(sizeof(UBTTask_JunoMoveTo) == 0x000178, "Wrong size on UBTTask_JunoMoveTo");
static_assert(offsetof(UBTTask_JunoMoveTo, BlockingBuildingTraceDistance) == 0x0000C8, "Member 'UBTTask_JunoMoveTo::BlockingBuildingTraceDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_JunoMoveTo, BlockingBuildingTraceCooldown) == 0x0000F0, "Member 'UBTTask_JunoMoveTo::BlockingBuildingTraceCooldown' has a wrong offset!");
static_assert(offsetof(UBTTask_JunoMoveTo, BlockedByBuildingKeySelector) == 0x000118, "Member 'UBTTask_JunoMoveTo::BlockedByBuildingKeySelector' has a wrong offset!");
static_assert(offsetof(UBTTask_JunoMoveTo, LastBlockingBuildingTraceTimeKeySelector) == 0x000140, "Member 'UBTTask_JunoMoveTo::LastBlockingBuildingTraceTimeKeySelector' has a wrong offset!");
static_assert(offsetof(UBTTask_JunoMoveTo, PathObstacleAction) == 0x000168, "Member 'UBTTask_JunoMoveTo::PathObstacleAction' has a wrong offset!");
static_assert(offsetof(UBTTask_JunoMoveTo, PathingCostLimitFactor) == 0x000170, "Member 'UBTTask_JunoMoveTo::PathingCostLimitFactor' has a wrong offset!");
static_assert(offsetof(UBTTask_JunoMoveTo, PathingMinimumCostLimit) == 0x000174, "Member 'UBTTask_JunoMoveTo::PathingMinimumCostLimit' has a wrong offset!");

// Class JunoAIRuntime.JunoWorldCondition_AIWorldSettings_State
// 0x0028 (0x0050 - 0x0028)
class UJunoWorldCondition_AIWorldSettings_State final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JunoWorldCondition_AIWorldSettings_State">();
	}
	static class UJunoWorldCondition_AIWorldSettings_State* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJunoWorldCondition_AIWorldSettings_State>();
	}
};
static_assert(alignof(UJunoWorldCondition_AIWorldSettings_State) == 0x000008, "Wrong alignment on UJunoWorldCondition_AIWorldSettings_State");
static_assert(sizeof(UJunoWorldCondition_AIWorldSettings_State) == 0x000050, "Wrong size on UJunoWorldCondition_AIWorldSettings_State");

}

