#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GrappleWeaponRuntime

#include "Basic.hpp"

#include "FortniteGame_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "MantisRuntime_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class GrappleWeaponRuntime.CustomCharacterPartAnimInstance_GrappleHook
// 0x0020 (0x0740 - 0x0720)
class UCustomCharacterPartAnimInstance_GrappleHook final : public UCustomCharacterPartAnimInstance
{
public:
	bool                                          IsFired;                                           // 0x0720(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DistanceBucket;                                    // 0x0724(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttackAir;                                   // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttack_1;                                    // 0x0729(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttack_2;                                    // 0x072A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttack_3;                                    // 0x072B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttack_4;                                    // 0x072C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAttackFromCast;                                  // 0x072D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHookFireShort;                                   // 0x072E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHookFireMid;                                     // 0x072F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHookFireLong;                                    // 0x0730(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_731[0xF];                                      // 0x0731(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPartAnimInstance_GrappleHook">();
	}
	static class UCustomCharacterPartAnimInstance_GrappleHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterPartAnimInstance_GrappleHook>();
	}
};
static_assert(alignof(UCustomCharacterPartAnimInstance_GrappleHook) == 0x000010, "Wrong alignment on UCustomCharacterPartAnimInstance_GrappleHook");
static_assert(sizeof(UCustomCharacterPartAnimInstance_GrappleHook) == 0x000740, "Wrong size on UCustomCharacterPartAnimInstance_GrappleHook");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, IsFired) == 0x000720, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::IsFired' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, DistanceBucket) == 0x000724, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::DistanceBucket' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, MantisAttackAir) == 0x000728, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::MantisAttackAir' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, MantisAttack_1) == 0x000729, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::MantisAttack_1' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, MantisAttack_2) == 0x00072A, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::MantisAttack_2' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, MantisAttack_3) == 0x00072B, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::MantisAttack_3' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, MantisAttack_4) == 0x00072C, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::MantisAttack_4' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, IsAttackFromCast) == 0x00072D, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::IsAttackFromCast' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, IsHookFireShort) == 0x00072E, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::IsHookFireShort' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, IsHookFireMid) == 0x00072F, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::IsHookFireMid' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance_GrappleHook, IsHookFireLong) == 0x000730, "Member 'UCustomCharacterPartAnimInstance_GrappleHook::IsHookFireLong' has a wrong offset!");

// Class GrappleWeaponRuntime.GrappleKnifeLayerAnimInstance
// 0x0020 (0x1650 - 0x1630)
class UGrappleKnifeLayerAnimInstance final : public UFortMantisLayerAnimInstance
{
public:
	bool                                          bIsAttached;                                       // 0x1630(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFired;                                          // 0x1631(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimStartWallBounce;                              // 0x1632(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1633[0x1];                                     // 0x1633(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PawnRotationRateYaw;                               // 0x1634(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBounceAngle;                                   // 0x1638(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFireOnMotorBike;                                // 0x163C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExitUnexpectedly;                               // 0x163D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCastInAir;                                      // 0x163E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCastUpperbody;                                  // 0x163F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCastGroundIdle;                                 // 0x1640(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCastGroundLoco;                                 // 0x1641(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceBucketIs0;                                // 0x1642(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceBucketIs2;                                // 0x1643(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExitGround;                                     // 0x1644(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExitWallBounce;                                 // 0x1645(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExitZipAirStart;                                // 0x1646(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1647[0x9];                                     // 0x1647(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrappleKnifeLayerAnimInstance">();
	}
	static class UGrappleKnifeLayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrappleKnifeLayerAnimInstance>();
	}
};
static_assert(alignof(UGrappleKnifeLayerAnimInstance) == 0x000010, "Wrong alignment on UGrappleKnifeLayerAnimInstance");
static_assert(sizeof(UGrappleKnifeLayerAnimInstance) == 0x001650, "Wrong size on UGrappleKnifeLayerAnimInstance");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsAttached) == 0x001630, "Member 'UGrappleKnifeLayerAnimInstance::bIsAttached' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsFired) == 0x001631, "Member 'UGrappleKnifeLayerAnimInstance::bIsFired' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bAnimStartWallBounce) == 0x001632, "Member 'UGrappleKnifeLayerAnimInstance::bAnimStartWallBounce' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, PawnRotationRateYaw) == 0x001634, "Member 'UGrappleKnifeLayerAnimInstance::PawnRotationRateYaw' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, AnimBounceAngle) == 0x001638, "Member 'UGrappleKnifeLayerAnimInstance::AnimBounceAngle' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsFireOnMotorBike) == 0x00163C, "Member 'UGrappleKnifeLayerAnimInstance::bIsFireOnMotorBike' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsExitUnexpectedly) == 0x00163D, "Member 'UGrappleKnifeLayerAnimInstance::bIsExitUnexpectedly' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsCastInAir) == 0x00163E, "Member 'UGrappleKnifeLayerAnimInstance::bIsCastInAir' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsCastUpperbody) == 0x00163F, "Member 'UGrappleKnifeLayerAnimInstance::bIsCastUpperbody' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsCastGroundIdle) == 0x001640, "Member 'UGrappleKnifeLayerAnimInstance::bIsCastGroundIdle' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsCastGroundLoco) == 0x001641, "Member 'UGrappleKnifeLayerAnimInstance::bIsCastGroundLoco' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bDistanceBucketIs0) == 0x001642, "Member 'UGrappleKnifeLayerAnimInstance::bDistanceBucketIs0' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bDistanceBucketIs2) == 0x001643, "Member 'UGrappleKnifeLayerAnimInstance::bDistanceBucketIs2' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsExitGround) == 0x001644, "Member 'UGrappleKnifeLayerAnimInstance::bIsExitGround' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsExitWallBounce) == 0x001645, "Member 'UGrappleKnifeLayerAnimInstance::bIsExitWallBounce' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeLayerAnimInstance, bIsExitZipAirStart) == 0x001646, "Member 'UGrappleKnifeLayerAnimInstance::bIsExitZipAirStart' has a wrong offset!");

// Class GrappleWeaponRuntime.GrappleKnifeWeaponAnimInstance
// 0x0000 (0x0470 - 0x0470)
class UGrappleKnifeWeaponAnimInstance final : public UFortMantisAnimInstance
{
public:
	bool                                          MantisAttackAir;                                   // 0x0468(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttack_1;                                    // 0x0469(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttack_2;                                    // 0x046A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttack_3;                                    // 0x046B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MantisAttack_4;                                    // 0x046C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrappleKnifeWeaponAnimInstance">();
	}
	static class UGrappleKnifeWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrappleKnifeWeaponAnimInstance>();
	}
};
static_assert(alignof(UGrappleKnifeWeaponAnimInstance) == 0x000010, "Wrong alignment on UGrappleKnifeWeaponAnimInstance");
static_assert(sizeof(UGrappleKnifeWeaponAnimInstance) == 0x000470, "Wrong size on UGrappleKnifeWeaponAnimInstance");
static_assert(offsetof(UGrappleKnifeWeaponAnimInstance, MantisAttackAir) == 0x000468, "Member 'UGrappleKnifeWeaponAnimInstance::MantisAttackAir' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeWeaponAnimInstance, MantisAttack_1) == 0x000469, "Member 'UGrappleKnifeWeaponAnimInstance::MantisAttack_1' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeWeaponAnimInstance, MantisAttack_2) == 0x00046A, "Member 'UGrappleKnifeWeaponAnimInstance::MantisAttack_2' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeWeaponAnimInstance, MantisAttack_3) == 0x00046B, "Member 'UGrappleKnifeWeaponAnimInstance::MantisAttack_3' has a wrong offset!");
static_assert(offsetof(UGrappleKnifeWeaponAnimInstance, MantisAttack_4) == 0x00046C, "Member 'UGrappleKnifeWeaponAnimInstance::MantisAttack_4' has a wrong offset!");

// Class GrappleWeaponRuntime.GrappleKnifeWeaponInterface
// 0x0000 (0x0028 - 0x0028)
class IGrappleKnifeWeaponInterface final : public IInterface
{
public:
	void GetGrappleKnifeData(bool* bIsAttached, bool* bIsFired, int32* DistanceBucket, bool* bAnimStartWallBounce, float* AnimBounceAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrappleKnifeWeaponInterface">();
	}
	static class IGrappleKnifeWeaponInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGrappleKnifeWeaponInterface>();
	}
};
static_assert(alignof(IGrappleKnifeWeaponInterface) == 0x000008, "Wrong alignment on IGrappleKnifeWeaponInterface");
static_assert(sizeof(IGrappleKnifeWeaponInterface) == 0x000028, "Wrong size on IGrappleKnifeWeaponInterface");

// Class GrappleWeaponRuntime.GrappleWeaponLibrary
// 0x0000 (0x0028 - 0x0028)
class UGrappleWeaponLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector CalculateDirectionalTargetOffset(const struct FVector& DirToTarget, const struct FVector& MovementOffset, const struct FVector& LedgeOffset);
	static void DidHitResultImpactLedge(class ACharacter* SourceCharacter, const struct FHitResult& HitResult, const struct FGrappleWeaponLedgeConfig& Config, bool* OutDidImpactWalkableSurface, bool* OutTargetingLedge, struct FVector* OutLedgeLocation, bool bDrawDebug);
	static struct FGrappleWeaponTargetInfo GetGrappleWeaponTargetInfo(class AFortPlayerPawn* SourcePlayerPawn, const struct FGrappleWeaponTargetingConfig& Config, float DrawDebugDuration);
	static void IsTargetingLedge(class ACharacter* SourceCharacter, const class AActor* TargetActor, const struct FVector& TargetLocation, const struct FVector& TargetNormal, const struct FGrappleWeaponLedgeConfig& Config, bool* OutDidImpactWalkableSurface, bool* OutTargetingLedge, struct FVector* OutLedgeLocation, bool bDrawDebug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrappleWeaponLibrary">();
	}
	static class UGrappleWeaponLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrappleWeaponLibrary>();
	}
};
static_assert(alignof(UGrappleWeaponLibrary) == 0x000008, "Wrong alignment on UGrappleWeaponLibrary");
static_assert(sizeof(UGrappleWeaponLibrary) == 0x000028, "Wrong size on UGrappleWeaponLibrary");

}

