#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DelMarCore

#include "Basic.hpp"

#include "DelMarCore_structs.hpp"
#include "ModularGameplay_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CosmeticsFrameworkLoadouts_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "VehicleCosmeticsAudioRuntime_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "FortniteAI_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DelMarTrackRuntime_classes.hpp"
#include "EnhancedInput_classes.hpp"
#include "VehicleCosmeticsRuntime_classes.hpp"
#include "GameFeatures_classes.hpp"
#include "AudioGameplay_classes.hpp"
#include "LinkId_structs.hpp"
#include "PlayspaceSystem_classes.hpp"


namespace SDK
{

// Class DelMarCore.DelMarActorMover
// 0x0040 (0x0C18 - 0x0BD8)
class ADelMarActorMover final : public AFortCreativeDeviceProp
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0BD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       MovementSpline;                                    // 0x0BE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarSplineMovementType                     MovementType;                                      // 0x0BE8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE9[0x7];                                      // 0x0BE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ManagedActor;                                      // 0x0BF0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarSplineActorMovementComponent*    SplineMovementComponent;                           // 0x0BF8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C00[0x10];                                     // 0x0C00(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerMovementStartTime;                           // 0x0C10(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C14[0x4];                                      // 0x0C14(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeMovement();
	void OnRep_ServerStartTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarActorMover">();
	}
	static class ADelMarActorMover* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarActorMover>();
	}
};
static_assert(alignof(ADelMarActorMover) == 0x000008, "Wrong alignment on ADelMarActorMover");
static_assert(sizeof(ADelMarActorMover) == 0x000C18, "Wrong size on ADelMarActorMover");
static_assert(offsetof(ADelMarActorMover, ActorClass) == 0x000BD8, "Member 'ADelMarActorMover::ActorClass' has a wrong offset!");
static_assert(offsetof(ADelMarActorMover, MovementSpline) == 0x000BE0, "Member 'ADelMarActorMover::MovementSpline' has a wrong offset!");
static_assert(offsetof(ADelMarActorMover, MovementType) == 0x000BE8, "Member 'ADelMarActorMover::MovementType' has a wrong offset!");
static_assert(offsetof(ADelMarActorMover, ManagedActor) == 0x000BF0, "Member 'ADelMarActorMover::ManagedActor' has a wrong offset!");
static_assert(offsetof(ADelMarActorMover, SplineMovementComponent) == 0x000BF8, "Member 'ADelMarActorMover::SplineMovementComponent' has a wrong offset!");
static_assert(offsetof(ADelMarActorMover, ServerMovementStartTime) == 0x000C10, "Member 'ADelMarActorMover::ServerMovementStartTime' has a wrong offset!");

// Class DelMarCore.DelMarGhostSessionComponent
// 0x0010 (0x00B0 - 0x00A0)
class UDelMarGhostSessionComponent : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartSession();
	void StopSession();

	bool IsSessionActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGhostSessionComponent">();
	}
	static class UDelMarGhostSessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGhostSessionComponent>();
	}
};
static_assert(alignof(UDelMarGhostSessionComponent) == 0x000008, "Wrong alignment on UDelMarGhostSessionComponent");
static_assert(sizeof(UDelMarGhostSessionComponent) == 0x0000B0, "Wrong size on UDelMarGhostSessionComponent");

// Class DelMarCore.DelMarGhostPlaybackSessionComponent
// 0x0048 (0x00F8 - 0x00B0)
class UDelMarGhostPlaybackSessionComponent final : public UDelMarGhostSessionComponent
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	ETeleportType                                 TeleportSetting;                                   // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortPhysicsPawn>           PlaybackActorClass;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFrame;                                      // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelMarGhostReplayLog*                  PlaybackLog;                                       // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPhysicsPawn*                       PlaybackActor;                                     // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetPlaybackLog(class UDelMarGhostReplayLog* InLog);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGhostPlaybackSessionComponent">();
	}
	static class UDelMarGhostPlaybackSessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGhostPlaybackSessionComponent>();
	}
};
static_assert(alignof(UDelMarGhostPlaybackSessionComponent) == 0x000008, "Wrong alignment on UDelMarGhostPlaybackSessionComponent");
static_assert(sizeof(UDelMarGhostPlaybackSessionComponent) == 0x0000F8, "Wrong size on UDelMarGhostPlaybackSessionComponent");
static_assert(offsetof(UDelMarGhostPlaybackSessionComponent, TeleportSetting) == 0x0000D0, "Member 'UDelMarGhostPlaybackSessionComponent::TeleportSetting' has a wrong offset!");
static_assert(offsetof(UDelMarGhostPlaybackSessionComponent, PlaybackActorClass) == 0x0000D8, "Member 'UDelMarGhostPlaybackSessionComponent::PlaybackActorClass' has a wrong offset!");
static_assert(offsetof(UDelMarGhostPlaybackSessionComponent, CurrentFrame) == 0x0000E0, "Member 'UDelMarGhostPlaybackSessionComponent::CurrentFrame' has a wrong offset!");
static_assert(offsetof(UDelMarGhostPlaybackSessionComponent, PlaybackLog) == 0x0000E8, "Member 'UDelMarGhostPlaybackSessionComponent::PlaybackLog' has a wrong offset!");
static_assert(offsetof(UDelMarGhostPlaybackSessionComponent, PlaybackActor) == 0x0000F0, "Member 'UDelMarGhostPlaybackSessionComponent::PlaybackActor' has a wrong offset!");

// Class DelMarCore.DelMarAIController
// 0x0230 (0x05E8 - 0x03B8)
class ADelMarAIController final : public AAIController
{
public:
	uint8                                         Pad_3B8[0x20];                                     // 0x03B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ADelMarAIController* AIController, struct FFortAthenaLoadout& Loadout)> OnLoadoutChanged;                                  // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFortAthenaLoadout                     CosmeticLoadoutBC;                                 // 0x03E8(0x0170)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FCosmeticLoadout                       VehicleCosmeticLoadout;                            // 0x0558(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EDelMarInvertSteerMethod                      BotSteerMethod;                                    // 0x0568(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x7];                                      // 0x0569(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BTAssetToRunOnPawnAISpawned;                       // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBehaviorTree*>                  SkillLevelBehaviorTrees;                           // 0x0578(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         MinSkillLevelForRubberbanding;                     // 0x0588(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDelMarCoreOobTubePositionalRenderingComponent> OobTubePositionRenderingComponentClass;            // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          DelMarVehicle;                                     // 0x0598(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A0[0x10];                                     // 0x05A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DelMarBotControllerUID;                            // 0x05B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DelMarBotSkillLevel;                               // 0x05B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DelMarBotPlayerName;                               // 0x05B8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarAIService*                       DelMarAIService;                                   // 0x05C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerPawn*                        PlayerBotPawn;                                     // 0x05D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x10];                                     // 0x05D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleGroundedStateChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarAIController">();
	}
	static class ADelMarAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarAIController>();
	}
};
static_assert(alignof(ADelMarAIController) == 0x000008, "Wrong alignment on ADelMarAIController");
static_assert(sizeof(ADelMarAIController) == 0x0005E8, "Wrong size on ADelMarAIController");
static_assert(offsetof(ADelMarAIController, OnLoadoutChanged) == 0x0003D8, "Member 'ADelMarAIController::OnLoadoutChanged' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, CosmeticLoadoutBC) == 0x0003E8, "Member 'ADelMarAIController::CosmeticLoadoutBC' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, VehicleCosmeticLoadout) == 0x000558, "Member 'ADelMarAIController::VehicleCosmeticLoadout' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, BotSteerMethod) == 0x000568, "Member 'ADelMarAIController::BotSteerMethod' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, BTAssetToRunOnPawnAISpawned) == 0x000570, "Member 'ADelMarAIController::BTAssetToRunOnPawnAISpawned' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, SkillLevelBehaviorTrees) == 0x000578, "Member 'ADelMarAIController::SkillLevelBehaviorTrees' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, MinSkillLevelForRubberbanding) == 0x000588, "Member 'ADelMarAIController::MinSkillLevelForRubberbanding' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, OobTubePositionRenderingComponentClass) == 0x000590, "Member 'ADelMarAIController::OobTubePositionRenderingComponentClass' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, DelMarVehicle) == 0x000598, "Member 'ADelMarAIController::DelMarVehicle' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, DelMarBotControllerUID) == 0x0005B0, "Member 'ADelMarAIController::DelMarBotControllerUID' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, DelMarBotSkillLevel) == 0x0005B4, "Member 'ADelMarAIController::DelMarBotSkillLevel' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, DelMarBotPlayerName) == 0x0005B8, "Member 'ADelMarAIController::DelMarBotPlayerName' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, DelMarAIService) == 0x0005C8, "Member 'ADelMarAIController::DelMarAIService' has a wrong offset!");
static_assert(offsetof(ADelMarAIController, PlayerBotPawn) == 0x0005D0, "Member 'ADelMarAIController::PlayerBotPawn' has a wrong offset!");

// Class DelMarCore.GuidedZoneRequirement
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement">();
	}
	static class UGuidedZoneRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement>();
	}
};
static_assert(alignof(UGuidedZoneRequirement) == 0x000008, "Wrong alignment on UGuidedZoneRequirement");
static_assert(sizeof(UGuidedZoneRequirement) == 0x000028, "Wrong size on UGuidedZoneRequirement");

// Class DelMarCore.GuidedZoneRequirement_TurboBonusZone
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_TurboBonusZone final : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_TurboBonusZone">();
	}
	static class UGuidedZoneRequirement_TurboBonusZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_TurboBonusZone>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_TurboBonusZone) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_TurboBonusZone");
static_assert(sizeof(UGuidedZoneRequirement_TurboBonusZone) == 0x000028, "Wrong size on UGuidedZoneRequirement_TurboBonusZone");

// Class DelMarCore.DelMarRaceMusicPlaylistComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarRaceMusicPlaylistComponent final : public UActorComponent
{
public:
	void SetMusicPlaylist(class UDelMarRaceMusicPlaylist* SetPlaylist, bool bEnableMusic);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRaceMusicPlaylistComponent">();
	}
	static class UDelMarRaceMusicPlaylistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRaceMusicPlaylistComponent>();
	}
};
static_assert(alignof(UDelMarRaceMusicPlaylistComponent) == 0x000008, "Wrong alignment on UDelMarRaceMusicPlaylistComponent");
static_assert(sizeof(UDelMarRaceMusicPlaylistComponent) == 0x0000A0, "Wrong size on UDelMarRaceMusicPlaylistComponent");

// Class DelMarCore.DelMarAIService
// 0x00F0 (0x0168 - 0x0078)
class UDelMarAIService final : public UAthenaAIService
{
public:
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase> CosmeticComponentClass;                            // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDelMarAIVehicleCosmeticLibraryData> VehicleCosmeticLibrary;                            // 0x0080(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBotsUniqueIDUseValidAccountID;                    // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRegionalNameList;                              // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortAthenaAIBotNameDataAsset> BotNameDataAsset;                                  // 0x00A8(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADelMarAIController>        AIControllerClass;                                 // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              MMRSpawnTablePtr;                                  // 0x00D0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ADelMarAIController*>            DelMarAIControllers;                               // 0x00F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      RaceManager;                                       // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarRespawnManagerComponent> RespawnManagerComponent;                           // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FString>                           ReservedPlayerNames;                               // 0x0110(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class ADelMarAIController*> GetRegisteredAIBotControllers();
	void HandlePlayerRegistered(class AFortPlayerState* RegisteredPlayerState);
	void HandlePlayerUnregistered(class AFortPlayerState* UnregisteredPlayerState, bool bSetAsInactive);

	int32 GetMaxNumberOfPlayers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarAIService">();
	}
	static class UDelMarAIService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarAIService>();
	}
};
static_assert(alignof(UDelMarAIService) == 0x000008, "Wrong alignment on UDelMarAIService");
static_assert(sizeof(UDelMarAIService) == 0x000168, "Wrong size on UDelMarAIService");
static_assert(offsetof(UDelMarAIService, CosmeticComponentClass) == 0x000078, "Member 'UDelMarAIService::CosmeticComponentClass' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, VehicleCosmeticLibrary) == 0x000080, "Member 'UDelMarAIService::VehicleCosmeticLibrary' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, bBotsUniqueIDUseValidAccountID) == 0x0000A0, "Member 'UDelMarAIService::bBotsUniqueIDUseValidAccountID' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, bUseRegionalNameList) == 0x0000A1, "Member 'UDelMarAIService::bUseRegionalNameList' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, BotNameDataAsset) == 0x0000A8, "Member 'UDelMarAIService::BotNameDataAsset' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, AIControllerClass) == 0x0000C8, "Member 'UDelMarAIService::AIControllerClass' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, MMRSpawnTablePtr) == 0x0000D0, "Member 'UDelMarAIService::MMRSpawnTablePtr' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, DelMarAIControllers) == 0x0000F0, "Member 'UDelMarAIService::DelMarAIControllers' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, RaceManager) == 0x000100, "Member 'UDelMarAIService::RaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, RespawnManagerComponent) == 0x000108, "Member 'UDelMarAIService::RespawnManagerComponent' has a wrong offset!");
static_assert(offsetof(UDelMarAIService, ReservedPlayerNames) == 0x000110, "Member 'UDelMarAIService::ReservedPlayerNames' has a wrong offset!");

// Class DelMarCore.DelMarAIVehicleCosmeticLibraryData
// 0x0030 (0x0060 - 0x0030)
class UDelMarAIVehicleCosmeticLibraryData final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UDataTable>              PredefineVehiclCosmeticSetsDataTable;              // 0x0030(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDelMarAIVehicleCosmeticSlotDataTableInfo> RandomizedVehicleSlotDataTables;                   // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarAIVehicleCosmeticLibraryData">();
	}
	static class UDelMarAIVehicleCosmeticLibraryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarAIVehicleCosmeticLibraryData>();
	}
};
static_assert(alignof(UDelMarAIVehicleCosmeticLibraryData) == 0x000008, "Wrong alignment on UDelMarAIVehicleCosmeticLibraryData");
static_assert(sizeof(UDelMarAIVehicleCosmeticLibraryData) == 0x000060, "Wrong size on UDelMarAIVehicleCosmeticLibraryData");
static_assert(offsetof(UDelMarAIVehicleCosmeticLibraryData, PredefineVehiclCosmeticSetsDataTable) == 0x000030, "Member 'UDelMarAIVehicleCosmeticLibraryData::PredefineVehiclCosmeticSetsDataTable' has a wrong offset!");
static_assert(offsetof(UDelMarAIVehicleCosmeticLibraryData, RandomizedVehicleSlotDataTables) == 0x000050, "Member 'UDelMarAIVehicleCosmeticLibraryData::RandomizedVehicleSlotDataTables' has a wrong offset!");

// Class DelMarCore.DelMarRaceManager
// 0x0210 (0x04A0 - 0x0290)
class ADelMarRaceManager : public AActor
{
public:
	uint8                                         Pad_290[0x90];                                     // 0x0290(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRaceFinished;                                    // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceStarted;                                     // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceCountdownStarted;                            // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceReset;                                       // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AFortPlayerState* PlayerState)> OnPlayerFinishedRace;                              // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AFortPlayerState* PlayerState)> OnPlayerLapComplete;                               // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AFortPlayerState* PlayerState)> OnPlayerResetRun;                                  // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bRaceStarted;                                      // 0x0390(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRaceFinished;                                     // 0x0391(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_392[0x6];                                      // 0x0392(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerState*>               SpectatorPlayerStates;                             // 0x0398(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AFortPlayerState*>               ActiveRacerPlayerStates;                           // 0x03A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UDelMarRaceConfigComponent*             RaceConfig;                                        // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceLevelConfig>  ActiveRaceLevelConfig;                             // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarTimeManagerComponent*            TimeManager;                                       // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarRespawnManagerComponent*         RespawnManager;                                    // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarCheckpointManagerComponent*      CheckpointManager;                                 // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarRubberbandingManagerComponent*   RubberbandingManager;                              // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarPositionalTrackerComponent*      PositionalTracker;                                 // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarEliminationRaceManagerComponent* EliminationManager;                                // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarGlobalInputDisabler*             InputDisablerComponent;                            // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AFortPlayerState*>                 ManagedPlayerStates;                               // 0x0400(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSet<TWeakObjectPtr<class AFortPlayerState>>  InactivePlayerStates;                              // 0x0450(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void FinalizeRegisteredPlayerInitialization(class AFortPlayerState* PlayerState);
	void FinishRace();
	void HandleRegisteredPlayerPawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn);
	void NetMulticast_FinishRace(double RaceFinishedTime);
	void NetMulticast_ResetRace(bool bNextRound);
	void NetMulticast_ResetRun(const class AFortPlayerState* InPlayerState, bool bPlayerTriggered);
	void OnRep_ActiveRaceLevelConfig();
	void RegisterPlayerController(class AController* InController);
	void RegisterPlayerState(class AFortPlayerState* InPlayerState);
	void RequestStartRace(bool bSkipCountdown);
	void ResetRace(bool bIsRoundReset);
	void ResetRun(class AFortPlayerState* PlayerState, bool bPlayerTriggered);
	void SetActiveRaceLevelConfig(class ADelMarRaceLevelConfig* InRaceLevelConfig);
	void SetPlayerAsSpectator(class AFortPlayerState* PlayerState);
	void SetSpectatorAsPlayer(class AFortPlayerState* PlayerState);
	void UnregisterAllPlayers(bool bSetAsInactive);
	void UnregisterPlayerController(class AController* InController, bool bSetAsInactive);
	void UnregisterPlayerState(class AFortPlayerState* InPlayerState, bool bSetAsInactive);

	class ADelMarRaceLevelConfig* GetActiveRaceLevelConfig() const;
	TArray<class AFortPlayerState*> GetActiveRacers() const;
	EDelMarRaceMode GetCurrentRaceMode() const;
	EDelMarRaceSpawnMode GetCurrentSpawnMode() const;
	class UDelMarEliminationRaceManagerComponent* GetEliminationManagerComponent() const;
	TArray<class AFortPlayerState*> GetManagedPlayerStatesArray() const;
	int32 GetNumberOfLapsForRace() const;
	int32 GetNumInactiveRacers() const;
	class UDelMarPositionalTrackerComponent* GetPositionalTracker() const;
	class UDelMarRaceConfigComponent* GetRaceConfig() const;
	class UDelMarRespawnManagerComponent* GetRespawnManagerComponent() const;
	class UDelMarRubberbandingManagerComponent* GetRubberbandingManager() const;
	TArray<class AFortPlayerState*> GetSpectators() const;
	class UDelMarTimeManagerComponent* GetTimeManager() const;
	bool IsActiveRacer(const class AFortPlayerState* PlayerState) const;
	bool IsSpectator(const class AFortPlayerState* PlayerState) const;
	void RequestCountdownForPlayer(class AFortPlayerState* PlayerState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRaceManager">();
	}
	static class ADelMarRaceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarRaceManager>();
	}
};
static_assert(alignof(ADelMarRaceManager) == 0x000008, "Wrong alignment on ADelMarRaceManager");
static_assert(sizeof(ADelMarRaceManager) == 0x0004A0, "Wrong size on ADelMarRaceManager");
static_assert(offsetof(ADelMarRaceManager, OnRaceFinished) == 0x000320, "Member 'ADelMarRaceManager::OnRaceFinished' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, OnRaceStarted) == 0x000330, "Member 'ADelMarRaceManager::OnRaceStarted' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, OnRaceCountdownStarted) == 0x000340, "Member 'ADelMarRaceManager::OnRaceCountdownStarted' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, OnRaceReset) == 0x000350, "Member 'ADelMarRaceManager::OnRaceReset' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, OnPlayerFinishedRace) == 0x000360, "Member 'ADelMarRaceManager::OnPlayerFinishedRace' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, OnPlayerLapComplete) == 0x000370, "Member 'ADelMarRaceManager::OnPlayerLapComplete' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, OnPlayerResetRun) == 0x000380, "Member 'ADelMarRaceManager::OnPlayerResetRun' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, bRaceStarted) == 0x000390, "Member 'ADelMarRaceManager::bRaceStarted' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, bRaceFinished) == 0x000391, "Member 'ADelMarRaceManager::bRaceFinished' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, SpectatorPlayerStates) == 0x000398, "Member 'ADelMarRaceManager::SpectatorPlayerStates' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, ActiveRacerPlayerStates) == 0x0003A8, "Member 'ADelMarRaceManager::ActiveRacerPlayerStates' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, RaceConfig) == 0x0003B8, "Member 'ADelMarRaceManager::RaceConfig' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, ActiveRaceLevelConfig) == 0x0003C0, "Member 'ADelMarRaceManager::ActiveRaceLevelConfig' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, TimeManager) == 0x0003C8, "Member 'ADelMarRaceManager::TimeManager' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, RespawnManager) == 0x0003D0, "Member 'ADelMarRaceManager::RespawnManager' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, CheckpointManager) == 0x0003D8, "Member 'ADelMarRaceManager::CheckpointManager' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, RubberbandingManager) == 0x0003E0, "Member 'ADelMarRaceManager::RubberbandingManager' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, PositionalTracker) == 0x0003E8, "Member 'ADelMarRaceManager::PositionalTracker' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, EliminationManager) == 0x0003F0, "Member 'ADelMarRaceManager::EliminationManager' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, InputDisablerComponent) == 0x0003F8, "Member 'ADelMarRaceManager::InputDisablerComponent' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, ManagedPlayerStates) == 0x000400, "Member 'ADelMarRaceManager::ManagedPlayerStates' has a wrong offset!");
static_assert(offsetof(ADelMarRaceManager, InactivePlayerStates) == 0x000450, "Member 'ADelMarRaceManager::InactivePlayerStates' has a wrong offset!");

// Class DelMarCore.DelMarTutorialRaceManager
// 0x0008 (0x04A8 - 0x04A0)
class ADelMarTutorialRaceManager final : public ADelMarRaceManager
{
public:
	class UDelMarTutorialConfigComponent*         TutorialConfigComponent;                           // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NetMulticast_TutorialSectionChanged(const class AFortPlayerState* PlayerState, const int32 SectionIndex, const int32 PrevSectionIndex);
	void RequestNextTutorialSection(class AFortPlayerState* PlayerState);
	void RequestPrevTutorialSection(class AFortPlayerState* PlayerState);
	void SetCurrentTutorialSection(const int32 SectionIndex, class AFortPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarTutorialRaceManager">();
	}
	static class ADelMarTutorialRaceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarTutorialRaceManager>();
	}
};
static_assert(alignof(ADelMarTutorialRaceManager) == 0x000008, "Wrong alignment on ADelMarTutorialRaceManager");
static_assert(sizeof(ADelMarTutorialRaceManager) == 0x0004A8, "Wrong size on ADelMarTutorialRaceManager");
static_assert(offsetof(ADelMarTutorialRaceManager, TutorialConfigComponent) == 0x0004A0, "Member 'ADelMarTutorialRaceManager::TutorialConfigComponent' has a wrong offset!");

// Class DelMarCore.DriveHazardInfo
// 0x0050 (0x0078 - 0x0028)
class UDriveHazardInfo final : public UObject
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DriveHazardInfo">();
	}
	static class UDriveHazardInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDriveHazardInfo>();
	}
};
static_assert(alignof(UDriveHazardInfo) == 0x000008, "Wrong alignment on UDriveHazardInfo");
static_assert(sizeof(UDriveHazardInfo) == 0x000078, "Wrong size on UDriveHazardInfo");
static_assert(offsetof(UDriveHazardInfo, Actor) == 0x000028, "Member 'UDriveHazardInfo::Actor' has a wrong offset!");

// Class DelMarCore.DelMarBTService_VehicleBase
// 0x0030 (0x00A0 - 0x0070)
class UDelMarBTService_VehicleBase : public UBTService
{
public:
	struct FBlackboardKeySelector                 VehicleKey;                                        // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          DelMarVehicle;                                     // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarBTService_VehicleBase">();
	}
	static class UDelMarBTService_VehicleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarBTService_VehicleBase>();
	}
};
static_assert(alignof(UDelMarBTService_VehicleBase) == 0x000008, "Wrong alignment on UDelMarBTService_VehicleBase");
static_assert(sizeof(UDelMarBTService_VehicleBase) == 0x0000A0, "Wrong size on UDelMarBTService_VehicleBase");
static_assert(offsetof(UDelMarBTService_VehicleBase, VehicleKey) == 0x000070, "Member 'UDelMarBTService_VehicleBase::VehicleKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_VehicleBase, DelMarVehicle) == 0x000098, "Member 'UDelMarBTService_VehicleBase::DelMarVehicle' has a wrong offset!");

// Class DelMarCore.GuidedZoneRequirement_DriftActive
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_DriftActive final : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_DriftActive">();
	}
	static class UGuidedZoneRequirement_DriftActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_DriftActive>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_DriftActive) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_DriftActive");
static_assert(sizeof(UGuidedZoneRequirement_DriftActive) == 0x000028, "Wrong size on UGuidedZoneRequirement_DriftActive");

// Class DelMarCore.DelMarSpeedUpDevice
// 0x0018 (0x0BF0 - 0x0BD8)
class ADelMarSpeedUpDevice final : public AFortCreativeDeviceProp
{
public:
	float                                         SpeedAmount;                                       // 0x0BD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedEffectDuration;                               // 0x0BDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDotProductAngleValue;                           // 0x0BE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SpeedSourceTag;                                    // 0x0BE4(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Collider;                                          // 0x0BE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_HandleSpeedEffectGranted();
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	bool ShouldGrantSpeedEffect(class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarSpeedUpDevice">();
	}
	static class ADelMarSpeedUpDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarSpeedUpDevice>();
	}
};
static_assert(alignof(ADelMarSpeedUpDevice) == 0x000008, "Wrong alignment on ADelMarSpeedUpDevice");
static_assert(sizeof(ADelMarSpeedUpDevice) == 0x000BF0, "Wrong size on ADelMarSpeedUpDevice");
static_assert(offsetof(ADelMarSpeedUpDevice, SpeedAmount) == 0x000BD8, "Member 'ADelMarSpeedUpDevice::SpeedAmount' has a wrong offset!");
static_assert(offsetof(ADelMarSpeedUpDevice, SpeedEffectDuration) == 0x000BDC, "Member 'ADelMarSpeedUpDevice::SpeedEffectDuration' has a wrong offset!");
static_assert(offsetof(ADelMarSpeedUpDevice, MinDotProductAngleValue) == 0x000BE0, "Member 'ADelMarSpeedUpDevice::MinDotProductAngleValue' has a wrong offset!");
static_assert(offsetof(ADelMarSpeedUpDevice, SpeedSourceTag) == 0x000BE4, "Member 'ADelMarSpeedUpDevice::SpeedSourceTag' has a wrong offset!");
static_assert(offsetof(ADelMarSpeedUpDevice, Collider) == 0x000BE8, "Member 'ADelMarSpeedUpDevice::Collider' has a wrong offset!");

// Class DelMarCore.DelMarBTService_FindDriveGoal
// 0x0430 (0x04D0 - 0x00A0)
class alignas(0x10) UDelMarBTService_FindDriveGoal final : public UDelMarBTService_VehicleBase
{
public:
	struct FBlackboardKeySelector                 DriveGoalLocationKey;                              // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 DriveGoalRotationKey;                              // 0x00C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 IsAirDriveGoalKey;                                 // 0x00F0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 HasUpcomingCollisionKey;                           // 0x0118(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         GroundedDriveGoalVehicleForwardOffset;             // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirDriveGoalVehicleForwardOffset;                  // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PathNoiseAmplitude;                                // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PathNoiseFrequency;                                // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOfCheckedTrackSegments;                   // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfSideAvoidanceRaycasts;                     // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DegreesBetweenRaycasts;                            // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriftPrimaryTraceRotationFactor;                   // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NonJumpableHazardMinHitNormalDegrees;              // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             RaycastCollisionChannel;                           // 0x0164(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             IgnoredActorClasses;                               // 0x0168(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     RaycastDistanceCurve;                              // 0x0178(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     RayCastDistanceContributionCurve;                  // 0x0208(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     VehicleDistanceAvoidanceCurve;                     // 0x0298(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         DriveGoalOffsetCancelPadding;                      // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriveHazardOffsetCancelPadding;                    // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VehicleTrackOffsetCancelPadding;                   // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriveHazardMaxJumpDistanceFactor;                  // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriveHazardMinJumpDistanceFactor;                  // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlockedJumpTracePadding;                           // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackGapJumpHeightThreshold;                       // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             JumpableActorClasses;                              // 0x0348(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     PercentChanceToIgnoreJumpHazardCurve;              // 0x0358(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         PercentChanceToIgnoreDriveHazard;                  // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentChanceToNotCheckForSafeLanding;             // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTrackPositionComponent> TrackPositionComponent;                            // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTrackOobTubePositionalRenderingComponent> OobTubePositionalRenderingComponent;               // 0x03F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class AActor>, class UDriveHazardInfo*> PrevFrameDriveHazardInfoMap;                       // 0x0400(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x80];                                     // 0x0450(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarBTService_FindDriveGoal">();
	}
	static class UDelMarBTService_FindDriveGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarBTService_FindDriveGoal>();
	}
};
static_assert(alignof(UDelMarBTService_FindDriveGoal) == 0x000010, "Wrong alignment on UDelMarBTService_FindDriveGoal");
static_assert(sizeof(UDelMarBTService_FindDriveGoal) == 0x0004D0, "Wrong size on UDelMarBTService_FindDriveGoal");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, DriveGoalLocationKey) == 0x0000A0, "Member 'UDelMarBTService_FindDriveGoal::DriveGoalLocationKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, DriveGoalRotationKey) == 0x0000C8, "Member 'UDelMarBTService_FindDriveGoal::DriveGoalRotationKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, IsAirDriveGoalKey) == 0x0000F0, "Member 'UDelMarBTService_FindDriveGoal::IsAirDriveGoalKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, HasUpcomingCollisionKey) == 0x000118, "Member 'UDelMarBTService_FindDriveGoal::HasUpcomingCollisionKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, GroundedDriveGoalVehicleForwardOffset) == 0x000140, "Member 'UDelMarBTService_FindDriveGoal::GroundedDriveGoalVehicleForwardOffset' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, AirDriveGoalVehicleForwardOffset) == 0x000144, "Member 'UDelMarBTService_FindDriveGoal::AirDriveGoalVehicleForwardOffset' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, PathNoiseAmplitude) == 0x000148, "Member 'UDelMarBTService_FindDriveGoal::PathNoiseAmplitude' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, PathNoiseFrequency) == 0x00014C, "Member 'UDelMarBTService_FindDriveGoal::PathNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, MaxNumberOfCheckedTrackSegments) == 0x000150, "Member 'UDelMarBTService_FindDriveGoal::MaxNumberOfCheckedTrackSegments' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, NumberOfSideAvoidanceRaycasts) == 0x000154, "Member 'UDelMarBTService_FindDriveGoal::NumberOfSideAvoidanceRaycasts' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, DegreesBetweenRaycasts) == 0x000158, "Member 'UDelMarBTService_FindDriveGoal::DegreesBetweenRaycasts' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, DriftPrimaryTraceRotationFactor) == 0x00015C, "Member 'UDelMarBTService_FindDriveGoal::DriftPrimaryTraceRotationFactor' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, NonJumpableHazardMinHitNormalDegrees) == 0x000160, "Member 'UDelMarBTService_FindDriveGoal::NonJumpableHazardMinHitNormalDegrees' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, RaycastCollisionChannel) == 0x000164, "Member 'UDelMarBTService_FindDriveGoal::RaycastCollisionChannel' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, IgnoredActorClasses) == 0x000168, "Member 'UDelMarBTService_FindDriveGoal::IgnoredActorClasses' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, RaycastDistanceCurve) == 0x000178, "Member 'UDelMarBTService_FindDriveGoal::RaycastDistanceCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, RayCastDistanceContributionCurve) == 0x000208, "Member 'UDelMarBTService_FindDriveGoal::RayCastDistanceContributionCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, VehicleDistanceAvoidanceCurve) == 0x000298, "Member 'UDelMarBTService_FindDriveGoal::VehicleDistanceAvoidanceCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, DriveGoalOffsetCancelPadding) == 0x000328, "Member 'UDelMarBTService_FindDriveGoal::DriveGoalOffsetCancelPadding' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, DriveHazardOffsetCancelPadding) == 0x00032C, "Member 'UDelMarBTService_FindDriveGoal::DriveHazardOffsetCancelPadding' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, VehicleTrackOffsetCancelPadding) == 0x000330, "Member 'UDelMarBTService_FindDriveGoal::VehicleTrackOffsetCancelPadding' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, DriveHazardMaxJumpDistanceFactor) == 0x000334, "Member 'UDelMarBTService_FindDriveGoal::DriveHazardMaxJumpDistanceFactor' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, DriveHazardMinJumpDistanceFactor) == 0x000338, "Member 'UDelMarBTService_FindDriveGoal::DriveHazardMinJumpDistanceFactor' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, BlockedJumpTracePadding) == 0x00033C, "Member 'UDelMarBTService_FindDriveGoal::BlockedJumpTracePadding' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, TrackGapJumpHeightThreshold) == 0x000340, "Member 'UDelMarBTService_FindDriveGoal::TrackGapJumpHeightThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, JumpableActorClasses) == 0x000348, "Member 'UDelMarBTService_FindDriveGoal::JumpableActorClasses' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, PercentChanceToIgnoreJumpHazardCurve) == 0x000358, "Member 'UDelMarBTService_FindDriveGoal::PercentChanceToIgnoreJumpHazardCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, PercentChanceToIgnoreDriveHazard) == 0x0003E8, "Member 'UDelMarBTService_FindDriveGoal::PercentChanceToIgnoreDriveHazard' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, PercentChanceToNotCheckForSafeLanding) == 0x0003EC, "Member 'UDelMarBTService_FindDriveGoal::PercentChanceToNotCheckForSafeLanding' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, TrackPositionComponent) == 0x0003F0, "Member 'UDelMarBTService_FindDriveGoal::TrackPositionComponent' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, OobTubePositionalRenderingComponent) == 0x0003F8, "Member 'UDelMarBTService_FindDriveGoal::OobTubePositionalRenderingComponent' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_FindDriveGoal, PrevFrameDriveHazardInfoMap) == 0x000400, "Member 'UDelMarBTService_FindDriveGoal::PrevFrameDriveHazardInfoMap' has a wrong offset!");

// Class DelMarCore.DelMarBTService_ResetVehicle
// 0x0020 (0x00C0 - 0x00A0)
class UDelMarBTService_ResetVehicle final : public UDelMarBTService_VehicleBase
{
public:
	TWeakObjectPtr<class UDelMarPlayerRaceDataComponent> PlayerRaceDataComponent;                           // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTrackPositionComponent> TrackPositionComponent;                            // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarBTService_ResetVehicle">();
	}
	static class UDelMarBTService_ResetVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarBTService_ResetVehicle>();
	}
};
static_assert(alignof(UDelMarBTService_ResetVehicle) == 0x000008, "Wrong alignment on UDelMarBTService_ResetVehicle");
static_assert(sizeof(UDelMarBTService_ResetVehicle) == 0x0000C0, "Wrong size on UDelMarBTService_ResetVehicle");
static_assert(offsetof(UDelMarBTService_ResetVehicle, PlayerRaceDataComponent) == 0x0000A0, "Member 'UDelMarBTService_ResetVehicle::PlayerRaceDataComponent' has a wrong offset!");
static_assert(offsetof(UDelMarBTService_ResetVehicle, TrackPositionComponent) == 0x0000A8, "Member 'UDelMarBTService_ResetVehicle::TrackPositionComponent' has a wrong offset!");

// Class DelMarCore.GuidedZoneRequirement_Kickflip
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_Kickflip final : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_Kickflip">();
	}
	static class UGuidedZoneRequirement_Kickflip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_Kickflip>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_Kickflip) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_Kickflip");
static_assert(sizeof(UGuidedZoneRequirement_Kickflip) == 0x000028, "Wrong size on UGuidedZoneRequirement_Kickflip");

// Class DelMarCore.DelMarRaceManagerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarRaceManagerComponent : public UGameFrameworkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRaceManagerComponent">();
	}
	static class UDelMarRaceManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRaceManagerComponent>();
	}
};
static_assert(alignof(UDelMarRaceManagerComponent) == 0x000008, "Wrong alignment on UDelMarRaceManagerComponent");
static_assert(sizeof(UDelMarRaceManagerComponent) == 0x0000A0, "Wrong size on UDelMarRaceManagerComponent");

// Class DelMarCore.DelMarRaceManagerVerbComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDelMarRaceManagerVerbComponent final : public UDelMarRaceManagerComponent
{
public:
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPositionalTrackerComponent> PositionalTracker;                                 // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortPlayerState*>               PrevRacePositions;                                 // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void HandleCountdownStarted();
	void HandleFinalRacePositionsChanged(const TArray<struct FDelMarFinalRacePositionEntry>& FinalRacePositions, const struct FDelMarEvent_RunRecorded& RecordedRun);
	void HandlePlayerLapCompleted(const struct FDelMarEvent_LapComplete& LapCompleteEvent);
	void HandlePlayerPositionsChanged(const TArray<class AFortPlayerState*>& RacePositions);
	void HandleRaceFinished();
	void HandleRaceStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRaceManagerVerbComponent">();
	}
	static class UDelMarRaceManagerVerbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRaceManagerVerbComponent>();
	}
};
static_assert(alignof(UDelMarRaceManagerVerbComponent) == 0x000008, "Wrong alignment on UDelMarRaceManagerVerbComponent");
static_assert(sizeof(UDelMarRaceManagerVerbComponent) == 0x0000C0, "Wrong size on UDelMarRaceManagerVerbComponent");
static_assert(offsetof(UDelMarRaceManagerVerbComponent, CachedRaceManager) == 0x0000A0, "Member 'UDelMarRaceManagerVerbComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarRaceManagerVerbComponent, PositionalTracker) == 0x0000A8, "Member 'UDelMarRaceManagerVerbComponent::PositionalTracker' has a wrong offset!");
static_assert(offsetof(UDelMarRaceManagerVerbComponent, PrevRacePositions) == 0x0000B0, "Member 'UDelMarRaceManagerVerbComponent::PrevRacePositions' has a wrong offset!");

// Class DelMarCore.DelMarBTTask_VehicleBase
// 0x0030 (0x00A0 - 0x0070)
class UDelMarBTTask_VehicleBase : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 VehicleKey;                                        // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADelMarVehicle>          DelMarVehicle;                                     // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarBTTask_VehicleBase">();
	}
	static class UDelMarBTTask_VehicleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarBTTask_VehicleBase>();
	}
};
static_assert(alignof(UDelMarBTTask_VehicleBase) == 0x000008, "Wrong alignment on UDelMarBTTask_VehicleBase");
static_assert(sizeof(UDelMarBTTask_VehicleBase) == 0x0000A0, "Wrong size on UDelMarBTTask_VehicleBase");
static_assert(offsetof(UDelMarBTTask_VehicleBase, VehicleKey) == 0x000070, "Member 'UDelMarBTTask_VehicleBase::VehicleKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_VehicleBase, DelMarVehicle) == 0x000098, "Member 'UDelMarBTTask_VehicleBase::DelMarVehicle' has a wrong offset!");

// Class DelMarCore.DelMarBTTask_DriveTrack
// 0x0750 (0x07F0 - 0x00A0)
class alignas(0x10) UDelMarBTTask_DriveTrack final : public UDelMarBTTask_VehicleBase
{
public:
	struct FBlackboardKeySelector                 DriveGoalLocationKey;                              // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 DriveGoalRotationKey;                              // 0x00C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 IsAirDriveGoalKey;                                 // 0x00F0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 HasUpcomingCollisionKey;                           // 0x0118(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     GroundedTrackHorizontalOffsetSteerCurve;           // 0x0140(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     AirTrackHorizontalOffsetSteerCurve;                // 0x01D0(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     CollisionAvoidanceHorizontalOffsetSteerCurve;      // 0x0260(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     GroundedTurnDegreesSteerDecisionCurve;             // 0x02F0(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     AirTurnDegreesSteerDecisionCurve;                  // 0x0380(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     CollisionTurnDegreesSteerDecisionCurve;            // 0x0410(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         DriveThrottle;                                     // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanKickDrift;                                     // 0x04A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfDriftCheckSamples;                         // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDriftSampleDistanceScaleFactor;                 // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDriftSampleDistanceScaleFactor;                 // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinExitDriftSampleDistanceFromVehicle;             // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxExitDriftSampleDistanceFromVehicle;             // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinRequiredDriftDegrees;                           // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRequiredDriftDegrees;                           // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinRequiredKickDriftDegrees;                       // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRequiredKickDriftDegrees;                       // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSecondsToUpdateRandomDriftConfigValues;         // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     PercentChanceToKickDriftCurve;                     // 0x04D0(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MinDriftSlipRatioForExitKickDrift;                 // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDriftSpeed;                                     // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriftKickUnderSteerDegreesThreshold;               // 0x0568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriftKickOverSteerDegreesThreshold;                // 0x056C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriftTapUnderSteerDegreesThreshold;                // 0x0570(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriftTapOverSteerDegreesThreshold;                 // 0x0574(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriftCounterSteerDegreesThreshold;                 // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarScaledCurve                     MinDriftSlipRatioCurve;                            // 0x0580(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     DistanceBetweenDriftSamplesCurve;                  // 0x0610(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDelMarScaledCurve                     DriftSampleDistanceFromVehicleCurve;               // 0x06A0(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         DriveGoalJumpHeightThreshold;                      // 0x0730(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriveGoalStopJumpEarlyHeightThreshold;             // 0x0734(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopJumpEarlyChance;                               // 0x0738(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinNumTurboChargesNeededToTurbo;                   // 0x073C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTurboTrackCutoffAngleInDegrees;                 // 0x0740(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboActivationBaseChance;                         // 0x0744(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryTurboBoostChance;                         // 0x0748(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenTurboCheck;                          // 0x074C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTimeBetweenTurboCheck;                          // 0x0750(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTrackPositionComponent> TrackPositionComponent;                            // 0x0754(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75C[0x94];                                     // 0x075C(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTurboActivated();
	void HandleVehicleGroundedStateChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue);
	void TurboBonusZoneStateChanged(EDelMarTurboZoneState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarBTTask_DriveTrack">();
	}
	static class UDelMarBTTask_DriveTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarBTTask_DriveTrack>();
	}
};
static_assert(alignof(UDelMarBTTask_DriveTrack) == 0x000010, "Wrong alignment on UDelMarBTTask_DriveTrack");
static_assert(sizeof(UDelMarBTTask_DriveTrack) == 0x0007F0, "Wrong size on UDelMarBTTask_DriveTrack");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriveGoalLocationKey) == 0x0000A0, "Member 'UDelMarBTTask_DriveTrack::DriveGoalLocationKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriveGoalRotationKey) == 0x0000C8, "Member 'UDelMarBTTask_DriveTrack::DriveGoalRotationKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, IsAirDriveGoalKey) == 0x0000F0, "Member 'UDelMarBTTask_DriveTrack::IsAirDriveGoalKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, HasUpcomingCollisionKey) == 0x000118, "Member 'UDelMarBTTask_DriveTrack::HasUpcomingCollisionKey' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, GroundedTrackHorizontalOffsetSteerCurve) == 0x000140, "Member 'UDelMarBTTask_DriveTrack::GroundedTrackHorizontalOffsetSteerCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, AirTrackHorizontalOffsetSteerCurve) == 0x0001D0, "Member 'UDelMarBTTask_DriveTrack::AirTrackHorizontalOffsetSteerCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, CollisionAvoidanceHorizontalOffsetSteerCurve) == 0x000260, "Member 'UDelMarBTTask_DriveTrack::CollisionAvoidanceHorizontalOffsetSteerCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, GroundedTurnDegreesSteerDecisionCurve) == 0x0002F0, "Member 'UDelMarBTTask_DriveTrack::GroundedTurnDegreesSteerDecisionCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, AirTurnDegreesSteerDecisionCurve) == 0x000380, "Member 'UDelMarBTTask_DriveTrack::AirTurnDegreesSteerDecisionCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, CollisionTurnDegreesSteerDecisionCurve) == 0x000410, "Member 'UDelMarBTTask_DriveTrack::CollisionTurnDegreesSteerDecisionCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriveThrottle) == 0x0004A0, "Member 'UDelMarBTTask_DriveTrack::DriveThrottle' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, bCanKickDrift) == 0x0004A4, "Member 'UDelMarBTTask_DriveTrack::bCanKickDrift' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, NumberOfDriftCheckSamples) == 0x0004A8, "Member 'UDelMarBTTask_DriveTrack::NumberOfDriftCheckSamples' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinDriftSampleDistanceScaleFactor) == 0x0004AC, "Member 'UDelMarBTTask_DriveTrack::MinDriftSampleDistanceScaleFactor' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MaxDriftSampleDistanceScaleFactor) == 0x0004B0, "Member 'UDelMarBTTask_DriveTrack::MaxDriftSampleDistanceScaleFactor' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinExitDriftSampleDistanceFromVehicle) == 0x0004B4, "Member 'UDelMarBTTask_DriveTrack::MinExitDriftSampleDistanceFromVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MaxExitDriftSampleDistanceFromVehicle) == 0x0004B8, "Member 'UDelMarBTTask_DriveTrack::MaxExitDriftSampleDistanceFromVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinRequiredDriftDegrees) == 0x0004BC, "Member 'UDelMarBTTask_DriveTrack::MinRequiredDriftDegrees' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MaxRequiredDriftDegrees) == 0x0004C0, "Member 'UDelMarBTTask_DriveTrack::MaxRequiredDriftDegrees' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinRequiredKickDriftDegrees) == 0x0004C4, "Member 'UDelMarBTTask_DriveTrack::MinRequiredKickDriftDegrees' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MaxRequiredKickDriftDegrees) == 0x0004C8, "Member 'UDelMarBTTask_DriveTrack::MaxRequiredKickDriftDegrees' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinSecondsToUpdateRandomDriftConfigValues) == 0x0004CC, "Member 'UDelMarBTTask_DriveTrack::MinSecondsToUpdateRandomDriftConfigValues' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, PercentChanceToKickDriftCurve) == 0x0004D0, "Member 'UDelMarBTTask_DriveTrack::PercentChanceToKickDriftCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinDriftSlipRatioForExitKickDrift) == 0x000560, "Member 'UDelMarBTTask_DriveTrack::MinDriftSlipRatioForExitKickDrift' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinDriftSpeed) == 0x000564, "Member 'UDelMarBTTask_DriveTrack::MinDriftSpeed' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriftKickUnderSteerDegreesThreshold) == 0x000568, "Member 'UDelMarBTTask_DriveTrack::DriftKickUnderSteerDegreesThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriftKickOverSteerDegreesThreshold) == 0x00056C, "Member 'UDelMarBTTask_DriveTrack::DriftKickOverSteerDegreesThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriftTapUnderSteerDegreesThreshold) == 0x000570, "Member 'UDelMarBTTask_DriveTrack::DriftTapUnderSteerDegreesThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriftTapOverSteerDegreesThreshold) == 0x000574, "Member 'UDelMarBTTask_DriveTrack::DriftTapOverSteerDegreesThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriftCounterSteerDegreesThreshold) == 0x000578, "Member 'UDelMarBTTask_DriveTrack::DriftCounterSteerDegreesThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinDriftSlipRatioCurve) == 0x000580, "Member 'UDelMarBTTask_DriveTrack::MinDriftSlipRatioCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DistanceBetweenDriftSamplesCurve) == 0x000610, "Member 'UDelMarBTTask_DriveTrack::DistanceBetweenDriftSamplesCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriftSampleDistanceFromVehicleCurve) == 0x0006A0, "Member 'UDelMarBTTask_DriveTrack::DriftSampleDistanceFromVehicleCurve' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriveGoalJumpHeightThreshold) == 0x000730, "Member 'UDelMarBTTask_DriveTrack::DriveGoalJumpHeightThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, DriveGoalStopJumpEarlyHeightThreshold) == 0x000734, "Member 'UDelMarBTTask_DriveTrack::DriveGoalStopJumpEarlyHeightThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, StopJumpEarlyChance) == 0x000738, "Member 'UDelMarBTTask_DriveTrack::StopJumpEarlyChance' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinNumTurboChargesNeededToTurbo) == 0x00073C, "Member 'UDelMarBTTask_DriveTrack::MinNumTurboChargesNeededToTurbo' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MaxTurboTrackCutoffAngleInDegrees) == 0x000740, "Member 'UDelMarBTTask_DriveTrack::MaxTurboTrackCutoffAngleInDegrees' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, TurboActivationBaseChance) == 0x000744, "Member 'UDelMarBTTask_DriveTrack::TurboActivationBaseChance' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, SecondaryTurboBoostChance) == 0x000748, "Member 'UDelMarBTTask_DriveTrack::SecondaryTurboBoostChance' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MinTimeBetweenTurboCheck) == 0x00074C, "Member 'UDelMarBTTask_DriveTrack::MinTimeBetweenTurboCheck' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, MaxTimeBetweenTurboCheck) == 0x000750, "Member 'UDelMarBTTask_DriveTrack::MaxTimeBetweenTurboCheck' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_DriveTrack, TrackPositionComponent) == 0x000754, "Member 'UDelMarBTTask_DriveTrack::TrackPositionComponent' has a wrong offset!");

// Class DelMarCore.DelMarTutorialConfigComponent
// 0x0010 (0x00B0 - 0x00A0)
class UDelMarTutorialConfigComponent final : public UActorComponent
{
public:
	TArray<struct FDelMarTutorialSection>         Sections;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarTutorialConfigComponent">();
	}
	static class UDelMarTutorialConfigComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarTutorialConfigComponent>();
	}
};
static_assert(alignof(UDelMarTutorialConfigComponent) == 0x000008, "Wrong alignment on UDelMarTutorialConfigComponent");
static_assert(sizeof(UDelMarTutorialConfigComponent) == 0x0000B0, "Wrong size on UDelMarTutorialConfigComponent");
static_assert(offsetof(UDelMarTutorialConfigComponent, Sections) == 0x0000A0, "Member 'UDelMarTutorialConfigComponent::Sections' has a wrong offset!");

// Class DelMarCore.DelMarBTTask_RaceCountdown
// 0x0018 (0x00B8 - 0x00A0)
class UDelMarBTTask_RaceCountdown final : public UDelMarBTTask_VehicleBase
{
public:
	float                                         MaxReactionTime;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinReactionTime;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarBTTask_RaceCountdown">();
	}
	static class UDelMarBTTask_RaceCountdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarBTTask_RaceCountdown>();
	}
};
static_assert(alignof(UDelMarBTTask_RaceCountdown) == 0x000008, "Wrong alignment on UDelMarBTTask_RaceCountdown");
static_assert(sizeof(UDelMarBTTask_RaceCountdown) == 0x0000B8, "Wrong size on UDelMarBTTask_RaceCountdown");
static_assert(offsetof(UDelMarBTTask_RaceCountdown, MaxReactionTime) == 0x0000A0, "Member 'UDelMarBTTask_RaceCountdown::MaxReactionTime' has a wrong offset!");
static_assert(offsetof(UDelMarBTTask_RaceCountdown, MinReactionTime) == 0x0000A4, "Member 'UDelMarBTTask_RaceCountdown::MinReactionTime' has a wrong offset!");

// Class DelMarCore.DelMarCameraModeOverrideComponent
// 0x0000 (0x00A8 - 0x00A8)
class UDelMarCameraModeOverrideComponent final : public UFortCameraModeOverrideComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCameraModeOverrideComponent">();
	}
	static class UDelMarCameraModeOverrideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCameraModeOverrideComponent>();
	}
};
static_assert(alignof(UDelMarCameraModeOverrideComponent) == 0x000008, "Wrong alignment on UDelMarCameraModeOverrideComponent");
static_assert(sizeof(UDelMarCameraModeOverrideComponent) == 0x0000A8, "Wrong size on UDelMarCameraModeOverrideComponent");

// Class DelMarCore.DelMarVehicleAction
// 0x0018 (0x0040 - 0x0028)
class UDelMarVehicleAction : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnActionPerformed;                                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleAction">();
	}
	static class UDelMarVehicleAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleAction>();
	}
};
static_assert(alignof(UDelMarVehicleAction) == 0x000008, "Wrong alignment on UDelMarVehicleAction");
static_assert(sizeof(UDelMarVehicleAction) == 0x000040, "Wrong size on UDelMarVehicleAction");
static_assert(offsetof(UDelMarVehicleAction, OnActionPerformed) == 0x000028, "Member 'UDelMarVehicleAction::OnActionPerformed' has a wrong offset!");

// Class DelMarCore.DelMarVehicleAction_Turbo
// 0x0000 (0x0040 - 0x0040)
class UDelMarVehicleAction_Turbo final : public UDelMarVehicleAction
{
public:
	void HandleTurbo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleAction_Turbo">();
	}
	static class UDelMarVehicleAction_Turbo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleAction_Turbo>();
	}
};
static_assert(alignof(UDelMarVehicleAction_Turbo) == 0x000008, "Wrong alignment on UDelMarVehicleAction_Turbo");
static_assert(sizeof(UDelMarVehicleAction_Turbo) == 0x000040, "Wrong size on UDelMarVehicleAction_Turbo");

// Class DelMarCore.DelMarChallengeGhostSystemControllerComponent
// 0x0030 (0x00D0 - 0x00A0)
class UDelMarChallengeGhostSystemControllerComponent final : public UControllerComponent
{
public:
	TSubclassOf<class UDelMarGhostPlaybackSessionComponent> GhostPlaybackSessionComponentClass;                // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDelMarGhostRecordingSessionComponent> GhostRecordingSessionComponentClass;               // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        BestRunTime;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarGhostPlaybackSessionComponent> CachedPlaybackSession;                             // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarGhostRecordingSessionComponent> CachedRecordingSession;                            // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarChallengeRaceManager> CachedRaceManager;                                 // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarChallengeGhostSystemControllerComponent">();
	}
	static class UDelMarChallengeGhostSystemControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarChallengeGhostSystemControllerComponent>();
	}
};
static_assert(alignof(UDelMarChallengeGhostSystemControllerComponent) == 0x000008, "Wrong alignment on UDelMarChallengeGhostSystemControllerComponent");
static_assert(sizeof(UDelMarChallengeGhostSystemControllerComponent) == 0x0000D0, "Wrong size on UDelMarChallengeGhostSystemControllerComponent");
static_assert(offsetof(UDelMarChallengeGhostSystemControllerComponent, GhostPlaybackSessionComponentClass) == 0x0000A0, "Member 'UDelMarChallengeGhostSystemControllerComponent::GhostPlaybackSessionComponentClass' has a wrong offset!");
static_assert(offsetof(UDelMarChallengeGhostSystemControllerComponent, GhostRecordingSessionComponentClass) == 0x0000A8, "Member 'UDelMarChallengeGhostSystemControllerComponent::GhostRecordingSessionComponentClass' has a wrong offset!");
static_assert(offsetof(UDelMarChallengeGhostSystemControllerComponent, BestRunTime) == 0x0000B0, "Member 'UDelMarChallengeGhostSystemControllerComponent::BestRunTime' has a wrong offset!");
static_assert(offsetof(UDelMarChallengeGhostSystemControllerComponent, CachedPlaybackSession) == 0x0000B8, "Member 'UDelMarChallengeGhostSystemControllerComponent::CachedPlaybackSession' has a wrong offset!");
static_assert(offsetof(UDelMarChallengeGhostSystemControllerComponent, CachedRecordingSession) == 0x0000C0, "Member 'UDelMarChallengeGhostSystemControllerComponent::CachedRecordingSession' has a wrong offset!");
static_assert(offsetof(UDelMarChallengeGhostSystemControllerComponent, CachedRaceManager) == 0x0000C8, "Member 'UDelMarChallengeGhostSystemControllerComponent::CachedRaceManager' has a wrong offset!");

// Class DelMarCore.DelMarUIInputControllerComponent
// 0x00A0 (0x0140 - 0x00A0)
class UDelMarUIInputControllerComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x68];                                      // 0x00A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           HudWidgetExpandAction;                             // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           ToggleQuestListAction;                             // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDelMarPlayerInputManagerComponent> InputManagerClass;                                 // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UEnhancedInputComponent> InputComponent;                                    // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        PlayerState;                                       // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerController>   PlayerController;                                  // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPlayerPreferencesComponent> PlayerPreferences;                                 // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleHudWidgetExpandCompleted();
	void HandleHudWidgetExpandTriggered();
	void HandleToggleQuestList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarUIInputControllerComponent">();
	}
	static class UDelMarUIInputControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarUIInputControllerComponent>();
	}
};
static_assert(alignof(UDelMarUIInputControllerComponent) == 0x000008, "Wrong alignment on UDelMarUIInputControllerComponent");
static_assert(sizeof(UDelMarUIInputControllerComponent) == 0x000140, "Wrong size on UDelMarUIInputControllerComponent");
static_assert(offsetof(UDelMarUIInputControllerComponent, HudWidgetExpandAction) == 0x000108, "Member 'UDelMarUIInputControllerComponent::HudWidgetExpandAction' has a wrong offset!");
static_assert(offsetof(UDelMarUIInputControllerComponent, ToggleQuestListAction) == 0x000110, "Member 'UDelMarUIInputControllerComponent::ToggleQuestListAction' has a wrong offset!");
static_assert(offsetof(UDelMarUIInputControllerComponent, InputManagerClass) == 0x000118, "Member 'UDelMarUIInputControllerComponent::InputManagerClass' has a wrong offset!");
static_assert(offsetof(UDelMarUIInputControllerComponent, InputComponent) == 0x000120, "Member 'UDelMarUIInputControllerComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UDelMarUIInputControllerComponent, PlayerState) == 0x000128, "Member 'UDelMarUIInputControllerComponent::PlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarUIInputControllerComponent, PlayerController) == 0x000130, "Member 'UDelMarUIInputControllerComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(UDelMarUIInputControllerComponent, PlayerPreferences) == 0x000138, "Member 'UDelMarUIInputControllerComponent::PlayerPreferences' has a wrong offset!");

// Class DelMarCore.DelMarChallengeRaceManager
// 0x0010 (0x04B0 - 0x04A0)
class ADelMarChallengeRaceManager final : public ADelMarRaceManager
{
public:
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           OvertimeTimer;                                     // 0x04A8(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NetMulticast_StartOvertime(const double RaceFinishTimestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarChallengeRaceManager">();
	}
	static class ADelMarChallengeRaceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarChallengeRaceManager>();
	}
};
static_assert(alignof(ADelMarChallengeRaceManager) == 0x000008, "Wrong alignment on ADelMarChallengeRaceManager");
static_assert(sizeof(ADelMarChallengeRaceManager) == 0x0004B0, "Wrong size on ADelMarChallengeRaceManager");
static_assert(offsetof(ADelMarChallengeRaceManager, OvertimeTimer) == 0x0004A8, "Member 'ADelMarChallengeRaceManager::OvertimeTimer' has a wrong offset!");

// Class DelMarCore.DelMarStateMachine
// 0x0108 (0x01A8 - 0x00A0)
class UDelMarStateMachine : public UActorComponent
{
public:
	TArray<struct FDelMarStateOverride>           StateOverrides;                                    // 0x00A0(0x0010)(ZeroConstructor, Transient, Config, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, TSubclassOf<class UDelMarState>> StateMappings;                                     // 0x00B0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RequestedStateTag;                                 // 0x0100(0x0004)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentStateTag;                                   // 0x0104(0x0004)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DefaultStateTag;                                   // 0x0108(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDelMarState*>                   ActiveStates;                                      // 0x0110(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UDelMarState*>                   ReplicatedStates;                                  // 0x0120(0x0010)(Net, ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTag                           WaitingForStateReplicationTag;                     // 0x0130(0x0004)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0x74];                                     // 0x0134(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RequestedStateTag();
	void RequestState(const struct FGameplayTag& StateTag);

	class UDelMarState* GetActiveStateByTag(const struct FGameplayTag& GameplayTag) const;
	class UDelMarState* GetCurrentState() const;
	struct FGameplayTag GetCurrentStateTag() const;
	struct FGameplayTag GetRequestedStateTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarStateMachine">();
	}
	static class UDelMarStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarStateMachine>();
	}
};
static_assert(alignof(UDelMarStateMachine) == 0x000008, "Wrong alignment on UDelMarStateMachine");
static_assert(sizeof(UDelMarStateMachine) == 0x0001A8, "Wrong size on UDelMarStateMachine");
static_assert(offsetof(UDelMarStateMachine, StateOverrides) == 0x0000A0, "Member 'UDelMarStateMachine::StateOverrides' has a wrong offset!");
static_assert(offsetof(UDelMarStateMachine, StateMappings) == 0x0000B0, "Member 'UDelMarStateMachine::StateMappings' has a wrong offset!");
static_assert(offsetof(UDelMarStateMachine, RequestedStateTag) == 0x000100, "Member 'UDelMarStateMachine::RequestedStateTag' has a wrong offset!");
static_assert(offsetof(UDelMarStateMachine, CurrentStateTag) == 0x000104, "Member 'UDelMarStateMachine::CurrentStateTag' has a wrong offset!");
static_assert(offsetof(UDelMarStateMachine, DefaultStateTag) == 0x000108, "Member 'UDelMarStateMachine::DefaultStateTag' has a wrong offset!");
static_assert(offsetof(UDelMarStateMachine, ActiveStates) == 0x000110, "Member 'UDelMarStateMachine::ActiveStates' has a wrong offset!");
static_assert(offsetof(UDelMarStateMachine, ReplicatedStates) == 0x000120, "Member 'UDelMarStateMachine::ReplicatedStates' has a wrong offset!");
static_assert(offsetof(UDelMarStateMachine, WaitingForStateReplicationTag) == 0x000130, "Member 'UDelMarStateMachine::WaitingForStateReplicationTag' has a wrong offset!");

// Class DelMarCore.DelMarStartLineActor
// 0x0008 (0x0298 - 0x0290)
class ADelMarStartLineActor final : public AActor
{
public:
	class ADelMarCheckpoint*                      Checkpoint;                                        // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarStartLineActor">();
	}
	static class ADelMarStartLineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarStartLineActor>();
	}
};
static_assert(alignof(ADelMarStartLineActor) == 0x000008, "Wrong alignment on ADelMarStartLineActor");
static_assert(sizeof(ADelMarStartLineActor) == 0x000298, "Wrong size on ADelMarStartLineActor");
static_assert(offsetof(ADelMarStartLineActor, Checkpoint) == 0x000290, "Member 'ADelMarStartLineActor::Checkpoint' has a wrong offset!");

// Class DelMarCore.DelMarState
// 0x0008 (0x0030 - 0x0028)
class UDelMarState : public UObject
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0028(0x0004)(Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState">();
	}
	static class UDelMarState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState>();
	}
};
static_assert(alignof(UDelMarState) == 0x000008, "Wrong alignment on UDelMarState");
static_assert(sizeof(UDelMarState) == 0x000030, "Wrong size on UDelMarState");
static_assert(offsetof(UDelMarState, StateTag) == 0x000028, "Member 'UDelMarState::StateTag' has a wrong offset!");

// Class DelMarCore.DelMarRacerState
// 0x0000 (0x0030 - 0x0030)
class UDelMarRacerState : public UDelMarState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRacerState">();
	}
	static class UDelMarRacerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRacerState>();
	}
};
static_assert(alignof(UDelMarRacerState) == 0x000008, "Wrong alignment on UDelMarRacerState");
static_assert(sizeof(UDelMarRacerState) == 0x000030, "Wrong size on UDelMarRacerState");

// Class DelMarCore.DelMarRacerState_WithSpectatorTransitionBase
// 0x0000 (0x0030 - 0x0030)
class UDelMarRacerState_WithSpectatorTransitionBase : public UDelMarRacerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRacerState_WithSpectatorTransitionBase">();
	}
	static class UDelMarRacerState_WithSpectatorTransitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRacerState_WithSpectatorTransitionBase>();
	}
};
static_assert(alignof(UDelMarRacerState_WithSpectatorTransitionBase) == 0x000008, "Wrong alignment on UDelMarRacerState_WithSpectatorTransitionBase");
static_assert(sizeof(UDelMarRacerState_WithSpectatorTransitionBase) == 0x000030, "Wrong size on UDelMarRacerState_WithSpectatorTransitionBase");

// Class DelMarCore.DelMarDeathRacerState_ActiveRace
// 0x0010 (0x0040 - 0x0030)
class UDelMarDeathRacerState_ActiveRace final : public UDelMarRacerState_WithSpectatorTransitionBase
{
public:
	TWeakObjectPtr<class ADelMarDeathRaceManager> DeathRaceManager;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishedRound;                                    // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDeathRacerState_ActiveRace">();
	}
	static class UDelMarDeathRacerState_ActiveRace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDeathRacerState_ActiveRace>();
	}
};
static_assert(alignof(UDelMarDeathRacerState_ActiveRace) == 0x000008, "Wrong alignment on UDelMarDeathRacerState_ActiveRace");
static_assert(sizeof(UDelMarDeathRacerState_ActiveRace) == 0x000040, "Wrong size on UDelMarDeathRacerState_ActiveRace");
static_assert(offsetof(UDelMarDeathRacerState_ActiveRace, DeathRaceManager) == 0x000030, "Member 'UDelMarDeathRacerState_ActiveRace::DeathRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarDeathRacerState_ActiveRace, bFinishedRound) == 0x000038, "Member 'UDelMarDeathRacerState_ActiveRace::bFinishedRound' has a wrong offset!");

// Class DelMarCore.DelMarVehicleAction_HazardHit
// 0x0000 (0x0040 - 0x0040)
class UDelMarVehicleAction_HazardHit final : public UDelMarVehicleAction
{
public:
	void HandleHazardHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleAction_HazardHit">();
	}
	static class UDelMarVehicleAction_HazardHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleAction_HazardHit>();
	}
};
static_assert(alignof(UDelMarVehicleAction_HazardHit) == 0x000008, "Wrong alignment on UDelMarVehicleAction_HazardHit");
static_assert(sizeof(UDelMarVehicleAction_HazardHit) == 0x000040, "Wrong size on UDelMarVehicleAction_HazardHit");

// Class DelMarCore.DelMarCompetitiveRacerState_RunFinished
// 0x0000 (0x0030 - 0x0030)
class UDelMarCompetitiveRacerState_RunFinished final : public UDelMarRacerState_WithSpectatorTransitionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCompetitiveRacerState_RunFinished">();
	}
	static class UDelMarCompetitiveRacerState_RunFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCompetitiveRacerState_RunFinished>();
	}
};
static_assert(alignof(UDelMarCompetitiveRacerState_RunFinished) == 0x000008, "Wrong alignment on UDelMarCompetitiveRacerState_RunFinished");
static_assert(sizeof(UDelMarCompetitiveRacerState_RunFinished) == 0x000030, "Wrong size on UDelMarCompetitiveRacerState_RunFinished");

// Class DelMarCore.DelMarChallengeRacerState_RunActive
// 0x0000 (0x0030 - 0x0030)
class UDelMarChallengeRacerState_RunActive final : public UDelMarRacerState_WithSpectatorTransitionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarChallengeRacerState_RunActive">();
	}
	static class UDelMarChallengeRacerState_RunActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarChallengeRacerState_RunActive>();
	}
};
static_assert(alignof(UDelMarChallengeRacerState_RunActive) == 0x000008, "Wrong alignment on UDelMarChallengeRacerState_RunActive");
static_assert(sizeof(UDelMarChallengeRacerState_RunActive) == 0x000030, "Wrong size on UDelMarChallengeRacerState_RunActive");

// Class DelMarCore.DelMarVehicleManager
// 0x0170 (0x01A0 - 0x0030)
class UDelMarVehicleManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x170];                                     // 0x0030(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePawnEnteredVehicle(const TScriptInterface<class IFortVehicleInterface>& Vehicle, class AFortPawn* Pawn, int32 SeatIndex);
	void HandlePawnExitedVehicle(const TScriptInterface<class IFortVehicleInterface>& Vehicle, class AFortPawn* Pawn, int32 SeatIndex);
	void HandlePawnPlayerStateSet(class AFortPlayerPawn* Pawn);
	void HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleManager">();
	}
	static class UDelMarVehicleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleManager>();
	}
};
static_assert(alignof(UDelMarVehicleManager) == 0x000008, "Wrong alignment on UDelMarVehicleManager");
static_assert(sizeof(UDelMarVehicleManager) == 0x0001A0, "Wrong size on UDelMarVehicleManager");

// Class DelMarCore.DelMarRacerStateMachineComponent
// 0x0030 (0x01D8 - 0x01A8)
class UDelMarRacerStateMachineComponent : public UDelMarStateMachine
{
public:
	TWeakObjectPtr<class ADelMarRaceManager>      RaceManager;                                       // 0x01A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PreviousStateTag;                                  // 0x01B0(0x0004)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B4[0x24];                                     // 0x01B4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRacerStateMachineComponent">();
	}
	static class UDelMarRacerStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRacerStateMachineComponent>();
	}
};
static_assert(alignof(UDelMarRacerStateMachineComponent) == 0x000008, "Wrong alignment on UDelMarRacerStateMachineComponent");
static_assert(sizeof(UDelMarRacerStateMachineComponent) == 0x0001D8, "Wrong size on UDelMarRacerStateMachineComponent");
static_assert(offsetof(UDelMarRacerStateMachineComponent, RaceManager) == 0x0001A8, "Member 'UDelMarRacerStateMachineComponent::RaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarRacerStateMachineComponent, PreviousStateTag) == 0x0001B0, "Member 'UDelMarRacerStateMachineComponent::PreviousStateTag' has a wrong offset!");

// Class DelMarCore.DelMarChallengeRacerStateMachineComponent
// 0x0000 (0x01D8 - 0x01D8)
class UDelMarChallengeRacerStateMachineComponent final : public UDelMarRacerStateMachineComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarChallengeRacerStateMachineComponent">();
	}
	static class UDelMarChallengeRacerStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarChallengeRacerStateMachineComponent>();
	}
};
static_assert(alignof(UDelMarChallengeRacerStateMachineComponent) == 0x000008, "Wrong alignment on UDelMarChallengeRacerStateMachineComponent");
static_assert(sizeof(UDelMarChallengeRacerStateMachineComponent) == 0x0001D8, "Wrong size on UDelMarChallengeRacerStateMachineComponent");

// Class DelMarCore.DelMarVehicleAutoInputComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDelMarVehicleAutoInputComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleAutoInputComponent">();
	}
	static class UDelMarVehicleAutoInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleAutoInputComponent>();
	}
};
static_assert(alignof(UDelMarVehicleAutoInputComponent) == 0x000008, "Wrong alignment on UDelMarVehicleAutoInputComponent");
static_assert(sizeof(UDelMarVehicleAutoInputComponent) == 0x0000C0, "Wrong size on UDelMarVehicleAutoInputComponent");

// Class DelMarCore.DelMarSpectatorControllerComponent
// 0x0060 (0x0100 - 0x00A0)
class UDelMarSpectatorControllerComponent : public UControllerComponent
{
public:
	class UInputAction*                           SpectateNextPlayerAction;                          // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           SpectatePrevPlayerAction;                          // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           ExitSpectateAction;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDelMarPlayerInputManagerComponent> InputManagerClass;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UEnhancedInputComponent> InputComponent;                                    // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarRequestComponent> SpectatorRequestComponent;                         // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        CurrentViewTarget;                                 // 0x00D8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        PrevValidViewTarget;                               // 0x00E0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        SpectatorPlayerState;                              // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerControllerZone> SpectatorController;                               // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLateJoinSpectator;                              // 0x00F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExitSpectate();
	void NetMulticast_BeginSpectating();
	void NetMulticast_FinishSpectating();
	void ServerSetSpectatorTarget(class AFortPlayerState* PlayerState);
	void SetIsLateJoinSpectator(bool bNewLateJoinSpectator);
	void SetSpectatorTarget(class AFortPlayerState* PlayerState);
	void SpectateNextPlayer();
	void SpectatePrevPlayer();

	bool IsLateJoinSpectator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarSpectatorControllerComponent">();
	}
	static class UDelMarSpectatorControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarSpectatorControllerComponent>();
	}
};
static_assert(alignof(UDelMarSpectatorControllerComponent) == 0x000008, "Wrong alignment on UDelMarSpectatorControllerComponent");
static_assert(sizeof(UDelMarSpectatorControllerComponent) == 0x000100, "Wrong size on UDelMarSpectatorControllerComponent");
static_assert(offsetof(UDelMarSpectatorControllerComponent, SpectateNextPlayerAction) == 0x0000A0, "Member 'UDelMarSpectatorControllerComponent::SpectateNextPlayerAction' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, SpectatePrevPlayerAction) == 0x0000A8, "Member 'UDelMarSpectatorControllerComponent::SpectatePrevPlayerAction' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, ExitSpectateAction) == 0x0000B0, "Member 'UDelMarSpectatorControllerComponent::ExitSpectateAction' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, InputManagerClass) == 0x0000B8, "Member 'UDelMarSpectatorControllerComponent::InputManagerClass' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, InputComponent) == 0x0000C0, "Member 'UDelMarSpectatorControllerComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, CachedRaceManager) == 0x0000C8, "Member 'UDelMarSpectatorControllerComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, SpectatorRequestComponent) == 0x0000D0, "Member 'UDelMarSpectatorControllerComponent::SpectatorRequestComponent' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, CurrentViewTarget) == 0x0000D8, "Member 'UDelMarSpectatorControllerComponent::CurrentViewTarget' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, PrevValidViewTarget) == 0x0000E0, "Member 'UDelMarSpectatorControllerComponent::PrevValidViewTarget' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, SpectatorPlayerState) == 0x0000E8, "Member 'UDelMarSpectatorControllerComponent::SpectatorPlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, SpectatorController) == 0x0000F0, "Member 'UDelMarSpectatorControllerComponent::SpectatorController' has a wrong offset!");
static_assert(offsetof(UDelMarSpectatorControllerComponent, bIsLateJoinSpectator) == 0x0000F8, "Member 'UDelMarSpectatorControllerComponent::bIsLateJoinSpectator' has a wrong offset!");

// Class DelMarCore.DelMarCoreSplineMeshComponent
// 0x0000 (0x0700 - 0x0700)
class UDelMarCoreSplineMeshComponent final : public USplineMeshComponent
{
public:
	void OnBeginActorOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCoreSplineMeshComponent">();
	}
	static class UDelMarCoreSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCoreSplineMeshComponent>();
	}
};
static_assert(alignof(UDelMarCoreSplineMeshComponent) == 0x000010, "Wrong alignment on UDelMarCoreSplineMeshComponent");
static_assert(sizeof(UDelMarCoreSplineMeshComponent) == 0x000700, "Wrong size on UDelMarCoreSplineMeshComponent");

// Class DelMarCore.DelMarChallengeSpectatorControllerComponent
// 0x0000 (0x0100 - 0x0100)
class UDelMarChallengeSpectatorControllerComponent final : public UDelMarSpectatorControllerComponent
{
public:
	void ClientUpdateFinishedSpectatorTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarChallengeSpectatorControllerComponent">();
	}
	static class UDelMarChallengeSpectatorControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarChallengeSpectatorControllerComponent>();
	}
};
static_assert(alignof(UDelMarChallengeSpectatorControllerComponent) == 0x000008, "Wrong alignment on UDelMarChallengeSpectatorControllerComponent");
static_assert(sizeof(UDelMarChallengeSpectatorControllerComponent) == 0x000100, "Wrong size on UDelMarChallengeSpectatorControllerComponent");

// Class DelMarCore.DelMarVehicleAction_Jump
// 0x0000 (0x0040 - 0x0040)
class UDelMarVehicleAction_Jump final : public UDelMarVehicleAction
{
public:
	void HandleJump();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleAction_Jump">();
	}
	static class UDelMarVehicleAction_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleAction_Jump>();
	}
};
static_assert(alignof(UDelMarVehicleAction_Jump) == 0x000008, "Wrong alignment on UDelMarVehicleAction_Jump");
static_assert(sizeof(UDelMarVehicleAction_Jump) == 0x000040, "Wrong size on UDelMarVehicleAction_Jump");

// Class DelMarCore.DelMarCompetitiveRaceManager
// 0x0018 (0x04B8 - 0x04A0)
class ADelMarCompetitiveRaceManager final : public ADelMarRaceManager
{
public:
	float                                         FinishRaceAfterFirstPlayerFinishedSeconds;         // 0x04A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0xC];                                      // 0x04A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        FirstPlayerFinishedTimestamp;                      // 0x04B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleFinalRacePositionsUpdated(const TArray<struct FDelMarFinalRacePositionEntry>& FinalRacePositions, const struct FDelMarEvent_RunRecorded& RecordedRun);
	void OnRep_FirstPlayerFinishedTimestamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCompetitiveRaceManager">();
	}
	static class ADelMarCompetitiveRaceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarCompetitiveRaceManager>();
	}
};
static_assert(alignof(ADelMarCompetitiveRaceManager) == 0x000008, "Wrong alignment on ADelMarCompetitiveRaceManager");
static_assert(sizeof(ADelMarCompetitiveRaceManager) == 0x0004B8, "Wrong size on ADelMarCompetitiveRaceManager");
static_assert(offsetof(ADelMarCompetitiveRaceManager, FinishRaceAfterFirstPlayerFinishedSeconds) == 0x0004A0, "Member 'ADelMarCompetitiveRaceManager::FinishRaceAfterFirstPlayerFinishedSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarCompetitiveRaceManager, FirstPlayerFinishedTimestamp) == 0x0004B0, "Member 'ADelMarCompetitiveRaceManager::FirstPlayerFinishedTimestamp' has a wrong offset!");

// Class DelMarCore.DelMarCompetitiveRacerState_RunActive
// 0x0000 (0x0030 - 0x0030)
class UDelMarCompetitiveRacerState_RunActive final : public UDelMarRacerState_WithSpectatorTransitionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCompetitiveRacerState_RunActive">();
	}
	static class UDelMarCompetitiveRacerState_RunActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCompetitiveRacerState_RunActive>();
	}
};
static_assert(alignof(UDelMarCompetitiveRacerState_RunActive) == 0x000008, "Wrong alignment on UDelMarCompetitiveRacerState_RunActive");
static_assert(sizeof(UDelMarCompetitiveRacerState_RunActive) == 0x000030, "Wrong size on UDelMarCompetitiveRacerState_RunActive");

// Class DelMarCore.DelMarCompetitiveRacerStateMachineComponent
// 0x0000 (0x01D8 - 0x01D8)
class UDelMarCompetitiveRacerStateMachineComponent final : public UDelMarRacerStateMachineComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCompetitiveRacerStateMachineComponent">();
	}
	static class UDelMarCompetitiveRacerStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCompetitiveRacerStateMachineComponent>();
	}
};
static_assert(alignof(UDelMarCompetitiveRacerStateMachineComponent) == 0x000008, "Wrong alignment on UDelMarCompetitiveRacerStateMachineComponent");
static_assert(sizeof(UDelMarCompetitiveRacerStateMachineComponent) == 0x0001D8, "Wrong size on UDelMarCompetitiveRacerStateMachineComponent");

// Class DelMarCore.DelMarConnectedHintComponent
// 0x0050 (0x00F0 - 0x00A0)
class UDelMarConnectedHintComponent final : public UActorComponent
{
public:
	bool                                          bShouldShowHint;                                   // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDelMarVehicleAction>       VehicleActionClass;                                // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptMultipleTags;                               // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MultipleTagContainer;                              // 0x00B8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADelMarVehicle>          CachedVehicle;                                     // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarVehicleAction*                   VehicleAction;                                     // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginPlay();
	void HandleActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void HandleActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void HandleVehicleActionPerformed();
	void PassNuxHintTypeToConnectedHintComponent(const struct FGameplayTag& HintTypeTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarConnectedHintComponent">();
	}
	static class UDelMarConnectedHintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarConnectedHintComponent>();
	}
};
static_assert(alignof(UDelMarConnectedHintComponent) == 0x000008, "Wrong alignment on UDelMarConnectedHintComponent");
static_assert(sizeof(UDelMarConnectedHintComponent) == 0x0000F0, "Wrong size on UDelMarConnectedHintComponent");
static_assert(offsetof(UDelMarConnectedHintComponent, bShouldShowHint) == 0x0000A0, "Member 'UDelMarConnectedHintComponent::bShouldShowHint' has a wrong offset!");
static_assert(offsetof(UDelMarConnectedHintComponent, VehicleActionClass) == 0x0000A8, "Member 'UDelMarConnectedHintComponent::VehicleActionClass' has a wrong offset!");
static_assert(offsetof(UDelMarConnectedHintComponent, bAcceptMultipleTags) == 0x0000B0, "Member 'UDelMarConnectedHintComponent::bAcceptMultipleTags' has a wrong offset!");
static_assert(offsetof(UDelMarConnectedHintComponent, MultipleTagContainer) == 0x0000B8, "Member 'UDelMarConnectedHintComponent::MultipleTagContainer' has a wrong offset!");
static_assert(offsetof(UDelMarConnectedHintComponent, CachedVehicle) == 0x0000D8, "Member 'UDelMarConnectedHintComponent::CachedVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarConnectedHintComponent, VehicleAction) == 0x0000E0, "Member 'UDelMarConnectedHintComponent::VehicleAction' has a wrong offset!");

// Class DelMarCore.DelMarCoreOobTubePositionalRenderingComponent
// 0x0008 (0x0118 - 0x0110)
class UDelMarCoreOobTubePositionalRenderingComponent final : public UDelMarTrackOobTubePositionalRenderingComponent
{
public:
	TWeakObjectPtr<class APlayerState>            ViewTargetPlayerState;                             // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCoreOobTubePositionalRenderingComponent">();
	}
	static class UDelMarCoreOobTubePositionalRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCoreOobTubePositionalRenderingComponent>();
	}
};
static_assert(alignof(UDelMarCoreOobTubePositionalRenderingComponent) == 0x000008, "Wrong alignment on UDelMarCoreOobTubePositionalRenderingComponent");
static_assert(sizeof(UDelMarCoreOobTubePositionalRenderingComponent) == 0x000118, "Wrong size on UDelMarCoreOobTubePositionalRenderingComponent");
static_assert(offsetof(UDelMarCoreOobTubePositionalRenderingComponent, ViewTargetPlayerState) == 0x000110, "Member 'UDelMarCoreOobTubePositionalRenderingComponent::ViewTargetPlayerState' has a wrong offset!");

// Class DelMarCore.DelMarCosmeticsDatabase
// 0x0020 (0x0050 - 0x0030)
class UDelMarCosmeticsDatabase final : public UPrimaryDataAsset
{
public:
	TArray<class UDelMarCosmeticItemDefinition*>  Items;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDelMarCosmeticSlotInfo>        SlotInfos;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	TArray<class UDelMarCosmeticItemDefinition*> GetItemsForSlot(const struct FGameplayTag& Slot);

	const TArray<struct FDelMarCosmeticSlotInfo> GetSlotInfos() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCosmeticsDatabase">();
	}
	static class UDelMarCosmeticsDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCosmeticsDatabase>();
	}
};
static_assert(alignof(UDelMarCosmeticsDatabase) == 0x000008, "Wrong alignment on UDelMarCosmeticsDatabase");
static_assert(sizeof(UDelMarCosmeticsDatabase) == 0x000050, "Wrong size on UDelMarCosmeticsDatabase");
static_assert(offsetof(UDelMarCosmeticsDatabase, Items) == 0x000030, "Member 'UDelMarCosmeticsDatabase::Items' has a wrong offset!");
static_assert(offsetof(UDelMarCosmeticsDatabase, SlotInfos) == 0x000040, "Member 'UDelMarCosmeticsDatabase::SlotInfos' has a wrong offset!");

// Class DelMarCore.DelMarDeathRacerState_FinishedRace
// 0x0000 (0x0030 - 0x0030)
class UDelMarDeathRacerState_FinishedRace final : public UDelMarRacerState_WithSpectatorTransitionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDeathRacerState_FinishedRace">();
	}
	static class UDelMarDeathRacerState_FinishedRace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDeathRacerState_FinishedRace>();
	}
};
static_assert(alignof(UDelMarDeathRacerState_FinishedRace) == 0x000008, "Wrong alignment on UDelMarDeathRacerState_FinishedRace");
static_assert(sizeof(UDelMarDeathRacerState_FinishedRace) == 0x000030, "Wrong size on UDelMarDeathRacerState_FinishedRace");

// Class DelMarCore.DelMarDeathRacerStateMachineComponent
// 0x0000 (0x01D8 - 0x01D8)
class UDelMarDeathRacerStateMachineComponent final : public UDelMarRacerStateMachineComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDeathRacerStateMachineComponent">();
	}
	static class UDelMarDeathRacerStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDeathRacerStateMachineComponent>();
	}
};
static_assert(alignof(UDelMarDeathRacerStateMachineComponent) == 0x000008, "Wrong alignment on UDelMarDeathRacerStateMachineComponent");
static_assert(sizeof(UDelMarDeathRacerStateMachineComponent) == 0x0001D8, "Wrong size on UDelMarDeathRacerStateMachineComponent");

// Class DelMarCore.DelMarDoubleTapInputTrigger
// 0x0010 (0x0060 - 0x0050)
class UDelMarDoubleTapInputTrigger final : public UInputTrigger
{
public:
	float                                         Delay;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDoubleTapInputTrigger">();
	}
	static class UDelMarDoubleTapInputTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDoubleTapInputTrigger>();
	}
};
static_assert(alignof(UDelMarDoubleTapInputTrigger) == 0x000008, "Wrong alignment on UDelMarDoubleTapInputTrigger");
static_assert(sizeof(UDelMarDoubleTapInputTrigger) == 0x000060, "Wrong size on UDelMarDoubleTapInputTrigger");
static_assert(offsetof(UDelMarDoubleTapInputTrigger, Delay) == 0x000050, "Member 'UDelMarDoubleTapInputTrigger::Delay' has a wrong offset!");

// Class DelMarCore.DelMarPhysMatAttribute
// 0x0000 (0x0028 - 0x0028)
class UDelMarPhysMatAttribute : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPhysMatAttribute">();
	}
	static class UDelMarPhysMatAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPhysMatAttribute>();
	}
};
static_assert(alignof(UDelMarPhysMatAttribute) == 0x000008, "Wrong alignment on UDelMarPhysMatAttribute");
static_assert(sizeof(UDelMarPhysMatAttribute) == 0x000028, "Wrong size on UDelMarPhysMatAttribute");

// Class DelMarCore.DelMarDriveParticlesPhysMatAttribute
// 0x0008 (0x0030 - 0x0028)
class UDelMarDriveParticlesPhysMatAttribute final : public UDelMarPhysMatAttribute
{
public:
	class UNiagaraSystem*                         DriveParticles;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriveParticlesPhysMatAttribute">();
	}
	static class UDelMarDriveParticlesPhysMatAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDriveParticlesPhysMatAttribute>();
	}
};
static_assert(alignof(UDelMarDriveParticlesPhysMatAttribute) == 0x000008, "Wrong alignment on UDelMarDriveParticlesPhysMatAttribute");
static_assert(sizeof(UDelMarDriveParticlesPhysMatAttribute) == 0x000030, "Wrong size on UDelMarDriveParticlesPhysMatAttribute");
static_assert(offsetof(UDelMarDriveParticlesPhysMatAttribute, DriveParticles) == 0x000028, "Member 'UDelMarDriveParticlesPhysMatAttribute::DriveParticles' has a wrong offset!");

// Class DelMarCore.DelMarDriverInteractionComponent
// 0x0058 (0x00F8 - 0x00A0)
class UDelMarDriverInteractionComponent final : public UControllerComponent
{
public:
	class AFortPlayerState*                       ViewPlayerState;                                   // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADelMarVehicle*                         ViewVehicle;                                       // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PassEventSquareDistThreshold;                      // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelMarPlayerRaceDataComponent*         RaceData;                                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverInteractionComponent">();
	}
	static class UDelMarDriverInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDriverInteractionComponent>();
	}
};
static_assert(alignof(UDelMarDriverInteractionComponent) == 0x000008, "Wrong alignment on UDelMarDriverInteractionComponent");
static_assert(sizeof(UDelMarDriverInteractionComponent) == 0x0000F8, "Wrong size on UDelMarDriverInteractionComponent");
static_assert(offsetof(UDelMarDriverInteractionComponent, ViewPlayerState) == 0x0000A0, "Member 'UDelMarDriverInteractionComponent::ViewPlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarDriverInteractionComponent, ViewVehicle) == 0x0000A8, "Member 'UDelMarDriverInteractionComponent::ViewVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarDriverInteractionComponent, PassEventSquareDistThreshold) == 0x0000E0, "Member 'UDelMarDriverInteractionComponent::PassEventSquareDistThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarDriverInteractionComponent, RaceData) == 0x0000E8, "Member 'UDelMarDriverInteractionComponent::RaceData' has a wrong offset!");

// Class DelMarCore.DelMarEvent_FinalFirstPlaceChanged
// 0x0010 (0x0038 - 0x0028)
class UDelMarEvent_FinalFirstPlaceChanged final : public UObject
{
public:
	TWeakObjectPtr<class AFortPlayerState>        NewFirstPlace;                                     // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AFortPlayerState>        PrevFirstPlace;                                    // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarEvent_FinalFirstPlaceChanged">();
	}
	static class UDelMarEvent_FinalFirstPlaceChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarEvent_FinalFirstPlaceChanged>();
	}
};
static_assert(alignof(UDelMarEvent_FinalFirstPlaceChanged) == 0x000008, "Wrong alignment on UDelMarEvent_FinalFirstPlaceChanged");
static_assert(sizeof(UDelMarEvent_FinalFirstPlaceChanged) == 0x000038, "Wrong size on UDelMarEvent_FinalFirstPlaceChanged");
static_assert(offsetof(UDelMarEvent_FinalFirstPlaceChanged, NewFirstPlace) == 0x000028, "Member 'UDelMarEvent_FinalFirstPlaceChanged::NewFirstPlace' has a wrong offset!");
static_assert(offsetof(UDelMarEvent_FinalFirstPlaceChanged, PrevFirstPlace) == 0x000030, "Member 'UDelMarEvent_FinalFirstPlaceChanged::PrevFirstPlace' has a wrong offset!");

// Class DelMarCore.DelMarEvent_GlobalLeaderboardActive
// 0x0020 (0x0048 - 0x0028)
class UDelMarEvent_GlobalLeaderboardActive final : public UObject
{
public:
	class FString                                 LeaderboardEventId;                                // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LeaderboardWindowId;                               // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarEvent_GlobalLeaderboardActive">();
	}
	static class UDelMarEvent_GlobalLeaderboardActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarEvent_GlobalLeaderboardActive>();
	}
};
static_assert(alignof(UDelMarEvent_GlobalLeaderboardActive) == 0x000008, "Wrong alignment on UDelMarEvent_GlobalLeaderboardActive");
static_assert(sizeof(UDelMarEvent_GlobalLeaderboardActive) == 0x000048, "Wrong size on UDelMarEvent_GlobalLeaderboardActive");
static_assert(offsetof(UDelMarEvent_GlobalLeaderboardActive, LeaderboardEventId) == 0x000028, "Member 'UDelMarEvent_GlobalLeaderboardActive::LeaderboardEventId' has a wrong offset!");
static_assert(offsetof(UDelMarEvent_GlobalLeaderboardActive, LeaderboardWindowId) == 0x000038, "Member 'UDelMarEvent_GlobalLeaderboardActive::LeaderboardWindowId' has a wrong offset!");

// Class DelMarCore.DelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated
// 0x0000 (0x0028 - 0x0028)
class UDelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated">();
	}
	static class UDelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated>();
	}
};
static_assert(alignof(UDelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated) == 0x000008, "Wrong alignment on UDelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated");
static_assert(sizeof(UDelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated) == 0x000028, "Wrong size on UDelMarEvent_GlobalLeaderboardFocusedLeaderboardEntriesPopulated");

// Class DelMarCore.DelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated
// 0x0000 (0x0028 - 0x0028)
class UDelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated">();
	}
	static class UDelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated>();
	}
};
static_assert(alignof(UDelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated) == 0x000008, "Wrong alignment on UDelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated");
static_assert(sizeof(UDelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated) == 0x000028, "Wrong size on UDelMarEvent_GlobalLeaderboardTopLeaderboardEntriesPopulated");

// Class DelMarCore.DelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated
// 0x0000 (0x0028 - 0x0028)
class UDelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated">();
	}
	static class UDelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated>();
	}
};
static_assert(alignof(UDelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated) == 0x000008, "Wrong alignment on UDelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated");
static_assert(sizeof(UDelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated) == 0x000028, "Wrong size on UDelMarEvent_GlobalLeaderboardFriendLeaderboardEntriesPopulated");

// Class DelMarCore.DelMarEvent_GlobalLeaderboardPersonalBestRetrieved
// 0x0040 (0x0068 - 0x0028)
class UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved final : public UObject
{
public:
	struct FDelMarGlobalLeaderboardEntry          PersonalBest;                                      // 0x0028(0x0040)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarEvent_GlobalLeaderboardPersonalBestRetrieved">();
	}
	static class UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved>();
	}
};
static_assert(alignof(UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved) == 0x000008, "Wrong alignment on UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved");
static_assert(sizeof(UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved) == 0x000068, "Wrong size on UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved");
static_assert(offsetof(UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved, PersonalBest) == 0x000028, "Member 'UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved::PersonalBest' has a wrong offset!");

// Class DelMarCore.DelMarFlowAnalyticsControllerComponent
// 0x0018 (0x00B8 - 0x00A0)
class UDelMarFlowAnalyticsControllerComponent final : public UControllerComponent
{
public:
	class FString                                 FlowAnalyicsEventName;                             // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerController>   PlayerController;                                  // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void TutorialComplete();
	void TutorialGoRace();
	void TutorialKeepTraining();
	void TutorialReplay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarFlowAnalyticsControllerComponent">();
	}
	static class UDelMarFlowAnalyticsControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarFlowAnalyticsControllerComponent>();
	}
};
static_assert(alignof(UDelMarFlowAnalyticsControllerComponent) == 0x000008, "Wrong alignment on UDelMarFlowAnalyticsControllerComponent");
static_assert(sizeof(UDelMarFlowAnalyticsControllerComponent) == 0x0000B8, "Wrong size on UDelMarFlowAnalyticsControllerComponent");
static_assert(offsetof(UDelMarFlowAnalyticsControllerComponent, FlowAnalyicsEventName) == 0x0000A0, "Member 'UDelMarFlowAnalyticsControllerComponent::FlowAnalyicsEventName' has a wrong offset!");
static_assert(offsetof(UDelMarFlowAnalyticsControllerComponent, PlayerController) == 0x0000B0, "Member 'UDelMarFlowAnalyticsControllerComponent::PlayerController' has a wrong offset!");

// Class DelMarCore.DelMarGameplayState
// 0x0000 (0x0030 - 0x0030)
class UDelMarGameplayState : public UDelMarState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGameplayState">();
	}
	static class UDelMarGameplayState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGameplayState>();
	}
};
static_assert(alignof(UDelMarGameplayState) == 0x000008, "Wrong alignment on UDelMarGameplayState");
static_assert(sizeof(UDelMarGameplayState) == 0x000030, "Wrong size on UDelMarGameplayState");

// Class DelMarCore.DelMarGameUserSettings
// 0x0018 (0x0040 - 0x0028)
class UDelMarGameUserSettings final : public UObject
{
public:
	bool                                          bNuxHasShownVideo;                                 // 0x0028(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNuxHasPromptedToPlayTutorial;                     // 0x0029(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNuxHasShownDefaultMode;                           // 0x002A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastPlayedDelMarMnemonic;                          // 0x0030(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGameUserSettings">();
	}
	static class UDelMarGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGameUserSettings>();
	}
};
static_assert(alignof(UDelMarGameUserSettings) == 0x000008, "Wrong alignment on UDelMarGameUserSettings");
static_assert(sizeof(UDelMarGameUserSettings) == 0x000040, "Wrong size on UDelMarGameUserSettings");
static_assert(offsetof(UDelMarGameUserSettings, bNuxHasShownVideo) == 0x000028, "Member 'UDelMarGameUserSettings::bNuxHasShownVideo' has a wrong offset!");
static_assert(offsetof(UDelMarGameUserSettings, bNuxHasPromptedToPlayTutorial) == 0x000029, "Member 'UDelMarGameUserSettings::bNuxHasPromptedToPlayTutorial' has a wrong offset!");
static_assert(offsetof(UDelMarGameUserSettings, bNuxHasShownDefaultMode) == 0x00002A, "Member 'UDelMarGameUserSettings::bNuxHasShownDefaultMode' has a wrong offset!");
static_assert(offsetof(UDelMarGameUserSettings, LastPlayedDelMarMnemonic) == 0x000030, "Member 'UDelMarGameUserSettings::LastPlayedDelMarMnemonic' has a wrong offset!");

// Class DelMarCore.DelMarGhostPlaybackTrigger
// 0x0030 (0x02C0 - 0x0290)
class ADelMarGhostPlaybackTrigger final : public AActor
{
public:
	int32                                         PreviewFrame;                                      // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartFrame;                                        // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EndFrame;                                          // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxFrame;                                          // 0x029C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarGhostReplayLog*                  PlaybackLog;                                       // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxCollider;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDelMarGhostPlaybackSessionComponent> PlaybackSessionClassOverride;                      // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarGhostPlaybackSessionComponent*   PlaybackSession;                                   // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_HandlePlaybackCompleted(const struct FVector& Location);
	void HandlePlaybackCompleted();
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGhostPlaybackTrigger">();
	}
	static class ADelMarGhostPlaybackTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarGhostPlaybackTrigger>();
	}
};
static_assert(alignof(ADelMarGhostPlaybackTrigger) == 0x000008, "Wrong alignment on ADelMarGhostPlaybackTrigger");
static_assert(sizeof(ADelMarGhostPlaybackTrigger) == 0x0002C0, "Wrong size on ADelMarGhostPlaybackTrigger");
static_assert(offsetof(ADelMarGhostPlaybackTrigger, PreviewFrame) == 0x000290, "Member 'ADelMarGhostPlaybackTrigger::PreviewFrame' has a wrong offset!");
static_assert(offsetof(ADelMarGhostPlaybackTrigger, StartFrame) == 0x000294, "Member 'ADelMarGhostPlaybackTrigger::StartFrame' has a wrong offset!");
static_assert(offsetof(ADelMarGhostPlaybackTrigger, EndFrame) == 0x000298, "Member 'ADelMarGhostPlaybackTrigger::EndFrame' has a wrong offset!");
static_assert(offsetof(ADelMarGhostPlaybackTrigger, MaxFrame) == 0x00029C, "Member 'ADelMarGhostPlaybackTrigger::MaxFrame' has a wrong offset!");
static_assert(offsetof(ADelMarGhostPlaybackTrigger, PlaybackLog) == 0x0002A0, "Member 'ADelMarGhostPlaybackTrigger::PlaybackLog' has a wrong offset!");
static_assert(offsetof(ADelMarGhostPlaybackTrigger, BoxCollider) == 0x0002A8, "Member 'ADelMarGhostPlaybackTrigger::BoxCollider' has a wrong offset!");
static_assert(offsetof(ADelMarGhostPlaybackTrigger, PlaybackSessionClassOverride) == 0x0002B0, "Member 'ADelMarGhostPlaybackTrigger::PlaybackSessionClassOverride' has a wrong offset!");
static_assert(offsetof(ADelMarGhostPlaybackTrigger, PlaybackSession) == 0x0002B8, "Member 'ADelMarGhostPlaybackTrigger::PlaybackSession' has a wrong offset!");

// Class DelMarCore.DelMarGhostRecordingSessionComponent
// 0x0050 (0x0100 - 0x00B0)
class UDelMarGhostRecordingSessionComponent final : public UDelMarGhostSessionComponent
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelMarGhostReplayLog*                  RecordLog;                                         // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordOffPhysicsDelegate;                         // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x23];                                      // 0x00D1(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentFrame;                                      // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          CachedDelMarVehicle;                               // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetRecordOffPhysicsDelegate(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGhostRecordingSessionComponent">();
	}
	static class UDelMarGhostRecordingSessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGhostRecordingSessionComponent>();
	}
};
static_assert(alignof(UDelMarGhostRecordingSessionComponent) == 0x000008, "Wrong alignment on UDelMarGhostRecordingSessionComponent");
static_assert(sizeof(UDelMarGhostRecordingSessionComponent) == 0x000100, "Wrong size on UDelMarGhostRecordingSessionComponent");
static_assert(offsetof(UDelMarGhostRecordingSessionComponent, RecordLog) == 0x0000C8, "Member 'UDelMarGhostRecordingSessionComponent::RecordLog' has a wrong offset!");
static_assert(offsetof(UDelMarGhostRecordingSessionComponent, bRecordOffPhysicsDelegate) == 0x0000D0, "Member 'UDelMarGhostRecordingSessionComponent::bRecordOffPhysicsDelegate' has a wrong offset!");
static_assert(offsetof(UDelMarGhostRecordingSessionComponent, CurrentFrame) == 0x0000F4, "Member 'UDelMarGhostRecordingSessionComponent::CurrentFrame' has a wrong offset!");
static_assert(offsetof(UDelMarGhostRecordingSessionComponent, CachedDelMarVehicle) == 0x0000F8, "Member 'UDelMarGhostRecordingSessionComponent::CachedDelMarVehicle' has a wrong offset!");

// Class DelMarCore.DelMarGhostReplayLog
// 0x0018 (0x0040 - 0x0028)
class UDelMarGhostReplayLog final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGhostReplayFrame>              Frames;                                            // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGhostReplayLog">();
	}
	static class UDelMarGhostReplayLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGhostReplayLog>();
	}
};
static_assert(alignof(UDelMarGhostReplayLog) == 0x000008, "Wrong alignment on UDelMarGhostReplayLog");
static_assert(sizeof(UDelMarGhostReplayLog) == 0x000040, "Wrong size on UDelMarGhostReplayLog");
static_assert(offsetof(UDelMarGhostReplayLog, Frames) == 0x000030, "Member 'UDelMarGhostReplayLog::Frames' has a wrong offset!");

// Class DelMarCore.DelMarGlobalLeaderboardControllerComponent
// 0x00B0 (0x0150 - 0x00A0)
class UDelMarGlobalLeaderboardControllerComponent final : public UControllerComponent
{
public:
	bool                                          bIsLeaderboardEnabled;                             // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDelMarGlobalLeaderboardEntry>  TopLeaderboardEntries;                             // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDelMarGlobalLeaderboardEntry>  FocusedLeaderboardEntries;                         // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDelMarGlobalLeaderboardEntry>  FriendLeaderboardEntries;                          // 0x00C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasRequestedLeaderboards;                         // 0x00D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasPersonalBest;                                  // 0x00D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarGlobalLeaderboardEntry          PersonalBest;                                      // 0x00E0(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelMarEvent_GlobalLeaderboardActive*   GlobalLeaderboardActiveEvent;                      // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDelMarLeaderboardSettings             LeaderboardSettings;                               // 0x0130(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void ClientNewPersonalBest(const struct FDelMarEvent_GlobalLeaderboardNewPersonalBest& PersonalBestEvent);
	void ClientUpdateLeaderboards();
	void OnRep_LeaderboardSettings();
	void ServerNewPersonalBest(const struct FDelMarEvent_GlobalLeaderboardNewPersonalBest& PersonalBestRetrievedEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGlobalLeaderboardControllerComponent">();
	}
	static class UDelMarGlobalLeaderboardControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGlobalLeaderboardControllerComponent>();
	}
};
static_assert(alignof(UDelMarGlobalLeaderboardControllerComponent) == 0x000008, "Wrong alignment on UDelMarGlobalLeaderboardControllerComponent");
static_assert(sizeof(UDelMarGlobalLeaderboardControllerComponent) == 0x000150, "Wrong size on UDelMarGlobalLeaderboardControllerComponent");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, bIsLeaderboardEnabled) == 0x0000A0, "Member 'UDelMarGlobalLeaderboardControllerComponent::bIsLeaderboardEnabled' has a wrong offset!");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, TopLeaderboardEntries) == 0x0000A8, "Member 'UDelMarGlobalLeaderboardControllerComponent::TopLeaderboardEntries' has a wrong offset!");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, FocusedLeaderboardEntries) == 0x0000B8, "Member 'UDelMarGlobalLeaderboardControllerComponent::FocusedLeaderboardEntries' has a wrong offset!");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, FriendLeaderboardEntries) == 0x0000C8, "Member 'UDelMarGlobalLeaderboardControllerComponent::FriendLeaderboardEntries' has a wrong offset!");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, bHasRequestedLeaderboards) == 0x0000D8, "Member 'UDelMarGlobalLeaderboardControllerComponent::bHasRequestedLeaderboards' has a wrong offset!");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, bHasPersonalBest) == 0x0000D9, "Member 'UDelMarGlobalLeaderboardControllerComponent::bHasPersonalBest' has a wrong offset!");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, PersonalBest) == 0x0000E0, "Member 'UDelMarGlobalLeaderboardControllerComponent::PersonalBest' has a wrong offset!");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, GlobalLeaderboardActiveEvent) == 0x000128, "Member 'UDelMarGlobalLeaderboardControllerComponent::GlobalLeaderboardActiveEvent' has a wrong offset!");
static_assert(offsetof(UDelMarGlobalLeaderboardControllerComponent, LeaderboardSettings) == 0x000130, "Member 'UDelMarGlobalLeaderboardControllerComponent::LeaderboardSettings' has a wrong offset!");

// Class DelMarCore.GuidedZoneRequirement_Drift
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_Drift final : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_Drift">();
	}
	static class UGuidedZoneRequirement_Drift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_Drift>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_Drift) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_Drift");
static_assert(sizeof(UGuidedZoneRequirement_Drift) == 0x000028, "Wrong size on UGuidedZoneRequirement_Drift");

// Class DelMarCore.GuidedZoneRequirement_DriftKick
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_DriftKick final : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_DriftKick">();
	}
	static class UGuidedZoneRequirement_DriftKick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_DriftKick>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_DriftKick) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_DriftKick");
static_assert(sizeof(UGuidedZoneRequirement_DriftKick) == 0x000028, "Wrong size on UGuidedZoneRequirement_DriftKick");

// Class DelMarCore.GuidedZoneRequirement_Turbo
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_Turbo final : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_Turbo">();
	}
	static class UGuidedZoneRequirement_Turbo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_Turbo>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_Turbo) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_Turbo");
static_assert(sizeof(UGuidedZoneRequirement_Turbo) == 0x000028, "Wrong size on UGuidedZoneRequirement_Turbo");

// Class DelMarCore.GuidedZoneRequirement_Underthrust
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_Underthrust final : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_Underthrust">();
	}
	static class UGuidedZoneRequirement_Underthrust* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_Underthrust>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_Underthrust) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_Underthrust");
static_assert(sizeof(UGuidedZoneRequirement_Underthrust) == 0x000028, "Wrong size on UGuidedZoneRequirement_Underthrust");

// Class DelMarCore.GuidedZoneRequirement_Jump
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_Jump : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_Jump">();
	}
	static class UGuidedZoneRequirement_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_Jump>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_Jump) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_Jump");
static_assert(sizeof(UGuidedZoneRequirement_Jump) == 0x000028, "Wrong size on UGuidedZoneRequirement_Jump");

// Class DelMarCore.GuidedZoneRequirement_JumpOrUnderthrust
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_JumpOrUnderthrust final : public UGuidedZoneRequirement_Jump
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_JumpOrUnderthrust">();
	}
	static class UGuidedZoneRequirement_JumpOrUnderthrust* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_JumpOrUnderthrust>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_JumpOrUnderthrust) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_JumpOrUnderthrust");
static_assert(sizeof(UGuidedZoneRequirement_JumpOrUnderthrust) == 0x000028, "Wrong size on UGuidedZoneRequirement_JumpOrUnderthrust");

// Class DelMarCore.GuidedZoneRequirement_DriftBoostActive
// 0x0000 (0x0028 - 0x0028)
class UGuidedZoneRequirement_DriftBoostActive final : public UGuidedZoneRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_DriftBoostActive">();
	}
	static class UGuidedZoneRequirement_DriftBoostActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_DriftBoostActive>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_DriftBoostActive) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_DriftBoostActive");
static_assert(sizeof(UGuidedZoneRequirement_DriftBoostActive) == 0x000028, "Wrong size on UGuidedZoneRequirement_DriftBoostActive");

// Class DelMarCore.GuidedZoneRequirement_MidTutorial
// 0x0010 (0x0038 - 0x0028)
class UGuidedZoneRequirement_MidTutorial final : public UGuidedZoneRequirement
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedZoneRequirement_MidTutorial">();
	}
	static class UGuidedZoneRequirement_MidTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuidedZoneRequirement_MidTutorial>();
	}
};
static_assert(alignof(UGuidedZoneRequirement_MidTutorial) == 0x000008, "Wrong alignment on UGuidedZoneRequirement_MidTutorial");
static_assert(sizeof(UGuidedZoneRequirement_MidTutorial) == 0x000038, "Wrong size on UGuidedZoneRequirement_MidTutorial");

// Class DelMarCore.DelMarGuidedTutorialZoneActor
// 0x0130 (0x03C0 - 0x0290)
class ADelMarGuidedTutorialZoneActor final : public AActor
{
public:
	class UBoxComponent*                          BoxCollider;                                       // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalTimeDilation;                                 // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionSeconds;                                 // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTimeDilationSeconds;                            // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDemoVehicleOnFail;                                // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarEvent_SetTutorialAnnouncement   ScreenMessage;                                     // 0x02A8(0x0058)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         HintDelaySeconds;                                  // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HintRemovalDelaySeconds;                           // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGuidedZoneRequirement>     ZoneRequirementClass;                              // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InputTagsToRemoveOnZoneStart;                      // 0x0310(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InputTagsToAddOnZoneStart;                         // 0x0330(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InputTagsToRemoveOnZoneEnd;                        // 0x0350(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InputTagsToAddOnZoneEnd;                           // 0x0370(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UGuidedZoneRequirement*                 ZoneRequirement;                                   // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      RaceManager;                                       // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          ActiveVehicle;                                     // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerController>   ActivePlayerController;                            // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnTutorialZoneComplete();
	void BP_OnTutorialZoneFailed();
	void BP_OnTutorialZoneStarted();
	void HandleVehicleDemolished(const struct FGameplayTag& CausedByTag);
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGuidedTutorialZoneActor">();
	}
	static class ADelMarGuidedTutorialZoneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarGuidedTutorialZoneActor>();
	}
};
static_assert(alignof(ADelMarGuidedTutorialZoneActor) == 0x000008, "Wrong alignment on ADelMarGuidedTutorialZoneActor");
static_assert(sizeof(ADelMarGuidedTutorialZoneActor) == 0x0003C0, "Wrong size on ADelMarGuidedTutorialZoneActor");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, BoxCollider) == 0x000290, "Member 'ADelMarGuidedTutorialZoneActor::BoxCollider' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, FinalTimeDilation) == 0x000298, "Member 'ADelMarGuidedTutorialZoneActor::FinalTimeDilation' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, TransitionSeconds) == 0x00029C, "Member 'ADelMarGuidedTutorialZoneActor::TransitionSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, MaxTimeDilationSeconds) == 0x0002A0, "Member 'ADelMarGuidedTutorialZoneActor::MaxTimeDilationSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, bDemoVehicleOnFail) == 0x0002A4, "Member 'ADelMarGuidedTutorialZoneActor::bDemoVehicleOnFail' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, ScreenMessage) == 0x0002A8, "Member 'ADelMarGuidedTutorialZoneActor::ScreenMessage' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, HintDelaySeconds) == 0x000300, "Member 'ADelMarGuidedTutorialZoneActor::HintDelaySeconds' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, HintRemovalDelaySeconds) == 0x000304, "Member 'ADelMarGuidedTutorialZoneActor::HintRemovalDelaySeconds' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, ZoneRequirementClass) == 0x000308, "Member 'ADelMarGuidedTutorialZoneActor::ZoneRequirementClass' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, InputTagsToRemoveOnZoneStart) == 0x000310, "Member 'ADelMarGuidedTutorialZoneActor::InputTagsToRemoveOnZoneStart' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, InputTagsToAddOnZoneStart) == 0x000330, "Member 'ADelMarGuidedTutorialZoneActor::InputTagsToAddOnZoneStart' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, InputTagsToRemoveOnZoneEnd) == 0x000350, "Member 'ADelMarGuidedTutorialZoneActor::InputTagsToRemoveOnZoneEnd' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, InputTagsToAddOnZoneEnd) == 0x000370, "Member 'ADelMarGuidedTutorialZoneActor::InputTagsToAddOnZoneEnd' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, ZoneRequirement) == 0x000390, "Member 'ADelMarGuidedTutorialZoneActor::ZoneRequirement' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, RaceManager) == 0x000398, "Member 'ADelMarGuidedTutorialZoneActor::RaceManager' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, ActiveVehicle) == 0x0003A0, "Member 'ADelMarGuidedTutorialZoneActor::ActiveVehicle' has a wrong offset!");
static_assert(offsetof(ADelMarGuidedTutorialZoneActor, ActivePlayerController) == 0x0003A8, "Member 'ADelMarGuidedTutorialZoneActor::ActivePlayerController' has a wrong offset!");

// Class DelMarCore.DelMarInputModifierHazard
// 0x0040 (0x02D0 - 0x0290)
class ADelMarInputModifierHazard final : public AActor
{
public:
	TArray<struct FDelMarActivatedInputFrame>     ActivatedInputSequence;                            // 0x0290(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDelMarDisabledInputData>       DisabledEffects;                                   // 0x02A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxCollider;                                       // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      LocalController;                                   // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnhancedPlayerInput*                   LocalPlayerInput;                                  // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartOverlapTime;                                  // 0x02C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TotalActivationSequenceTime;                       // 0x02CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarInputModifierHazard">();
	}
	static class ADelMarInputModifierHazard* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarInputModifierHazard>();
	}
};
static_assert(alignof(ADelMarInputModifierHazard) == 0x000008, "Wrong alignment on ADelMarInputModifierHazard");
static_assert(sizeof(ADelMarInputModifierHazard) == 0x0002D0, "Wrong size on ADelMarInputModifierHazard");
static_assert(offsetof(ADelMarInputModifierHazard, ActivatedInputSequence) == 0x000290, "Member 'ADelMarInputModifierHazard::ActivatedInputSequence' has a wrong offset!");
static_assert(offsetof(ADelMarInputModifierHazard, DisabledEffects) == 0x0002A0, "Member 'ADelMarInputModifierHazard::DisabledEffects' has a wrong offset!");
static_assert(offsetof(ADelMarInputModifierHazard, BoxCollider) == 0x0002B0, "Member 'ADelMarInputModifierHazard::BoxCollider' has a wrong offset!");
static_assert(offsetof(ADelMarInputModifierHazard, LocalController) == 0x0002B8, "Member 'ADelMarInputModifierHazard::LocalController' has a wrong offset!");
static_assert(offsetof(ADelMarInputModifierHazard, LocalPlayerInput) == 0x0002C0, "Member 'ADelMarInputModifierHazard::LocalPlayerInput' has a wrong offset!");
static_assert(offsetof(ADelMarInputModifierHazard, StartOverlapTime) == 0x0002C8, "Member 'ADelMarInputModifierHazard::StartOverlapTime' has a wrong offset!");
static_assert(offsetof(ADelMarInputModifierHazard, TotalActivationSequenceTime) == 0x0002CC, "Member 'ADelMarInputModifierHazard::TotalActivationSequenceTime' has a wrong offset!");

// Class DelMarCore.DelMarInputModifierPitchInversion
// 0x0000 (0x0028 - 0x0028)
class UDelMarInputModifierPitchInversion final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarInputModifierPitchInversion">();
	}
	static class UDelMarInputModifierPitchInversion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarInputModifierPitchInversion>();
	}
};
static_assert(alignof(UDelMarInputModifierPitchInversion) == 0x000008, "Wrong alignment on UDelMarInputModifierPitchInversion");
static_assert(sizeof(UDelMarInputModifierPitchInversion) == 0x000028, "Wrong size on UDelMarInputModifierPitchInversion");

// Class DelMarCore.DelMarInputModifierZeroOut
// 0x0000 (0x0028 - 0x0028)
class UDelMarInputModifierZeroOut final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarInputModifierZeroOut">();
	}
	static class UDelMarInputModifierZeroOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarInputModifierZeroOut>();
	}
};
static_assert(alignof(UDelMarInputModifierZeroOut) == 0x000008, "Wrong alignment on UDelMarInputModifierZeroOut");
static_assert(sizeof(UDelMarInputModifierZeroOut) == 0x000028, "Wrong size on UDelMarInputModifierZeroOut");

// Class DelMarCore.DelMarInputModifierAlwaysOne
// 0x0000 (0x0028 - 0x0028)
class UDelMarInputModifierAlwaysOne final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarInputModifierAlwaysOne">();
	}
	static class UDelMarInputModifierAlwaysOne* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarInputModifierAlwaysOne>();
	}
};
static_assert(alignof(UDelMarInputModifierAlwaysOne) == 0x000008, "Wrong alignment on UDelMarInputModifierAlwaysOne");
static_assert(sizeof(UDelMarInputModifierAlwaysOne) == 0x000028, "Wrong size on UDelMarInputModifierAlwaysOne");

// Class DelMarCore.DelMarInputModifierScalarBySign
// 0x0030 (0x0058 - 0x0028)
class UDelMarInputModifierScalarBySign final : public UInputModifier
{
public:
	struct FVector                                PositiveScalar;                                    // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NegativeScalar;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarInputModifierScalarBySign">();
	}
	static class UDelMarInputModifierScalarBySign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarInputModifierScalarBySign>();
	}
};
static_assert(alignof(UDelMarInputModifierScalarBySign) == 0x000008, "Wrong alignment on UDelMarInputModifierScalarBySign");
static_assert(sizeof(UDelMarInputModifierScalarBySign) == 0x000058, "Wrong size on UDelMarInputModifierScalarBySign");
static_assert(offsetof(UDelMarInputModifierScalarBySign, PositiveScalar) == 0x000028, "Member 'UDelMarInputModifierScalarBySign::PositiveScalar' has a wrong offset!");
static_assert(offsetof(UDelMarInputModifierScalarBySign, NegativeScalar) == 0x000040, "Member 'UDelMarInputModifierScalarBySign::NegativeScalar' has a wrong offset!");

// Class DelMarCore.DelMarInputModifierClamp
// 0x0030 (0x0058 - 0x0028)
class UDelMarInputModifierClamp final : public UInputModifier
{
public:
	struct FVector                                Minimum;                                           // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Maximum;                                           // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarInputModifierClamp">();
	}
	static class UDelMarInputModifierClamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarInputModifierClamp>();
	}
};
static_assert(alignof(UDelMarInputModifierClamp) == 0x000008, "Wrong alignment on UDelMarInputModifierClamp");
static_assert(sizeof(UDelMarInputModifierClamp) == 0x000058, "Wrong size on UDelMarInputModifierClamp");
static_assert(offsetof(UDelMarInputModifierClamp, Minimum) == 0x000028, "Member 'UDelMarInputModifierClamp::Minimum' has a wrong offset!");
static_assert(offsetof(UDelMarInputModifierClamp, Maximum) == 0x000040, "Member 'UDelMarInputModifierClamp::Maximum' has a wrong offset!");

// Class DelMarCore.DelMarLevelDataAsset
// 0x0080 (0x00B0 - 0x0030)
class UDelMarLevelDataAsset final : public UPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   LevelDescription;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LevelBackgroundImage;                              // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          Levels;                                            // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LevelDescriptionTags;                              // 0x0090(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarLevelDataAsset">();
	}
	static class UDelMarLevelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarLevelDataAsset>();
	}
};
static_assert(alignof(UDelMarLevelDataAsset) == 0x000008, "Wrong alignment on UDelMarLevelDataAsset");
static_assert(sizeof(UDelMarLevelDataAsset) == 0x0000B0, "Wrong size on UDelMarLevelDataAsset");
static_assert(offsetof(UDelMarLevelDataAsset, DisplayName) == 0x000030, "Member 'UDelMarLevelDataAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UDelMarLevelDataAsset, LevelDescription) == 0x000048, "Member 'UDelMarLevelDataAsset::LevelDescription' has a wrong offset!");
static_assert(offsetof(UDelMarLevelDataAsset, LevelBackgroundImage) == 0x000060, "Member 'UDelMarLevelDataAsset::LevelBackgroundImage' has a wrong offset!");
static_assert(offsetof(UDelMarLevelDataAsset, Levels) == 0x000080, "Member 'UDelMarLevelDataAsset::Levels' has a wrong offset!");
static_assert(offsetof(UDelMarLevelDataAsset, LevelDescriptionTags) == 0x000090, "Member 'UDelMarLevelDataAsset::LevelDescriptionTags' has a wrong offset!");

// Class DelMarCore.DelMarLoadoutSave
// 0x0050 (0x0078 - 0x0028)
class UDelMarLoadoutSave final : public USaveGame
{
public:
	TMap<struct FGameplayTag, TSoftObjectPtr<class UDelMarCosmeticItemDefinition>> EquippedLoadout;                                   // 0x0028(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarLoadoutSave">();
	}
	static class UDelMarLoadoutSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarLoadoutSave>();
	}
};
static_assert(alignof(UDelMarLoadoutSave) == 0x000008, "Wrong alignment on UDelMarLoadoutSave");
static_assert(sizeof(UDelMarLoadoutSave) == 0x000078, "Wrong size on UDelMarLoadoutSave");
static_assert(offsetof(UDelMarLoadoutSave, EquippedLoadout) == 0x000028, "Member 'UDelMarLoadoutSave::EquippedLoadout' has a wrong offset!");

// Class DelMarCore.DelMarMatchmakingFlowInjector
// 0x0000 (0x0028 - 0x0028)
class UDelMarMatchmakingFlowInjector final : public UInjectPreMatchmakingFlow
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarMatchmakingFlowInjector">();
	}
	static class UDelMarMatchmakingFlowInjector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarMatchmakingFlowInjector>();
	}
};
static_assert(alignof(UDelMarMatchmakingFlowInjector) == 0x000008, "Wrong alignment on UDelMarMatchmakingFlowInjector");
static_assert(sizeof(UDelMarMatchmakingFlowInjector) == 0x000028, "Wrong size on UDelMarMatchmakingFlowInjector");

// Class DelMarCore.DelMarMatchmakingGracefulUpgrader
// 0x0000 (0x0028 - 0x0028)
class UDelMarMatchmakingGracefulUpgrader final : public UGracefulUpgradeOverrider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarMatchmakingGracefulUpgrader">();
	}
	static class UDelMarMatchmakingGracefulUpgrader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarMatchmakingGracefulUpgrader>();
	}
};
static_assert(alignof(UDelMarMatchmakingGracefulUpgrader) == 0x000008, "Wrong alignment on UDelMarMatchmakingGracefulUpgrader");
static_assert(sizeof(UDelMarMatchmakingGracefulUpgrader) == 0x000028, "Wrong size on UDelMarMatchmakingGracefulUpgrader");

// Class DelMarCore.DelMarNetModelSubsystem
// 0x0008 (0x0038 - 0x0030)
class UDelMarNetModelSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarNetModelSubsystem">();
	}
	static class UDelMarNetModelSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarNetModelSubsystem>();
	}
};
static_assert(alignof(UDelMarNetModelSubsystem) == 0x000008, "Wrong alignment on UDelMarNetModelSubsystem");
static_assert(sizeof(UDelMarNetModelSubsystem) == 0x000038, "Wrong size on UDelMarNetModelSubsystem");

// Class DelMarCore.DelMarMutator
// 0x0008 (0x0340 - 0x0338)
class ADelMarMutator : public AFortAthenaMutator
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarMutator">();
	}
	static class ADelMarMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarMutator>();
	}
};
static_assert(alignof(ADelMarMutator) == 0x000008, "Wrong alignment on ADelMarMutator");
static_assert(sizeof(ADelMarMutator) == 0x000340, "Wrong size on ADelMarMutator");

// Class DelMarCore.DelMarNetworkPredictionMutator
// 0x0018 (0x0358 - 0x0340)
class ADelMarNetworkPredictionMutator final : public ADelMarMutator
{
public:
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarNetworkPredictionMutator">();
	}
	static class ADelMarNetworkPredictionMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarNetworkPredictionMutator>();
	}
};
static_assert(alignof(ADelMarNetworkPredictionMutator) == 0x000008, "Wrong alignment on ADelMarNetworkPredictionMutator");
static_assert(sizeof(ADelMarNetworkPredictionMutator) == 0x000358, "Wrong size on ADelMarNetworkPredictionMutator");

// Class DelMarCore.DelMarObjectiveProcessorBase
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessorBase : public UFortObjectiveProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessorBase">();
	}
	static class UDelMarObjectiveProcessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessorBase>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessorBase) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessorBase");
static_assert(sizeof(UDelMarObjectiveProcessorBase) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessorBase");

// Class DelMarCore.DelMarObjectiveProcessor_BeatPlayers
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_BeatPlayers final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_BeatPlayers">();
	}
	static class UDelMarObjectiveProcessor_BeatPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_BeatPlayers>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_BeatPlayers) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_BeatPlayers");
static_assert(sizeof(UDelMarObjectiveProcessor_BeatPlayers) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_BeatPlayers");

// Class DelMarCore.DelMarObjectiveProcessor_BonusTurboActivated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_BonusTurboActivated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_BonusTurboActivated">();
	}
	static class UDelMarObjectiveProcessor_BonusTurboActivated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_BonusTurboActivated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_BonusTurboActivated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_BonusTurboActivated");
static_assert(sizeof(UDelMarObjectiveProcessor_BonusTurboActivated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_BonusTurboActivated");

// Class DelMarCore.DelMarObjectiveProcessor_BoostPadBonusSpeedEnded
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_BoostPadBonusSpeedEnded final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_BoostPadBonusSpeedEnded">();
	}
	static class UDelMarObjectiveProcessor_BoostPadBonusSpeedEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_BoostPadBonusSpeedEnded>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_BoostPadBonusSpeedEnded) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_BoostPadBonusSpeedEnded");
static_assert(sizeof(UDelMarObjectiveProcessor_BoostPadBonusSpeedEnded) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_BoostPadBonusSpeedEnded");

// Class DelMarCore.DelMarObjectiveProcessor_BoostPadHit
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_BoostPadHit final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_BoostPadHit">();
	}
	static class UDelMarObjectiveProcessor_BoostPadHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_BoostPadHit>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_BoostPadHit) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_BoostPadHit");
static_assert(sizeof(UDelMarObjectiveProcessor_BoostPadHit) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_BoostPadHit");

// Class DelMarCore.DelMarObjectiveProcessor_DistanceTraveled
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_DistanceTraveled final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_DistanceTraveled">();
	}
	static class UDelMarObjectiveProcessor_DistanceTraveled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_DistanceTraveled>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_DistanceTraveled) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_DistanceTraveled");
static_assert(sizeof(UDelMarObjectiveProcessor_DistanceTraveled) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_DistanceTraveled");

// Class DelMarCore.DelMarObjectiveProcessor_DraftActivated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_DraftActivated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_DraftActivated">();
	}
	static class UDelMarObjectiveProcessor_DraftActivated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_DraftActivated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_DraftActivated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_DraftActivated");
static_assert(sizeof(UDelMarObjectiveProcessor_DraftActivated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_DraftActivated");

// Class DelMarCore.DelMarObjectiveProcessor_DriftBoostActivated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_DriftBoostActivated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_DriftBoostActivated">();
	}
	static class UDelMarObjectiveProcessor_DriftBoostActivated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_DriftBoostActivated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_DriftBoostActivated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_DriftBoostActivated");
static_assert(sizeof(UDelMarObjectiveProcessor_DriftBoostActivated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_DriftBoostActivated");

// Class DelMarCore.DelMarObjectiveProcessor_DriftBoostDeactivated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_DriftBoostDeactivated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_DriftBoostDeactivated">();
	}
	static class UDelMarObjectiveProcessor_DriftBoostDeactivated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_DriftBoostDeactivated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_DriftBoostDeactivated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_DriftBoostDeactivated");
static_assert(sizeof(UDelMarObjectiveProcessor_DriftBoostDeactivated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_DriftBoostDeactivated");

// Class DelMarCore.DelMarObjectiveProcessor_DriftComplete
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_DriftComplete final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_DriftComplete">();
	}
	static class UDelMarObjectiveProcessor_DriftComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_DriftComplete>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_DriftComplete) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_DriftComplete");
static_assert(sizeof(UDelMarObjectiveProcessor_DriftComplete) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_DriftComplete");

// Class DelMarCore.DelMarObjectiveProcessor_HighestSpeedUpdated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_HighestSpeedUpdated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_HighestSpeedUpdated">();
	}
	static class UDelMarObjectiveProcessor_HighestSpeedUpdated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_HighestSpeedUpdated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_HighestSpeedUpdated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_HighestSpeedUpdated");
static_assert(sizeof(UDelMarObjectiveProcessor_HighestSpeedUpdated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_HighestSpeedUpdated");

// Class DelMarCore.DelMarObjectiveProcessor_InitialTurboActivated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_InitialTurboActivated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_InitialTurboActivated">();
	}
	static class UDelMarObjectiveProcessor_InitialTurboActivated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_InitialTurboActivated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_InitialTurboActivated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_InitialTurboActivated");
static_assert(sizeof(UDelMarObjectiveProcessor_InitialTurboActivated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_InitialTurboActivated");

// Class DelMarCore.DelMarObjectiveProcessor_Kickflipped
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_Kickflipped final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_Kickflipped">();
	}
	static class UDelMarObjectiveProcessor_Kickflipped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_Kickflipped>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_Kickflipped) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_Kickflipped");
static_assert(sizeof(UDelMarObjectiveProcessor_Kickflipped) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_Kickflipped");

// Class DelMarCore.DelMarObjectiveProcessor_LapComplete
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_LapComplete final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_LapComplete">();
	}
	static class UDelMarObjectiveProcessor_LapComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_LapComplete>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_LapComplete) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_LapComplete");
static_assert(sizeof(UDelMarObjectiveProcessor_LapComplete) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_LapComplete");

// Class DelMarCore.DelMarObjectiveProcessor_PlacementUpdated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_PlacementUpdated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_PlacementUpdated">();
	}
	static class UDelMarObjectiveProcessor_PlacementUpdated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_PlacementUpdated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_PlacementUpdated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_PlacementUpdated");
static_assert(sizeof(UDelMarObjectiveProcessor_PlacementUpdated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_PlacementUpdated");

// Class DelMarCore.DelMarObjectiveProcessor_PlayedDelMarExperience
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_PlayedDelMarExperience final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_PlayedDelMarExperience">();
	}
	static class UDelMarObjectiveProcessor_PlayedDelMarExperience* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_PlayedDelMarExperience>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_PlayedDelMarExperience) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_PlayedDelMarExperience");
static_assert(sizeof(UDelMarObjectiveProcessor_PlayedDelMarExperience) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_PlayedDelMarExperience");

// Class DelMarCore.DelMarObjectiveProcessor_RaceFinished
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_RaceFinished final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_RaceFinished">();
	}
	static class UDelMarObjectiveProcessor_RaceFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_RaceFinished>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_RaceFinished) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_RaceFinished");
static_assert(sizeof(UDelMarObjectiveProcessor_RaceFinished) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_RaceFinished");

// Class DelMarCore.DelMarObjectiveProcessor_RankAchieved
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_RankAchieved final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_RankAchieved">();
	}
	static class UDelMarObjectiveProcessor_RankAchieved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_RankAchieved>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_RankAchieved) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_RankAchieved");
static_assert(sizeof(UDelMarObjectiveProcessor_RankAchieved) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_RankAchieved");

// Class DelMarCore.DelMarObjectiveProcessor_RunComplete
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_RunComplete final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_RunComplete">();
	}
	static class UDelMarObjectiveProcessor_RunComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_RunComplete>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_RunComplete) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_RunComplete");
static_assert(sizeof(UDelMarObjectiveProcessor_RunComplete) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_RunComplete");

// Class DelMarCore.DelMarObjectiveProcessor_RunCompleteTest
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_RunCompleteTest final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_RunCompleteTest">();
	}
	static class UDelMarObjectiveProcessor_RunCompleteTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_RunCompleteTest>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_RunCompleteTest) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_RunCompleteTest");
static_assert(sizeof(UDelMarObjectiveProcessor_RunCompleteTest) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_RunCompleteTest");

// Class DelMarCore.DelMarObjectiveProcessor_StartlineBoostActivated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_StartlineBoostActivated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_StartlineBoostActivated">();
	}
	static class UDelMarObjectiveProcessor_StartlineBoostActivated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_StartlineBoostActivated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_StartlineBoostActivated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_StartlineBoostActivated");
static_assert(sizeof(UDelMarObjectiveProcessor_StartlineBoostActivated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_StartlineBoostActivated");

// Class DelMarCore.DelMarObjectiveProcessor_UnderthrustDeactivated
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_UnderthrustDeactivated final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_UnderthrustDeactivated">();
	}
	static class UDelMarObjectiveProcessor_UnderthrustDeactivated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_UnderthrustDeactivated>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_UnderthrustDeactivated) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_UnderthrustDeactivated");
static_assert(sizeof(UDelMarObjectiveProcessor_UnderthrustDeactivated) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_UnderthrustDeactivated");

// Class DelMarCore.DelMarObjectiveProcessor_UnderthrustPercentUsed
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_UnderthrustPercentUsed final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_UnderthrustPercentUsed">();
	}
	static class UDelMarObjectiveProcessor_UnderthrustPercentUsed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_UnderthrustPercentUsed>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_UnderthrustPercentUsed) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_UnderthrustPercentUsed");
static_assert(sizeof(UDelMarObjectiveProcessor_UnderthrustPercentUsed) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_UnderthrustPercentUsed");

// Class DelMarCore.DelMarObjectiveProcessor_VehicleJumped
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_VehicleJumped final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_VehicleJumped">();
	}
	static class UDelMarObjectiveProcessor_VehicleJumped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_VehicleJumped>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_VehicleJumped) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_VehicleJumped");
static_assert(sizeof(UDelMarObjectiveProcessor_VehicleJumped) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_VehicleJumped");

// Class DelMarCore.DelMarObjectiveProcessor_VehicleLanded
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarObjectiveProcessor_VehicleLanded final : public UDelMarObjectiveProcessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarObjectiveProcessor_VehicleLanded">();
	}
	static class UDelMarObjectiveProcessor_VehicleLanded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarObjectiveProcessor_VehicleLanded>();
	}
};
static_assert(alignof(UDelMarObjectiveProcessor_VehicleLanded) == 0x000008, "Wrong alignment on UDelMarObjectiveProcessor_VehicleLanded");
static_assert(sizeof(UDelMarObjectiveProcessor_VehicleLanded) == 0x0000A0, "Wrong size on UDelMarObjectiveProcessor_VehicleLanded");

// Class DelMarCore.DelMarPhysicsRateDevice
// 0x0050 (0x0C28 - 0x0BD8)
class ADelMarPhysicsRateDevice final : public AFortCreativeDeviceProp
{
public:
	uint8                                         Pad_BD8[0x50];                                     // 0x0BD8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPhysicsRate(EDelMarPhysicsRate PhysicsRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPhysicsRateDevice">();
	}
	static class ADelMarPhysicsRateDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarPhysicsRateDevice>();
	}
};
static_assert(alignof(ADelMarPhysicsRateDevice) == 0x000008, "Wrong alignment on ADelMarPhysicsRateDevice");
static_assert(sizeof(ADelMarPhysicsRateDevice) == 0x000C28, "Wrong size on ADelMarPhysicsRateDevice");

// Class DelMarCore.DelMarPhysMatAttribute_SoundTag
// 0x0008 (0x0030 - 0x0028)
class UDelMarPhysMatAttribute_SoundTag final : public UDelMarPhysMatAttribute
{
public:
	class FName                                   SoundTag;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPhysMatAttribute_SoundTag">();
	}
	static class UDelMarPhysMatAttribute_SoundTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPhysMatAttribute_SoundTag>();
	}
};
static_assert(alignof(UDelMarPhysMatAttribute_SoundTag) == 0x000008, "Wrong alignment on UDelMarPhysMatAttribute_SoundTag");
static_assert(sizeof(UDelMarPhysMatAttribute_SoundTag) == 0x000030, "Wrong size on UDelMarPhysMatAttribute_SoundTag");
static_assert(offsetof(UDelMarPhysMatAttribute_SoundTag, SoundTag) == 0x000028, "Member 'UDelMarPhysMatAttribute_SoundTag::SoundTag' has a wrong offset!");
static_assert(offsetof(UDelMarPhysMatAttribute_SoundTag, Priority) == 0x00002C, "Member 'UDelMarPhysMatAttribute_SoundTag::Priority' has a wrong offset!");

// Class DelMarCore.DelMarPhysMatAttribute_Terrain
// 0x0020 (0x0048 - 0x0028)
class UDelMarPhysMatAttribute_Terrain final : public UDelMarPhysMatAttribute
{
public:
	struct FDelMarTerrainData                     TerrainData;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDriveableSurface;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPhysMatAttribute_Terrain">();
	}
	static class UDelMarPhysMatAttribute_Terrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPhysMatAttribute_Terrain>();
	}
};
static_assert(alignof(UDelMarPhysMatAttribute_Terrain) == 0x000008, "Wrong alignment on UDelMarPhysMatAttribute_Terrain");
static_assert(sizeof(UDelMarPhysMatAttribute_Terrain) == 0x000048, "Wrong size on UDelMarPhysMatAttribute_Terrain");
static_assert(offsetof(UDelMarPhysMatAttribute_Terrain, TerrainData) == 0x000028, "Member 'UDelMarPhysMatAttribute_Terrain::TerrainData' has a wrong offset!");
static_assert(offsetof(UDelMarPhysMatAttribute_Terrain, bDriveableSurface) == 0x000040, "Member 'UDelMarPhysMatAttribute_Terrain::bDriveableSurface' has a wrong offset!");

// Class DelMarCore.DelMarPlayerStateComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarPlayerStateComponent : public UPlayerStateComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerStateComponent">();
	}
	static class UDelMarPlayerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerStateComponent>();
	}
};
static_assert(alignof(UDelMarPlayerStateComponent) == 0x000008, "Wrong alignment on UDelMarPlayerStateComponent");
static_assert(sizeof(UDelMarPlayerStateComponent) == 0x0000A0, "Wrong size on UDelMarPlayerStateComponent");

// Class DelMarCore.DelMarPlayerActiveRaceManagerComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDelMarPlayerActiveRaceManagerComponent final : public UDelMarPlayerStateComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarRaceManager*                     ActiveRaceManager;                                 // 0x00B8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_ActiveRaceManager(class ADelMarRaceManager* PreviousRaceManager);
	void SetActiveRaceManager(class ADelMarRaceManager* RaceManager);

	class ADelMarRaceManager* GetActiveRaceManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerActiveRaceManagerComponent">();
	}
	static class UDelMarPlayerActiveRaceManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerActiveRaceManagerComponent>();
	}
};
static_assert(alignof(UDelMarPlayerActiveRaceManagerComponent) == 0x000008, "Wrong alignment on UDelMarPlayerActiveRaceManagerComponent");
static_assert(sizeof(UDelMarPlayerActiveRaceManagerComponent) == 0x0000C0, "Wrong size on UDelMarPlayerActiveRaceManagerComponent");
static_assert(offsetof(UDelMarPlayerActiveRaceManagerComponent, ActiveRaceManager) == 0x0000B8, "Member 'UDelMarPlayerActiveRaceManagerComponent::ActiveRaceManager' has a wrong offset!");

// Class DelMarCore.DelMarPlayerAnalyticsComponent
// 0x00C8 (0x0168 - 0x00A0)
class UDelMarPlayerAnalyticsComponent final : public UDelMarPlayerStateComponent
{
public:
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          CachedVehicle;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPlayerRaceDataComponent> CachedPlayerRaceData;                              // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarRaceInfoComponent> CachedRaceInfo;                                    // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPositionalTrackerComponent> CachedPositionalTracker;                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelmarCompetitiveMatchmakeRatingComponent> MatchmakeRatingComponent;                          // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDelMarAnalyticsPlayerRaceData         CurrentRaceData;                                   // 0x00D0(0x0038)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDelMarAnalyticsPlayerRaceData         CurrentRunData;                                    // 0x0108(0x0038)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x28];                                     // 0x0140(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDraftActivated();
	void HandleDriftBoostDeactivated();
	void HandleDriftKickActivated(float DriftDirection, EDelMarVehicleDriftState DriftState);
	void HandleKickflipActivated(bool bLeft);
	void HandlePlayerResetRun(class AFortPlayerState* PlayerState);
	void HandlePotentialDriftBoostChanged(float Percent);
	void HandleRaceFinished();
	void HandleRaceStarted();
	void HandleTurboBonusZoneChanged(EDelMarTurboZoneState BonusZoneState);
	void HandleTurboChargeUsed();
	void HandleUnderthrustActivated();
	void HandleUnderthrustDeactivated();
	void HandleUnderthrustPercentChanged(float PercentageUnderthrustRemaining);
	void HandleVehicleDemolished(const struct FGameplayTag& CausedByTag);
	void HandleVehicleHitHazard();
	void HandleWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerAnalyticsComponent">();
	}
	static class UDelMarPlayerAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerAnalyticsComponent>();
	}
};
static_assert(alignof(UDelMarPlayerAnalyticsComponent) == 0x000008, "Wrong alignment on UDelMarPlayerAnalyticsComponent");
static_assert(sizeof(UDelMarPlayerAnalyticsComponent) == 0x000168, "Wrong size on UDelMarPlayerAnalyticsComponent");
static_assert(offsetof(UDelMarPlayerAnalyticsComponent, CachedRaceManager) == 0x0000A0, "Member 'UDelMarPlayerAnalyticsComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerAnalyticsComponent, CachedVehicle) == 0x0000A8, "Member 'UDelMarPlayerAnalyticsComponent::CachedVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerAnalyticsComponent, CachedPlayerRaceData) == 0x0000B0, "Member 'UDelMarPlayerAnalyticsComponent::CachedPlayerRaceData' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerAnalyticsComponent, CachedRaceInfo) == 0x0000B8, "Member 'UDelMarPlayerAnalyticsComponent::CachedRaceInfo' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerAnalyticsComponent, CachedPositionalTracker) == 0x0000C0, "Member 'UDelMarPlayerAnalyticsComponent::CachedPositionalTracker' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerAnalyticsComponent, MatchmakeRatingComponent) == 0x0000C8, "Member 'UDelMarPlayerAnalyticsComponent::MatchmakeRatingComponent' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerAnalyticsComponent, CurrentRaceData) == 0x0000D0, "Member 'UDelMarPlayerAnalyticsComponent::CurrentRaceData' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerAnalyticsComponent, CurrentRunData) == 0x000108, "Member 'UDelMarPlayerAnalyticsComponent::CurrentRunData' has a wrong offset!");

// Class DelMarCore.DelMarPlayerIdleComponent
// 0x0030 (0x00D0 - 0x00A0)
class UDelMarPlayerIdleComponent final : public UDelMarPlayerStateComponent
{
public:
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          CachedDelMarVehicle;                               // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerDisconnected(class AFortPlayerStateAthena* PlayerState, bool bIsDisconnected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerIdleComponent">();
	}
	static class UDelMarPlayerIdleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerIdleComponent>();
	}
};
static_assert(alignof(UDelMarPlayerIdleComponent) == 0x000008, "Wrong alignment on UDelMarPlayerIdleComponent");
static_assert(sizeof(UDelMarPlayerIdleComponent) == 0x0000D0, "Wrong size on UDelMarPlayerIdleComponent");
static_assert(offsetof(UDelMarPlayerIdleComponent, CachedRaceManager) == 0x0000A0, "Member 'UDelMarPlayerIdleComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerIdleComponent, CachedDelMarVehicle) == 0x0000A8, "Member 'UDelMarPlayerIdleComponent::CachedDelMarVehicle' has a wrong offset!");

// Class DelMarCore.DelMarPlayerQuestDistanceTraveledComponent
// 0x0050 (0x00F0 - 0x00A0)
class UDelMarPlayerQuestDistanceTraveledComponent final : public UDelMarPlayerStateComponent
{
public:
	TWeakObjectPtr<class ADelMarVehicle>          CachedVehicle;                                     // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        CachedPlayerState;                                 // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DistanceTraveledTimer;                             // 0x00B8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x28];                                      // 0x00C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDelMarObjectiveProcessor_DistanceTraveled> DistanceTravelledObjectiveProcessor;               // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleVehicleDemolished(const struct FGameplayTag& CausedByTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerQuestDistanceTraveledComponent">();
	}
	static class UDelMarPlayerQuestDistanceTraveledComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerQuestDistanceTraveledComponent>();
	}
};
static_assert(alignof(UDelMarPlayerQuestDistanceTraveledComponent) == 0x000008, "Wrong alignment on UDelMarPlayerQuestDistanceTraveledComponent");
static_assert(sizeof(UDelMarPlayerQuestDistanceTraveledComponent) == 0x0000F0, "Wrong size on UDelMarPlayerQuestDistanceTraveledComponent");
static_assert(offsetof(UDelMarPlayerQuestDistanceTraveledComponent, CachedVehicle) == 0x0000A0, "Member 'UDelMarPlayerQuestDistanceTraveledComponent::CachedVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerQuestDistanceTraveledComponent, CachedPlayerState) == 0x0000A8, "Member 'UDelMarPlayerQuestDistanceTraveledComponent::CachedPlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerQuestDistanceTraveledComponent, CachedRaceManager) == 0x0000B0, "Member 'UDelMarPlayerQuestDistanceTraveledComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerQuestDistanceTraveledComponent, DistanceTraveledTimer) == 0x0000B8, "Member 'UDelMarPlayerQuestDistanceTraveledComponent::DistanceTraveledTimer' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerQuestDistanceTraveledComponent, DistanceTravelledObjectiveProcessor) == 0x0000E8, "Member 'UDelMarPlayerQuestDistanceTraveledComponent::DistanceTravelledObjectiveProcessor' has a wrong offset!");

// Class DelMarCore.DelMarPlayerQuestMatchInfoComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDelMarPlayerQuestMatchInfoComponent final : public UDelMarPlayerStateComponent
{
public:
	uint8                                         Pad_A0[0x4];                                       // 0x00A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADelMarVehicle>          CachedVehicle;                                     // 0x00A4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00AC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        CachedPlayerState;                                 // 0x00B4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleRaceStarted();
	void HandleVehicleDemolished(const struct FGameplayTag& CausedByTag);
	void HandleVehicleHitHazard();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerQuestMatchInfoComponent">();
	}
	static class UDelMarPlayerQuestMatchInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerQuestMatchInfoComponent>();
	}
};
static_assert(alignof(UDelMarPlayerQuestMatchInfoComponent) == 0x000008, "Wrong alignment on UDelMarPlayerQuestMatchInfoComponent");
static_assert(sizeof(UDelMarPlayerQuestMatchInfoComponent) == 0x0000C0, "Wrong size on UDelMarPlayerQuestMatchInfoComponent");
static_assert(offsetof(UDelMarPlayerQuestMatchInfoComponent, CachedVehicle) == 0x0000A4, "Member 'UDelMarPlayerQuestMatchInfoComponent::CachedVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerQuestMatchInfoComponent, CachedRaceManager) == 0x0000AC, "Member 'UDelMarPlayerQuestMatchInfoComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerQuestMatchInfoComponent, CachedPlayerState) == 0x0000B4, "Member 'UDelMarPlayerQuestMatchInfoComponent::CachedPlayerState' has a wrong offset!");

// Class DelMarCore.DelMarPlayerStart
// 0x0010 (0x0310 - 0x0300)
class ADelMarPlayerStart final : public AFortPlayerStart
{
public:
	int32                                         StartlinePriority;                                 // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsClaimedZDistanceCheck;                           // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      DelMarRaceManager;                                 // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerStart">();
	}
	static class ADelMarPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarPlayerStart>();
	}
};
static_assert(alignof(ADelMarPlayerStart) == 0x000008, "Wrong alignment on ADelMarPlayerStart");
static_assert(sizeof(ADelMarPlayerStart) == 0x000310, "Wrong size on ADelMarPlayerStart");
static_assert(offsetof(ADelMarPlayerStart, StartlinePriority) == 0x000300, "Member 'ADelMarPlayerStart::StartlinePriority' has a wrong offset!");
static_assert(offsetof(ADelMarPlayerStart, IsClaimedZDistanceCheck) == 0x000304, "Member 'ADelMarPlayerStart::IsClaimedZDistanceCheck' has a wrong offset!");
static_assert(offsetof(ADelMarPlayerStart, DelMarRaceManager) == 0x000308, "Member 'ADelMarPlayerStart::DelMarRaceManager' has a wrong offset!");

// Class DelMarCore.DelMarPlayerWrongwayComponent
// 0x0078 (0x0118 - 0x00A0)
class UDelMarPlayerWrongwayComponent final : public UDelMarPlayerStateComponent
{
public:
	TWeakObjectPtr<class ADelMarVehicle>          CachedDelMarVehicle;                               // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTrackPositionComponent> CachedTrackPositionComp;                           // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPlayerRaceDataComponent> CachedRaceData;                                    // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarCheckpointManagerComponent> CachedCheckpointManager;                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTrackManager>     CachedTrackManager;                                // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerWrongwayComponent">();
	}
	static class UDelMarPlayerWrongwayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerWrongwayComponent>();
	}
};
static_assert(alignof(UDelMarPlayerWrongwayComponent) == 0x000008, "Wrong alignment on UDelMarPlayerWrongwayComponent");
static_assert(sizeof(UDelMarPlayerWrongwayComponent) == 0x000118, "Wrong size on UDelMarPlayerWrongwayComponent");
static_assert(offsetof(UDelMarPlayerWrongwayComponent, CachedDelMarVehicle) == 0x0000A0, "Member 'UDelMarPlayerWrongwayComponent::CachedDelMarVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerWrongwayComponent, CachedRaceManager) == 0x0000A8, "Member 'UDelMarPlayerWrongwayComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerWrongwayComponent, CachedTrackPositionComp) == 0x0000B0, "Member 'UDelMarPlayerWrongwayComponent::CachedTrackPositionComp' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerWrongwayComponent, CachedRaceData) == 0x0000B8, "Member 'UDelMarPlayerWrongwayComponent::CachedRaceData' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerWrongwayComponent, CachedCheckpointManager) == 0x0000C0, "Member 'UDelMarPlayerWrongwayComponent::CachedCheckpointManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerWrongwayComponent, CachedTrackManager) == 0x0000C8, "Member 'UDelMarPlayerWrongwayComponent::CachedTrackManager' has a wrong offset!");

// Class DelMarCore.DelMarPlayspaceComponent_ServerExpiration
// 0x0000 (0x01B8 - 0x01B8)
class UDelMarPlayspaceComponent_ServerExpiration final : public UPlayspaceComponent_ServerExpiration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayspaceComponent_ServerExpiration">();
	}
	static class UDelMarPlayspaceComponent_ServerExpiration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayspaceComponent_ServerExpiration>();
	}
};
static_assert(alignof(UDelMarPlayspaceComponent_ServerExpiration) == 0x000008, "Wrong alignment on UDelMarPlayspaceComponent_ServerExpiration");
static_assert(sizeof(UDelMarPlayspaceComponent_ServerExpiration) == 0x0001B8, "Wrong size on UDelMarPlayspaceComponent_ServerExpiration");

// Class DelMarCore.DelMarProxyGhostVisualComponent
// 0x0068 (0x0108 - 0x00A0)
class UDelMarProxyGhostVisualComponent final : public UDelMarPlayerStateComponent
{
public:
	TWeakObjectPtr<class AFortAthenaVehicle>      CachedVehicle;                                     // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UVehicleCosmeticsAssembledMeshUserComponent> CachedVCAMUC;                                      // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ProxyGhostMaterial;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FDelMarProxyMeshMaterialInfo> VehicleMaterialInfoMap;                            // 0x00B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void HandlePartCustomizationUpdated(const int32 MeshPartIndex);
	void HandleVehicleCosmeticsFinished();
	void HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarProxyGhostVisualComponent">();
	}
	static class UDelMarProxyGhostVisualComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarProxyGhostVisualComponent>();
	}
};
static_assert(alignof(UDelMarProxyGhostVisualComponent) == 0x000008, "Wrong alignment on UDelMarProxyGhostVisualComponent");
static_assert(sizeof(UDelMarProxyGhostVisualComponent) == 0x000108, "Wrong size on UDelMarProxyGhostVisualComponent");
static_assert(offsetof(UDelMarProxyGhostVisualComponent, CachedVehicle) == 0x0000A0, "Member 'UDelMarProxyGhostVisualComponent::CachedVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarProxyGhostVisualComponent, CachedVCAMUC) == 0x0000A8, "Member 'UDelMarProxyGhostVisualComponent::CachedVCAMUC' has a wrong offset!");
static_assert(offsetof(UDelMarProxyGhostVisualComponent, ProxyGhostMaterial) == 0x0000B0, "Member 'UDelMarProxyGhostVisualComponent::ProxyGhostMaterial' has a wrong offset!");
static_assert(offsetof(UDelMarProxyGhostVisualComponent, VehicleMaterialInfoMap) == 0x0000B8, "Member 'UDelMarProxyGhostVisualComponent::VehicleMaterialInfoMap' has a wrong offset!");

// Class DelMarCore.DelMarRaceInfoComponent
// 0x0010 (0x00B0 - 0x00A0)
class UDelMarRaceInfoComponent final : public UDelMarRaceManagerComponent
{
public:
	class FString                                 RaceGUID;                                          // 0x00A0(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleRaceStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRaceInfoComponent">();
	}
	static class UDelMarRaceInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRaceInfoComponent>();
	}
};
static_assert(alignof(UDelMarRaceInfoComponent) == 0x000008, "Wrong alignment on UDelMarRaceInfoComponent");
static_assert(sizeof(UDelMarRaceInfoComponent) == 0x0000B0, "Wrong size on UDelMarRaceInfoComponent");
static_assert(offsetof(UDelMarRaceInfoComponent, RaceGUID) == 0x0000A0, "Member 'UDelMarRaceInfoComponent::RaceGUID' has a wrong offset!");

// Class DelMarCore.DelMarRaceLevelConfig
// 0x0080 (0x0C58 - 0x0BD8)
class ADelMarRaceLevelConfig final : public AFortCreativeDeviceProp
{
public:
	EDelMarRaceMode                               RaceMode;                                          // 0x0BD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD9[0x3];                                      // 0x0BD9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultNumRequiredLaps;                            // 0x0BDC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZKillOffsetDistanceFromLowestSplinePoint;          // 0x0BE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRunAsADelMarExperience;                     // 0x0BE4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE5[0x3];                                      // 0x0BE5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchTimeLimitSeconds;                             // 0x0BE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OvertimeSeconds;                                   // 0x0BEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTurboChargeRegenRateSeconds;              // 0x0BF0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF1[0x3];                                      // 0x0BF1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurboChargeRegenRateSeconds;                       // 0x0BF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTurboRaceStartCharges;                    // 0x0BF8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF9[0x3];                                      // 0x0BF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurboRaceStartCharges;                             // 0x0BFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTurboLapCompleteCharges;                  // 0x0C00(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C01[0x3];                                      // 0x0C01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurboLapCompleteCharges;                           // 0x0C04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EDelMarRaceMode, TSubclassOf<class ADelMarRaceManager>> RaceManagerClassMap;                               // 0x0C08(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	class ADelMarRaceManager* SpawnRaceManager(bool bFireInitializationEvent);

	TSubclassOf<class ADelMarRaceManager> GetRaceManagerClass() const;
	struct FGameplayTag GetRaceModeTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRaceLevelConfig">();
	}
	static class ADelMarRaceLevelConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarRaceLevelConfig>();
	}
};
static_assert(alignof(ADelMarRaceLevelConfig) == 0x000008, "Wrong alignment on ADelMarRaceLevelConfig");
static_assert(sizeof(ADelMarRaceLevelConfig) == 0x000C58, "Wrong size on ADelMarRaceLevelConfig");
static_assert(offsetof(ADelMarRaceLevelConfig, RaceMode) == 0x000BD8, "Member 'ADelMarRaceLevelConfig::RaceMode' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, DefaultNumRequiredLaps) == 0x000BDC, "Member 'ADelMarRaceLevelConfig::DefaultNumRequiredLaps' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, ZKillOffsetDistanceFromLowestSplinePoint) == 0x000BE0, "Member 'ADelMarRaceLevelConfig::ZKillOffsetDistanceFromLowestSplinePoint' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, bShouldRunAsADelMarExperience) == 0x000BE4, "Member 'ADelMarRaceLevelConfig::bShouldRunAsADelMarExperience' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, MatchTimeLimitSeconds) == 0x000BE8, "Member 'ADelMarRaceLevelConfig::MatchTimeLimitSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, OvertimeSeconds) == 0x000BEC, "Member 'ADelMarRaceLevelConfig::OvertimeSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, bOverrideTurboChargeRegenRateSeconds) == 0x000BF0, "Member 'ADelMarRaceLevelConfig::bOverrideTurboChargeRegenRateSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, TurboChargeRegenRateSeconds) == 0x000BF4, "Member 'ADelMarRaceLevelConfig::TurboChargeRegenRateSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, bOverrideTurboRaceStartCharges) == 0x000BF8, "Member 'ADelMarRaceLevelConfig::bOverrideTurboRaceStartCharges' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, TurboRaceStartCharges) == 0x000BFC, "Member 'ADelMarRaceLevelConfig::TurboRaceStartCharges' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, bOverrideTurboLapCompleteCharges) == 0x000C00, "Member 'ADelMarRaceLevelConfig::bOverrideTurboLapCompleteCharges' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, TurboLapCompleteCharges) == 0x000C04, "Member 'ADelMarRaceLevelConfig::TurboLapCompleteCharges' has a wrong offset!");
static_assert(offsetof(ADelMarRaceLevelConfig, RaceManagerClassMap) == 0x000C08, "Member 'ADelMarRaceLevelConfig::RaceManagerClassMap' has a wrong offset!");

// Class DelMarCore.DelMarRaceMusicPlaylist
// 0x0010 (0x0040 - 0x0030)
class UDelMarRaceMusicPlaylist final : public UPrimaryDataAsset
{
public:
	TArray<struct FDelMarMusicTrack>              Tracks;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRaceMusicPlaylist">();
	}
	static class UDelMarRaceMusicPlaylist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRaceMusicPlaylist>();
	}
};
static_assert(alignof(UDelMarRaceMusicPlaylist) == 0x000008, "Wrong alignment on UDelMarRaceMusicPlaylist");
static_assert(sizeof(UDelMarRaceMusicPlaylist) == 0x000040, "Wrong size on UDelMarRaceMusicPlaylist");
static_assert(offsetof(UDelMarRaceMusicPlaylist, Tracks) == 0x000030, "Member 'UDelMarRaceMusicPlaylist::Tracks' has a wrong offset!");

// Class DelMarCore.DelMarRacerState_Spectator
// 0x0000 (0x0030 - 0x0030)
class UDelMarRacerState_Spectator final : public UDelMarRacerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRacerState_Spectator">();
	}
	static class UDelMarRacerState_Spectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRacerState_Spectator>();
	}
};
static_assert(alignof(UDelMarRacerState_Spectator) == 0x000008, "Wrong alignment on UDelMarRacerState_Spectator");
static_assert(sizeof(UDelMarRacerState_Spectator) == 0x000030, "Wrong size on UDelMarRacerState_Spectator");

// Class DelMarCore.DelMarRacerState_Countdown
// 0x0008 (0x0038 - 0x0030)
class UDelMarRacerState_Countdown final : public UDelMarRacerState
{
public:
	TWeakObjectPtr<class ADelMarVehicle>          Vehicle;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRacerState_Countdown">();
	}
	static class UDelMarRacerState_Countdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRacerState_Countdown>();
	}
};
static_assert(alignof(UDelMarRacerState_Countdown) == 0x000008, "Wrong alignment on UDelMarRacerState_Countdown");
static_assert(sizeof(UDelMarRacerState_Countdown) == 0x000038, "Wrong size on UDelMarRacerState_Countdown");
static_assert(offsetof(UDelMarRacerState_Countdown, Vehicle) == 0x000030, "Member 'UDelMarRacerState_Countdown::Vehicle' has a wrong offset!");

// Class DelMarCore.DelMarRacerState_RunFinished
// 0x0008 (0x0038 - 0x0030)
class UDelMarRacerState_RunFinished final : public UDelMarRacerState_WithSpectatorTransitionBase
{
public:
	TWeakObjectPtr<class ADelMarVehicle>          Vehicle;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRacerState_RunFinished">();
	}
	static class UDelMarRacerState_RunFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRacerState_RunFinished>();
	}
};
static_assert(alignof(UDelMarRacerState_RunFinished) == 0x000008, "Wrong alignment on UDelMarRacerState_RunFinished");
static_assert(sizeof(UDelMarRacerState_RunFinished) == 0x000038, "Wrong size on UDelMarRacerState_RunFinished");
static_assert(offsetof(UDelMarRacerState_RunFinished, Vehicle) == 0x000030, "Member 'UDelMarRacerState_RunFinished::Vehicle' has a wrong offset!");

// Class DelMarCore.DelMarSplineActorMovementComponent
// 0x0010 (0x00B0 - 0x00A0)
class UDelMarSplineActorMovementComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class USplineComponent>        MovementSpline;                                    // 0x00A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeed;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarSplineActorMovementComponent">();
	}
	static class UDelMarSplineActorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarSplineActorMovementComponent>();
	}
};
static_assert(alignof(UDelMarSplineActorMovementComponent) == 0x000008, "Wrong alignment on UDelMarSplineActorMovementComponent");
static_assert(sizeof(UDelMarSplineActorMovementComponent) == 0x0000B0, "Wrong size on UDelMarSplineActorMovementComponent");
static_assert(offsetof(UDelMarSplineActorMovementComponent, MovementSpline) == 0x0000A0, "Member 'UDelMarSplineActorMovementComponent::MovementSpline' has a wrong offset!");
static_assert(offsetof(UDelMarSplineActorMovementComponent, MovementSpeed) == 0x0000A8, "Member 'UDelMarSplineActorMovementComponent::MovementSpeed' has a wrong offset!");

// Class DelMarCore.DelMarTimeManagerComponent
// 0x0090 (0x0130 - 0x00A0)
class UDelMarTimeManagerComponent final : public UDelMarRaceManagerComponent
{
public:
	TMulticastInlineDelegate<void(class AFortPlayerState* PlayerState)> OnPlayerCountdownStarted;                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	double                                        ServerRaceStartTime;                               // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        ServerRaceFinishTime;                              // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        ServerCountdownIntervalTime;                       // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarRaceConfigComponent> RaceConfig;                                        // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceLevelConfig>  RaceLevelConfig;                                   // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class AFortPlayerState>, double> ActiveCountdownRunStartTimeMap;                    // 0x00E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ResetClocks();
	void StartCountdownForPlayer(class AFortPlayerState* PlayerState, double ServerCountdownStartTime, double ServerRunStartTime);
	void StartCountdownForRace(double ServerCountdownStartTime, double ServerRunStartTime, double InServerCountdownIntervalTime);

	double GetRaceTimeRemaining() const;
	double GetSecondsRemainingTillRaceStart() const;
	double GetSecondsSinceRaceStart() const;
	double GetServerCountdownIntervalTime() const;
	double GetServerRaceFinishTime() const;
	double GetServerRaceStartTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarTimeManagerComponent">();
	}
	static class UDelMarTimeManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarTimeManagerComponent>();
	}
};
static_assert(alignof(UDelMarTimeManagerComponent) == 0x000008, "Wrong alignment on UDelMarTimeManagerComponent");
static_assert(sizeof(UDelMarTimeManagerComponent) == 0x000130, "Wrong size on UDelMarTimeManagerComponent");
static_assert(offsetof(UDelMarTimeManagerComponent, OnPlayerCountdownStarted) == 0x0000A0, "Member 'UDelMarTimeManagerComponent::OnPlayerCountdownStarted' has a wrong offset!");
static_assert(offsetof(UDelMarTimeManagerComponent, ServerRaceStartTime) == 0x0000B0, "Member 'UDelMarTimeManagerComponent::ServerRaceStartTime' has a wrong offset!");
static_assert(offsetof(UDelMarTimeManagerComponent, ServerRaceFinishTime) == 0x0000B8, "Member 'UDelMarTimeManagerComponent::ServerRaceFinishTime' has a wrong offset!");
static_assert(offsetof(UDelMarTimeManagerComponent, ServerCountdownIntervalTime) == 0x0000C0, "Member 'UDelMarTimeManagerComponent::ServerCountdownIntervalTime' has a wrong offset!");
static_assert(offsetof(UDelMarTimeManagerComponent, RaceConfig) == 0x0000C8, "Member 'UDelMarTimeManagerComponent::RaceConfig' has a wrong offset!");
static_assert(offsetof(UDelMarTimeManagerComponent, RaceLevelConfig) == 0x0000D0, "Member 'UDelMarTimeManagerComponent::RaceLevelConfig' has a wrong offset!");
static_assert(offsetof(UDelMarTimeManagerComponent, CachedRaceManager) == 0x0000D8, "Member 'UDelMarTimeManagerComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarTimeManagerComponent, ActiveCountdownRunStartTimeMap) == 0x0000E0, "Member 'UDelMarTimeManagerComponent::ActiveCountdownRunStartTimeMap' has a wrong offset!");

// Class DelMarCore.DelMarTutorialInteractableSpline
// 0x0060 (0x02F0 - 0x0290)
class ADelMarTutorialInteractableSpline final : public AActor
{
public:
	bool                                          bMustTriggerInOrder;                               // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ChildActorScaleMultiplier;                         // 0x0298(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarSplineGenerationMode                   SplineGenerationMode;                              // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChildActorCount;                                   // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSplineRotationForActors;                       // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugNumbers;                                 // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x2];                                      // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugTextZOffset;                                  // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugTextSize;                                     // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              DebugTextMaterial;                                 // 0x02C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADelMarTutorialTriggerActor> ChildActorClass;                                   // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UChildActorComponent*>           ChildActorComponents;                              // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void BP_HandleAllSplineTriggersCompleted(class AActor* FinalCompletedTrigger);
	void HandleColliderOverlap(class ADelMarTutorialTriggerActor* InTrigger);
	void ResetTriggers();

	bool GetHaveAllTriggersCompleted() const;
	int32 GetTriggerIndex(class ADelMarTutorialTriggerActor* InTrigger) const;
	float GetTriggerIndexAsRatio(class ADelMarTutorialTriggerActor* InTrigger) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarTutorialInteractableSpline">();
	}
	static class ADelMarTutorialInteractableSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarTutorialInteractableSpline>();
	}
};
static_assert(alignof(ADelMarTutorialInteractableSpline) == 0x000008, "Wrong alignment on ADelMarTutorialInteractableSpline");
static_assert(sizeof(ADelMarTutorialInteractableSpline) == 0x0002F0, "Wrong size on ADelMarTutorialInteractableSpline");
static_assert(offsetof(ADelMarTutorialInteractableSpline, bMustTriggerInOrder) == 0x000290, "Member 'ADelMarTutorialInteractableSpline::bMustTriggerInOrder' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, ChildActorScaleMultiplier) == 0x000298, "Member 'ADelMarTutorialInteractableSpline::ChildActorScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, SplineGenerationMode) == 0x0002B0, "Member 'ADelMarTutorialInteractableSpline::SplineGenerationMode' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, ChildActorCount) == 0x0002B4, "Member 'ADelMarTutorialInteractableSpline::ChildActorCount' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, bUseSplineRotationForActors) == 0x0002B8, "Member 'ADelMarTutorialInteractableSpline::bUseSplineRotationForActors' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, bShowDebugNumbers) == 0x0002B9, "Member 'ADelMarTutorialInteractableSpline::bShowDebugNumbers' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, DebugTextZOffset) == 0x0002BC, "Member 'ADelMarTutorialInteractableSpline::DebugTextZOffset' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, DebugTextSize) == 0x0002C0, "Member 'ADelMarTutorialInteractableSpline::DebugTextSize' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, DebugTextMaterial) == 0x0002C8, "Member 'ADelMarTutorialInteractableSpline::DebugTextMaterial' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, SplineComponent) == 0x0002D0, "Member 'ADelMarTutorialInteractableSpline::SplineComponent' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, ChildActorClass) == 0x0002D8, "Member 'ADelMarTutorialInteractableSpline::ChildActorClass' has a wrong offset!");
static_assert(offsetof(ADelMarTutorialInteractableSpline, ChildActorComponents) == 0x0002E0, "Member 'ADelMarTutorialInteractableSpline::ChildActorComponents' has a wrong offset!");

// Class DelMarCore.DelMarTutorialTriggerActor
// 0x0028 (0x02B8 - 0x0290)
class ADelMarTutorialTriggerActor final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BoxCollider;                                       // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BP_CanTriggerActor(class AActor* OtherActor);
	void BP_HandleColliderReset();
	void BP_HandleColliderTriggered();
	bool CanTriggerActor(class AActor* OtherActor);
	void HandleColliderOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void ResetTrigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarTutorialTriggerActor">();
	}
	static class ADelMarTutorialTriggerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarTutorialTriggerActor>();
	}
};
static_assert(alignof(ADelMarTutorialTriggerActor) == 0x000008, "Wrong alignment on ADelMarTutorialTriggerActor");
static_assert(sizeof(ADelMarTutorialTriggerActor) == 0x0002B8, "Wrong size on ADelMarTutorialTriggerActor");
static_assert(offsetof(ADelMarTutorialTriggerActor, BoxCollider) == 0x000298, "Member 'ADelMarTutorialTriggerActor::BoxCollider' has a wrong offset!");

// Class DelMarCore.DelMarVehicleAction_Drift
// 0x0000 (0x0040 - 0x0040)
class UDelMarVehicleAction_Drift final : public UDelMarVehicleAction
{
public:
	void HandleDrift(float DriftDirection, EDelMarVehicleDriftState DriftState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleAction_Drift">();
	}
	static class UDelMarVehicleAction_Drift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleAction_Drift>();
	}
};
static_assert(alignof(UDelMarVehicleAction_Drift) == 0x000008, "Wrong alignment on UDelMarVehicleAction_Drift");
static_assert(sizeof(UDelMarVehicleAction_Drift) == 0x000040, "Wrong size on UDelMarVehicleAction_Drift");

// Class DelMarCore.DelMarVehicleAction_KickFlip
// 0x0000 (0x0040 - 0x0040)
class UDelMarVehicleAction_KickFlip final : public UDelMarVehicleAction
{
public:
	void HandleKickflip(bool bLeftSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleAction_KickFlip">();
	}
	static class UDelMarVehicleAction_KickFlip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleAction_KickFlip>();
	}
};
static_assert(alignof(UDelMarVehicleAction_KickFlip) == 0x000008, "Wrong alignment on UDelMarVehicleAction_KickFlip");
static_assert(sizeof(UDelMarVehicleAction_KickFlip) == 0x000040, "Wrong size on UDelMarVehicleAction_KickFlip");

// Class DelMarCore.DelMarVehicleAction_Underthrust
// 0x0000 (0x0040 - 0x0040)
class UDelMarVehicleAction_Underthrust final : public UDelMarVehicleAction
{
public:
	void HandleUnderthrust();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleAction_Underthrust">();
	}
	static class UDelMarVehicleAction_Underthrust* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleAction_Underthrust>();
	}
};
static_assert(alignof(UDelMarVehicleAction_Underthrust) == 0x000008, "Wrong alignment on UDelMarVehicleAction_Underthrust");
static_assert(sizeof(UDelMarVehicleAction_Underthrust) == 0x000040, "Wrong size on UDelMarVehicleAction_Underthrust");

// Class DelMarCore.DelMarVehicleBodySetup
// 0x0058 (0x0088 - 0x0030)
class UDelMarVehicleBodySetup final : public UDataAsset
{
public:
	struct FDelMarVehicleAxleConfig               FrontAxle;                                         // 0x0030(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleAxleConfig               BackAxle;                                          // 0x005C(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleBodySetup">();
	}
	static class UDelMarVehicleBodySetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleBodySetup>();
	}
};
static_assert(alignof(UDelMarVehicleBodySetup) == 0x000008, "Wrong alignment on UDelMarVehicleBodySetup");
static_assert(sizeof(UDelMarVehicleBodySetup) == 0x000088, "Wrong size on UDelMarVehicleBodySetup");
static_assert(offsetof(UDelMarVehicleBodySetup, FrontAxle) == 0x000030, "Member 'UDelMarVehicleBodySetup::FrontAxle' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleBodySetup, BackAxle) == 0x00005C, "Member 'UDelMarVehicleBodySetup::BackAxle' has a wrong offset!");

// Class DelMarCore.DelMarVehicleBodySetupMap
// 0x0050 (0x0080 - 0x0030)
class UDelMarVehicleBodySetupMap final : public UDataAsset
{
public:
	TMap<class FName, class UDelMarVehicleBodySetup*> BodySetupMap;                                      // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleBodySetupMap">();
	}
	static class UDelMarVehicleBodySetupMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleBodySetupMap>();
	}
};
static_assert(alignof(UDelMarVehicleBodySetupMap) == 0x000008, "Wrong alignment on UDelMarVehicleBodySetupMap");
static_assert(sizeof(UDelMarVehicleBodySetupMap) == 0x000080, "Wrong size on UDelMarVehicleBodySetupMap");
static_assert(offsetof(UDelMarVehicleBodySetupMap, BodySetupMap) == 0x000030, "Member 'UDelMarVehicleBodySetupMap::BodySetupMap' has a wrong offset!");

// Class DelMarCore.DelMarVehicleCameraMode_V2
// 0x3050 (0x30B0 - 0x0060)
class alignas(0x10) UDelMarVehicleCameraMode_V2 final : public UFortCameraMode
{
public:
	TSubclassOf<class UDelMarCameraInputControllerComponent> CameraInputControllerComponentClass;               // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalFOVInterpLambda;                              // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            TotalFOVClamp;                                     // 0x0070(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDistanceInterpLambda;                         // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            TotalDistanceClamp;                                // 0x0088(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalHeightInterpLambda;                           // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffsetInterpLambda;                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            TotalHeightClamp;                                  // 0x00A4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleToOriginDegrees;                              // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleToOriginInterpLambda;                         // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            TotalAngleToOriginClamp;                           // 0x00BC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelInterpLambda;                                // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelPitchMax;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelYawMax;                                      // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundNormalInterpLambda;                          // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardInterpLambda;                               // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarPitchInterpLambda;                              // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRotationAxisInterpLambda;                     // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalDriftDegreeThreshold;                      // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDegreesVehicleWorldUpThreshold;                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldUpInterpRate;                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventPenetration;                               // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoPredictiveAvoidance;                            // 0x00F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6[0x2];                                       // 0x00F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionPushOutDistance;                          // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationBlendOutTime;                           // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationBlendInTime;                            // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             PenetrationTraceChannel;                           // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPenetrationAvoidanceFeeler>    PenetrationAvoidanceFeelers;                       // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     ForwardAirInterpLambdaCurve;                       // 0x0118(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     ForwardAirBlendCurve;                              // 0x01A8(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         MinForwardSpeedForAerialBlend;                     // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeInAirBeforeUsingVehicleUp;                  // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     GroundNormalAirInterpLambdaCurve;                  // 0x0238(0x0090)(Edit, NativeAccessSpecifierPublic)
	float                                         AirFreestyleDeactivationExtendedSeconds;           // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirFreestyleDeactivationLambdaSeconds;             // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirFreestyleDeactivationForwardLambda;             // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirFreestyleDeactivationNormalLambda;              // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DriftForwardBlendCurve;                            // 0x02D8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AerialDriftForwardBlendCurve;                      // 0x0360(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DriftForwardInterpLambdaCurve;                     // 0x03E8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DriftOriginOffsetCurve;                            // 0x0470(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     DriftOriginOffsetInterpLambdaCurve;                // 0x04F8(0x0090)(Edit, NativeAccessSpecifierPublic)
	float                                         DriftOriginOffsetInactiveLambda;                   // 0x0588(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarCameraFloatBlendedProperty      DriftKickOffsetDistance;                           // 0x0590(0x01D0)(Edit, NativeAccessSpecifierPublic)
	float                                         DriftKickOffsetLambda;                             // 0x0760(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriftKickOffsetInactiveLambda;                     // 0x0764(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeactivateKickOffsetOnKickEnd;                    // 0x0768(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_769[0x7];                                      // 0x0769(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     DriftRollDegreesCurve;                             // 0x0770(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     DriftRollDegreesInterpLambdaCurve;                 // 0x07F8(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     DriftScalarCurveCurve;                             // 0x0888(0x0090)(Edit, NativeAccessSpecifierPublic)
	float                                         GroundMaxPitchForNormalBlend;                      // 0x0918(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundExtraPitchForNormalBlend;                    // 0x091C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             StableSpeedDistance;                               // 0x0920(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             StableSpeedFOV;                                    // 0x09D0(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             StableSpeedHeight;                                 // 0x0A80(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             StableSpeedAngleToOrigin;                          // 0x0B30(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             AccelerationDistance;                              // 0x0BE0(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             AccelerationFOV;                                   // 0x0C90(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             AccelerationHeight;                                // 0x0D40(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             AccelerationAngleToOrigin;                         // 0x0DF0(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             BaseSpeedDistance;                                 // 0x0EA0(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             BaseSpeedFOV;                                      // 0x0F50(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             BaseSpeedHeight;                                   // 0x1000(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             BaseSpeedAngleToOrigin;                            // 0x10B0(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             BaseAccelerationDistance;                          // 0x1160(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             BaseAccelerationFOV;                               // 0x1210(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             BaseAccelerationHeight;                            // 0x12C0(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             BaseAccelerationAngleToOrigin;                     // 0x1370(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      TurboDistance;                                     // 0x1420(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      TurboFOV;                                          // 0x15F0(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      TurboBonusZoneSuccessDistance;                     // 0x17C0(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      TurboBonusZoneSuccessFOV;                          // 0x1990(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      DriftBonusDistance;                                // 0x1B60(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      DriftBonusFOV;                                     // 0x1D30(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      StartlineDistance;                                 // 0x1F00(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      StartlineFOV;                                      // 0x20D0(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             DraftDistance;                                     // 0x22A0(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatProperty             DraftFOV;                                          // 0x2350(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      WorldBonusSpeedDistance;                           // 0x2400(0x01D0)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarCameraFloatBlendedProperty      WorldBonusSpeedFOV;                                // 0x25D0(0x01D0)(Edit, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADelMarVehicle>          VehicleTarget;                                     // 0x27A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarCameraInputControllerComponent> CameraInputControllerComponent;                    // 0x27A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27B0[0x900];                                   // 0x27B0(0x0900)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAirFreestyleDeactivated();
	void OnAppliedTeleportRotation();
	void OnDriftBonusActivated();
	void OnDriftBonusDeactivated();
	void OnDriftKickActivated(float DriftDirection, EDelMarVehicleDriftState DriftState);
	void OnDriftKickDeactivated();
	void OnStartlineBoostActivated(float StartlineBoostPerc);
	void OnStartlineBoostDeactivated();
	void OnTurboActivated();
	void OnTurboBonusZoneStateChanged(EDelMarTurboZoneState ZoneState);
	void OnTurboDeactivated();
	void OnWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks);
	void OnWorldBonusSpeedStackLost(const struct FGameplayTag& Source, int32 Stacks);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleCameraMode_V2">();
	}
	static class UDelMarVehicleCameraMode_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleCameraMode_V2>();
	}
};
static_assert(alignof(UDelMarVehicleCameraMode_V2) == 0x000010, "Wrong alignment on UDelMarVehicleCameraMode_V2");
static_assert(sizeof(UDelMarVehicleCameraMode_V2) == 0x0030B0, "Wrong size on UDelMarVehicleCameraMode_V2");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, CameraInputControllerComponentClass) == 0x000060, "Member 'UDelMarVehicleCameraMode_V2::CameraInputControllerComponentClass' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, FOV) == 0x000068, "Member 'UDelMarVehicleCameraMode_V2::FOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TotalFOVInterpLambda) == 0x00006C, "Member 'UDelMarVehicleCameraMode_V2::TotalFOVInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TotalFOVClamp) == 0x000070, "Member 'UDelMarVehicleCameraMode_V2::TotalFOVClamp' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, Distance) == 0x000080, "Member 'UDelMarVehicleCameraMode_V2::Distance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TotalDistanceInterpLambda) == 0x000084, "Member 'UDelMarVehicleCameraMode_V2::TotalDistanceInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TotalDistanceClamp) == 0x000088, "Member 'UDelMarVehicleCameraMode_V2::TotalDistanceClamp' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, Height) == 0x000098, "Member 'UDelMarVehicleCameraMode_V2::Height' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TotalHeightInterpLambda) == 0x00009C, "Member 'UDelMarVehicleCameraMode_V2::TotalHeightInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, HeightOffsetInterpLambda) == 0x0000A0, "Member 'UDelMarVehicleCameraMode_V2::HeightOffsetInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TotalHeightClamp) == 0x0000A4, "Member 'UDelMarVehicleCameraMode_V2::TotalHeightClamp' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AngleToOriginDegrees) == 0x0000B4, "Member 'UDelMarVehicleCameraMode_V2::AngleToOriginDegrees' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AngleToOriginInterpLambda) == 0x0000B8, "Member 'UDelMarVehicleCameraMode_V2::AngleToOriginInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TotalAngleToOriginClamp) == 0x0000BC, "Member 'UDelMarVehicleCameraMode_V2::TotalAngleToOriginClamp' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, SwivelInterpLambda) == 0x0000CC, "Member 'UDelMarVehicleCameraMode_V2::SwivelInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, SwivelPitchMax) == 0x0000D0, "Member 'UDelMarVehicleCameraMode_V2::SwivelPitchMax' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, SwivelYawMax) == 0x0000D4, "Member 'UDelMarVehicleCameraMode_V2::SwivelYawMax' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, GroundNormalInterpLambda) == 0x0000D8, "Member 'UDelMarVehicleCameraMode_V2::GroundNormalInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, ForwardInterpLambda) == 0x0000DC, "Member 'UDelMarVehicleCameraMode_V2::ForwardInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, CarPitchInterpLambda) == 0x0000E0, "Member 'UDelMarVehicleCameraMode_V2::CarPitchInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, PitchRotationAxisInterpLambda) == 0x0000E4, "Member 'UDelMarVehicleCameraMode_V2::PitchRotationAxisInterpLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, VerticalDriftDegreeThreshold) == 0x0000E8, "Member 'UDelMarVehicleCameraMode_V2::VerticalDriftDegreeThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, MinDegreesVehicleWorldUpThreshold) == 0x0000EC, "Member 'UDelMarVehicleCameraMode_V2::MinDegreesVehicleWorldUpThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, WorldUpInterpRate) == 0x0000F0, "Member 'UDelMarVehicleCameraMode_V2::WorldUpInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, bPreventPenetration) == 0x0000F4, "Member 'UDelMarVehicleCameraMode_V2::bPreventPenetration' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, bDoPredictiveAvoidance) == 0x0000F5, "Member 'UDelMarVehicleCameraMode_V2::bDoPredictiveAvoidance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, CollisionPushOutDistance) == 0x0000F8, "Member 'UDelMarVehicleCameraMode_V2::CollisionPushOutDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, PenetrationBlendOutTime) == 0x0000FC, "Member 'UDelMarVehicleCameraMode_V2::PenetrationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, PenetrationBlendInTime) == 0x000100, "Member 'UDelMarVehicleCameraMode_V2::PenetrationBlendInTime' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, PenetrationTraceChannel) == 0x000104, "Member 'UDelMarVehicleCameraMode_V2::PenetrationTraceChannel' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, PenetrationAvoidanceFeelers) == 0x000108, "Member 'UDelMarVehicleCameraMode_V2::PenetrationAvoidanceFeelers' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, ForwardAirInterpLambdaCurve) == 0x000118, "Member 'UDelMarVehicleCameraMode_V2::ForwardAirInterpLambdaCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, ForwardAirBlendCurve) == 0x0001A8, "Member 'UDelMarVehicleCameraMode_V2::ForwardAirBlendCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, MinForwardSpeedForAerialBlend) == 0x000230, "Member 'UDelMarVehicleCameraMode_V2::MinForwardSpeedForAerialBlend' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, MinTimeInAirBeforeUsingVehicleUp) == 0x000234, "Member 'UDelMarVehicleCameraMode_V2::MinTimeInAirBeforeUsingVehicleUp' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, GroundNormalAirInterpLambdaCurve) == 0x000238, "Member 'UDelMarVehicleCameraMode_V2::GroundNormalAirInterpLambdaCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AirFreestyleDeactivationExtendedSeconds) == 0x0002C8, "Member 'UDelMarVehicleCameraMode_V2::AirFreestyleDeactivationExtendedSeconds' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AirFreestyleDeactivationLambdaSeconds) == 0x0002CC, "Member 'UDelMarVehicleCameraMode_V2::AirFreestyleDeactivationLambdaSeconds' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AirFreestyleDeactivationForwardLambda) == 0x0002D0, "Member 'UDelMarVehicleCameraMode_V2::AirFreestyleDeactivationForwardLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AirFreestyleDeactivationNormalLambda) == 0x0002D4, "Member 'UDelMarVehicleCameraMode_V2::AirFreestyleDeactivationNormalLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftForwardBlendCurve) == 0x0002D8, "Member 'UDelMarVehicleCameraMode_V2::DriftForwardBlendCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AerialDriftForwardBlendCurve) == 0x000360, "Member 'UDelMarVehicleCameraMode_V2::AerialDriftForwardBlendCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftForwardInterpLambdaCurve) == 0x0003E8, "Member 'UDelMarVehicleCameraMode_V2::DriftForwardInterpLambdaCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftOriginOffsetCurve) == 0x000470, "Member 'UDelMarVehicleCameraMode_V2::DriftOriginOffsetCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftOriginOffsetInterpLambdaCurve) == 0x0004F8, "Member 'UDelMarVehicleCameraMode_V2::DriftOriginOffsetInterpLambdaCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftOriginOffsetInactiveLambda) == 0x000588, "Member 'UDelMarVehicleCameraMode_V2::DriftOriginOffsetInactiveLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftKickOffsetDistance) == 0x000590, "Member 'UDelMarVehicleCameraMode_V2::DriftKickOffsetDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftKickOffsetLambda) == 0x000760, "Member 'UDelMarVehicleCameraMode_V2::DriftKickOffsetLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftKickOffsetInactiveLambda) == 0x000764, "Member 'UDelMarVehicleCameraMode_V2::DriftKickOffsetInactiveLambda' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, bDeactivateKickOffsetOnKickEnd) == 0x000768, "Member 'UDelMarVehicleCameraMode_V2::bDeactivateKickOffsetOnKickEnd' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftRollDegreesCurve) == 0x000770, "Member 'UDelMarVehicleCameraMode_V2::DriftRollDegreesCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftRollDegreesInterpLambdaCurve) == 0x0007F8, "Member 'UDelMarVehicleCameraMode_V2::DriftRollDegreesInterpLambdaCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftScalarCurveCurve) == 0x000888, "Member 'UDelMarVehicleCameraMode_V2::DriftScalarCurveCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, GroundMaxPitchForNormalBlend) == 0x000918, "Member 'UDelMarVehicleCameraMode_V2::GroundMaxPitchForNormalBlend' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, GroundExtraPitchForNormalBlend) == 0x00091C, "Member 'UDelMarVehicleCameraMode_V2::GroundExtraPitchForNormalBlend' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, StableSpeedDistance) == 0x000920, "Member 'UDelMarVehicleCameraMode_V2::StableSpeedDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, StableSpeedFOV) == 0x0009D0, "Member 'UDelMarVehicleCameraMode_V2::StableSpeedFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, StableSpeedHeight) == 0x000A80, "Member 'UDelMarVehicleCameraMode_V2::StableSpeedHeight' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, StableSpeedAngleToOrigin) == 0x000B30, "Member 'UDelMarVehicleCameraMode_V2::StableSpeedAngleToOrigin' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AccelerationDistance) == 0x000BE0, "Member 'UDelMarVehicleCameraMode_V2::AccelerationDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AccelerationFOV) == 0x000C90, "Member 'UDelMarVehicleCameraMode_V2::AccelerationFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AccelerationHeight) == 0x000D40, "Member 'UDelMarVehicleCameraMode_V2::AccelerationHeight' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, AccelerationAngleToOrigin) == 0x000DF0, "Member 'UDelMarVehicleCameraMode_V2::AccelerationAngleToOrigin' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, BaseSpeedDistance) == 0x000EA0, "Member 'UDelMarVehicleCameraMode_V2::BaseSpeedDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, BaseSpeedFOV) == 0x000F50, "Member 'UDelMarVehicleCameraMode_V2::BaseSpeedFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, BaseSpeedHeight) == 0x001000, "Member 'UDelMarVehicleCameraMode_V2::BaseSpeedHeight' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, BaseSpeedAngleToOrigin) == 0x0010B0, "Member 'UDelMarVehicleCameraMode_V2::BaseSpeedAngleToOrigin' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, BaseAccelerationDistance) == 0x001160, "Member 'UDelMarVehicleCameraMode_V2::BaseAccelerationDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, BaseAccelerationFOV) == 0x001210, "Member 'UDelMarVehicleCameraMode_V2::BaseAccelerationFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, BaseAccelerationHeight) == 0x0012C0, "Member 'UDelMarVehicleCameraMode_V2::BaseAccelerationHeight' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, BaseAccelerationAngleToOrigin) == 0x001370, "Member 'UDelMarVehicleCameraMode_V2::BaseAccelerationAngleToOrigin' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TurboDistance) == 0x001420, "Member 'UDelMarVehicleCameraMode_V2::TurboDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TurboFOV) == 0x0015F0, "Member 'UDelMarVehicleCameraMode_V2::TurboFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TurboBonusZoneSuccessDistance) == 0x0017C0, "Member 'UDelMarVehicleCameraMode_V2::TurboBonusZoneSuccessDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, TurboBonusZoneSuccessFOV) == 0x001990, "Member 'UDelMarVehicleCameraMode_V2::TurboBonusZoneSuccessFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftBonusDistance) == 0x001B60, "Member 'UDelMarVehicleCameraMode_V2::DriftBonusDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DriftBonusFOV) == 0x001D30, "Member 'UDelMarVehicleCameraMode_V2::DriftBonusFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, StartlineDistance) == 0x001F00, "Member 'UDelMarVehicleCameraMode_V2::StartlineDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, StartlineFOV) == 0x0020D0, "Member 'UDelMarVehicleCameraMode_V2::StartlineFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DraftDistance) == 0x0022A0, "Member 'UDelMarVehicleCameraMode_V2::DraftDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, DraftFOV) == 0x002350, "Member 'UDelMarVehicleCameraMode_V2::DraftFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, WorldBonusSpeedDistance) == 0x002400, "Member 'UDelMarVehicleCameraMode_V2::WorldBonusSpeedDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, WorldBonusSpeedFOV) == 0x0025D0, "Member 'UDelMarVehicleCameraMode_V2::WorldBonusSpeedFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, VehicleTarget) == 0x0027A0, "Member 'UDelMarVehicleCameraMode_V2::VehicleTarget' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode_V2, CameraInputControllerComponent) == 0x0027A8, "Member 'UDelMarVehicleCameraMode_V2::CameraInputControllerComponent' has a wrong offset!");

// Class DelMarCore.DelMarVehicleInterface
// 0x0000 (0x0028 - 0x0028)
class IDelMarVehicleInterface final : public IVehicleCosmeticsInterface
{
public:
	bool AnyWheelsOnGround() const;
	bool CanStrafeBeActivated() const;
	float GetAcceleration() const;
	float GetBaseForwardSpeed() const;
	float GetBaseTargetSpeed() const;
	float GetBonusSpeed() const;
	class UDelMarVehicleCosmeticComponent* GetCosmeticComponent() const;
	float GetCurrentNumTurboCharges() const;
	EDelMarTurboZoneState GetCurrentTurboBonusZoneState() const;
	float GetDraftingMaxBonusSpeedPercentage() const;
	EDelmarDraftingState GetDraftingState() const;
	float GetDriftAngle() const;
	float GetDriftBoostAppliedBonusSpeed() const;
	float GetDriftDuration() const;
	float GetDriftSlipAngleRatio() const;
	float GetForwardSpeed() const;
	int32 GetKickflipActivationCharges() const;
	float GetKickflipDistanceToSuctionSurface() const;
	float GetKickflipDuration() const;
	struct FDelMarVehicleLandingData GetLandingData() const;
	float GetMaxNumTurboCharges() const;
	float GetNormalizedBonusSpeed() const;
	float GetNormalizedForwardSpeed() const;
	float GetOversteerAccumulationPercentage() const;
	float GetPercentageTurboActiveTimeRemaining() const;
	class UPostProcessComponent* GetPostProcessComponent() const;
	float GetPotentialDriftBoostPercentage() const;
	float GetQueuedBonusSpeed() const;
	struct FVector GetReattachmentDirection() const;
	float GetRemainingTurboActiveSeconds() const;
	float GetSideSpeed() const;
	class USkeletalMeshComponent* GetSkeletalMeshComponent() const;
	float GetSpeedometerSpeed() const;
	float GetStableSpeed() const;
	float GetStartlineAppliedBonusSpeed() const;
	float GetStartlineMaxEarnedBonusSpeed() const;
	float GetStartlinePercentageMaxBonusSpeedEarned() const;
	float GetSteering() const;
	float GetSteeringAngle() const;
	float GetStrafeCooldownPercentage() const;
	float GetTargetDriftSide() const;
	float GetTargetSpeed() const;
	float GetThrottle() const;
	float GetTotalTimeSkydiving() const;
	class UDelMarTrackPositionComponent* GetTrackPositionComponent() const;
	float GetTurboAdditionalActiveSeconds() const;
	float GetTurboAppliedBonusSpeed() const;
	float GetTurboBonusZoneBonusSpeed() const;
	float GetUnderthrustActiveDuration() const;
	float GetUnderthrustPercentageTankRemaining() const;
	EDelMarVehicleForwardState GetVehicleForwardState() const;
	struct FVector GetVelocity() const;
	float GetWorldAppliedBonusSpeed() const;
	bool HasValidDraftingTarget() const;
	bool InDriftBoostRange() const;
	bool IsAccelerating() const;
	bool IsAirFreestyling() const;
	bool IsAllVehicleInputDisabled() const;
	bool IsBraking() const;
	bool IsDriftControlled() const;
	bool IsInvulnerabilityActive() const;
	bool IsKickflipSuctionActive() const;
	bool IsKickingWheels() const;
	bool IsLosingAppliedBonusSpeed() const;
	bool IsReattaching() const;
	bool IsSkyDiving() const;
	bool IsStrafeActive() const;
	bool IsStrafeDisabled() const;
	bool IsStrafeLeft() const;
	bool WheelsOnGround() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleInterface">();
	}
	static class IDelMarVehicleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDelMarVehicleInterface>();
	}
};
static_assert(alignof(IDelMarVehicleInterface) == 0x000008, "Wrong alignment on IDelMarVehicleInterface");
static_assert(sizeof(IDelMarVehicleInterface) == 0x000028, "Wrong size on IDelMarVehicleInterface");

// Class DelMarCore.DelMarVehicleLoadoutSetup
// 0x0050 (0x0080 - 0x0030)
class UDelMarVehicleLoadoutSetup final : public UPrimaryDataAsset
{
public:
	struct FDelMarLoadout                         Loadout;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleLoadoutSetup">();
	}
	static class UDelMarVehicleLoadoutSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleLoadoutSetup>();
	}
};
static_assert(alignof(UDelMarVehicleLoadoutSetup) == 0x000008, "Wrong alignment on UDelMarVehicleLoadoutSetup");
static_assert(sizeof(UDelMarVehicleLoadoutSetup) == 0x000080, "Wrong size on UDelMarVehicleLoadoutSetup");
static_assert(offsetof(UDelMarVehicleLoadoutSetup, Loadout) == 0x000030, "Member 'UDelMarVehicleLoadoutSetup::Loadout' has a wrong offset!");

// Class DelMarCore.DelMarVehicle
// 0x0D30 (0x2C50 - 0x1F20)
class ADelMarVehicle final : public AFortAthenaSKVehicle
{
public:
	uint8                                         Pad_1F18[0x50];                                    // 0x1F18(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortCameraMode>>    DelMarCameraModes;                                 // 0x1F68(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bLocalDriverHasReplicatedVehicle;                  // 0x1F78(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F79[0xF];                                     // 0x1F79(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAthenaVehicleInputState           PendingDriverInputState;                           // 0x1F88(0x0040)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TurboCharges;                                      // 0x1FC8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToPack;                                    // 0x1FCC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromTrackFinish;                           // 0x1FD0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ATTR_bVehicleThrottleDisabled;                     // 0x1FD4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD5[0x3];                                     // 0x1FD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarInputAction                     ThrottleAction;                                    // 0x1FD8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     BrakeAction;                                       // 0x1FE8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     SteerAction;                                       // 0x1FF8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     SteerLeftAction;                                   // 0x2008(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     SteerRightAction;                                  // 0x2018(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     PitchAction;                                       // 0x2028(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     PitchUpAction;                                     // 0x2038(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     PitchDownAction;                                   // 0x2048(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     RollAction;                                        // 0x2058(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     YawAction;                                         // 0x2068(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     DriftAction;                                       // 0x2078(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     JumpAction;                                        // 0x2088(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     KickFlipAction;                                    // 0x2098(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     UnderthrustAction;                                 // 0x20A8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     TurboAction;                                       // 0x20B8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     DelMarExitAction;                                  // 0x20C8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     ResetRunAction;                                    // 0x20D8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     AirFreestyleAction;                                // 0x20E8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     StrafeAction;                                      // 0x20F8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     AerialPitchAction;                                 // 0x2108(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     DemolishAction;                                    // 0x2118(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UDelMarPlayerInputManagerComponent> InputManagerClass;                                 // 0x2128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2130[0x18];                                    // 0x2130(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleVelocityLengthThreshold;                       // 0x2148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      RaceManager;                                       // 0x214C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2154[0x4];                                     // 0x2154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelMarVehicleNetworkPhysicsComponent*  NetworkPhysicsComponent;                           // 0x2158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarVehicleCosmeticComponent*        CosmeticComponent;                                 // 0x2160(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2168[0x8];                                     // 0x2168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelMarVehicleMovementSet*              DelMarVehicleMovementSet;                          // 0x2170(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortClientSettingsRecord*              FortSettings;                                      // 0x2178(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDelMarTrackPositionComponent> TrackPositionComponentClass;                       // 0x2180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarTrackPositionComponent*          TrackPositionComponent;                            // 0x2188(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDelMarVehicleCachedContact>    CachedContacts;                                    // 0x2190(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         NearbyTrackDistanceThreshold;                      // 0x21A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A4[0xA0];                                    // 0x21A4(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisualSteerAngleInterpRate;                        // 0x2244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriftVisualSteerAngleInterpRate;                   // 0x2248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideVisualSteeringAngle;                      // 0x224C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224D[0x3];                                     // 0x224D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrivingVisualSteeringDegrees;                      // 0x2250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2254[0x4];                                     // 0x2254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarScaledCurve                     DriftSteeringDegreesCurve;                         // 0x2258(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowVisualSteerAngleInAir;                        // 0x22E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E9[0x7];                                     // 0x22E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelMarVehicleBodySetup*                BodySetup;                                         // 0x22F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarRaceConfigComponent> ActiveRaceConfig;                                  // 0x22F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTimeManagerComponent> RaceTimeManager;                                   // 0x2300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarGlobalInputDisabler> GlobalInputDisabler;                               // 0x2308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2310[0x10];                                    // 0x2310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnVehicleWheelsLeftGround;                         // 0x2320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float UpdatedSpeedometerSpeed)> OnSpeedometerSpeedChanged;                         // 0x2330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         MinNoThrottleSpeed;                                // 0x2340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedSlowdownSpeedometerSeconds;                   // 0x2344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   SpeedSlowdownTags;                                 // 0x2348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EDelMarInvertSteerMethod                      InvertSteerMethod;                                 // 0x2358(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPitchInverted;                                    // 0x2359(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerticalKickflipInverted;                         // 0x235A(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialPitchActivationEnabled;                     // 0x235B(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235C[0x34];                                    // 0x235C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnBonusSpeedActivated;                             // 0x2390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBonusSpeedDeactivated;                           // 0x23A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnBonusSpeedChanged;                               // 0x23B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue)> OnAnyWheelsOnGroundChanged;                        // 0x23C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue)> OnWheelsOnGroundChanged;                           // 0x23D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EDelMarVehicleForwardState NewForwardState)> OnVehicleForwardStateChanged;                      // 0x23E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F0[0xC0];                                    // 0x23F0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float ImpactMagnitude, const struct FVector& WorldLocation, float ForwardRotationDegrees)> OnDelMarVehicleHitWall;                            // 0x24B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Magnitude, const struct FVector& WorldLocation)> OnDelMarVehicleHitVehicle;                         // 0x24C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Magnitude, const struct FVector& WorldLocation)> OnDelMarVehicleHitByVehicle;                       // 0x24D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float LandingForce, bool bLandedKickflip)> OnVehicleLanded;                                   // 0x24E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F0[0x10];                                    // 0x24F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayTag& Source, int32 Stacks)> OnWorldBonusSpeedStackGained;                      // 0x2500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& Source, int32 Stacks)> OnWorldBonusSpeedStackLost;                        // 0x2510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnforceSpeedAdjustmentChecks;                     // 0x2520(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2521[0x6F];                                    // 0x2521(0x006F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnVehicleStartedSkydiving;                         // 0x2590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVehicleStoppedSkydiving;                         // 0x25A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B0[0x8];                                     // 0x25B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnDriftActivated;                                  // 0x25B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDriftDeactivated;                                // 0x25C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float DriftSlipAngleRatio)> OnDriftSlipAngleRatioChanged;                      // 0x25D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float DriftDirection, EDelMarVehicleDriftState DriftState)> OnDriftKickActivated;                              // 0x25E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDriftKickDeactivated;                            // 0x25F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsDriftingControlled)> OnDriftControlChanged;                             // 0x2608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float duration)> OnDriftDurationChanged;                            // 0x2618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2628[0x40];                                    // 0x2628(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEnteredDriftBoostRange;                          // 0x2668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnExitedDriftBoostRange;                           // 0x2678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStartedLosingAppliedDriftBoost;                  // 0x2688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDriftBoostActivated;                             // 0x2698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDriftBoostDeactivated;                           // 0x26A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMaxPotentialReached;                             // 0x26B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMaxPotentialLost;                                // 0x26C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllPotentialLost;                                // 0x26D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float PercentageBoost)> OnEarnedDriftBoost;                                // 0x26E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float PercentageBoost)> OnPotentialDriftBoostChanged;                      // 0x26F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2708[0x38];                                    // 0x2708(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnDraftActivated;                                  // 0x2740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDraftDeactivated;                                // 0x2750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EDelmarDraftingState CurrentState)> OnDraftStateChanged;                               // 0x2760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReachedMaxBonusSpeed;                            // 0x2770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2780[0x2C];                                    // 0x2780(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarRubberbandingConfig             RubberbandingConfig;                               // 0x27AC(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27D4[0x34];                                    // 0x27D4(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float PercentageMaxBonusSpeedEarned)> OnStartlineBoostActivated;                         // 0x2808(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStartlineBoostDeactivated;                       // 0x2818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStartlineBoostFailed;                            // 0x2828(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDelMarStartlineBoostData              StartlineBoostData;                                // 0x2838(0x0010)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2848[0x20];                                    // 0x2848(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bLeftSide)> OnStrafeActivated;                                 // 0x2868(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStrafeDeactivated;                               // 0x2878(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnStrafeCooldownChanged;                           // 0x2888(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bValue)>   OnStrafeUsabilityChanged;                          // 0x2898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bValue)>   OnStrafeDisabledChanged;                           // 0x28A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B8[0x20];                                    // 0x28B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTurboActivated;                                  // 0x28D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTurboDeactivated;                                // 0x28E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTurboChargesUpdated;                             // 0x28F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EDelMarTurboZoneState ZoneState)> OnTurboBonusZoneStateChanged;                      // 0x2908(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTurboChargeUsed;                                 // 0x2918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2928[0x38];                                    // 0x2928(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bLeftSide)> OnKickflipActivated;                               // 0x2960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnKickflipDeactivated;                             // 0x2970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnKickflipSuctionActivated;                        // 0x2980(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnKickflipSuctionDeactivated;                      // 0x2990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float duration)> OnKickflipDistanceToSuctionSurfaceChanged;         // 0x29A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float duration)> OnKickflipDurationChanged;                         // 0x29B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Value)>   OnKickflipActivationChargesChanged;                // 0x29C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D0[0x88];                                    // 0x29D0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnReattachmentActivated;                           // 0x2A58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReattachmentDeactivated;                         // 0x2A68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                ForcedReattachmentDirection;                       // 0x2A78(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A90[0x28];                                    // 0x2A90(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnUnderthrustActivated;                            // 0x2AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUnderthrustDeactivated;                          // 0x2AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float PercentageUnderthrustRemaining)> OnUnderthrustPercentChanged;                       // 0x2AD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE8[0x18];                                    // 0x2AE8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnJumpActivated;                                   // 0x2B00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnJumpDeactivated;                                 // 0x2B10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B20[0x8];                                     // 0x2B20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DemolitionRespawnSeconds;                          // 0x2B28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2C[0x4];                                     // 0x2B2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayTag& CausedByTag)> OnVehicleDemolished;                               // 0x2B30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnDemolishPressDurationUpdated;                    // 0x2B40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B50[0x18];                                    // 0x2B50(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHazardHit;                                       // 0x2B68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInvulnerabilityActivated;                        // 0x2B78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInvulnerabilityDeactivated;                      // 0x2B88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B98[0x4];                                     // 0x2B98(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpawnBroadcastSeconds;                          // 0x2B9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarVehicleSpawnInfo                SpawnInfo;                                         // 0x2BA0(0x0010)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bFirstCar, bool bPrevCarDemolished)> OnDelMarVehicleSpawned;                            // 0x2BB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAllowExitingVehicle;                              // 0x2BC0(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC1[0x7];                                     // 0x2BC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnVehicleTeleportEntered;                          // 0x2BC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVehicleTeleportExit;                             // 0x2BD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVehicleAppliedTeleportRotation;                  // 0x2BE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAirFreestyleActivated;                           // 0x2BF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAirFreestyleDeactivated;                         // 0x2C08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C18[0x8];                                     // 0x2C18(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarAudioController*                 CachedVehicleAudioController;                      // 0x2C20(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVehicleCollisionsEnabled;                         // 0x2C28(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPawnCollisionsEnabled;                            // 0x2C29(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2A[0xE];                                     // 0x2C2A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsePredictiveInterpolation;                       // 0x2C38(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C39[0x7];                                     // 0x2C39(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessComponent*                  PostProcessComp;                                   // 0x2C40(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C48[0x8];                                     // 0x2C48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTargetSpeedAdjustment(const class FName& Source, float Value);
	void AddWorldBonusSpeedStack(const struct FDelMarWorldBonusSpeedStack& BonusSpeedStack);
	void DemolishVehicle(const struct FGameplayTag& InCausedByTag);
	void HandleAerialThrottleBrakeChanged();
	void HandleOnVehicleCosmeticsFinished();
	void HandlePitchDeadzoneChanged();
	void HandleSteerDeadzoneChanged();
	void HandleThrottleDeadzoneChanged();
	void HandleThrottleToggleChanged();
	void OnRep_bPawnCollisionsEnabled();
	void OnRep_bVehicleCollisionsEnabled();
	void OnRep_SpawnInfo();
	void OnRep_StartlineBoostData();
	void OnRep_TurboCharges();
	void ResetRunPressed();
	void ResetTrackPosition(class ADelMarTrackBase* Track, int32 TrackSegment);
	void ServerAddReplicatedGameplayTag(const struct FGameplayTag& InTag);
	void ServerAddReplicatedGameplayTags(const struct FGameplayTagContainer& InTags);
	void ServerDemolishVehicle(const struct FGameplayTag& InCausedByTag);
	void ServerNotifyTurboActivated();
	void ServerRemoveReplicatedGameplayTag(const struct FGameplayTag& InTag);
	void ServerRemoveReplicatedGameplayTags(const struct FGameplayTagContainer& InTags);
	void ServerSetLocalDriverHasReplicatedTheVehicle(bool bNewValue);
	void ServerTeleportVehicleEntered();
	void ServerTeleportVehicleExited();
	void SetTeleportRotation(const struct FRotator& DestRotation);
	void SetVehicleMesh(class USkeletalMesh* NewMesh, class UPhysicsAsset* PhysicsAsset);
	void TeleportVehicleEntered();
	void TeleportVehicleExited();
	void TryGetFortClientSettings();

	class UDelMarAudioComponentGroup* GetAudioComponentGroup() const;
	class UDelMarVehicleCosmeticComponent* GetCosmeticComponent() const;
	float GetNewestStackActiveDurationFromSource(const struct FGameplayTag& Source) const;
	class ADelMarRaceManager* GetRaceManager() const;
	class UDelMarTrackPositionComponent* GetTrackPositionComponent() const;
	bool IsInvulnerabilityActive() const;
	bool IsRespawnEffectSignificant() const;
	bool IsWheelOnGround(EDelMarVehicleWheelIndex WheelIndex) const;
	bool VehicleHasTag(const struct FGameplayTag& InTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicle">();
	}
	static class ADelMarVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarVehicle>();
	}
};
static_assert(alignof(ADelMarVehicle) == 0x000010, "Wrong alignment on ADelMarVehicle");
static_assert(sizeof(ADelMarVehicle) == 0x002C50, "Wrong size on ADelMarVehicle");
static_assert(offsetof(ADelMarVehicle, DelMarCameraModes) == 0x001F68, "Member 'ADelMarVehicle::DelMarCameraModes' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bLocalDriverHasReplicatedVehicle) == 0x001F78, "Member 'ADelMarVehicle::bLocalDriverHasReplicatedVehicle' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, PendingDriverInputState) == 0x001F88, "Member 'ADelMarVehicle::PendingDriverInputState' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, TurboCharges) == 0x001FC8, "Member 'ADelMarVehicle::TurboCharges' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DistanceToPack) == 0x001FCC, "Member 'ADelMarVehicle::DistanceToPack' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DistanceFromTrackFinish) == 0x001FD0, "Member 'ADelMarVehicle::DistanceFromTrackFinish' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, ATTR_bVehicleThrottleDisabled) == 0x001FD4, "Member 'ADelMarVehicle::ATTR_bVehicleThrottleDisabled' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, ThrottleAction) == 0x001FD8, "Member 'ADelMarVehicle::ThrottleAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, BrakeAction) == 0x001FE8, "Member 'ADelMarVehicle::BrakeAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, SteerAction) == 0x001FF8, "Member 'ADelMarVehicle::SteerAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, SteerLeftAction) == 0x002008, "Member 'ADelMarVehicle::SteerLeftAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, SteerRightAction) == 0x002018, "Member 'ADelMarVehicle::SteerRightAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, PitchAction) == 0x002028, "Member 'ADelMarVehicle::PitchAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, PitchUpAction) == 0x002038, "Member 'ADelMarVehicle::PitchUpAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, PitchDownAction) == 0x002048, "Member 'ADelMarVehicle::PitchDownAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, RollAction) == 0x002058, "Member 'ADelMarVehicle::RollAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, YawAction) == 0x002068, "Member 'ADelMarVehicle::YawAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DriftAction) == 0x002078, "Member 'ADelMarVehicle::DriftAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, JumpAction) == 0x002088, "Member 'ADelMarVehicle::JumpAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, KickFlipAction) == 0x002098, "Member 'ADelMarVehicle::KickFlipAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, UnderthrustAction) == 0x0020A8, "Member 'ADelMarVehicle::UnderthrustAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, TurboAction) == 0x0020B8, "Member 'ADelMarVehicle::TurboAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DelMarExitAction) == 0x0020C8, "Member 'ADelMarVehicle::DelMarExitAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, ResetRunAction) == 0x0020D8, "Member 'ADelMarVehicle::ResetRunAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, AirFreestyleAction) == 0x0020E8, "Member 'ADelMarVehicle::AirFreestyleAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, StrafeAction) == 0x0020F8, "Member 'ADelMarVehicle::StrafeAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, AerialPitchAction) == 0x002108, "Member 'ADelMarVehicle::AerialPitchAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DemolishAction) == 0x002118, "Member 'ADelMarVehicle::DemolishAction' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, InputManagerClass) == 0x002128, "Member 'ADelMarVehicle::InputManagerClass' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, IdleVelocityLengthThreshold) == 0x002148, "Member 'ADelMarVehicle::IdleVelocityLengthThreshold' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, RaceManager) == 0x00214C, "Member 'ADelMarVehicle::RaceManager' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, NetworkPhysicsComponent) == 0x002158, "Member 'ADelMarVehicle::NetworkPhysicsComponent' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, CosmeticComponent) == 0x002160, "Member 'ADelMarVehicle::CosmeticComponent' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DelMarVehicleMovementSet) == 0x002170, "Member 'ADelMarVehicle::DelMarVehicleMovementSet' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, FortSettings) == 0x002178, "Member 'ADelMarVehicle::FortSettings' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, TrackPositionComponentClass) == 0x002180, "Member 'ADelMarVehicle::TrackPositionComponentClass' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, TrackPositionComponent) == 0x002188, "Member 'ADelMarVehicle::TrackPositionComponent' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, CachedContacts) == 0x002190, "Member 'ADelMarVehicle::CachedContacts' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, NearbyTrackDistanceThreshold) == 0x0021A0, "Member 'ADelMarVehicle::NearbyTrackDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, VisualSteerAngleInterpRate) == 0x002244, "Member 'ADelMarVehicle::VisualSteerAngleInterpRate' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DriftVisualSteerAngleInterpRate) == 0x002248, "Member 'ADelMarVehicle::DriftVisualSteerAngleInterpRate' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bOverrideVisualSteeringAngle) == 0x00224C, "Member 'ADelMarVehicle::bOverrideVisualSteeringAngle' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DrivingVisualSteeringDegrees) == 0x002250, "Member 'ADelMarVehicle::DrivingVisualSteeringDegrees' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DriftSteeringDegreesCurve) == 0x002258, "Member 'ADelMarVehicle::DriftSteeringDegreesCurve' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bShowVisualSteerAngleInAir) == 0x0022E8, "Member 'ADelMarVehicle::bShowVisualSteerAngleInAir' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, BodySetup) == 0x0022F0, "Member 'ADelMarVehicle::BodySetup' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, ActiveRaceConfig) == 0x0022F8, "Member 'ADelMarVehicle::ActiveRaceConfig' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, RaceTimeManager) == 0x002300, "Member 'ADelMarVehicle::RaceTimeManager' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, GlobalInputDisabler) == 0x002308, "Member 'ADelMarVehicle::GlobalInputDisabler' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleWheelsLeftGround) == 0x002320, "Member 'ADelMarVehicle::OnVehicleWheelsLeftGround' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnSpeedometerSpeedChanged) == 0x002330, "Member 'ADelMarVehicle::OnSpeedometerSpeedChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, MinNoThrottleSpeed) == 0x002340, "Member 'ADelMarVehicle::MinNoThrottleSpeed' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, SpeedSlowdownSpeedometerSeconds) == 0x002344, "Member 'ADelMarVehicle::SpeedSlowdownSpeedometerSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, SpeedSlowdownTags) == 0x002348, "Member 'ADelMarVehicle::SpeedSlowdownTags' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, InvertSteerMethod) == 0x002358, "Member 'ADelMarVehicle::InvertSteerMethod' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bPitchInverted) == 0x002359, "Member 'ADelMarVehicle::bPitchInverted' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bVerticalKickflipInverted) == 0x00235A, "Member 'ADelMarVehicle::bVerticalKickflipInverted' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bAerialPitchActivationEnabled) == 0x00235B, "Member 'ADelMarVehicle::bAerialPitchActivationEnabled' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnBonusSpeedActivated) == 0x002390, "Member 'ADelMarVehicle::OnBonusSpeedActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnBonusSpeedDeactivated) == 0x0023A0, "Member 'ADelMarVehicle::OnBonusSpeedDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnBonusSpeedChanged) == 0x0023B0, "Member 'ADelMarVehicle::OnBonusSpeedChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnAnyWheelsOnGroundChanged) == 0x0023C0, "Member 'ADelMarVehicle::OnAnyWheelsOnGroundChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnWheelsOnGroundChanged) == 0x0023D0, "Member 'ADelMarVehicle::OnWheelsOnGroundChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleForwardStateChanged) == 0x0023E0, "Member 'ADelMarVehicle::OnVehicleForwardStateChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDelMarVehicleHitWall) == 0x0024B0, "Member 'ADelMarVehicle::OnDelMarVehicleHitWall' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDelMarVehicleHitVehicle) == 0x0024C0, "Member 'ADelMarVehicle::OnDelMarVehicleHitVehicle' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDelMarVehicleHitByVehicle) == 0x0024D0, "Member 'ADelMarVehicle::OnDelMarVehicleHitByVehicle' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleLanded) == 0x0024E0, "Member 'ADelMarVehicle::OnVehicleLanded' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnWorldBonusSpeedStackGained) == 0x002500, "Member 'ADelMarVehicle::OnWorldBonusSpeedStackGained' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnWorldBonusSpeedStackLost) == 0x002510, "Member 'ADelMarVehicle::OnWorldBonusSpeedStackLost' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bEnforceSpeedAdjustmentChecks) == 0x002520, "Member 'ADelMarVehicle::bEnforceSpeedAdjustmentChecks' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleStartedSkydiving) == 0x002590, "Member 'ADelMarVehicle::OnVehicleStartedSkydiving' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleStoppedSkydiving) == 0x0025A0, "Member 'ADelMarVehicle::OnVehicleStoppedSkydiving' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftActivated) == 0x0025B8, "Member 'ADelMarVehicle::OnDriftActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftDeactivated) == 0x0025C8, "Member 'ADelMarVehicle::OnDriftDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftSlipAngleRatioChanged) == 0x0025D8, "Member 'ADelMarVehicle::OnDriftSlipAngleRatioChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftKickActivated) == 0x0025E8, "Member 'ADelMarVehicle::OnDriftKickActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftKickDeactivated) == 0x0025F8, "Member 'ADelMarVehicle::OnDriftKickDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftControlChanged) == 0x002608, "Member 'ADelMarVehicle::OnDriftControlChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftDurationChanged) == 0x002618, "Member 'ADelMarVehicle::OnDriftDurationChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnEnteredDriftBoostRange) == 0x002668, "Member 'ADelMarVehicle::OnEnteredDriftBoostRange' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnExitedDriftBoostRange) == 0x002678, "Member 'ADelMarVehicle::OnExitedDriftBoostRange' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStartedLosingAppliedDriftBoost) == 0x002688, "Member 'ADelMarVehicle::OnStartedLosingAppliedDriftBoost' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftBoostActivated) == 0x002698, "Member 'ADelMarVehicle::OnDriftBoostActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDriftBoostDeactivated) == 0x0026A8, "Member 'ADelMarVehicle::OnDriftBoostDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnMaxPotentialReached) == 0x0026B8, "Member 'ADelMarVehicle::OnMaxPotentialReached' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnMaxPotentialLost) == 0x0026C8, "Member 'ADelMarVehicle::OnMaxPotentialLost' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnAllPotentialLost) == 0x0026D8, "Member 'ADelMarVehicle::OnAllPotentialLost' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnEarnedDriftBoost) == 0x0026E8, "Member 'ADelMarVehicle::OnEarnedDriftBoost' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnPotentialDriftBoostChanged) == 0x0026F8, "Member 'ADelMarVehicle::OnPotentialDriftBoostChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDraftActivated) == 0x002740, "Member 'ADelMarVehicle::OnDraftActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDraftDeactivated) == 0x002750, "Member 'ADelMarVehicle::OnDraftDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDraftStateChanged) == 0x002760, "Member 'ADelMarVehicle::OnDraftStateChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnReachedMaxBonusSpeed) == 0x002770, "Member 'ADelMarVehicle::OnReachedMaxBonusSpeed' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, RubberbandingConfig) == 0x0027AC, "Member 'ADelMarVehicle::RubberbandingConfig' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStartlineBoostActivated) == 0x002808, "Member 'ADelMarVehicle::OnStartlineBoostActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStartlineBoostDeactivated) == 0x002818, "Member 'ADelMarVehicle::OnStartlineBoostDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStartlineBoostFailed) == 0x002828, "Member 'ADelMarVehicle::OnStartlineBoostFailed' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, StartlineBoostData) == 0x002838, "Member 'ADelMarVehicle::StartlineBoostData' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStrafeActivated) == 0x002868, "Member 'ADelMarVehicle::OnStrafeActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStrafeDeactivated) == 0x002878, "Member 'ADelMarVehicle::OnStrafeDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStrafeCooldownChanged) == 0x002888, "Member 'ADelMarVehicle::OnStrafeCooldownChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStrafeUsabilityChanged) == 0x002898, "Member 'ADelMarVehicle::OnStrafeUsabilityChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnStrafeDisabledChanged) == 0x0028A8, "Member 'ADelMarVehicle::OnStrafeDisabledChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnTurboActivated) == 0x0028D8, "Member 'ADelMarVehicle::OnTurboActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnTurboDeactivated) == 0x0028E8, "Member 'ADelMarVehicle::OnTurboDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnTurboChargesUpdated) == 0x0028F8, "Member 'ADelMarVehicle::OnTurboChargesUpdated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnTurboBonusZoneStateChanged) == 0x002908, "Member 'ADelMarVehicle::OnTurboBonusZoneStateChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnTurboChargeUsed) == 0x002918, "Member 'ADelMarVehicle::OnTurboChargeUsed' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnKickflipActivated) == 0x002960, "Member 'ADelMarVehicle::OnKickflipActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnKickflipDeactivated) == 0x002970, "Member 'ADelMarVehicle::OnKickflipDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnKickflipSuctionActivated) == 0x002980, "Member 'ADelMarVehicle::OnKickflipSuctionActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnKickflipSuctionDeactivated) == 0x002990, "Member 'ADelMarVehicle::OnKickflipSuctionDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnKickflipDistanceToSuctionSurfaceChanged) == 0x0029A0, "Member 'ADelMarVehicle::OnKickflipDistanceToSuctionSurfaceChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnKickflipDurationChanged) == 0x0029B0, "Member 'ADelMarVehicle::OnKickflipDurationChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnKickflipActivationChargesChanged) == 0x0029C0, "Member 'ADelMarVehicle::OnKickflipActivationChargesChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnReattachmentActivated) == 0x002A58, "Member 'ADelMarVehicle::OnReattachmentActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnReattachmentDeactivated) == 0x002A68, "Member 'ADelMarVehicle::OnReattachmentDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, ForcedReattachmentDirection) == 0x002A78, "Member 'ADelMarVehicle::ForcedReattachmentDirection' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnUnderthrustActivated) == 0x002AB8, "Member 'ADelMarVehicle::OnUnderthrustActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnUnderthrustDeactivated) == 0x002AC8, "Member 'ADelMarVehicle::OnUnderthrustDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnUnderthrustPercentChanged) == 0x002AD8, "Member 'ADelMarVehicle::OnUnderthrustPercentChanged' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnJumpActivated) == 0x002B00, "Member 'ADelMarVehicle::OnJumpActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnJumpDeactivated) == 0x002B10, "Member 'ADelMarVehicle::OnJumpDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, DemolitionRespawnSeconds) == 0x002B28, "Member 'ADelMarVehicle::DemolitionRespawnSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleDemolished) == 0x002B30, "Member 'ADelMarVehicle::OnVehicleDemolished' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDemolishPressDurationUpdated) == 0x002B40, "Member 'ADelMarVehicle::OnDemolishPressDurationUpdated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnHazardHit) == 0x002B68, "Member 'ADelMarVehicle::OnHazardHit' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnInvulnerabilityActivated) == 0x002B78, "Member 'ADelMarVehicle::OnInvulnerabilityActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnInvulnerabilityDeactivated) == 0x002B88, "Member 'ADelMarVehicle::OnInvulnerabilityDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, MaxSpawnBroadcastSeconds) == 0x002B9C, "Member 'ADelMarVehicle::MaxSpawnBroadcastSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, SpawnInfo) == 0x002BA0, "Member 'ADelMarVehicle::SpawnInfo' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnDelMarVehicleSpawned) == 0x002BB0, "Member 'ADelMarVehicle::OnDelMarVehicleSpawned' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bAllowExitingVehicle) == 0x002BC0, "Member 'ADelMarVehicle::bAllowExitingVehicle' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleTeleportEntered) == 0x002BC8, "Member 'ADelMarVehicle::OnVehicleTeleportEntered' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleTeleportExit) == 0x002BD8, "Member 'ADelMarVehicle::OnVehicleTeleportExit' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnVehicleAppliedTeleportRotation) == 0x002BE8, "Member 'ADelMarVehicle::OnVehicleAppliedTeleportRotation' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnAirFreestyleActivated) == 0x002BF8, "Member 'ADelMarVehicle::OnAirFreestyleActivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, OnAirFreestyleDeactivated) == 0x002C08, "Member 'ADelMarVehicle::OnAirFreestyleDeactivated' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, CachedVehicleAudioController) == 0x002C20, "Member 'ADelMarVehicle::CachedVehicleAudioController' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bVehicleCollisionsEnabled) == 0x002C28, "Member 'ADelMarVehicle::bVehicleCollisionsEnabled' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bPawnCollisionsEnabled) == 0x002C29, "Member 'ADelMarVehicle::bPawnCollisionsEnabled' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, bUsePredictiveInterpolation) == 0x002C38, "Member 'ADelMarVehicle::bUsePredictiveInterpolation' has a wrong offset!");
static_assert(offsetof(ADelMarVehicle, PostProcessComp) == 0x002C40, "Member 'ADelMarVehicle::PostProcessComp' has a wrong offset!");

// Class DelMarCore.DelMarVehicleNetworkPhysicsComponent
// 0x0540 (0x05E0 - 0x00A0)
class UDelMarVehicleNetworkPhysicsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarVehicleReplicatedState          ReplicatedState;                                   // 0x00B0(0x0290)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x2A0];                                    // 0x0340(0x02A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPhysicsStateChanged(class UPrimitiveComponent* ChangedComponent, EComponentPhysicsStateChange StateChange);
	void OnRep_ReplicatedState(const struct FDelMarVehicleReplicatedState& PrevReplicatedState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleNetworkPhysicsComponent">();
	}
	static class UDelMarVehicleNetworkPhysicsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleNetworkPhysicsComponent>();
	}
};
static_assert(alignof(UDelMarVehicleNetworkPhysicsComponent) == 0x000010, "Wrong alignment on UDelMarVehicleNetworkPhysicsComponent");
static_assert(sizeof(UDelMarVehicleNetworkPhysicsComponent) == 0x0005E0, "Wrong size on UDelMarVehicleNetworkPhysicsComponent");
static_assert(offsetof(UDelMarVehicleNetworkPhysicsComponent, ReplicatedState) == 0x0000B0, "Member 'UDelMarVehicleNetworkPhysicsComponent::ReplicatedState' has a wrong offset!");

// Class DelMarCore.DelMarVehicleStateTagManagerComponent
// 0x0010 (0x00B0 - 0x00A0)
class UDelMarVehicleStateTagManagerComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class ADelMarVehicle>          CachedVehicle;                                     // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAbilitySystemComponent> CachedASC;                                         // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleAnyWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& Vehicle, bool bWheelsOnGround);
	void HandleDraftActivated();
	void HandleDraftDeactivated();
	void HandleDriftActivated();
	void HandleDriftBoostActivated();
	void HandleDriftBoostDeactivated();
	void HandleDriftDeactivated();
	void HandleTurboChargeUsed();
	void HandleTurboDeactivated();
	void HandleWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks);
	void HandleWorldBonusSpeedStackLost(const struct FGameplayTag& Source, int32 Stacks);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleStateTagManagerComponent">();
	}
	static class UDelMarVehicleStateTagManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleStateTagManagerComponent>();
	}
};
static_assert(alignof(UDelMarVehicleStateTagManagerComponent) == 0x000008, "Wrong alignment on UDelMarVehicleStateTagManagerComponent");
static_assert(sizeof(UDelMarVehicleStateTagManagerComponent) == 0x0000B0, "Wrong size on UDelMarVehicleStateTagManagerComponent");
static_assert(offsetof(UDelMarVehicleStateTagManagerComponent, CachedVehicle) == 0x0000A0, "Member 'UDelMarVehicleStateTagManagerComponent::CachedVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleStateTagManagerComponent, CachedASC) == 0x0000A8, "Member 'UDelMarVehicleStateTagManagerComponent::CachedASC' has a wrong offset!");

// Class DelMarCore.DelMarVehicleVerbComponent
// 0x0028 (0x00C8 - 0x00A0)
class UDelMarVehicleVerbComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAnyWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& Vehicle, bool bWheelsOnGround);
	void HandleDraftActivated();
	void HandleDriftBoostActivated();
	void HandleDriftBoostDeactivated();
	void HandleDriftDeactivated();
	void HandleDriftDurationChanged(float duration);
	void HandleJumpActivated();
	void HandleKickflipped(bool bLeft);
	void HandlePotentialDriftBoostChanged(float Percent);
	void HandleSpeedometerSpeedChanged(float UpdatedSpeedometerSpeed);
	void HandleStartlineBoostActivated(float BoostPercent);
	void HandleTurboBonusZoneChanged(EDelMarTurboZoneState BonusZoneState);
	void HandleTurboChargeUsed();
	void HandleUnderthrustDeactivated();
	void HandleUnderthrustPercentChanged(float PercentageUnderthrustRemaining);
	void HandleVehicleLanded(float LandingForce, bool bLandedKickflip);
	void HandleWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks);
	void HandleWorldBonusSpeedStackLost(const struct FGameplayTag& Source, int32 Stacks);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleVerbComponent">();
	}
	static class UDelMarVehicleVerbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleVerbComponent>();
	}
};
static_assert(alignof(UDelMarVehicleVerbComponent) == 0x000008, "Wrong alignment on UDelMarVehicleVerbComponent");
static_assert(sizeof(UDelMarVehicleVerbComponent) == 0x0000C8, "Wrong size on UDelMarVehicleVerbComponent");

// Class DelMarCore.GameFeatureAction_MergeRankedDisplayData
// 0x0010 (0x0038 - 0x0028)
class UGameFeatureAction_MergeRankedDisplayData final : public UGameFeatureAction
{
public:
	class UFortHabaneroDisplayData*               MergeSource;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortHabaneroDisplayData*               MergeDestination;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_MergeRankedDisplayData">();
	}
	static class UGameFeatureAction_MergeRankedDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_MergeRankedDisplayData>();
	}
};
static_assert(alignof(UGameFeatureAction_MergeRankedDisplayData) == 0x000008, "Wrong alignment on UGameFeatureAction_MergeRankedDisplayData");
static_assert(sizeof(UGameFeatureAction_MergeRankedDisplayData) == 0x000038, "Wrong size on UGameFeatureAction_MergeRankedDisplayData");
static_assert(offsetof(UGameFeatureAction_MergeRankedDisplayData, MergeSource) == 0x000028, "Member 'UGameFeatureAction_MergeRankedDisplayData::MergeSource' has a wrong offset!");
static_assert(offsetof(UGameFeatureAction_MergeRankedDisplayData, MergeDestination) == 0x000030, "Member 'UGameFeatureAction_MergeRankedDisplayData::MergeDestination' has a wrong offset!");

// Class DelMarCore.GameFeatureAction_OverrideGameModeAISettings
// 0x0020 (0x0048 - 0x0028)
class UGameFeatureAction_OverrideGameModeAISettings final : public UGameFeatureAction
{
public:
	TSoftObjectPtr<class UAthenaAISettings>       AISettings;                                        // 0x0028(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureAction_OverrideGameModeAISettings">();
	}
	static class UGameFeatureAction_OverrideGameModeAISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureAction_OverrideGameModeAISettings>();
	}
};
static_assert(alignof(UGameFeatureAction_OverrideGameModeAISettings) == 0x000008, "Wrong alignment on UGameFeatureAction_OverrideGameModeAISettings");
static_assert(sizeof(UGameFeatureAction_OverrideGameModeAISettings) == 0x000048, "Wrong size on UGameFeatureAction_OverrideGameModeAISettings");
static_assert(offsetof(UGameFeatureAction_OverrideGameModeAISettings, AISettings) == 0x000028, "Member 'UGameFeatureAction_OverrideGameModeAISettings::AISettings' has a wrong offset!");

// Class DelMarCore.UDelMarPlayerSuspendComponent
// 0x0018 (0x00B8 - 0x00A0)
class UUDelMarPlayerSuspendComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UDelMarPlayerSuspendComponent">();
	}
	static class UUDelMarPlayerSuspendComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUDelMarPlayerSuspendComponent>();
	}
};
static_assert(alignof(UUDelMarPlayerSuspendComponent) == 0x000008, "Wrong alignment on UUDelMarPlayerSuspendComponent");
static_assert(sizeof(UUDelMarPlayerSuspendComponent) == 0x0000B8, "Wrong size on UUDelMarPlayerSuspendComponent");
static_assert(offsetof(UUDelMarPlayerSuspendComponent, CachedRaceManager) == 0x0000A8, "Member 'UUDelMarPlayerSuspendComponent::CachedRaceManager' has a wrong offset!");

// Class DelMarCore.DelMarAudioComponentGroup
// 0x0010 (0x03E0 - 0x03D0)
class UDelMarAudioComponentGroup final : public UAudioComponentGroup
{
public:
	class UDelMarAudioMixModifierExtension*       MixModifierExtension;                              // 0x03C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDelMarSubmixSendExtension*             SubmixSendExtension;                               // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UDelMarAudioMixModifierExtension* GetMixModifiers() const;
	class UDelMarSubmixSendExtension* GetSubmixSends() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarAudioComponentGroup">();
	}
	static class UDelMarAudioComponentGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarAudioComponentGroup>();
	}
};
static_assert(alignof(UDelMarAudioComponentGroup) == 0x000010, "Wrong alignment on UDelMarAudioComponentGroup");
static_assert(sizeof(UDelMarAudioComponentGroup) == 0x0003E0, "Wrong size on UDelMarAudioComponentGroup");
static_assert(offsetof(UDelMarAudioComponentGroup, MixModifierExtension) == 0x0003C8, "Member 'UDelMarAudioComponentGroup::MixModifierExtension' has a wrong offset!");
static_assert(offsetof(UDelMarAudioComponentGroup, SubmixSendExtension) == 0x0003D0, "Member 'UDelMarAudioComponentGroup::SubmixSendExtension' has a wrong offset!");

// Class DelMarCore.DelMarAudioController
// 0x00A0 (0x03D8 - 0x0338)
class ADelMarAudioController final : public AVehicleCosmeticsAudioController
{
public:
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnBigAirStarted;                                   // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBigAirStopped;                                   // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDelMarAudioComponentGroup*             ComponentGroup;                                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocal;                                          // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinishLineDistanceThreshold;                       // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproachingFinishLineMinTime;                      // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BigAirLandingDistanceThreshold;                    // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BigAirTimeThreshold;                               // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BigAirDownSpeedThreshold;                          // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonLocalVelocityInterpSpeed;                       // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInBigAir;                                         // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarVehicle*                         CachedVehicle;                                     // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x30];                                     // 0x03A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleVehicleDemolished(const struct FGameplayTag& CausedByTag);
	class UAudioComponent* PlaySound(class USoundBase* sound, float InFadeInTime, float InTargetVolume, bool bDisableAttenuation, const EAudioFaderCurve InFadeCurve);

	class UDelMarAudioComponentGroup* GetComponentGroup() const;
	bool IsVirtualized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarAudioController">();
	}
	static class ADelMarAudioController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarAudioController>();
	}
};
static_assert(alignof(ADelMarAudioController) == 0x000008, "Wrong alignment on ADelMarAudioController");
static_assert(sizeof(ADelMarAudioController) == 0x0003D8, "Wrong size on ADelMarAudioController");
static_assert(offsetof(ADelMarAudioController, OnBigAirStarted) == 0x000350, "Member 'ADelMarAudioController::OnBigAirStarted' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, OnBigAirStopped) == 0x000360, "Member 'ADelMarAudioController::OnBigAirStopped' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, ComponentGroup) == 0x000370, "Member 'ADelMarAudioController::ComponentGroup' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, bIsLocal) == 0x000378, "Member 'ADelMarAudioController::bIsLocal' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, FinishLineDistanceThreshold) == 0x00037C, "Member 'ADelMarAudioController::FinishLineDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, ApproachingFinishLineMinTime) == 0x000380, "Member 'ADelMarAudioController::ApproachingFinishLineMinTime' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, BigAirLandingDistanceThreshold) == 0x000384, "Member 'ADelMarAudioController::BigAirLandingDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, BigAirTimeThreshold) == 0x000388, "Member 'ADelMarAudioController::BigAirTimeThreshold' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, BigAirDownSpeedThreshold) == 0x00038C, "Member 'ADelMarAudioController::BigAirDownSpeedThreshold' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, NonLocalVelocityInterpSpeed) == 0x000390, "Member 'ADelMarAudioController::NonLocalVelocityInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, MaxAcceleration) == 0x000394, "Member 'ADelMarAudioController::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, bInBigAir) == 0x000398, "Member 'ADelMarAudioController::bInBigAir' has a wrong offset!");
static_assert(offsetof(ADelMarAudioController, CachedVehicle) == 0x0003A0, "Member 'ADelMarAudioController::CachedVehicle' has a wrong offset!");

// Class DelMarCore.DelMarAudioMixModifierExtension
// 0x0028 (0x00C8 - 0x00A0)
class UDelMarAudioMixModifierExtension final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMixGroup(const struct FAudioMixModifierGroup& InMixModifier);
	void RemoveMixGroup(const struct FAudioMixModifierGroup& InMixModifier);
	void RemoveMixGroupByName(const class FName InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarAudioMixModifierExtension">();
	}
	static class UDelMarAudioMixModifierExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarAudioMixModifierExtension>();
	}
};
static_assert(alignof(UDelMarAudioMixModifierExtension) == 0x000008, "Wrong alignment on UDelMarAudioMixModifierExtension");
static_assert(sizeof(UDelMarAudioMixModifierExtension) == 0x0000C8, "Wrong size on UDelMarAudioMixModifierExtension");

// Class DelMarCore.DelMarAudioReverbComponent
// 0x0288 (0x0328 - 0x00A0)
class UDelMarAudioReverbComponent final : public UActorComponent
{
public:
	class USoundSubmixBase*                       ReverbSend;                                        // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundSubmixBase*                       EarlyReflectionSend;                               // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     EnclosureReverbBlendCurve;                         // 0x00B0(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     WallDistanceBlendCurve;                            // 0x0138(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     EnclosureSendLevelCurve;                           // 0x01C0(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     WallDistanceSendLevelCurve;                        // 0x0248(0x0088)(Edit, NativeAccessSpecifierPublic)
	int32                                         NumPoints;                                         // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRadius;                                       // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceOrigin;                                       // 0x02D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTracesPerFrame;                                 // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarVehicle*                         CachedVehicleOwner;                                // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x28];                                     // 0x0300(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarAudioReverbComponent">();
	}
	static class UDelMarAudioReverbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarAudioReverbComponent>();
	}
};
static_assert(alignof(UDelMarAudioReverbComponent) == 0x000008, "Wrong alignment on UDelMarAudioReverbComponent");
static_assert(sizeof(UDelMarAudioReverbComponent) == 0x000328, "Wrong size on UDelMarAudioReverbComponent");
static_assert(offsetof(UDelMarAudioReverbComponent, ReverbSend) == 0x0000A0, "Member 'UDelMarAudioReverbComponent::ReverbSend' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, EarlyReflectionSend) == 0x0000A8, "Member 'UDelMarAudioReverbComponent::EarlyReflectionSend' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, EnclosureReverbBlendCurve) == 0x0000B0, "Member 'UDelMarAudioReverbComponent::EnclosureReverbBlendCurve' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, WallDistanceBlendCurve) == 0x000138, "Member 'UDelMarAudioReverbComponent::WallDistanceBlendCurve' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, EnclosureSendLevelCurve) == 0x0001C0, "Member 'UDelMarAudioReverbComponent::EnclosureSendLevelCurve' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, WallDistanceSendLevelCurve) == 0x000248, "Member 'UDelMarAudioReverbComponent::WallDistanceSendLevelCurve' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, NumPoints) == 0x0002D0, "Member 'UDelMarAudioReverbComponent::NumPoints' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, TraceRadius) == 0x0002D4, "Member 'UDelMarAudioReverbComponent::TraceRadius' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, TraceOrigin) == 0x0002D8, "Member 'UDelMarAudioReverbComponent::TraceOrigin' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, NumTracesPerFrame) == 0x0002F0, "Member 'UDelMarAudioReverbComponent::NumTracesPerFrame' has a wrong offset!");
static_assert(offsetof(UDelMarAudioReverbComponent, CachedVehicleOwner) == 0x0002F8, "Member 'UDelMarAudioReverbComponent::CachedVehicleOwner' has a wrong offset!");

// Class DelMarCore.DelMarSubmixSendExtension
// 0x0020 (0x00C0 - 0x00A0)
class UDelMarSubmixSendExtension final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SendInterpTime;                                    // 0x00A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x14];                                      // 0x00AC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveSend(class USoundSubmixBase* InSubmix);
	void SetSend(class USoundSubmixBase* InSubmix, const float InLevel, const bool bTrackCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarSubmixSendExtension">();
	}
	static class UDelMarSubmixSendExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarSubmixSendExtension>();
	}
};
static_assert(alignof(UDelMarSubmixSendExtension) == 0x000008, "Wrong alignment on UDelMarSubmixSendExtension");
static_assert(sizeof(UDelMarSubmixSendExtension) == 0x0000C0, "Wrong size on UDelMarSubmixSendExtension");
static_assert(offsetof(UDelMarSubmixSendExtension, SendInterpTime) == 0x0000A8, "Member 'UDelMarSubmixSendExtension::SendInterpTime' has a wrong offset!");

// Class DelMarCore.DelMarNuxBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDelMarNuxBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetCurrentLapNumber(const class ADelMarVehicle* Vehicle);
	static struct FDelMarRankedInfo GetCurrentRankedInfoForVehicle(const class ADelMarVehicle* Vehicle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarNuxBlueprintFunctionLibrary">();
	}
	static class UDelMarNuxBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarNuxBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UDelMarNuxBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UDelMarNuxBlueprintFunctionLibrary");
static_assert(sizeof(UDelMarNuxBlueprintFunctionLibrary) == 0x000028, "Wrong size on UDelMarNuxBlueprintFunctionLibrary");

// Class DelMarCore.DelMarCheckpoint
// 0x01A8 (0x0D80 - 0x0BD8)
class alignas(0x10) ADelMarCheckpoint final : public AFortCreativeDeviceProp
{
public:
	TMulticastInlineDelegate<void(class ADelMarVehicle* Vehicle)> OnCheckpointTirggeredEvent;                        // 0x0BD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DynamicSpawnOffset;                                // 0x0BE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnDistanceBeforeOrAfterSplineLocation;          // 0x0BEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseRadius;                                        // 0x0BF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CheckpointId;                                      // 0x0BF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SplinePointIndex;                                  // 0x0BF8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BFC[0x4];                                      // 0x0BFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarPlayerStart*                     SpawnPoint;                                        // 0x0C00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarTrackSnapToComponent*            SnapToComponent;                                   // 0x0C08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class ADelMarCheckpoint*>                NextCheckpoints;                                   // 0x0C10(0x0050)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSet<class ADelMarCheckpoint*>                PreviousCheckpoints;                               // 0x0C60(0x0050)(Edit, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FCheckpointTrackDistance               NearestTrack;                                      // 0x0CB0(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCheckpointTrackDistance>       AssociatedTracks;                                  // 0x0CC8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsFinishLine : 1;                                 // 0x0CD8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsStartingLine : 1;                               // 0x0CD8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsTimeTrialSectionEnd : 1;                        // 0x0CD8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsTeleportEnabled : 1;                            // 0x0CD8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_CD9[0x7];                                      // 0x0CD9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarCheckpoint*                      CheckpointToTeleportTo;                            // 0x0CE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ComputedCheckpointIndex;                           // 0x0CE8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CEC[0x4];                                      // 0x0CEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ColliderVolume;                                    // 0x0CF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF8[0x88];                                     // 0x0CF8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ActivateRift();
	void BP_DeactivateRift();
	void BP_FirstPlaceChanged(bool bValidPrevFirstPlace);
	void BP_LapFinished(int32 CompletedLap, int32 CurrentLap, int32 TotalLaps);
	void BP_RaceFinished();
	void BP_RaceReset();
	void ClientSetCheckpointActive(int32 CurrentLap, int32 TotalLaps);
	void ClientSetCheckpointInactive();
	void HandlePawnEnteredVehicle(const TScriptInterface<class IFortVehicleInterface>& Vehicle, class AFortPawn* Pawn, int32 SeatIndex);
	void OnTriggered(class ADelMarVehicle* InDelMarVehicle);
	void UpdateCheckpointMesh(EDelMarCheckpointMeshType MeshType);

	EDelMarCheckpointMeshType GetCheckpointMeshType() const;
	const struct FCheckpointTrackDistance GetFurthestAheadTrackDistance() const;
	const struct FCheckpointTrackDistance GetFurthestBehindTrackDistance() const;
	const struct FCheckpointTrackDistance GetNearestTrackData() const;
	struct FTransform GetSpawnTransform() const;
	const struct FCheckpointTrackDistance GetTrackDistanceDataForTrack(const class ADelMarTrackBase* InTrack, const bool bEnsureAssociated) const;
	bool IsAssociatedWithTrack(const class ADelMarTrackBase* InTrack) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCheckpoint">();
	}
	static class ADelMarCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarCheckpoint>();
	}
};
static_assert(alignof(ADelMarCheckpoint) == 0x000010, "Wrong alignment on ADelMarCheckpoint");
static_assert(sizeof(ADelMarCheckpoint) == 0x000D80, "Wrong size on ADelMarCheckpoint");
static_assert(offsetof(ADelMarCheckpoint, OnCheckpointTirggeredEvent) == 0x000BD8, "Member 'ADelMarCheckpoint::OnCheckpointTirggeredEvent' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, DynamicSpawnOffset) == 0x000BE8, "Member 'ADelMarCheckpoint::DynamicSpawnOffset' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, SpawnDistanceBeforeOrAfterSplineLocation) == 0x000BEC, "Member 'ADelMarCheckpoint::SpawnDistanceBeforeOrAfterSplineLocation' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, BaseRadius) == 0x000BF0, "Member 'ADelMarCheckpoint::BaseRadius' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, CheckpointId) == 0x000BF4, "Member 'ADelMarCheckpoint::CheckpointId' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, SplinePointIndex) == 0x000BF8, "Member 'ADelMarCheckpoint::SplinePointIndex' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, SpawnPoint) == 0x000C00, "Member 'ADelMarCheckpoint::SpawnPoint' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, SnapToComponent) == 0x000C08, "Member 'ADelMarCheckpoint::SnapToComponent' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, NextCheckpoints) == 0x000C10, "Member 'ADelMarCheckpoint::NextCheckpoints' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, PreviousCheckpoints) == 0x000C60, "Member 'ADelMarCheckpoint::PreviousCheckpoints' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, NearestTrack) == 0x000CB0, "Member 'ADelMarCheckpoint::NearestTrack' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, AssociatedTracks) == 0x000CC8, "Member 'ADelMarCheckpoint::AssociatedTracks' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, CheckpointToTeleportTo) == 0x000CE0, "Member 'ADelMarCheckpoint::CheckpointToTeleportTo' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, ComputedCheckpointIndex) == 0x000CE8, "Member 'ADelMarCheckpoint::ComputedCheckpointIndex' has a wrong offset!");
static_assert(offsetof(ADelMarCheckpoint, ColliderVolume) == 0x000CF0, "Member 'ADelMarCheckpoint::ColliderVolume' has a wrong offset!");

// Class DelMarCore.FortClientPilot_QuickSmokeDelMar
// 0x0010 (0x0320 - 0x0310)
class UFortClientPilot_QuickSmokeDelMar final : public UFortClientPilot_GameplayBase
{
public:
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientPilot_QuickSmokeDelMar">();
	}
	static class UFortClientPilot_QuickSmokeDelMar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientPilot_QuickSmokeDelMar>();
	}
};
static_assert(alignof(UFortClientPilot_QuickSmokeDelMar) == 0x000010, "Wrong alignment on UFortClientPilot_QuickSmokeDelMar");
static_assert(sizeof(UFortClientPilot_QuickSmokeDelMar) == 0x000320, "Wrong size on UFortClientPilot_QuickSmokeDelMar");

// Class DelMarCore.DelMarBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDelMarBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AreAllLeaderboardFiltersEnabled();
	static bool BP_KillAndRespawnVehicle(const class AController* Controller, const struct FGameplayTag& CausedByTag);
	static class FText DelMarFormatTime(const double TimeSeconds, const bool bIncludeMilliseconds);
	static double GetClientWorldTimeSeconds(const class UObject* WorldContextObject);
	static class ADelMarPlayspace* GetDelMarPlayspace(const class UObject* WorldContextObject);
	static class ADelMarVehicle* GetDelMarVehicle(const class APlayerController* PlayerController);
	static EDelMarNetModel GetNetModel(const class UObject* WorldContextObject);
	static class AFortPlayerController* GetPrimaryPlayerController(const class UObject* WorldContextObject);
	static class AFortPlayerState* GetPrimaryPlayerState(const class UObject* WorldContextObject);
	static double GetTimerDeltaFromServerTime(const double TimestampSeconds, const EDelMarTimerDirection Direction, const bool bCapAtZero, bool* bIsPositive, const class UObject* WorldContextObject);
	static bool IsDelMarExperience(bool bEnableCaching);
	static void SetDelMarControlsText(const class APlayerController* PlayerController, const struct FDelMarEvent_SetControlsText& Event);
	static void SetDelMarTutorialHint(const class APlayerController* PlayerController, const struct FDelMarEvent_SetTutorialHint& Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarBlueprintLibrary">();
	}
	static class UDelMarBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarBlueprintLibrary>();
	}
};
static_assert(alignof(UDelMarBlueprintLibrary) == 0x000008, "Wrong alignment on UDelMarBlueprintLibrary");
static_assert(sizeof(UDelMarBlueprintLibrary) == 0x000028, "Wrong size on UDelMarBlueprintLibrary");

// Class DelMarCore.DelMarCheatManager
// 0x0010 (0x0038 - 0x0028)
class UDelMarCheatManager final : public UChildCheatManager
{
public:
	TArray<class FString>                         SafePlayerNames;                                   // 0x0028(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)

public:
	void DelMarCancelMissedCheckpointDemoCountdown();
	void DelMarCancelReturnToTrackDemoCountdown();
	void DelMarClearActiveAutoInput();
	void DelMarClearQueuedAutoInput();
	void DelMarDemolishSelf();
	void DelMarDemolishSelfWithTag(const class FString& DemolishTagString);
	void DelMarEndSpectate();
	void DelMarExitVehicle();
	void DelMarFetchFocusedLeaderboard();
	void DelMarFetchFriendsLeaderboard();
	void DelMarFetchGlobalLeaderboard();
	void DelMarFinishRace();
	void DelMarFinishRaceSelf();
	void DelMarForceEveryoneToReadyUp();
	void DelMarForceLoadLevel(const class FString& LevelName);
	void DelMarForceLoadUEFNIsland(const class FString& IslandCode);
	void DelMarGhostClearPlaybackFile();
	void DelMarGhostForcePlayAllTriggers();
	void DelMarGhostSetRecordOffPhysics(bool bEnabled);
	void DelMarGhostSetReplayEnabled(bool bEnabled);
	void DelMarGhostStartPlayerPlayback();
	void DelMarGhostStartPlayerRecording(const class FString& SaveFileName, bool bSaveToFile);
	void DelMarGhostStopPlayerRecording();
	void DelMarGiveSelfSomeCompetitiveMMRStats(const int32 MyPosition, const int32 TotalNumberOfPlayers, const int32 NumberOfTimesToSendMMRUpdate);
	void DelMarGrantQuestsInDir(const class FString& Dir);
	void DelMarGrantTurboCharges(const float Amount, const bool bGrantToEveryone);
	void DelMarInitiateMissedCheckpointDemoCountdown(float SecondsUntilDemo);
	void DelMarInitiateReturnToTrackDemoCountdown(float SecondsUntilDemo);
	void DelMarNextTutorialSection();
	void DelMarPauseAllBots();
	void DelMarPrevTutorialSection();
	void DelMarPrintLogsToDiagnoseSpinout();
	void DelMarPrintQuestProgress();
	void DelMarQueueAutoInputDriveThenTurn(int32 Repeat, float Throttle, float StraightDuration, float Steer, float TurnDuration);
	void DelMarQueueAutoInputJump(int32 Repeat, float Delay);
	void DelMarQueueAutoInputThrottle(float Throttle, float duration);
	void DelMarRemoveAllBots();
	void DelMarRemoveBotByName(class FString* BotName);
	void DelMarRemoveNumberOfBots(int32 NumberOfBotsToRemove);
	void DelMarRenamePlayers();
	void DelMarResetPreRaceViewTarget();
	void DelMarResetRace();
	void DelMarResetTutorialSplines();
	void DelMarRespawnAtLastCheckpoint();
	void DelMarRespawnAtLastCheckpoint_ParallelPath();
	void DelMarResumeAllBots();
	void DelMarReturnToLobby();
	void DelMarSetAirFreestyleEnabled(bool bEnabled);
	void DelMarSetCollisionDemosEnabled(bool bEnabled);
	void DelMarSetDemoModeEnabled(const bool bEnabled);
	void DelMarSetDraftingEnabled(bool bEnabled);
	void DelMarSetGlobalInputEnabled(const class FString& InputTag, const bool bEnableInput);
	void DelMarSetInfiniteUnderthrustEnabled(bool bEnabled);
	void DelMarSetInputMappingContextEnabled(const class FString& InputTag, const bool bEnableInput);
	void DelMarSetInvertSteerMethod(EDelMarInvertSteerMethod InInvertSteerMethod);
	void DelMarSetLap(int32 LapNum);
	void DelMarSetLapTotal(int32 NewTotal);
	void DelMarSetLoadingScreenVisibility(bool bShouldBeVisible);
	void DelMarSetReplicatedTagEnabledOnSelf(const class FString& InputTag, const bool bEnabled);
	void DelMarSetRespawnCollisionProtectionEnabled(bool bEnabled);
	void DelMarSetRespawnCollisionProtectionSeconds(float Seconds);
	void DelMarSetRespawnInvulnerabilityEnabled(bool bEnabled);
	void DelMarSetRespawnInvulnerabilitySeconds(float Seconds);
	void DelMarSetRespawnTracesEnabled(bool bEnabled);
	void DelMarSetRubberbandingEnabled(bool bEnabled);
	void DelMarSetRubberbandingMaxBonusSpeedScalar(float InMaxBonusSpeedScalar);
	void DelMarSetRubberbandingMaxDistanceFromPack(float InMaxDistanceFromPack);
	void DelMarSetRubberbandingMaxPackDistance(float InMaxPackDistance);
	void DelMarSetRubberbandingMaxPackDistanceGainedPerSecond(float InMaxPackDistanceGainedPerSecond);
	void DelMarSetRubberbandingMaxPackDistanceLostPerSecond(float InMaxPackDistanceLostPerSecond);
	void DelMarSetRubberbandingMinDistanceFromPack(float InMinDistanceFromPack);
	void DelMarSetRubberbandingMinPackDistance(float InMinPackDistance);
	void DelMarSetRubberbandingMMR(int32 InMMR);
	void DelMarSetRubberbandingNumPlayersForPackDistance(int32 InNumPlayersForPackDistance);
	void DelMarSetSpawnMode(EDelMarRaceSpawnMode SpawnMode);
	void DelMarSetStartlineBoostEnabled(bool bEnabled);
	void DelMarSetStrafeEnabled(bool bEnabled);
	void DelMarSetTurboCharges(const float Amount, const bool bGrantToEveryone);
	void DelMarSetTutorialSection(int32 Index_0);
	void DelMarSetVehicleCollisionsOverrideForSelf(EDelMarVehicleCollisionOverrideSetting NewValue);
	void DelMarSetVehicleCollisionsOverrideGlobal(EDelMarVehicleCollisionOverrideSetting NewValue);
	void DelMarSetVerticalKickflipInverted(bool InbVerticalKickflipInverted);
	void DelMarSkipWaitingForPlayers();
	void DelMarSpawnBots(int32 NumberOfBotsToSpawn);
	void DelMarSpawnBotsAtSkillLevel(int32 NumberOfBotsToSpawn, int32 SkillLevel);
	void DelMarSpawnVehicleForSelf();
	void DelMarSpectate();
	void DelMarStartFollowTrack(float Throttle);
	void DelMarStartQueuedAutoInput();
	void DelMarStartRace();
	void DelMarUsePredictiveInterpolation(bool bEnabled, bool bEveryOther);

	void DelMarCreateTrackScrubberForProfiling() const;
	void DelMarDestroyTrackScrubbers() const;
	void DelMarStartTrackScrubberWithViewTarget(bool bRunCsvProfilerDuringScrub) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCheatManager">();
	}
	static class UDelMarCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCheatManager>();
	}
};
static_assert(alignof(UDelMarCheatManager) == 0x000008, "Wrong alignment on UDelMarCheatManager");
static_assert(sizeof(UDelMarCheatManager) == 0x000038, "Wrong size on UDelMarCheatManager");
static_assert(offsetof(UDelMarCheatManager, SafePlayerNames) == 0x000028, "Member 'UDelMarCheatManager::SafePlayerNames' has a wrong offset!");

// Class DelMarCore.DelMarGlobals
// 0x0000 (0x0028 - 0x0028)
class UDelMarGlobals final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGlobals">();
	}
	static class UDelMarGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGlobals>();
	}
};
static_assert(alignof(UDelMarGlobals) == 0x000008, "Wrong alignment on UDelMarGlobals");
static_assert(sizeof(UDelMarGlobals) == 0x000028, "Wrong size on UDelMarGlobals");

// Class DelMarCore.DelMarVehicleCameraMode
// 0x0620 (0x21E0 - 0x1BC0)
class UDelMarVehicleCameraMode final : public UFortCameraMode_AthenaVehicle
{
public:
	struct FDelMarVehicleCameraSettings           CameraSettings;                                    // 0x1BB8(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BD4[0x4];                                     // 0x1BD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     VelocityViewDistance;                              // 0x1BD8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VelocityFOV;                                       // 0x1C60(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AerialViewDistance;                                // 0x1CE8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AerialFocusOffset;                                 // 0x1D70(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AerialPitch;                                       // 0x1DF8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AccelViewDistance;                                 // 0x1E80(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AccelPitch;                                        // 0x1F08(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AirRotationInterpRate;                             // 0x1F90(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         DriftSwivelSpeed;                                  // 0x2018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewDistanceInterpSpeed;                           // 0x201C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInterpSpeed;                                    // 0x2020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationViewDistanceDecayRate;                 // 0x2024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccumulatedAccelViewDistance;                   // 0x2028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAccumulatedAccelViewDistance;                   // 0x202C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialOffsetInterpSpeed;                           // 0x2030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDownwardAerialPitch;                        // 0x2034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumUpwardAerialPitch;                          // 0x2038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationPitchDecayRate;                        // 0x203C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccumulatedAccelPitch;                          // 0x2040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAccumulatedAccelPitch;                          // 0x2044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventSpeedIncreaseInAir;                        // 0x2048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2049[0x3];                                     // 0x2049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedInputScalar;                                  // 0x204C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelPitchMax;                                    // 0x2050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelYawMax;                                      // 0x2054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundPitchInterpRate;                             // 0x2058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundMaxPitchForNormalBlend;                      // 0x205C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundNormalInterpRate;                            // 0x2060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundNormalAirInterpRate;                         // 0x2064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundYawRateMin;                                  // 0x2068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundYawRateMax;                                  // 0x206C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallYawRateMin;                                    // 0x2070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallYawRateMax;                                    // 0x2074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpToGroundTime;                                // 0x2078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpToAirTime;                                   // 0x207C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageVelocityInterpRate;                         // 0x2080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusOffsetInterpRate;                             // 0x2084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceSpeedScale;                                // 0x2088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceOffsetMin;                                 // 0x208C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceOffsetMax;                                 // 0x2090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceInterpRate;                                // 0x2094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedFOVOffset;                                 // 0x2098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupersonicFOVOffset;                               // 0x209C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInterpRate;                                     // 0x20A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20A4[0x4];                                     // 0x20A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarVehicle*                         VehicleTarget;                                     // 0x20A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20B0[0x130];                                   // 0x20B0(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleCameraMode">();
	}
	static class UDelMarVehicleCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleCameraMode>();
	}
};
static_assert(alignof(UDelMarVehicleCameraMode) == 0x000010, "Wrong alignment on UDelMarVehicleCameraMode");
static_assert(sizeof(UDelMarVehicleCameraMode) == 0x0021E0, "Wrong size on UDelMarVehicleCameraMode");
static_assert(offsetof(UDelMarVehicleCameraMode, CameraSettings) == 0x001BB8, "Member 'UDelMarVehicleCameraMode::CameraSettings' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, VelocityViewDistance) == 0x001BD8, "Member 'UDelMarVehicleCameraMode::VelocityViewDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, VelocityFOV) == 0x001C60, "Member 'UDelMarVehicleCameraMode::VelocityFOV' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AerialViewDistance) == 0x001CE8, "Member 'UDelMarVehicleCameraMode::AerialViewDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AerialFocusOffset) == 0x001D70, "Member 'UDelMarVehicleCameraMode::AerialFocusOffset' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AerialPitch) == 0x001DF8, "Member 'UDelMarVehicleCameraMode::AerialPitch' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AccelViewDistance) == 0x001E80, "Member 'UDelMarVehicleCameraMode::AccelViewDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AccelPitch) == 0x001F08, "Member 'UDelMarVehicleCameraMode::AccelPitch' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AirRotationInterpRate) == 0x001F90, "Member 'UDelMarVehicleCameraMode::AirRotationInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, DriftSwivelSpeed) == 0x002018, "Member 'UDelMarVehicleCameraMode::DriftSwivelSpeed' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, ViewDistanceInterpSpeed) == 0x00201C, "Member 'UDelMarVehicleCameraMode::ViewDistanceInterpSpeed' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, FOVInterpSpeed) == 0x002020, "Member 'UDelMarVehicleCameraMode::FOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AccelerationViewDistanceDecayRate) == 0x002024, "Member 'UDelMarVehicleCameraMode::AccelerationViewDistanceDecayRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, MaxAccumulatedAccelViewDistance) == 0x002028, "Member 'UDelMarVehicleCameraMode::MaxAccumulatedAccelViewDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, MinAccumulatedAccelViewDistance) == 0x00202C, "Member 'UDelMarVehicleCameraMode::MinAccumulatedAccelViewDistance' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AerialOffsetInterpSpeed) == 0x002030, "Member 'UDelMarVehicleCameraMode::AerialOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, MaximumDownwardAerialPitch) == 0x002034, "Member 'UDelMarVehicleCameraMode::MaximumDownwardAerialPitch' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, MaximumUpwardAerialPitch) == 0x002038, "Member 'UDelMarVehicleCameraMode::MaximumUpwardAerialPitch' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AccelerationPitchDecayRate) == 0x00203C, "Member 'UDelMarVehicleCameraMode::AccelerationPitchDecayRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, MaxAccumulatedAccelPitch) == 0x002040, "Member 'UDelMarVehicleCameraMode::MaxAccumulatedAccelPitch' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, MinAccumulatedAccelPitch) == 0x002044, "Member 'UDelMarVehicleCameraMode::MinAccumulatedAccelPitch' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, bPreventSpeedIncreaseInAir) == 0x002048, "Member 'UDelMarVehicleCameraMode::bPreventSpeedIncreaseInAir' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, SpeedInputScalar) == 0x00204C, "Member 'UDelMarVehicleCameraMode::SpeedInputScalar' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, SwivelPitchMax) == 0x002050, "Member 'UDelMarVehicleCameraMode::SwivelPitchMax' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, SwivelYawMax) == 0x002054, "Member 'UDelMarVehicleCameraMode::SwivelYawMax' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, GroundPitchInterpRate) == 0x002058, "Member 'UDelMarVehicleCameraMode::GroundPitchInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, GroundMaxPitchForNormalBlend) == 0x00205C, "Member 'UDelMarVehicleCameraMode::GroundMaxPitchForNormalBlend' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, GroundNormalInterpRate) == 0x002060, "Member 'UDelMarVehicleCameraMode::GroundNormalInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, GroundNormalAirInterpRate) == 0x002064, "Member 'UDelMarVehicleCameraMode::GroundNormalAirInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, GroundYawRateMin) == 0x002068, "Member 'UDelMarVehicleCameraMode::GroundYawRateMin' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, GroundYawRateMax) == 0x00206C, "Member 'UDelMarVehicleCameraMode::GroundYawRateMax' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, WallYawRateMin) == 0x002070, "Member 'UDelMarVehicleCameraMode::WallYawRateMin' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, WallYawRateMax) == 0x002074, "Member 'UDelMarVehicleCameraMode::WallYawRateMax' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, InterpToGroundTime) == 0x002078, "Member 'UDelMarVehicleCameraMode::InterpToGroundTime' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, InterpToAirTime) == 0x00207C, "Member 'UDelMarVehicleCameraMode::InterpToAirTime' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, AverageVelocityInterpRate) == 0x002080, "Member 'UDelMarVehicleCameraMode::AverageVelocityInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, FocusOffsetInterpRate) == 0x002084, "Member 'UDelMarVehicleCameraMode::FocusOffsetInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, DistanceSpeedScale) == 0x002088, "Member 'UDelMarVehicleCameraMode::DistanceSpeedScale' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, DistanceOffsetMin) == 0x00208C, "Member 'UDelMarVehicleCameraMode::DistanceOffsetMin' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, DistanceOffsetMax) == 0x002090, "Member 'UDelMarVehicleCameraMode::DistanceOffsetMax' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, DistanceInterpRate) == 0x002094, "Member 'UDelMarVehicleCameraMode::DistanceInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, MaxSpeedFOVOffset) == 0x002098, "Member 'UDelMarVehicleCameraMode::MaxSpeedFOVOffset' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, SupersonicFOVOffset) == 0x00209C, "Member 'UDelMarVehicleCameraMode::SupersonicFOVOffset' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, FOVInterpRate) == 0x0020A0, "Member 'UDelMarVehicleCameraMode::FOVInterpRate' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCameraMode, VehicleTarget) == 0x0020A8, "Member 'UDelMarVehicleCameraMode::VehicleTarget' has a wrong offset!");

// Class DelMarCore.DelMarEliminationRaceManagerComponent
// 0x0018 (0x00B8 - 0x00A0)
class UDelMarEliminationRaceManagerComponent final : public UDelMarRaceManagerComponent
{
public:
	TArray<struct FDelMarEliminationMMRCountPair> EliminationsConfig;                                // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         ParsedNumberOfPlayersToEliminate;                  // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarEliminationRaceManagerComponent">();
	}
	static class UDelMarEliminationRaceManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarEliminationRaceManagerComponent>();
	}
};
static_assert(alignof(UDelMarEliminationRaceManagerComponent) == 0x000008, "Wrong alignment on UDelMarEliminationRaceManagerComponent");
static_assert(sizeof(UDelMarEliminationRaceManagerComponent) == 0x0000B8, "Wrong size on UDelMarEliminationRaceManagerComponent");
static_assert(offsetof(UDelMarEliminationRaceManagerComponent, EliminationsConfig) == 0x0000A0, "Member 'UDelMarEliminationRaceManagerComponent::EliminationsConfig' has a wrong offset!");
static_assert(offsetof(UDelMarEliminationRaceManagerComponent, ParsedNumberOfPlayersToEliminate) == 0x0000B0, "Member 'UDelMarEliminationRaceManagerComponent::ParsedNumberOfPlayersToEliminate' has a wrong offset!");

// Class DelMarCore.DelMarStateSequencerFXComponent
// 0x0128 (0x01C8 - 0x00A0)
class UDelMarStateSequencerFXComponent final : public UActorComponent
{
public:
	float                                         FXSizeScalar;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UNiagaraSystem*> ParticleClassMap;                                  // 0x00A8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFXSystemSpawnParameters               SpawnParams;                                       // 0x0100(0x0070)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class ADelMarTimeDelayedStateSequencer*       ParentRef;                                         // 0x0170(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class UNiagaraComponent*> ParticleComponentMap;                              // 0x0178(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void HandleCurrentStateChanged(const struct FGameplayTag& NewState);
	void HandleEnabledChanged(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarStateSequencerFXComponent">();
	}
	static class UDelMarStateSequencerFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarStateSequencerFXComponent>();
	}
};
static_assert(alignof(UDelMarStateSequencerFXComponent) == 0x000008, "Wrong alignment on UDelMarStateSequencerFXComponent");
static_assert(sizeof(UDelMarStateSequencerFXComponent) == 0x0001C8, "Wrong size on UDelMarStateSequencerFXComponent");
static_assert(offsetof(UDelMarStateSequencerFXComponent, FXSizeScalar) == 0x0000A0, "Member 'UDelMarStateSequencerFXComponent::FXSizeScalar' has a wrong offset!");
static_assert(offsetof(UDelMarStateSequencerFXComponent, ParticleClassMap) == 0x0000A8, "Member 'UDelMarStateSequencerFXComponent::ParticleClassMap' has a wrong offset!");
static_assert(offsetof(UDelMarStateSequencerFXComponent, SpawnParams) == 0x000100, "Member 'UDelMarStateSequencerFXComponent::SpawnParams' has a wrong offset!");
static_assert(offsetof(UDelMarStateSequencerFXComponent, ParentRef) == 0x000170, "Member 'UDelMarStateSequencerFXComponent::ParentRef' has a wrong offset!");
static_assert(offsetof(UDelMarStateSequencerFXComponent, ParticleComponentMap) == 0x000178, "Member 'UDelMarStateSequencerFXComponent::ParticleComponentMap' has a wrong offset!");

// Class DelMarCore.DelMarTimeDelayedStateSequencer
// 0x0050 (0x02E0 - 0x0290)
class ADelMarTimeDelayedStateSequencer final : public AActor
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& NewState)> OnCurrentStateChanged;                             // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bEnabled)> OnEnabledChanged;                                  // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableOnSpawn;                                    // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopSpecificAmount;                               // 0x02B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B2[0x2];                                      // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalLoopCount;                                    // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDelMarTimeDelayedState>        StateArray;                                        // 0x02B8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0xC];                                      // 0x02C8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEnabled;                                        // 0x02D4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentStateIndex;                                 // 0x02D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bIsEnabled();
	void OnRep_CurrentStateIndex();
	void SetEnabled(const bool bEnabled);

	struct FGameplayTag GetCurrentStateTag() const;
	int32 GetStateCount() const;
	struct FGameplayTag GetStateTagAtIndex(const int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarTimeDelayedStateSequencer">();
	}
	static class ADelMarTimeDelayedStateSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarTimeDelayedStateSequencer>();
	}
};
static_assert(alignof(ADelMarTimeDelayedStateSequencer) == 0x000008, "Wrong alignment on ADelMarTimeDelayedStateSequencer");
static_assert(sizeof(ADelMarTimeDelayedStateSequencer) == 0x0002E0, "Wrong size on ADelMarTimeDelayedStateSequencer");
static_assert(offsetof(ADelMarTimeDelayedStateSequencer, OnCurrentStateChanged) == 0x000290, "Member 'ADelMarTimeDelayedStateSequencer::OnCurrentStateChanged' has a wrong offset!");
static_assert(offsetof(ADelMarTimeDelayedStateSequencer, OnEnabledChanged) == 0x0002A0, "Member 'ADelMarTimeDelayedStateSequencer::OnEnabledChanged' has a wrong offset!");
static_assert(offsetof(ADelMarTimeDelayedStateSequencer, bEnableOnSpawn) == 0x0002B0, "Member 'ADelMarTimeDelayedStateSequencer::bEnableOnSpawn' has a wrong offset!");
static_assert(offsetof(ADelMarTimeDelayedStateSequencer, bLoopSpecificAmount) == 0x0002B1, "Member 'ADelMarTimeDelayedStateSequencer::bLoopSpecificAmount' has a wrong offset!");
static_assert(offsetof(ADelMarTimeDelayedStateSequencer, TotalLoopCount) == 0x0002B4, "Member 'ADelMarTimeDelayedStateSequencer::TotalLoopCount' has a wrong offset!");
static_assert(offsetof(ADelMarTimeDelayedStateSequencer, StateArray) == 0x0002B8, "Member 'ADelMarTimeDelayedStateSequencer::StateArray' has a wrong offset!");
static_assert(offsetof(ADelMarTimeDelayedStateSequencer, bIsEnabled) == 0x0002D4, "Member 'ADelMarTimeDelayedStateSequencer::bIsEnabled' has a wrong offset!");
static_assert(offsetof(ADelMarTimeDelayedStateSequencer, CurrentStateIndex) == 0x0002D8, "Member 'ADelMarTimeDelayedStateSequencer::CurrentStateIndex' has a wrong offset!");

// Class DelMarCore.DelMarGhostVehicle
// 0x0000 (0x1E90 - 0x1E90)
class ADelMarGhostVehicle final : public AFortAthenaVehicle
{
public:
	class UMaterial*                              GhostMaterial;                                     // 0x1E88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleVehicleCosmeticsFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGhostVehicle">();
	}
	static class ADelMarGhostVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarGhostVehicle>();
	}
};
static_assert(alignof(ADelMarGhostVehicle) == 0x000010, "Wrong alignment on ADelMarGhostVehicle");
static_assert(sizeof(ADelMarGhostVehicle) == 0x001E90, "Wrong size on ADelMarGhostVehicle");
static_assert(offsetof(ADelMarGhostVehicle, GhostMaterial) == 0x001E88, "Member 'ADelMarGhostVehicle::GhostMaterial' has a wrong offset!");

// Class DelMarCore.DelMarGlobalInputDisabler
// 0x0038 (0x00D8 - 0x00A0)
class UDelMarGlobalInputDisabler final : public UDelMarRaceManagerComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DisabledInputTags;                                 // 0x00B8(0x0020)(Edit, Net, Protected, NativeAccessSpecifierProtected)

public:
	void SetGlobalInputsEnabled(const struct FGameplayTagContainer& InputTags, const bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGlobalInputDisabler">();
	}
	static class UDelMarGlobalInputDisabler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGlobalInputDisabler>();
	}
};
static_assert(alignof(UDelMarGlobalInputDisabler) == 0x000008, "Wrong alignment on UDelMarGlobalInputDisabler");
static_assert(sizeof(UDelMarGlobalInputDisabler) == 0x0000D8, "Wrong size on UDelMarGlobalInputDisabler");
static_assert(offsetof(UDelMarGlobalInputDisabler, DisabledInputTags) == 0x0000B8, "Member 'UDelMarGlobalInputDisabler::DisabledInputTags' has a wrong offset!");

// Class DelMarCore.DelMarCosmeticActorSpawnLogic
// 0x0000 (0x0028 - 0x0028)
class UDelMarCosmeticActorSpawnLogic : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCosmeticActorSpawnLogic">();
	}
	static class UDelMarCosmeticActorSpawnLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCosmeticActorSpawnLogic>();
	}
};
static_assert(alignof(UDelMarCosmeticActorSpawnLogic) == 0x000008, "Wrong alignment on UDelMarCosmeticActorSpawnLogic");
static_assert(sizeof(UDelMarCosmeticActorSpawnLogic) == 0x000028, "Wrong size on UDelMarCosmeticActorSpawnLogic");

// Class DelMarCore.DelMarCosmeticActorSpawnLogic_AttachTo
// 0x0008 (0x0030 - 0x0028)
class UDelMarCosmeticActorSpawnLogic_AttachTo final : public UDelMarCosmeticActorSpawnLogic
{
public:
	class FName                                   AttachSocket;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCosmeticActorSpawnLogic_AttachTo">();
	}
	static class UDelMarCosmeticActorSpawnLogic_AttachTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCosmeticActorSpawnLogic_AttachTo>();
	}
};
static_assert(alignof(UDelMarCosmeticActorSpawnLogic_AttachTo) == 0x000008, "Wrong alignment on UDelMarCosmeticActorSpawnLogic_AttachTo");
static_assert(sizeof(UDelMarCosmeticActorSpawnLogic_AttachTo) == 0x000030, "Wrong size on UDelMarCosmeticActorSpawnLogic_AttachTo");
static_assert(offsetof(UDelMarCosmeticActorSpawnLogic_AttachTo, AttachSocket) == 0x000028, "Member 'UDelMarCosmeticActorSpawnLogic_AttachTo::AttachSocket' has a wrong offset!");

// Class DelMarCore.DelMarCosmeticActorSpawnLogic_AttachToEach
// 0x0010 (0x0038 - 0x0028)
class UDelMarCosmeticActorSpawnLogic_AttachToEach final : public UDelMarCosmeticActorSpawnLogic
{
public:
	TArray<class FName>                           AttachSockets;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCosmeticActorSpawnLogic_AttachToEach">();
	}
	static class UDelMarCosmeticActorSpawnLogic_AttachToEach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCosmeticActorSpawnLogic_AttachToEach>();
	}
};
static_assert(alignof(UDelMarCosmeticActorSpawnLogic_AttachToEach) == 0x000008, "Wrong alignment on UDelMarCosmeticActorSpawnLogic_AttachToEach");
static_assert(sizeof(UDelMarCosmeticActorSpawnLogic_AttachToEach) == 0x000038, "Wrong size on UDelMarCosmeticActorSpawnLogic_AttachToEach");
static_assert(offsetof(UDelMarCosmeticActorSpawnLogic_AttachToEach, AttachSockets) == 0x000028, "Member 'UDelMarCosmeticActorSpawnLogic_AttachToEach::AttachSockets' has a wrong offset!");

// Class DelMarCore.DelMarCosmeticActor
// 0x0038 (0x02C8 - 0x0290)
class ADelMarCosmeticActor : public AActor
{
public:
	class UDelMarCosmeticActorSpawnLogic*         SpawnLogic;                                        // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ADelMarCosmeticActor>> CosmeticDependencies;                              // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TScriptInterface<class IDelMarVehicleInterface> Vehicle;                                           // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarVehicleConfigs*                  VehicleConfig;                                     // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarVehicleCosmeticComponent*        VehicleCosmeticComponent;                          // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyCosmetic();
	void BP_OnAnyWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue);
	void BP_OnBonusSpeedActivated();
	void BP_OnBonusSpeedChanged(float BonusSpeed);
	void BP_OnBonusSpeedDeactivated();
	void BP_OnCosmeticApplied();
	void BP_OnDelMarAppliedTeleportRotation();
	void BP_OnDelMarTeleportEntered();
	void BP_OnDelMarTeleportExited();
	void BP_OnDelMarVehicleSpawned(bool bFirstVehicleForPlayer, bool bPrevVehicleDemolished);
	void BP_OnDraftStateChanged(EDelmarDraftingState CurrentState);
	void BP_OnDriftActivated();
	void BP_OnDriftBoostActivated();
	void BP_OnDriftBoostDeactivated();
	void BP_OnDriftControlChanged(bool bIsDriftingControlled);
	void BP_OnDriftDeactivated();
	void BP_OnDriftDurationChanged(float duration);
	void BP_OnDriftKickActivated(float DriftDirection, EDelMarVehicleDriftState DriftState);
	void BP_OnDriftKickDeactivated();
	void BP_OnInvulnerabilityActivated();
	void BP_OnInvulnerabilityDeactivated();
	void BP_OnJumpActivated();
	void BP_OnJumpDeactivated();
	void BP_OnKickflipActivated(bool bLeftSide);
	void BP_OnKickflipActivationChargesChanged(int32 ActivationCharges);
	void BP_OnKickflipDeactivated();
	void BP_OnKickflipDistanceToSuctionSurfaceChanged(float Distance);
	void BP_OnKickflipDurationChanged(float duration);
	void BP_OnKickflipSuctionActivated();
	void BP_OnKickflipSuctionDeactivated();
	void BP_OnReachedMaxDraftBonusSpeed();
	void BP_OnReattachmentActivated();
	void BP_OnReattachmentDeactivated();
	void BP_OnStartlineBoostActivated(float PercentageMaxBonusSpeedEarned);
	void BP_OnStartlineBoostDeactivated();
	void BP_OnStartlineBoostFailed();
	void BP_OnStrafeActivated(bool bLeftSide);
	void BP_OnStrafeCooldownChanged(float CooldownPercentage);
	void BP_OnStrafeDeactivated();
	void BP_OnStrafeDisabledChanged(bool bDisabled);
	void BP_OnStrafeUsabilityChanged(bool bCanActivate);
	void BP_OnTurboActivated();
	void BP_OnTurboBonusStateChanged(EDelMarTurboZoneState NewState);
	void BP_OnTurboDeactivated();
	void BP_OnUnderthrustActivated();
	void BP_OnUnderthrustDeactivated();
	void BP_OnVehicleDemolished(const struct FGameplayTag& CausedByTag);
	void BP_OnVehicleForwardStateChanged(EDelMarVehicleForwardState NewForwardState);
	void BP_OnVehicleLanded(float LandingForced, bool bLandedKickflip);
	void BP_OnVehicleStartedSkydiving();
	void BP_OnVehicleStoppedSkydiving();
	void BP_OnVehicleWheelsLeftGround();
	void BP_OnWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue);
	void BP_OnWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks);
	void BP_OnWorldBonusSpeedStackLost(const struct FGameplayTag& Source, int32 Stacks);

	class USkeletalMeshComponent* GetBodyMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCosmeticActor">();
	}
	static class ADelMarCosmeticActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarCosmeticActor>();
	}
};
static_assert(alignof(ADelMarCosmeticActor) == 0x000008, "Wrong alignment on ADelMarCosmeticActor");
static_assert(sizeof(ADelMarCosmeticActor) == 0x0002C8, "Wrong size on ADelMarCosmeticActor");
static_assert(offsetof(ADelMarCosmeticActor, SpawnLogic) == 0x000290, "Member 'ADelMarCosmeticActor::SpawnLogic' has a wrong offset!");
static_assert(offsetof(ADelMarCosmeticActor, CosmeticDependencies) == 0x000298, "Member 'ADelMarCosmeticActor::CosmeticDependencies' has a wrong offset!");
static_assert(offsetof(ADelMarCosmeticActor, Vehicle) == 0x0002A8, "Member 'ADelMarCosmeticActor::Vehicle' has a wrong offset!");
static_assert(offsetof(ADelMarCosmeticActor, VehicleConfig) == 0x0002B8, "Member 'ADelMarCosmeticActor::VehicleConfig' has a wrong offset!");
static_assert(offsetof(ADelMarCosmeticActor, VehicleCosmeticComponent) == 0x0002C0, "Member 'ADelMarCosmeticActor::VehicleCosmeticComponent' has a wrong offset!");

// Class DelMarCore.DelMarCosmeticItemDefinition
// 0x0018 (0x03C0 - 0x03A8)
class UDelMarCosmeticItemDefinition : public UFortAccountItemDefinition
{
public:
	struct FGameplayTag                           Slot;                                              // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           CosmeticActorClasses;                              // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCosmeticItemDefinition">();
	}
	static class UDelMarCosmeticItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCosmeticItemDefinition>();
	}
};
static_assert(alignof(UDelMarCosmeticItemDefinition) == 0x000008, "Wrong alignment on UDelMarCosmeticItemDefinition");
static_assert(sizeof(UDelMarCosmeticItemDefinition) == 0x0003C0, "Wrong size on UDelMarCosmeticItemDefinition");
static_assert(offsetof(UDelMarCosmeticItemDefinition, Slot) == 0x0003A8, "Member 'UDelMarCosmeticItemDefinition::Slot' has a wrong offset!");
static_assert(offsetof(UDelMarCosmeticItemDefinition, CosmeticActorClasses) == 0x0003B0, "Member 'UDelMarCosmeticItemDefinition::CosmeticActorClasses' has a wrong offset!");

// Class DelMarCore.DelMarVehicleBodyItemDefinition
// 0x0000 (0x03C0 - 0x03C0)
class UDelMarVehicleBodyItemDefinition final : public UDelMarCosmeticItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleBodyItemDefinition">();
	}
	static class UDelMarVehicleBodyItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleBodyItemDefinition>();
	}
};
static_assert(alignof(UDelMarVehicleBodyItemDefinition) == 0x000008, "Wrong alignment on UDelMarVehicleBodyItemDefinition");
static_assert(sizeof(UDelMarVehicleBodyItemDefinition) == 0x0003C0, "Wrong size on UDelMarVehicleBodyItemDefinition");

// Class DelMarCore.DelMarLeaderboardManager
// 0x0168 (0x0208 - 0x00A0)
class UDelMarLeaderboardManager final : public UDelMarRaceManagerComponent
{
public:
	class UDelMarEvent_GlobalLeaderboardPersonalBestRetrieved* PersonalBestRetrievedEvent;                        // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarLeaderboardConfig               LeaderboardConfig;                                 // 0x00C8(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x120];                                     // 0x00E8(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LeaderboardConfig();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarLeaderboardManager">();
	}
	static class UDelMarLeaderboardManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarLeaderboardManager>();
	}
};
static_assert(alignof(UDelMarLeaderboardManager) == 0x000008, "Wrong alignment on UDelMarLeaderboardManager");
static_assert(sizeof(UDelMarLeaderboardManager) == 0x000208, "Wrong size on UDelMarLeaderboardManager");
static_assert(offsetof(UDelMarLeaderboardManager, PersonalBestRetrievedEvent) == 0x0000A0, "Member 'UDelMarLeaderboardManager::PersonalBestRetrievedEvent' has a wrong offset!");
static_assert(offsetof(UDelMarLeaderboardManager, LeaderboardConfig) == 0x0000C8, "Member 'UDelMarLeaderboardManager::LeaderboardConfig' has a wrong offset!");

// Class DelMarCore.DelMarMatchmakingComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarMatchmakingComponent final : public UControllerComponent
{
public:
	void ClientStartMatchmaking(const struct FOnlineLinkId& LinkId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarMatchmakingComponent">();
	}
	static class UDelMarMatchmakingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarMatchmakingComponent>();
	}
};
static_assert(alignof(UDelMarMatchmakingComponent) == 0x000008, "Wrong alignment on UDelMarMatchmakingComponent");
static_assert(sizeof(UDelMarMatchmakingComponent) == 0x0000A0, "Wrong size on UDelMarMatchmakingComponent");

// Class DelMarCore.DelMarMutator_AllowSpectateOtherTeams
// 0x0000 (0x0340 - 0x0340)
class ADelMarMutator_AllowSpectateOtherTeams final : public AFortAthenaMutator_AllowSpectateOtherTeams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarMutator_AllowSpectateOtherTeams">();
	}
	static class ADelMarMutator_AllowSpectateOtherTeams* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarMutator_AllowSpectateOtherTeams>();
	}
};
static_assert(alignof(ADelMarMutator_AllowSpectateOtherTeams) == 0x000008, "Wrong alignment on ADelMarMutator_AllowSpectateOtherTeams");
static_assert(sizeof(ADelMarMutator_AllowSpectateOtherTeams) == 0x000340, "Wrong size on ADelMarMutator_AllowSpectateOtherTeams");

// Class DelMarCore.DelMarAsyncPhysicsTickMutator
// 0x0010 (0x0350 - 0x0340)
class ADelMarAsyncPhysicsTickMutator final : public ADelMarMutator
{
public:
	float                                         AsyncTickRate;                                     // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0xC];                                      // 0x0344(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TryToApplySolverOverrides();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarAsyncPhysicsTickMutator">();
	}
	static class ADelMarAsyncPhysicsTickMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarAsyncPhysicsTickMutator>();
	}
};
static_assert(alignof(ADelMarAsyncPhysicsTickMutator) == 0x000008, "Wrong alignment on ADelMarAsyncPhysicsTickMutator");
static_assert(sizeof(ADelMarAsyncPhysicsTickMutator) == 0x000350, "Wrong size on ADelMarAsyncPhysicsTickMutator");
static_assert(offsetof(ADelMarAsyncPhysicsTickMutator, AsyncTickRate) == 0x000340, "Member 'ADelMarAsyncPhysicsTickMutator::AsyncTickRate' has a wrong offset!");

// Class DelMarCore.DelMarConsoleVariableMutator
// 0x0030 (0x0370 - 0x0340)
class ADelMarConsoleVariableMutator final : public ADelMarMutator
{
public:
	class FString                                 VariableName;                                      // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Value;                                             // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarConsoleVariableMutator">();
	}
	static class ADelMarConsoleVariableMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarConsoleVariableMutator>();
	}
};
static_assert(alignof(ADelMarConsoleVariableMutator) == 0x000008, "Wrong alignment on ADelMarConsoleVariableMutator");
static_assert(sizeof(ADelMarConsoleVariableMutator) == 0x000370, "Wrong size on ADelMarConsoleVariableMutator");
static_assert(offsetof(ADelMarConsoleVariableMutator, VariableName) == 0x000340, "Member 'ADelMarConsoleVariableMutator::VariableName' has a wrong offset!");
static_assert(offsetof(ADelMarConsoleVariableMutator, Value) == 0x000350, "Member 'ADelMarConsoleVariableMutator::Value' has a wrong offset!");

// Class DelMarCore.DelMarPhysMatAttributeMap
// 0x0050 (0x0080 - 0x0030)
class UDelMarPhysMatAttributeMap final : public UDataAsset
{
public:
	TMap<class UPhysicalMaterial*, struct FPhysicalMaterialAttributes_X> MaterialAttributesMap;                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPhysMatAttributeMap">();
	}
	static class UDelMarPhysMatAttributeMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPhysMatAttributeMap>();
	}
};
static_assert(alignof(UDelMarPhysMatAttributeMap) == 0x000008, "Wrong alignment on UDelMarPhysMatAttributeMap");
static_assert(sizeof(UDelMarPhysMatAttributeMap) == 0x000080, "Wrong size on UDelMarPhysMatAttributeMap");
static_assert(offsetof(UDelMarPhysMatAttributeMap, MaterialAttributesMap) == 0x000030, "Member 'UDelMarPhysMatAttributeMap::MaterialAttributesMap' has a wrong offset!");

// Class DelMarCore.DelMarCameraComponent
// 0x0008 (0x00A8 - 0x00A0)
class UDelMarCameraComponent final : public UControllerComponent
{
public:
	TWeakObjectPtr<class UDelMarVehicleManager>   VehicleManager;                                    // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCameraComponent">();
	}
	static class UDelMarCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCameraComponent>();
	}
};
static_assert(alignof(UDelMarCameraComponent) == 0x000008, "Wrong alignment on UDelMarCameraComponent");
static_assert(sizeof(UDelMarCameraComponent) == 0x0000A8, "Wrong size on UDelMarCameraComponent");
static_assert(offsetof(UDelMarCameraComponent, VehicleManager) == 0x0000A0, "Member 'UDelMarCameraComponent::VehicleManager' has a wrong offset!");

// Class DelMarCore.DelMarCameraInputControllerComponent
// 0x0060 (0x0100 - 0x00A0)
class UDelMarCameraInputControllerComponent final : public UControllerComponent
{
public:
	struct FDelMarInputAction                     TurnCameraAction;                                  // 0x00A0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     LookUpCameraAction;                                // 0x00B0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputAction                     ReverseCameraAction;                               // 0x00C0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UDelMarPlayerInputManagerComponent> InputManagerClass;                                 // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UEnhancedInputComponent> InputComponent;                                    // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UFortClientSettingsRecord> FortSettings;                                      // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCameraSwivelDeadzoneChanged();
	void HandleInputSettingsChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCameraInputControllerComponent">();
	}
	static class UDelMarCameraInputControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCameraInputControllerComponent>();
	}
};
static_assert(alignof(UDelMarCameraInputControllerComponent) == 0x000008, "Wrong alignment on UDelMarCameraInputControllerComponent");
static_assert(sizeof(UDelMarCameraInputControllerComponent) == 0x000100, "Wrong size on UDelMarCameraInputControllerComponent");
static_assert(offsetof(UDelMarCameraInputControllerComponent, TurnCameraAction) == 0x0000A0, "Member 'UDelMarCameraInputControllerComponent::TurnCameraAction' has a wrong offset!");
static_assert(offsetof(UDelMarCameraInputControllerComponent, LookUpCameraAction) == 0x0000B0, "Member 'UDelMarCameraInputControllerComponent::LookUpCameraAction' has a wrong offset!");
static_assert(offsetof(UDelMarCameraInputControllerComponent, ReverseCameraAction) == 0x0000C0, "Member 'UDelMarCameraInputControllerComponent::ReverseCameraAction' has a wrong offset!");
static_assert(offsetof(UDelMarCameraInputControllerComponent, InputManagerClass) == 0x0000D0, "Member 'UDelMarCameraInputControllerComponent::InputManagerClass' has a wrong offset!");
static_assert(offsetof(UDelMarCameraInputControllerComponent, InputComponent) == 0x0000D8, "Member 'UDelMarCameraInputControllerComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UDelMarCameraInputControllerComponent, FortSettings) == 0x0000E0, "Member 'UDelMarCameraInputControllerComponent::FortSettings' has a wrong offset!");

// Class DelMarCore.DelMarContextualHintComponent
// 0x0128 (0x01C8 - 0x00A0)
class UDelMarContextualHintComponent final : public UControllerComponent
{
public:
	struct FDelMarEvent_SetTutorialHint           HazardHitHint;                                     // 0x00A0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FDelMarEvent_SetTutorialHint> DemolishedByHints;                                 // 0x0100(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarEvent_SetTutorialHint           SlowerTerrainHint;                                 // 0x0150(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADelMarVehicle>          Vehicle;                                           // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class APlayerController>       CachedPlayerController;                            // 0x01B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0x8];                                      // 0x01C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleVehicleDemolished(const struct FGameplayTag& CausedByTag);
	void HandleVehicleHazardHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarContextualHintComponent">();
	}
	static class UDelMarContextualHintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarContextualHintComponent>();
	}
};
static_assert(alignof(UDelMarContextualHintComponent) == 0x000008, "Wrong alignment on UDelMarContextualHintComponent");
static_assert(sizeof(UDelMarContextualHintComponent) == 0x0001C8, "Wrong size on UDelMarContextualHintComponent");
static_assert(offsetof(UDelMarContextualHintComponent, HazardHitHint) == 0x0000A0, "Member 'UDelMarContextualHintComponent::HazardHitHint' has a wrong offset!");
static_assert(offsetof(UDelMarContextualHintComponent, DemolishedByHints) == 0x000100, "Member 'UDelMarContextualHintComponent::DemolishedByHints' has a wrong offset!");
static_assert(offsetof(UDelMarContextualHintComponent, SlowerTerrainHint) == 0x000150, "Member 'UDelMarContextualHintComponent::SlowerTerrainHint' has a wrong offset!");
static_assert(offsetof(UDelMarContextualHintComponent, Vehicle) == 0x0001B0, "Member 'UDelMarContextualHintComponent::Vehicle' has a wrong offset!");
static_assert(offsetof(UDelMarContextualHintComponent, CachedPlayerController) == 0x0001B8, "Member 'UDelMarContextualHintComponent::CachedPlayerController' has a wrong offset!");

// Class DelMarCore.DelMarLocalCheckpointVisibilityControllerComponent
// 0x0068 (0x0108 - 0x00A0)
class UDelMarLocalCheckpointVisibilityControllerComponent final : public UControllerComponent
{
public:
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarCheckpointManagerComponent> CachedCheckpointManager;                           // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        ViewTargetPlayerState;                             // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class ADelMarCheckpoint*>                CurrentlyActiveCheckpoints;                        // 0x00B8(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void HandleCheckpointPassed(const struct FDelMarEvent_CheckpointPassed_ParallelPath& CheckpointEvent);
	void HandleLapComplete(const struct FDelMarEvent_LapComplete& LapEvent);
	void HandleViewTargetChanged(class AFortPlayerController* PlayerController, class AActor* OldViewTarget, class AActor* NewViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarLocalCheckpointVisibilityControllerComponent">();
	}
	static class UDelMarLocalCheckpointVisibilityControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarLocalCheckpointVisibilityControllerComponent>();
	}
};
static_assert(alignof(UDelMarLocalCheckpointVisibilityControllerComponent) == 0x000008, "Wrong alignment on UDelMarLocalCheckpointVisibilityControllerComponent");
static_assert(sizeof(UDelMarLocalCheckpointVisibilityControllerComponent) == 0x000108, "Wrong size on UDelMarLocalCheckpointVisibilityControllerComponent");
static_assert(offsetof(UDelMarLocalCheckpointVisibilityControllerComponent, CachedRaceManager) == 0x0000A0, "Member 'UDelMarLocalCheckpointVisibilityControllerComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarLocalCheckpointVisibilityControllerComponent, CachedCheckpointManager) == 0x0000A8, "Member 'UDelMarLocalCheckpointVisibilityControllerComponent::CachedCheckpointManager' has a wrong offset!");
static_assert(offsetof(UDelMarLocalCheckpointVisibilityControllerComponent, ViewTargetPlayerState) == 0x0000B0, "Member 'UDelMarLocalCheckpointVisibilityControllerComponent::ViewTargetPlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarLocalCheckpointVisibilityControllerComponent, CurrentlyActiveCheckpoints) == 0x0000B8, "Member 'UDelMarLocalCheckpointVisibilityControllerComponent::CurrentlyActiveCheckpoints' has a wrong offset!");

// Class DelMarCore.DelMarNetworkInputComponent
// 0x0060 (0x0100 - 0x00A0)
class UDelMarNetworkInputComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerSendInputs(const struct FDelMarNetworkInputPacket& InputPacket);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarNetworkInputComponent">();
	}
	static class UDelMarNetworkInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarNetworkInputComponent>();
	}
};
static_assert(alignof(UDelMarNetworkInputComponent) == 0x000008, "Wrong alignment on UDelMarNetworkInputComponent");
static_assert(sizeof(UDelMarNetworkInputComponent) == 0x000100, "Wrong size on UDelMarNetworkInputComponent");

// Class DelMarCore.DelMarPlayerRaceDataComponent
// 0x0188 (0x0228 - 0x00A0)
class UDelMarPlayerRaceDataComponent : public UDelMarPlayerStateComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   VisitedCheckpoints;                                // 0x00B8(0x0050)(Transient, NativeAccessSpecifierPublic)
	TSet<class ADelMarCheckpoint*>                VisitedCheckpoints_ParallelPath;                   // 0x0108(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	double                                        RunStartTime;                                      // 0x0158(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RunFinishTime;                                     // 0x0160(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CheckpointStartTime;                               // 0x0168(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        LapStartTime;                                      // 0x0170(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToFinishLine;                              // 0x0178(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LapDistance;                                       // 0x017C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryTrackDistance;                              // 0x0180(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LapsCompleted;                                     // 0x0184(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStartedFirstLap;                               // 0x0188(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishedRace;                                     // 0x0189(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A[0x6];                                      // 0x018A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerState*>                   ViewingSpectators;                                 // 0x0190(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ADelMarCheckpoint*                      MostRecentlyVisitedCheckpoint;                     // 0x01A0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarCheckpointManagerComponent> CachedCheckpointManager;                           // 0x01A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          CachedDelMarVehicle;                               // 0x01B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPositionalTrackerComponent> CachedPositionalTracker;                           // 0x01C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTrackPositionComponent> CachedLapTracker;                                  // 0x01C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class ADelMarCheckpoint*>                CheckpointsVisitedThisLap;                         // 0x01D0(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         TimeTrialSectionIndex;                             // 0x0220(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CheckPointIndex;                                   // 0x0224(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetNumViewingSpectator();
	TArray<class APlayerState*> GetViewingSpectators();
	void NetMulticast_CheckpointPassed_ParallelPath(const struct FDelMarEvent_CheckpointPassed_ParallelPath& CheckpointEvent);
	void NetMulticast_CheckpointPassedOutOfOrder_ParallelPath(const struct FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath& InCheckpointPassedOutOfOrderEvent);
	void NetMulticast_LapCompleted(const struct FDelMarEvent_LapComplete& InLapEvent);
	void NetMulticast_RaceCompleted(double RunTime, const bool bValidRun);
	void NetMulticast_SectionCompleted_ParallelPath(const struct FDelMarEvent_SectionComplete_ParallelPath& InSectionEvent);
	void NetMulticast_TeleportEntered(const struct FDelMarEvent_TeleportEnteredEvent& InCheckpointTeleportingEvent);
	void OnRep_ViewingSpectators();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerRaceDataComponent">();
	}
	static class UDelMarPlayerRaceDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerRaceDataComponent>();
	}
};
static_assert(alignof(UDelMarPlayerRaceDataComponent) == 0x000008, "Wrong alignment on UDelMarPlayerRaceDataComponent");
static_assert(sizeof(UDelMarPlayerRaceDataComponent) == 0x000228, "Wrong size on UDelMarPlayerRaceDataComponent");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, VisitedCheckpoints) == 0x0000B8, "Member 'UDelMarPlayerRaceDataComponent::VisitedCheckpoints' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, VisitedCheckpoints_ParallelPath) == 0x000108, "Member 'UDelMarPlayerRaceDataComponent::VisitedCheckpoints_ParallelPath' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, RunStartTime) == 0x000158, "Member 'UDelMarPlayerRaceDataComponent::RunStartTime' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, RunFinishTime) == 0x000160, "Member 'UDelMarPlayerRaceDataComponent::RunFinishTime' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, CheckpointStartTime) == 0x000168, "Member 'UDelMarPlayerRaceDataComponent::CheckpointStartTime' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, LapStartTime) == 0x000170, "Member 'UDelMarPlayerRaceDataComponent::LapStartTime' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, DistanceToFinishLine) == 0x000178, "Member 'UDelMarPlayerRaceDataComponent::DistanceToFinishLine' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, LapDistance) == 0x00017C, "Member 'UDelMarPlayerRaceDataComponent::LapDistance' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, PrimaryTrackDistance) == 0x000180, "Member 'UDelMarPlayerRaceDataComponent::PrimaryTrackDistance' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, LapsCompleted) == 0x000184, "Member 'UDelMarPlayerRaceDataComponent::LapsCompleted' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, bHasStartedFirstLap) == 0x000188, "Member 'UDelMarPlayerRaceDataComponent::bHasStartedFirstLap' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, bFinishedRace) == 0x000189, "Member 'UDelMarPlayerRaceDataComponent::bFinishedRace' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, ViewingSpectators) == 0x000190, "Member 'UDelMarPlayerRaceDataComponent::ViewingSpectators' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, MostRecentlyVisitedCheckpoint) == 0x0001A0, "Member 'UDelMarPlayerRaceDataComponent::MostRecentlyVisitedCheckpoint' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, CachedCheckpointManager) == 0x0001A8, "Member 'UDelMarPlayerRaceDataComponent::CachedCheckpointManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, CachedRaceManager) == 0x0001B0, "Member 'UDelMarPlayerRaceDataComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, CachedDelMarVehicle) == 0x0001B8, "Member 'UDelMarPlayerRaceDataComponent::CachedDelMarVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, CachedPositionalTracker) == 0x0001C0, "Member 'UDelMarPlayerRaceDataComponent::CachedPositionalTracker' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, CachedLapTracker) == 0x0001C8, "Member 'UDelMarPlayerRaceDataComponent::CachedLapTracker' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, CheckpointsVisitedThisLap) == 0x0001D0, "Member 'UDelMarPlayerRaceDataComponent::CheckpointsVisitedThisLap' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, TimeTrialSectionIndex) == 0x000220, "Member 'UDelMarPlayerRaceDataComponent::TimeTrialSectionIndex' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRaceDataComponent, CheckPointIndex) == 0x000224, "Member 'UDelMarPlayerRaceDataComponent::CheckPointIndex' has a wrong offset!");

// Class DelMarCore.DelMarPlayerDeathRaceDataComponent
// 0x0008 (0x0230 - 0x0228)
class UDelMarPlayerDeathRaceDataComponent final : public UDelMarPlayerRaceDataComponent
{
public:
	int32                                         Score;                                             // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerDeathRaceDataComponent">();
	}
	static class UDelMarPlayerDeathRaceDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerDeathRaceDataComponent>();
	}
};
static_assert(alignof(UDelMarPlayerDeathRaceDataComponent) == 0x000008, "Wrong alignment on UDelMarPlayerDeathRaceDataComponent");
static_assert(sizeof(UDelMarPlayerDeathRaceDataComponent) == 0x000230, "Wrong size on UDelMarPlayerDeathRaceDataComponent");
static_assert(offsetof(UDelMarPlayerDeathRaceDataComponent, Score) == 0x000228, "Member 'UDelMarPlayerDeathRaceDataComponent::Score' has a wrong offset!");

// Class DelMarCore.DelMarPlayerInputManagerComponent
// 0x0068 (0x0108 - 0x00A0)
class UDelMarPlayerInputManagerComponent final : public UDelMarPlayerStateComponent
{
public:
	TMap<struct FGameplayTag, struct FDelMarInputMappingContextData> InputMappingContextMap;                            // 0x00A0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerController>   CachedController;                                  // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          CachedVehicle;                                     // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerInputManagerComponent">();
	}
	static class UDelMarPlayerInputManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerInputManagerComponent>();
	}
};
static_assert(alignof(UDelMarPlayerInputManagerComponent) == 0x000008, "Wrong alignment on UDelMarPlayerInputManagerComponent");
static_assert(sizeof(UDelMarPlayerInputManagerComponent) == 0x000108, "Wrong size on UDelMarPlayerInputManagerComponent");
static_assert(offsetof(UDelMarPlayerInputManagerComponent, InputMappingContextMap) == 0x0000A0, "Member 'UDelMarPlayerInputManagerComponent::InputMappingContextMap' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerInputManagerComponent, CachedController) == 0x0000F0, "Member 'UDelMarPlayerInputManagerComponent::CachedController' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerInputManagerComponent, CachedVehicle) == 0x0000F8, "Member 'UDelMarPlayerInputManagerComponent::CachedVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerInputManagerComponent, CachedRaceManager) == 0x000100, "Member 'UDelMarPlayerInputManagerComponent::CachedRaceManager' has a wrong offset!");

// Class DelMarCore.DelMarPlayerPreferencesComponent
// 0x0058 (0x00F8 - 0x00A0)
class UDelMarPlayerPreferencesComponent final : public UDelMarPlayerStateComponent
{
public:
	TMulticastInlineDelegate<void(bool bUseToggle)> OnUseToggleOnExpandableHudWidgetChanged;           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bUseToggle)> OnUseIconOnlyPlayerNameplatesChanged;              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& Layout)> OnTouchControlsLayoutChanged;                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EDelMarInvertSteerMethod                      InvertSteerMethod;                                 // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPitchInverted;                                    // 0x00D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVerticalKickflipInverted;                         // 0x00D2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAerialPitchActivationEnabled;                     // 0x00D3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseToggleOnExpandableHudWidget;                   // 0x00D4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseIconOnlyPlayerNameplates;                      // 0x00D5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TouchControlsLayout;                               // 0x00D8(0x0004)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          CachedDelMarVehicle;                               // 0x00DC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UFortClientSettingsRecord> FortSettings;                                      // 0x00E4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0xC];                                       // 0x00EC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAerialPitchActivationSettingChanged();
	void HandleIconOnlyNameplatesSettingChanged();
	void HandleInvertSteerSettingChanged();
	void HandleLocalFortInputSettingsChanged();
	void HandleTouchControlsSettingsChanged();
	void ServerSetInvertSteerMethod(EDelMarInvertSteerMethod InInvertSteerMethod);
	void ServerUpdateAerialPitchActivation(const bool bInAerialPitchActivationEnabled);
	void ServerUpdatePitchInverted(const bool bInPitchInverted);
	void TryGetFortClientSettings();

	struct FGameplayTag GetTouchControlsLayout() const;
	bool GetUseIconOnlyPlayerNameplates() const;
	bool GetUseToggleOnExpandableHudWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerPreferencesComponent">();
	}
	static class UDelMarPlayerPreferencesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerPreferencesComponent>();
	}
};
static_assert(alignof(UDelMarPlayerPreferencesComponent) == 0x000008, "Wrong alignment on UDelMarPlayerPreferencesComponent");
static_assert(sizeof(UDelMarPlayerPreferencesComponent) == 0x0000F8, "Wrong size on UDelMarPlayerPreferencesComponent");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, OnUseToggleOnExpandableHudWidgetChanged) == 0x0000A0, "Member 'UDelMarPlayerPreferencesComponent::OnUseToggleOnExpandableHudWidgetChanged' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, OnUseIconOnlyPlayerNameplatesChanged) == 0x0000B0, "Member 'UDelMarPlayerPreferencesComponent::OnUseIconOnlyPlayerNameplatesChanged' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, OnTouchControlsLayoutChanged) == 0x0000C0, "Member 'UDelMarPlayerPreferencesComponent::OnTouchControlsLayoutChanged' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, InvertSteerMethod) == 0x0000D0, "Member 'UDelMarPlayerPreferencesComponent::InvertSteerMethod' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, bPitchInverted) == 0x0000D1, "Member 'UDelMarPlayerPreferencesComponent::bPitchInverted' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, bVerticalKickflipInverted) == 0x0000D2, "Member 'UDelMarPlayerPreferencesComponent::bVerticalKickflipInverted' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, bAerialPitchActivationEnabled) == 0x0000D3, "Member 'UDelMarPlayerPreferencesComponent::bAerialPitchActivationEnabled' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, bUseToggleOnExpandableHudWidget) == 0x0000D4, "Member 'UDelMarPlayerPreferencesComponent::bUseToggleOnExpandableHudWidget' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, bUseIconOnlyPlayerNameplates) == 0x0000D5, "Member 'UDelMarPlayerPreferencesComponent::bUseIconOnlyPlayerNameplates' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, TouchControlsLayout) == 0x0000D8, "Member 'UDelMarPlayerPreferencesComponent::TouchControlsLayout' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, CachedDelMarVehicle) == 0x0000DC, "Member 'UDelMarPlayerPreferencesComponent::CachedDelMarVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerPreferencesComponent, FortSettings) == 0x0000E4, "Member 'UDelMarPlayerPreferencesComponent::FortSettings' has a wrong offset!");

// Class DelMarCore.DelMarPlayerRespawnComponent
// 0x00B0 (0x0150 - 0x00A0)
class UDelMarPlayerRespawnComponent final : public UDelMarPlayerStateComponent
{
public:
	float                                         TeleportEnterPhaseSeconds;                         // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnBackwardsRangeDistance;                     // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnForwardRangeDistance;                       // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnHeightStartDistance;                        // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnHeightPenetrationDistance;                  // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnValidTrackRadius;                           // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckForObstacles;                                // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OppositeSideThreshold;                             // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ObstacleAreaBounds;                                // 0x00C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             ObstacleActorClasses;                              // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             ObstacleActorIgnoreClasses;                        // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADelMarRaceManager>      RaceManager;                                       // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          DelMarVehicle;                                     // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarCheckpointManagerComponent> CheckpointManager;                                 // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPlayerRaceDataComponent> PlayerRaceData;                                    // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarRaceConfigComponent> RaceConfig;                                        // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarTrack>            LastActiveTrack;                                   // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarTrackPositionComponent> TrackPosition;                                     // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastValidSegmentIndex;                             // 0x0130(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastValidDistanceAlongSpline;                      // 0x0134(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnOnOppositeSide;                              // 0x0138(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPreviousVehicleDemolished;                        // 0x0139(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFirstVehicleForPlayer;                            // 0x013A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B[0x15];                                     // 0x013B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerRespawnComponent">();
	}
	static class UDelMarPlayerRespawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerRespawnComponent>();
	}
};
static_assert(alignof(UDelMarPlayerRespawnComponent) == 0x000008, "Wrong alignment on UDelMarPlayerRespawnComponent");
static_assert(sizeof(UDelMarPlayerRespawnComponent) == 0x000150, "Wrong size on UDelMarPlayerRespawnComponent");
static_assert(offsetof(UDelMarPlayerRespawnComponent, TeleportEnterPhaseSeconds) == 0x0000A0, "Member 'UDelMarPlayerRespawnComponent::TeleportEnterPhaseSeconds' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, RespawnBackwardsRangeDistance) == 0x0000A4, "Member 'UDelMarPlayerRespawnComponent::RespawnBackwardsRangeDistance' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, RespawnForwardRangeDistance) == 0x0000A8, "Member 'UDelMarPlayerRespawnComponent::RespawnForwardRangeDistance' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, RespawnHeightStartDistance) == 0x0000AC, "Member 'UDelMarPlayerRespawnComponent::RespawnHeightStartDistance' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, RespawnHeightPenetrationDistance) == 0x0000B0, "Member 'UDelMarPlayerRespawnComponent::RespawnHeightPenetrationDistance' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, RespawnValidTrackRadius) == 0x0000B4, "Member 'UDelMarPlayerRespawnComponent::RespawnValidTrackRadius' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, bCheckForObstacles) == 0x0000B8, "Member 'UDelMarPlayerRespawnComponent::bCheckForObstacles' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, OppositeSideThreshold) == 0x0000BC, "Member 'UDelMarPlayerRespawnComponent::OppositeSideThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, ObstacleAreaBounds) == 0x0000C0, "Member 'UDelMarPlayerRespawnComponent::ObstacleAreaBounds' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, ObstacleActorClasses) == 0x0000D8, "Member 'UDelMarPlayerRespawnComponent::ObstacleActorClasses' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, ObstacleActorIgnoreClasses) == 0x0000E8, "Member 'UDelMarPlayerRespawnComponent::ObstacleActorIgnoreClasses' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, RaceManager) == 0x0000F8, "Member 'UDelMarPlayerRespawnComponent::RaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, DelMarVehicle) == 0x000100, "Member 'UDelMarPlayerRespawnComponent::DelMarVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, CheckpointManager) == 0x000108, "Member 'UDelMarPlayerRespawnComponent::CheckpointManager' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, PlayerRaceData) == 0x000110, "Member 'UDelMarPlayerRespawnComponent::PlayerRaceData' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, RaceConfig) == 0x000118, "Member 'UDelMarPlayerRespawnComponent::RaceConfig' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, LastActiveTrack) == 0x000120, "Member 'UDelMarPlayerRespawnComponent::LastActiveTrack' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, TrackPosition) == 0x000128, "Member 'UDelMarPlayerRespawnComponent::TrackPosition' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, LastValidSegmentIndex) == 0x000130, "Member 'UDelMarPlayerRespawnComponent::LastValidSegmentIndex' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, LastValidDistanceAlongSpline) == 0x000134, "Member 'UDelMarPlayerRespawnComponent::LastValidDistanceAlongSpline' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, bSpawnOnOppositeSide) == 0x000138, "Member 'UDelMarPlayerRespawnComponent::bSpawnOnOppositeSide' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, bPreviousVehicleDemolished) == 0x000139, "Member 'UDelMarPlayerRespawnComponent::bPreviousVehicleDemolished' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerRespawnComponent, bFirstVehicleForPlayer) == 0x00013A, "Member 'UDelMarPlayerRespawnComponent::bFirstVehicleForPlayer' has a wrong offset!");

// Class DelMarCore.DelMarPlayerStartlineComponent
// 0x0040 (0x00E0 - 0x00A0)
class UDelMarPlayerStartlineComponent final : public UDelMarPlayerStateComponent
{
public:
	float                                         FailBufferSeconds;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADelMarVehicle>          DelMarVehicle;                                     // 0x00A4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x34];                                      // 0x00AC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerStartlineComponent">();
	}
	static class UDelMarPlayerStartlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerStartlineComponent>();
	}
};
static_assert(alignof(UDelMarPlayerStartlineComponent) == 0x000008, "Wrong alignment on UDelMarPlayerStartlineComponent");
static_assert(sizeof(UDelMarPlayerStartlineComponent) == 0x0000E0, "Wrong size on UDelMarPlayerStartlineComponent");
static_assert(offsetof(UDelMarPlayerStartlineComponent, FailBufferSeconds) == 0x0000A0, "Member 'UDelMarPlayerStartlineComponent::FailBufferSeconds' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerStartlineComponent, DelMarVehicle) == 0x0000A4, "Member 'UDelMarPlayerStartlineComponent::DelMarVehicle' has a wrong offset!");

// Class DelMarCore.DelMarPlayerTurboManagerComponent
// 0x0028 (0x00C8 - 0x00A0)
class UDelMarPlayerTurboManagerComponent final : public UDelMarPlayerStateComponent
{
public:
	float                                         TurboCharges;                                      // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RechargeRateSeconds;                               // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LapCompleteCharges;                                // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RaceStartCharges;                                  // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCharges;                                        // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          CachedDelMarVehicle;                               // 0x00B4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00BC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTurboChargeUsed();
	void ModifyTurboCharges(float TurboChargeAmount);
	void ModifyTurboCharges_Delayed(float TurboChargeAmount);
	void SetTurboCharges(float TurboChargeAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayerTurboManagerComponent">();
	}
	static class UDelMarPlayerTurboManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPlayerTurboManagerComponent>();
	}
};
static_assert(alignof(UDelMarPlayerTurboManagerComponent) == 0x000008, "Wrong alignment on UDelMarPlayerTurboManagerComponent");
static_assert(sizeof(UDelMarPlayerTurboManagerComponent) == 0x0000C8, "Wrong size on UDelMarPlayerTurboManagerComponent");
static_assert(offsetof(UDelMarPlayerTurboManagerComponent, TurboCharges) == 0x0000A0, "Member 'UDelMarPlayerTurboManagerComponent::TurboCharges' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerTurboManagerComponent, RechargeRateSeconds) == 0x0000A4, "Member 'UDelMarPlayerTurboManagerComponent::RechargeRateSeconds' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerTurboManagerComponent, LapCompleteCharges) == 0x0000A8, "Member 'UDelMarPlayerTurboManagerComponent::LapCompleteCharges' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerTurboManagerComponent, RaceStartCharges) == 0x0000AC, "Member 'UDelMarPlayerTurboManagerComponent::RaceStartCharges' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerTurboManagerComponent, MaxCharges) == 0x0000B0, "Member 'UDelMarPlayerTurboManagerComponent::MaxCharges' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerTurboManagerComponent, CachedDelMarVehicle) == 0x0000B4, "Member 'UDelMarPlayerTurboManagerComponent::CachedDelMarVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarPlayerTurboManagerComponent, CachedRaceManager) == 0x0000BC, "Member 'UDelMarPlayerTurboManagerComponent::CachedRaceManager' has a wrong offset!");

// Class DelMarCore.DelMarRemoveAthenaMarkerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarRemoveAthenaMarkerComponent final : public UControllerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRemoveAthenaMarkerComponent">();
	}
	static class UDelMarRemoveAthenaMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRemoveAthenaMarkerComponent>();
	}
};
static_assert(alignof(UDelMarRemoveAthenaMarkerComponent) == 0x000008, "Wrong alignment on UDelMarRemoveAthenaMarkerComponent");
static_assert(sizeof(UDelMarRemoveAthenaMarkerComponent) == 0x0000A0, "Wrong size on UDelMarRemoveAthenaMarkerComponent");

// Class DelMarCore.DelMarRequestComponent
// 0x0088 (0x0128 - 0x00A0)
class UDelMarRequestComponent final : public UDelMarPlayerStateComponent
{
public:
	uint8                                         Pad_A0[0x48];                                      // 0x00A0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MapChoice;                                         // 0x00E8(0x0020)(Net, Transient, NativeAccessSpecifierPublic)
	bool                                          bIsReadyToStartRace;                               // 0x0108(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReadyToJoinRace;                                // 0x0109(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarPostRaceVote                           PostRaceVote;                                      // 0x010A(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVotedPostRace;                                    // 0x010B(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x010C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarRespawnManagerComponent> CachedRespawnManager;                              // 0x0114(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        PlayerState;                                       // 0x011C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PostRaceNextRaceSelected();
	void PostRaceReturnToLobbySelected();
	void ServerPostRaceNextRaceSelected();
	void ServerPostRaceReturnToLobbySelected();
	void ServerReadyUp(bool bInReadyUp);
	void ServerRequestBecomeSpectator();
	void ServerRequestFinalInitialization();
	void ServerRequestMap(const struct FGameplayTagContainer& InMapChoice);
	void ServerRequestMapFromGameplay(const struct FGameplayTagContainer& InMapChoice);
	void ServerRequestRacerCountdown();
	void ServerRequestResetRun();
	void ServerRequestSpectatorBecomePlayer();
	void ServerRequestVehicleSpawn();
	void ServerSetJoinNextRace(bool bInReadyToJoinRace);
	void ServerSetPostRaceVote(EDelMarPostRaceVote NewVote);

	void OnRep_bIsReadyToJoinRace() const;
	void OnRep_bIsReadyToStartRace() const;
	void OnRep_PostRaceVote() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRequestComponent">();
	}
	static class UDelMarRequestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRequestComponent>();
	}
};
static_assert(alignof(UDelMarRequestComponent) == 0x000008, "Wrong alignment on UDelMarRequestComponent");
static_assert(sizeof(UDelMarRequestComponent) == 0x000128, "Wrong size on UDelMarRequestComponent");
static_assert(offsetof(UDelMarRequestComponent, MapChoice) == 0x0000E8, "Member 'UDelMarRequestComponent::MapChoice' has a wrong offset!");
static_assert(offsetof(UDelMarRequestComponent, bIsReadyToStartRace) == 0x000108, "Member 'UDelMarRequestComponent::bIsReadyToStartRace' has a wrong offset!");
static_assert(offsetof(UDelMarRequestComponent, bIsReadyToJoinRace) == 0x000109, "Member 'UDelMarRequestComponent::bIsReadyToJoinRace' has a wrong offset!");
static_assert(offsetof(UDelMarRequestComponent, PostRaceVote) == 0x00010A, "Member 'UDelMarRequestComponent::PostRaceVote' has a wrong offset!");
static_assert(offsetof(UDelMarRequestComponent, bVotedPostRace) == 0x00010B, "Member 'UDelMarRequestComponent::bVotedPostRace' has a wrong offset!");
static_assert(offsetof(UDelMarRequestComponent, CachedRaceManager) == 0x00010C, "Member 'UDelMarRequestComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarRequestComponent, CachedRespawnManager) == 0x000114, "Member 'UDelMarRequestComponent::CachedRespawnManager' has a wrong offset!");
static_assert(offsetof(UDelMarRequestComponent, PlayerState) == 0x00011C, "Member 'UDelMarRequestComponent::PlayerState' has a wrong offset!");

// Class DelMarCore.DelMarRunRecordPlayerComponent
// 0x0070 (0x0110 - 0x00A0)
class UDelMarRunRecordPlayerComponent final : public UDelMarPlayerStateComponent
{
public:
	struct FDelMarRunRecord                       CurrentRunRecord;                                  // 0x00A0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FDelMarRunRecord                       BestRunRecord;                                     // 0x00C0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FDelMarRunRecord                       BestSectionsRecord;                                // 0x00E0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	double                                        BestSingleLapTime;                                 // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADelMarRaceManager>      RaceManager;                                       // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void PrintRecords(const struct FDelMarRunRecord& RunRecord, const class FString& Name_0);

	void NetMulticast_LapRecorded(const struct FDelMarEvent_LapRecorded& InLapRecordedEvent);
	void NetMulticast_RunRecorded(const struct FDelMarEvent_RunRecorded& InRunRecordedEvent);
	void NetMulticast_SectionRecorded(const struct FDelMarEvent_SectionRecorded& InSectionRecordedEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRunRecordPlayerComponent">();
	}
	static class UDelMarRunRecordPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRunRecordPlayerComponent>();
	}
};
static_assert(alignof(UDelMarRunRecordPlayerComponent) == 0x000008, "Wrong alignment on UDelMarRunRecordPlayerComponent");
static_assert(sizeof(UDelMarRunRecordPlayerComponent) == 0x000110, "Wrong size on UDelMarRunRecordPlayerComponent");
static_assert(offsetof(UDelMarRunRecordPlayerComponent, CurrentRunRecord) == 0x0000A0, "Member 'UDelMarRunRecordPlayerComponent::CurrentRunRecord' has a wrong offset!");
static_assert(offsetof(UDelMarRunRecordPlayerComponent, BestRunRecord) == 0x0000C0, "Member 'UDelMarRunRecordPlayerComponent::BestRunRecord' has a wrong offset!");
static_assert(offsetof(UDelMarRunRecordPlayerComponent, BestSectionsRecord) == 0x0000E0, "Member 'UDelMarRunRecordPlayerComponent::BestSectionsRecord' has a wrong offset!");
static_assert(offsetof(UDelMarRunRecordPlayerComponent, BestSingleLapTime) == 0x000100, "Member 'UDelMarRunRecordPlayerComponent::BestSingleLapTime' has a wrong offset!");
static_assert(offsetof(UDelMarRunRecordPlayerComponent, RaceManager) == 0x000108, "Member 'UDelMarRunRecordPlayerComponent::RaceManager' has a wrong offset!");

// Class DelMarCore.DelMarTutorialPlayerRaceDataComponent
// 0x0008 (0x0230 - 0x0228)
class UDelMarTutorialPlayerRaceDataComponent final : public UDelMarPlayerRaceDataComponent
{
public:
	int32                                         CurrentTutorialSectionIndex;                       // 0x0228(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarTutorialPlayerRaceDataComponent">();
	}
	static class UDelMarTutorialPlayerRaceDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarTutorialPlayerRaceDataComponent>();
	}
};
static_assert(alignof(UDelMarTutorialPlayerRaceDataComponent) == 0x000008, "Wrong alignment on UDelMarTutorialPlayerRaceDataComponent");
static_assert(sizeof(UDelMarTutorialPlayerRaceDataComponent) == 0x000230, "Wrong size on UDelMarTutorialPlayerRaceDataComponent");
static_assert(offsetof(UDelMarTutorialPlayerRaceDataComponent, CurrentTutorialSectionIndex) == 0x000228, "Member 'UDelMarTutorialPlayerRaceDataComponent::CurrentTutorialSectionIndex' has a wrong offset!");

// Class DelMarCore.DelMarTutorialRequestComponent
// 0x0010 (0x00B0 - 0x00A0)
class UDelMarTutorialRequestComponent final : public UDelMarPlayerStateComponent
{
public:
	TWeakObjectPtr<class AFortPlayerState>        PlayerState;                                       // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarTutorialRaceManager> TutorialRaceManager;                               // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Replay();
	void Server_RequestNextSection();
	void Server_RequestPrevSection();
	void Server_RequestSection(int32 SectionIndex);
	void Server_RequestStartRace(const bool bSkipCountdown);

	void GoRace() const;
	void KeepTraining() const;
	void Server_KeepTraining() const;
	void TutorialComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarTutorialRequestComponent">();
	}
	static class UDelMarTutorialRequestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarTutorialRequestComponent>();
	}
};
static_assert(alignof(UDelMarTutorialRequestComponent) == 0x000008, "Wrong alignment on UDelMarTutorialRequestComponent");
static_assert(sizeof(UDelMarTutorialRequestComponent) == 0x0000B0, "Wrong size on UDelMarTutorialRequestComponent");
static_assert(offsetof(UDelMarTutorialRequestComponent, PlayerState) == 0x0000A0, "Member 'UDelMarTutorialRequestComponent::PlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarTutorialRequestComponent, TutorialRaceManager) == 0x0000A8, "Member 'UDelMarTutorialRequestComponent::TutorialRaceManager' has a wrong offset!");

// Class DelMarCore.DelMarLevelManagerComponent
// 0x00B0 (0x0150 - 0x00A0)
class UDelMarLevelManagerComponent final : public UPlayspaceComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDelMarLevelDataAsset>   CurrentLevelData;                                  // 0x00D0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOnlineLinkId                          CurrentLevelLinkId;                                // 0x00D8(0x0018)(Net, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DesiredMapDescription;                             // 0x00F0(0x0020)(Net, Transient, NativeAccessSpecifierPrivate)
	struct FOnlineLinkId                          DesiredLinkId;                                     // 0x0110(0x0018)(Net, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestLevelLoad(const struct FGameplayTagContainer& DesiredMap);
	void ServerRequestLevel(const struct FGameplayTagContainer& DesiredMap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarLevelManagerComponent">();
	}
	static class UDelMarLevelManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarLevelManagerComponent>();
	}
};
static_assert(alignof(UDelMarLevelManagerComponent) == 0x000008, "Wrong alignment on UDelMarLevelManagerComponent");
static_assert(sizeof(UDelMarLevelManagerComponent) == 0x000150, "Wrong size on UDelMarLevelManagerComponent");
static_assert(offsetof(UDelMarLevelManagerComponent, CurrentLevelData) == 0x0000D0, "Member 'UDelMarLevelManagerComponent::CurrentLevelData' has a wrong offset!");
static_assert(offsetof(UDelMarLevelManagerComponent, CurrentLevelLinkId) == 0x0000D8, "Member 'UDelMarLevelManagerComponent::CurrentLevelLinkId' has a wrong offset!");
static_assert(offsetof(UDelMarLevelManagerComponent, DesiredMapDescription) == 0x0000F0, "Member 'UDelMarLevelManagerComponent::DesiredMapDescription' has a wrong offset!");
static_assert(offsetof(UDelMarLevelManagerComponent, DesiredLinkId) == 0x000110, "Member 'UDelMarLevelManagerComponent::DesiredLinkId' has a wrong offset!");

// Class DelMarCore.DelMarLoadingScreenMutator
// 0x0010 (0x0348 - 0x0338)
class ADelMarLoadingScreenMutator final : public AFortAthenaMutator
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarLoadingScreenMutator">();
	}
	static class ADelMarLoadingScreenMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarLoadingScreenMutator>();
	}
};
static_assert(alignof(ADelMarLoadingScreenMutator) == 0x000008, "Wrong alignment on ADelMarLoadingScreenMutator");
static_assert(sizeof(ADelMarLoadingScreenMutator) == 0x000348, "Wrong size on ADelMarLoadingScreenMutator");

// Class DelMarCore.DelMarPlayspace
// 0x00D8 (0x07C0 - 0x06E8)
class ADelMarPlayspace final : public AFortPlayspace
{
public:
	uint8                                         Pad_6E8[0x48];                                     // 0x06E8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UFortPlaylistAthena>     MRSPlaylistData;                                   // 0x0730(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDelMarGameStateMachine*                PrimaryStateMachine;                               // 0x0738(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldShowLoadingScreen;                          // 0x0740(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_741[0x3];                                      // 0x0741(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADelMarRaceManager>      ActiveRaceManager;                                 // 0x0744(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UFortPlaylistAthena>     PlaylistData;                                      // 0x074C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarLevelManagerComponent> LevelManager;                                      // 0x0754(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75C[0x4];                                      // 0x075C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortLevelStreamComponent*              LevelStreamComponent;                              // 0x0760(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDelMarMapSet                          MapSet;                                            // 0x0768(0x0018)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  PlaylistDefinedMapTags;                            // 0x0780(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A0[0x20];                                     // 0x07A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActiveRaceManagerUpdated();
	void RequestNextMapFromMapSet();
	void ServerRequestLoadingLevel(const struct FGameplayTagContainer& DesiredMap);
	void ServerRequestLoadingLevelWithLinkCode(const struct FOnlineLinkId& DesiredMap);
	void ServerReturnToSetup(const struct FGameplayTagContainer& OptionalMapToForceLoad);
	void ServerReturnToSetupWithLinkCode(const struct FOnlineLinkId& OptionalMapToForceLoad);
	void SetLoadingScreenVisibiliy(bool bInShouldShowLoadingScreen);
	bool ShouldShowLoadingScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPlayspace">();
	}
	static class ADelMarPlayspace* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarPlayspace>();
	}
};
static_assert(alignof(ADelMarPlayspace) == 0x000008, "Wrong alignment on ADelMarPlayspace");
static_assert(sizeof(ADelMarPlayspace) == 0x0007C0, "Wrong size on ADelMarPlayspace");
static_assert(offsetof(ADelMarPlayspace, MRSPlaylistData) == 0x000730, "Member 'ADelMarPlayspace::MRSPlaylistData' has a wrong offset!");
static_assert(offsetof(ADelMarPlayspace, PrimaryStateMachine) == 0x000738, "Member 'ADelMarPlayspace::PrimaryStateMachine' has a wrong offset!");
static_assert(offsetof(ADelMarPlayspace, bShouldShowLoadingScreen) == 0x000740, "Member 'ADelMarPlayspace::bShouldShowLoadingScreen' has a wrong offset!");
static_assert(offsetof(ADelMarPlayspace, ActiveRaceManager) == 0x000744, "Member 'ADelMarPlayspace::ActiveRaceManager' has a wrong offset!");
static_assert(offsetof(ADelMarPlayspace, PlaylistData) == 0x00074C, "Member 'ADelMarPlayspace::PlaylistData' has a wrong offset!");
static_assert(offsetof(ADelMarPlayspace, LevelManager) == 0x000754, "Member 'ADelMarPlayspace::LevelManager' has a wrong offset!");
static_assert(offsetof(ADelMarPlayspace, LevelStreamComponent) == 0x000760, "Member 'ADelMarPlayspace::LevelStreamComponent' has a wrong offset!");
static_assert(offsetof(ADelMarPlayspace, MapSet) == 0x000768, "Member 'ADelMarPlayspace::MapSet' has a wrong offset!");
static_assert(offsetof(ADelMarPlayspace, PlaylistDefinedMapTags) == 0x000780, "Member 'ADelMarPlayspace::PlaylistDefinedMapTags' has a wrong offset!");

// Class DelMarCore.DelMarPreRaceControllerComponent
// 0x0070 (0x0110 - 0x00A0)
class UDelMarPreRaceControllerComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           NavigateAction;                                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FViewTargetTransitionParams            ViewTargetTransitionParams;                        // 0x00C0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         NavigateInputDeadzone;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDelMarPlayerInputManagerComponent> InputManagerClass;                                 // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPlayerInputManagerComponent> InputManager;                                      // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UEnhancedInputComponent> InputComponent;                                    // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDelMarPositionalTrackerComponent> PositionTracker;                                   // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerState>        CurrentViewTarget;                                 // 0x00F8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CellDistThreshold;                                 // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxGridDim;                                        // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerSetViewTarget(class AFortPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPreRaceControllerComponent">();
	}
	static class UDelMarPreRaceControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPreRaceControllerComponent>();
	}
};
static_assert(alignof(UDelMarPreRaceControllerComponent) == 0x000008, "Wrong alignment on UDelMarPreRaceControllerComponent");
static_assert(sizeof(UDelMarPreRaceControllerComponent) == 0x000110, "Wrong size on UDelMarPreRaceControllerComponent");
static_assert(offsetof(UDelMarPreRaceControllerComponent, NavigateAction) == 0x0000B8, "Member 'UDelMarPreRaceControllerComponent::NavigateAction' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, ViewTargetTransitionParams) == 0x0000C0, "Member 'UDelMarPreRaceControllerComponent::ViewTargetTransitionParams' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, NavigateInputDeadzone) == 0x0000D0, "Member 'UDelMarPreRaceControllerComponent::NavigateInputDeadzone' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, InputManagerClass) == 0x0000D8, "Member 'UDelMarPreRaceControllerComponent::InputManagerClass' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, InputManager) == 0x0000E0, "Member 'UDelMarPreRaceControllerComponent::InputManager' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, InputComponent) == 0x0000E8, "Member 'UDelMarPreRaceControllerComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, PositionTracker) == 0x0000F0, "Member 'UDelMarPreRaceControllerComponent::PositionTracker' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, CurrentViewTarget) == 0x0000F8, "Member 'UDelMarPreRaceControllerComponent::CurrentViewTarget' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, CellDistThreshold) == 0x000100, "Member 'UDelMarPreRaceControllerComponent::CellDistThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarPreRaceControllerComponent, MaxGridDim) == 0x000104, "Member 'UDelMarPreRaceControllerComponent::MaxGridDim' has a wrong offset!");

// Class DelMarCore.DelMarCheckpointManagerComponent
// 0x0068 (0x0108 - 0x00A0)
class UDelMarCheckpointManagerComponent final : public UDelMarRaceManagerComponent
{
public:
	bool                                          bPromptFirstPlaceEvent;                            // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarCheckpoint*                      StartingLineCheckpoint;                            // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADelMarCheckpoint*                      FinishLineCheckpoint;                              // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class ADelMarCheckpoint*>                LevelCheckpoints;                                  // 0x00B8(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void HandleRaceFinished(const struct FDelMarEvent_RaceFinished& Event);
	void HandleResetRace(const struct FDelMarEvent_ResetRace& Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCheckpointManagerComponent">();
	}
	static class UDelMarCheckpointManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCheckpointManagerComponent>();
	}
};
static_assert(alignof(UDelMarCheckpointManagerComponent) == 0x000008, "Wrong alignment on UDelMarCheckpointManagerComponent");
static_assert(sizeof(UDelMarCheckpointManagerComponent) == 0x000108, "Wrong size on UDelMarCheckpointManagerComponent");
static_assert(offsetof(UDelMarCheckpointManagerComponent, bPromptFirstPlaceEvent) == 0x0000A0, "Member 'UDelMarCheckpointManagerComponent::bPromptFirstPlaceEvent' has a wrong offset!");
static_assert(offsetof(UDelMarCheckpointManagerComponent, StartingLineCheckpoint) == 0x0000A8, "Member 'UDelMarCheckpointManagerComponent::StartingLineCheckpoint' has a wrong offset!");
static_assert(offsetof(UDelMarCheckpointManagerComponent, FinishLineCheckpoint) == 0x0000B0, "Member 'UDelMarCheckpointManagerComponent::FinishLineCheckpoint' has a wrong offset!");
static_assert(offsetof(UDelMarCheckpointManagerComponent, LevelCheckpoints) == 0x0000B8, "Member 'UDelMarCheckpointManagerComponent::LevelCheckpoints' has a wrong offset!");

// Class DelMarCore.DelMarDeathRaceManager
// 0x0030 (0x04D0 - 0x04A0)
class ADelMarDeathRaceManager final : public ADelMarRaceManager
{
public:
	float                                         NextRoundSeconds;                                  // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarDeathRaceConfig                 DeathRaceConfigData;                               // 0x04A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPlayersFinished;                                // 0x04C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetPointsAwardForPlacement(const int32 InPlacement) const;
	int32 GetScoreThresholdToEndMatch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDeathRaceManager">();
	}
	static class ADelMarDeathRaceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarDeathRaceManager>();
	}
};
static_assert(alignof(ADelMarDeathRaceManager) == 0x000008, "Wrong alignment on ADelMarDeathRaceManager");
static_assert(sizeof(ADelMarDeathRaceManager) == 0x0004D0, "Wrong size on ADelMarDeathRaceManager");
static_assert(offsetof(ADelMarDeathRaceManager, NextRoundSeconds) == 0x0004A0, "Member 'ADelMarDeathRaceManager::NextRoundSeconds' has a wrong offset!");
static_assert(offsetof(ADelMarDeathRaceManager, DeathRaceConfigData) == 0x0004A8, "Member 'ADelMarDeathRaceManager::DeathRaceConfigData' has a wrong offset!");
static_assert(offsetof(ADelMarDeathRaceManager, NumPlayersFinished) == 0x0004C8, "Member 'ADelMarDeathRaceManager::NumPlayersFinished' has a wrong offset!");

// Class DelMarCore.DelMarMatchmakeRatingComponentBase
// 0x0000 (0x00A0 - 0x00A0)
class UDelMarMatchmakeRatingComponentBase : public UDelMarRaceManagerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarMatchmakeRatingComponentBase">();
	}
	static class UDelMarMatchmakeRatingComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarMatchmakeRatingComponentBase>();
	}
};
static_assert(alignof(UDelMarMatchmakeRatingComponentBase) == 0x000008, "Wrong alignment on UDelMarMatchmakeRatingComponentBase");
static_assert(sizeof(UDelMarMatchmakeRatingComponentBase) == 0x0000A0, "Wrong size on UDelMarMatchmakeRatingComponentBase");

// Class DelMarCore.DelmarCompetitiveMatchmakeRatingComponent
// 0x00F8 (0x0198 - 0x00A0)
class UDelmarCompetitiveMatchmakeRatingComponent final : public UDelMarMatchmakeRatingComponentBase
{
public:
	TMap<class AFortPlayerState*, int32>          CachedPlayerRankMap;                               // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class FString>                           PlayerUniqueIdsGivenMMR;                           // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class FString>                           PlayerUniqueIds;                                   // 0x0140(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelmarCompetitiveMatchmakeRatingComponent">();
	}
	static class UDelmarCompetitiveMatchmakeRatingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelmarCompetitiveMatchmakeRatingComponent>();
	}
};
static_assert(alignof(UDelmarCompetitiveMatchmakeRatingComponent) == 0x000008, "Wrong alignment on UDelmarCompetitiveMatchmakeRatingComponent");
static_assert(sizeof(UDelmarCompetitiveMatchmakeRatingComponent) == 0x000198, "Wrong size on UDelmarCompetitiveMatchmakeRatingComponent");
static_assert(offsetof(UDelmarCompetitiveMatchmakeRatingComponent, CachedPlayerRankMap) == 0x0000A0, "Member 'UDelmarCompetitiveMatchmakeRatingComponent::CachedPlayerRankMap' has a wrong offset!");
static_assert(offsetof(UDelmarCompetitiveMatchmakeRatingComponent, PlayerUniqueIdsGivenMMR) == 0x0000F0, "Member 'UDelmarCompetitiveMatchmakeRatingComponent::PlayerUniqueIdsGivenMMR' has a wrong offset!");
static_assert(offsetof(UDelmarCompetitiveMatchmakeRatingComponent, PlayerUniqueIds) == 0x000140, "Member 'UDelmarCompetitiveMatchmakeRatingComponent::PlayerUniqueIds' has a wrong offset!");

// Class DelMarCore.DelMarPositionalTrackerComponent
// 0x00B8 (0x0158 - 0x00A0)
class UDelMarPositionalTrackerComponent final : public UDelMarRaceManagerComponent
{
public:
	float                                         TargetUpdateRateInSeconds;                         // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x34];                                      // 0x00A4(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AFortPlayerState*, struct FDelMarPositionValue> SplinePositions;                                   // 0x00D8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortPlayerState*>               RacePositions;                                     // 0x0128(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDelMarFinalRacePositionEntry>  FinalRacePositions;                                // 0x0138(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastUpdate;                               // 0x0148(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumLapsInRace;                                     // 0x014C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FinalRacePositions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarPositionalTrackerComponent">();
	}
	static class UDelMarPositionalTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarPositionalTrackerComponent>();
	}
};
static_assert(alignof(UDelMarPositionalTrackerComponent) == 0x000008, "Wrong alignment on UDelMarPositionalTrackerComponent");
static_assert(sizeof(UDelMarPositionalTrackerComponent) == 0x000158, "Wrong size on UDelMarPositionalTrackerComponent");
static_assert(offsetof(UDelMarPositionalTrackerComponent, TargetUpdateRateInSeconds) == 0x0000A0, "Member 'UDelMarPositionalTrackerComponent::TargetUpdateRateInSeconds' has a wrong offset!");
static_assert(offsetof(UDelMarPositionalTrackerComponent, SplinePositions) == 0x0000D8, "Member 'UDelMarPositionalTrackerComponent::SplinePositions' has a wrong offset!");
static_assert(offsetof(UDelMarPositionalTrackerComponent, RacePositions) == 0x000128, "Member 'UDelMarPositionalTrackerComponent::RacePositions' has a wrong offset!");
static_assert(offsetof(UDelMarPositionalTrackerComponent, FinalRacePositions) == 0x000138, "Member 'UDelMarPositionalTrackerComponent::FinalRacePositions' has a wrong offset!");
static_assert(offsetof(UDelMarPositionalTrackerComponent, TimeSinceLastUpdate) == 0x000148, "Member 'UDelMarPositionalTrackerComponent::TimeSinceLastUpdate' has a wrong offset!");
static_assert(offsetof(UDelMarPositionalTrackerComponent, NumLapsInRace) == 0x00014C, "Member 'UDelMarPositionalTrackerComponent::NumLapsInRace' has a wrong offset!");

// Class DelMarCore.DelMarRaceConfigComponent
// 0x0160 (0x0200 - 0x00A0)
class UDelMarRaceConfigComponent final : public UDelMarRaceManagerComponent
{
public:
	bool                                          bGhostReplayEnabled;                               // 0x00A0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowExitingVehicles;                             // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsBeforeWrongwayWarning;                      // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsBeforeDemoWarningsAppear;                   // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsBeforeMissedCheckpointDemo;                 // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsBeforeReturnToTrackDemo;                    // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DistanceFromTrackBeforeDemoWarning;                // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultVehicleClass;                               // 0x00C0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UDelMarPlayerStateComponent>> ServerPlayerStateComponents;                       // 0x00E0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UDelMarPlayerStateComponent>> ClientPlayerStateComponents;                       // 0x00F0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UControllerComponent>> ServerControllerComponents;                        // 0x0100(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UControllerComponent>> ClientControllerComponents;                        // 0x0110(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UDelMarSpectatorControllerComponent> SpectatorControllerComponentClass;                 // 0x0120(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarMatchmakingConfig               MatchmakingConfig;                                 // 0x0128(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarStartlineConfig                 StartlineConfig;                                   // 0x0140(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDelMarVehicleRuntimeConfig            VehicleRuntimeConfig;                              // 0x0168(0x0014)(Edit, BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleAbilityConfig            VehicleAbilityConfig;                              // 0x017C(0x0011)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarRespawnConfig                   RespawnConfig;                                     // 0x0190(0x0010)(Edit, BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarRubberbandingConfig             DefaultRubberbandingConfig;                        // 0x01A0(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDelMarRubberbandingMMRConfig>  RubberbandingMMRConfigs;                           // 0x01C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDelMarRubberbandingMMRConfig>  RubberbandingMMROverrideConfigs;                   // 0x01D8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x18];                                     // 0x01E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastVehicleAbilityConfigUpdated();
	void OnRep_VehicleAbilityConfig(const struct FDelMarVehicleAbilityConfig& OldConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRaceConfigComponent">();
	}
	static class UDelMarRaceConfigComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRaceConfigComponent>();
	}
};
static_assert(alignof(UDelMarRaceConfigComponent) == 0x000008, "Wrong alignment on UDelMarRaceConfigComponent");
static_assert(sizeof(UDelMarRaceConfigComponent) == 0x000200, "Wrong size on UDelMarRaceConfigComponent");
static_assert(offsetof(UDelMarRaceConfigComponent, bGhostReplayEnabled) == 0x0000A0, "Member 'UDelMarRaceConfigComponent::bGhostReplayEnabled' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, bAllowExitingVehicles) == 0x0000A1, "Member 'UDelMarRaceConfigComponent::bAllowExitingVehicles' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, SecondsBeforeWrongwayWarning) == 0x0000A4, "Member 'UDelMarRaceConfigComponent::SecondsBeforeWrongwayWarning' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, SecondsBeforeDemoWarningsAppear) == 0x0000A8, "Member 'UDelMarRaceConfigComponent::SecondsBeforeDemoWarningsAppear' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, SecondsBeforeMissedCheckpointDemo) == 0x0000AC, "Member 'UDelMarRaceConfigComponent::SecondsBeforeMissedCheckpointDemo' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, SecondsBeforeReturnToTrackDemo) == 0x0000B0, "Member 'UDelMarRaceConfigComponent::SecondsBeforeReturnToTrackDemo' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, DistanceFromTrackBeforeDemoWarning) == 0x0000B8, "Member 'UDelMarRaceConfigComponent::DistanceFromTrackBeforeDemoWarning' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, DefaultVehicleClass) == 0x0000C0, "Member 'UDelMarRaceConfigComponent::DefaultVehicleClass' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, ServerPlayerStateComponents) == 0x0000E0, "Member 'UDelMarRaceConfigComponent::ServerPlayerStateComponents' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, ClientPlayerStateComponents) == 0x0000F0, "Member 'UDelMarRaceConfigComponent::ClientPlayerStateComponents' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, ServerControllerComponents) == 0x000100, "Member 'UDelMarRaceConfigComponent::ServerControllerComponents' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, ClientControllerComponents) == 0x000110, "Member 'UDelMarRaceConfigComponent::ClientControllerComponents' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, SpectatorControllerComponentClass) == 0x000120, "Member 'UDelMarRaceConfigComponent::SpectatorControllerComponentClass' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, MatchmakingConfig) == 0x000128, "Member 'UDelMarRaceConfigComponent::MatchmakingConfig' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, StartlineConfig) == 0x000140, "Member 'UDelMarRaceConfigComponent::StartlineConfig' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, VehicleRuntimeConfig) == 0x000168, "Member 'UDelMarRaceConfigComponent::VehicleRuntimeConfig' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, VehicleAbilityConfig) == 0x00017C, "Member 'UDelMarRaceConfigComponent::VehicleAbilityConfig' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, RespawnConfig) == 0x000190, "Member 'UDelMarRaceConfigComponent::RespawnConfig' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, DefaultRubberbandingConfig) == 0x0001A0, "Member 'UDelMarRaceConfigComponent::DefaultRubberbandingConfig' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, RubberbandingMMRConfigs) == 0x0001C8, "Member 'UDelMarRaceConfigComponent::RubberbandingMMRConfigs' has a wrong offset!");
static_assert(offsetof(UDelMarRaceConfigComponent, RubberbandingMMROverrideConfigs) == 0x0001D8, "Member 'UDelMarRaceConfigComponent::RubberbandingMMROverrideConfigs' has a wrong offset!");

// Class DelMarCore.DelMarRequestTrackerComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDelMarRequestTrackerComponent final : public UDelMarRaceManagerComponent
{
public:
	struct FDelMarEvent_TrackedPlayerReadyStates  PlayerReadyStates;                                 // 0x00A0(0x0020)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_PlayerReadyStates();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRequestTrackerComponent">();
	}
	static class UDelMarRequestTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRequestTrackerComponent>();
	}
};
static_assert(alignof(UDelMarRequestTrackerComponent) == 0x000008, "Wrong alignment on UDelMarRequestTrackerComponent");
static_assert(sizeof(UDelMarRequestTrackerComponent) == 0x0000C0, "Wrong size on UDelMarRequestTrackerComponent");
static_assert(offsetof(UDelMarRequestTrackerComponent, PlayerReadyStates) == 0x0000A0, "Member 'UDelMarRequestTrackerComponent::PlayerReadyStates' has a wrong offset!");

// Class DelMarCore.DelMarRespawnManagerComponent
// 0x0098 (0x0138 - 0x00A0)
class UDelMarRespawnManagerComponent final : public UDelMarRaceManagerComponent
{
public:
	float                                         RespawnRetrySeconds;                               // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x14];                                      // 0x00A4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDelMarCheckpointManagerComponent> CachedCheckpointManager;                           // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADelMarPlayerStart>      CachedChallengeStartSpawnPoint;                    // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AController>>     RespawnRetryQueue;                                 // 0x00D0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class AFortPlayerState>, TWeakObjectPtr<class ADelMarVehicle>> LastSpawnedVehicleMap;                             // 0x00E0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ADelMarVehicle* RequestRespawnPawnAndVehicle(class AController* InController);
	class ADelMarVehicle* RequestRespawnVehicleForPawn(class AFortPlayerPawn* InPlayerPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRespawnManagerComponent">();
	}
	static class UDelMarRespawnManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRespawnManagerComponent>();
	}
};
static_assert(alignof(UDelMarRespawnManagerComponent) == 0x000008, "Wrong alignment on UDelMarRespawnManagerComponent");
static_assert(sizeof(UDelMarRespawnManagerComponent) == 0x000138, "Wrong size on UDelMarRespawnManagerComponent");
static_assert(offsetof(UDelMarRespawnManagerComponent, RespawnRetrySeconds) == 0x0000A0, "Member 'UDelMarRespawnManagerComponent::RespawnRetrySeconds' has a wrong offset!");
static_assert(offsetof(UDelMarRespawnManagerComponent, CachedCheckpointManager) == 0x0000B8, "Member 'UDelMarRespawnManagerComponent::CachedCheckpointManager' has a wrong offset!");
static_assert(offsetof(UDelMarRespawnManagerComponent, CachedRaceManager) == 0x0000C0, "Member 'UDelMarRespawnManagerComponent::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarRespawnManagerComponent, CachedChallengeStartSpawnPoint) == 0x0000C8, "Member 'UDelMarRespawnManagerComponent::CachedChallengeStartSpawnPoint' has a wrong offset!");
static_assert(offsetof(UDelMarRespawnManagerComponent, RespawnRetryQueue) == 0x0000D0, "Member 'UDelMarRespawnManagerComponent::RespawnRetryQueue' has a wrong offset!");
static_assert(offsetof(UDelMarRespawnManagerComponent, LastSpawnedVehicleMap) == 0x0000E0, "Member 'UDelMarRespawnManagerComponent::LastSpawnedVehicleMap' has a wrong offset!");

// Class DelMarCore.DelMarRubberbandingManagerComponent
// 0x0048 (0x00E8 - 0x00A0)
class UDelMarRubberbandingManagerComponent final : public UDelMarRaceManagerComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PackDistance;                                      // 0x00B8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDelMarRubberbandingConfig             RubberbandingConfig;                               // 0x00BC(0x0028)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MMRUsed;                                           // 0x00E4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_RubberbandingConfig();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarRubberbandingManagerComponent">();
	}
	static class UDelMarRubberbandingManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarRubberbandingManagerComponent>();
	}
};
static_assert(alignof(UDelMarRubberbandingManagerComponent) == 0x000008, "Wrong alignment on UDelMarRubberbandingManagerComponent");
static_assert(sizeof(UDelMarRubberbandingManagerComponent) == 0x0000E8, "Wrong size on UDelMarRubberbandingManagerComponent");
static_assert(offsetof(UDelMarRubberbandingManagerComponent, PackDistance) == 0x0000B8, "Member 'UDelMarRubberbandingManagerComponent::PackDistance' has a wrong offset!");
static_assert(offsetof(UDelMarRubberbandingManagerComponent, RubberbandingConfig) == 0x0000BC, "Member 'UDelMarRubberbandingManagerComponent::RubberbandingConfig' has a wrong offset!");
static_assert(offsetof(UDelMarRubberbandingManagerComponent, MMRUsed) == 0x0000E4, "Member 'UDelMarRubberbandingManagerComponent::MMRUsed' has a wrong offset!");

// Class DelMarCore.DelMarGameStateMachine
// 0x0000 (0x01A8 - 0x01A8)
class UDelMarGameStateMachine final : public UDelMarStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarGameStateMachine">();
	}
	static class UDelMarGameStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarGameStateMachine>();
	}
};
static_assert(alignof(UDelMarGameStateMachine) == 0x000008, "Wrong alignment on UDelMarGameStateMachine");
static_assert(sizeof(UDelMarGameStateMachine) == 0x0001A8, "Wrong size on UDelMarGameStateMachine");

// Class DelMarCore.DelMarState_Gameplay
// 0x0000 (0x0030 - 0x0030)
class UDelMarState_Gameplay final : public UDelMarState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_Gameplay">();
	}
	static class UDelMarState_Gameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_Gameplay>();
	}
};
static_assert(alignof(UDelMarState_Gameplay) == 0x000008, "Wrong alignment on UDelMarState_Gameplay");
static_assert(sizeof(UDelMarState_Gameplay) == 0x000030, "Wrong size on UDelMarState_Gameplay");

// Class DelMarCore.DelMarState_Gameplay_ActiveRace
// 0x0000 (0x0030 - 0x0030)
class UDelMarState_Gameplay_ActiveRace final : public UDelMarGameplayState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_Gameplay_ActiveRace">();
	}
	static class UDelMarState_Gameplay_ActiveRace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_Gameplay_ActiveRace>();
	}
};
static_assert(alignof(UDelMarState_Gameplay_ActiveRace) == 0x000008, "Wrong alignment on UDelMarState_Gameplay_ActiveRace");
static_assert(sizeof(UDelMarState_Gameplay_ActiveRace) == 0x000030, "Wrong size on UDelMarState_Gameplay_ActiveRace");

// Class DelMarCore.DelMarState_Gameplay_Postrace
// 0x0280 (0x02B0 - 0x0030)
class UDelMarState_Gameplay_Postrace final : public UDelMarGameplayState
{
public:
	float                                         PostRaceDuration;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PostRaceEndServerTime;                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<TWeakObjectPtr<class AFortPlayerState>>  ReadyPlayers;                                      // 0x0040(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarPlayspace>        CachedPlayspace;                                   // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      CachedRaceManager;                                 // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EliminationList;                                   // 0x00D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x1D0];                                     // 0x00E0(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EliminationList();
	void OnRep_PostRaceEndServerTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_Gameplay_Postrace">();
	}
	static class UDelMarState_Gameplay_Postrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_Gameplay_Postrace>();
	}
};
static_assert(alignof(UDelMarState_Gameplay_Postrace) == 0x000008, "Wrong alignment on UDelMarState_Gameplay_Postrace");
static_assert(sizeof(UDelMarState_Gameplay_Postrace) == 0x0002B0, "Wrong size on UDelMarState_Gameplay_Postrace");
static_assert(offsetof(UDelMarState_Gameplay_Postrace, PostRaceDuration) == 0x000030, "Member 'UDelMarState_Gameplay_Postrace::PostRaceDuration' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_Postrace, PostRaceEndServerTime) == 0x000038, "Member 'UDelMarState_Gameplay_Postrace::PostRaceEndServerTime' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_Postrace, ReadyPlayers) == 0x000040, "Member 'UDelMarState_Gameplay_Postrace::ReadyPlayers' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_Postrace, CachedPlayspace) == 0x000090, "Member 'UDelMarState_Gameplay_Postrace::CachedPlayspace' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_Postrace, CachedRaceManager) == 0x000098, "Member 'UDelMarState_Gameplay_Postrace::CachedRaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_Postrace, EliminationList) == 0x0000D0, "Member 'UDelMarState_Gameplay_Postrace::EliminationList' has a wrong offset!");

// Class DelMarCore.DelMarState_Gameplay_Prerace
// 0x0018 (0x0048 - 0x0030)
class UDelMarState_Gameplay_Prerace final : public UDelMarGameplayState
{
public:
	TWeakObjectPtr<class ADelMarRaceManager>      RaceManager;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PreRaceCountdownFinishServerTime;                  // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_PreRaceCountdownFinishServerTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_Gameplay_Prerace">();
	}
	static class UDelMarState_Gameplay_Prerace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_Gameplay_Prerace>();
	}
};
static_assert(alignof(UDelMarState_Gameplay_Prerace) == 0x000008, "Wrong alignment on UDelMarState_Gameplay_Prerace");
static_assert(sizeof(UDelMarState_Gameplay_Prerace) == 0x000048, "Wrong size on UDelMarState_Gameplay_Prerace");
static_assert(offsetof(UDelMarState_Gameplay_Prerace, RaceManager) == 0x000030, "Member 'UDelMarState_Gameplay_Prerace::RaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_Prerace, PreRaceCountdownFinishServerTime) == 0x000040, "Member 'UDelMarState_Gameplay_Prerace::PreRaceCountdownFinishServerTime' has a wrong offset!");

// Class DelMarCore.DelMarState_Gameplay_WaitingForPlayers
// 0x0040 (0x0070 - 0x0030)
class UDelMarState_Gameplay_WaitingForPlayers final : public UDelMarGameplayState
{
public:
	int32                                         MinPlayers;                                        // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarRaceManager>      RaceManager;                                       // 0x0034(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDelMarEvent_LoadedPlayerStates        LoadedPlayerStates;                                // 0x003C(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPartyBeaconHost>    FortPartyBeacon;                                   // 0x0044(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x24];                                      // 0x004C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LoadedPlayerStates();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_Gameplay_WaitingForPlayers">();
	}
	static class UDelMarState_Gameplay_WaitingForPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_Gameplay_WaitingForPlayers>();
	}
};
static_assert(alignof(UDelMarState_Gameplay_WaitingForPlayers) == 0x000008, "Wrong alignment on UDelMarState_Gameplay_WaitingForPlayers");
static_assert(sizeof(UDelMarState_Gameplay_WaitingForPlayers) == 0x000070, "Wrong size on UDelMarState_Gameplay_WaitingForPlayers");
static_assert(offsetof(UDelMarState_Gameplay_WaitingForPlayers, MinPlayers) == 0x000030, "Member 'UDelMarState_Gameplay_WaitingForPlayers::MinPlayers' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_WaitingForPlayers, RaceManager) == 0x000034, "Member 'UDelMarState_Gameplay_WaitingForPlayers::RaceManager' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_WaitingForPlayers, LoadedPlayerStates) == 0x00003C, "Member 'UDelMarState_Gameplay_WaitingForPlayers::LoadedPlayerStates' has a wrong offset!");
static_assert(offsetof(UDelMarState_Gameplay_WaitingForPlayers, FortPartyBeacon) == 0x000044, "Member 'UDelMarState_Gameplay_WaitingForPlayers::FortPartyBeacon' has a wrong offset!");

// Class DelMarCore.DelMarState_LevelSetup
// 0x0008 (0x0038 - 0x0030)
class UDelMarState_LevelSetup final : public UDelMarGameplayState
{
public:
	bool                                          bVehiclesReady;                                    // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVehiclesSpawned;                                  // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_LevelSetup">();
	}
	static class UDelMarState_LevelSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_LevelSetup>();
	}
};
static_assert(alignof(UDelMarState_LevelSetup) == 0x000008, "Wrong alignment on UDelMarState_LevelSetup");
static_assert(sizeof(UDelMarState_LevelSetup) == 0x000038, "Wrong size on UDelMarState_LevelSetup");
static_assert(offsetof(UDelMarState_LevelSetup, bVehiclesReady) == 0x000030, "Member 'UDelMarState_LevelSetup::bVehiclesReady' has a wrong offset!");
static_assert(offsetof(UDelMarState_LevelSetup, bVehiclesSpawned) == 0x000031, "Member 'UDelMarState_LevelSetup::bVehiclesSpawned' has a wrong offset!");

// Class DelMarCore.DelMarState_Loading
// 0x0038 (0x0068 - 0x0030)
class UDelMarState_Loading final : public UDelMarGameplayState
{
public:
	float                                         DelayBeforeLoadingActuallyStarts;                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DesiredMap;                                        // 0x0038(0x0020)(Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_Loading">();
	}
	static class UDelMarState_Loading* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_Loading>();
	}
};
static_assert(alignof(UDelMarState_Loading) == 0x000008, "Wrong alignment on UDelMarState_Loading");
static_assert(sizeof(UDelMarState_Loading) == 0x000068, "Wrong size on UDelMarState_Loading");
static_assert(offsetof(UDelMarState_Loading, DelayBeforeLoadingActuallyStarts) == 0x000030, "Member 'UDelMarState_Loading::DelayBeforeLoadingActuallyStarts' has a wrong offset!");
static_assert(offsetof(UDelMarState_Loading, DesiredMap) == 0x000038, "Member 'UDelMarState_Loading::DesiredMap' has a wrong offset!");

// Class DelMarCore.DelMarState_Lobby
// 0x0008 (0x0038 - 0x0030)
class UDelMarState_Lobby final : public UDelMarGameplayState
{
public:
	bool                                          bLevelLoadRequested;                               // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_Lobby">();
	}
	static class UDelMarState_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_Lobby>();
	}
};
static_assert(alignof(UDelMarState_Lobby) == 0x000008, "Wrong alignment on UDelMarState_Lobby");
static_assert(sizeof(UDelMarState_Lobby) == 0x000038, "Wrong size on UDelMarState_Lobby");
static_assert(offsetof(UDelMarState_Lobby, bLevelLoadRequested) == 0x000030, "Member 'UDelMarState_Lobby::bLevelLoadRequested' has a wrong offset!");

// Class DelMarCore.DelMarState_Setup
// 0x0050 (0x0080 - 0x0030)
class UDelMarState_Setup final : public UDelMarGameplayState
{
public:
	bool                                          bHasRequestedLink;                                 // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasRecievedMatchAssignment;                       // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequiresMatchAssignmentToProceed;                 // 0x0032(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalledMapRotationService;                         // 0x0033(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DebugMapToLoad;                                    // 0x0038(0x0020)(Transient, NativeAccessSpecifierPrivate)
	struct FOnlineLinkId                          DebugIslandCodeToLoad;                             // 0x0058(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarState_Setup">();
	}
	static class UDelMarState_Setup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarState_Setup>();
	}
};
static_assert(alignof(UDelMarState_Setup) == 0x000008, "Wrong alignment on UDelMarState_Setup");
static_assert(sizeof(UDelMarState_Setup) == 0x000080, "Wrong size on UDelMarState_Setup");
static_assert(offsetof(UDelMarState_Setup, bHasRequestedLink) == 0x000030, "Member 'UDelMarState_Setup::bHasRequestedLink' has a wrong offset!");
static_assert(offsetof(UDelMarState_Setup, bHasRecievedMatchAssignment) == 0x000031, "Member 'UDelMarState_Setup::bHasRecievedMatchAssignment' has a wrong offset!");
static_assert(offsetof(UDelMarState_Setup, bRequiresMatchAssignmentToProceed) == 0x000032, "Member 'UDelMarState_Setup::bRequiresMatchAssignmentToProceed' has a wrong offset!");
static_assert(offsetof(UDelMarState_Setup, bCalledMapRotationService) == 0x000033, "Member 'UDelMarState_Setup::bCalledMapRotationService' has a wrong offset!");
static_assert(offsetof(UDelMarState_Setup, DebugMapToLoad) == 0x000038, "Member 'UDelMarState_Setup::DebugMapToLoad' has a wrong offset!");
static_assert(offsetof(UDelMarState_Setup, DebugIslandCodeToLoad) == 0x000058, "Member 'UDelMarState_Setup::DebugIslandCodeToLoad' has a wrong offset!");

// Class DelMarCore.DelMarCameraShakeComponent
// 0x04D0 (0x0570 - 0x00A0)
class UDelMarCameraShakeComponent final : public UControllerComponent
{
public:
	TMap<EBrelmarCameraShake, float>              ShakeIntensitySettingMap;                          // 0x00A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           JumpShakeEffect;                                   // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           HazardShakeEffect;                                 // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVehicleLandedKickflipShake;                    // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           VehicleLandedKickflipShake;                        // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     VehicleLandedKickflipShakeIntensityCurve;          // 0x0110(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           VehicleLandedCameraShakeEffect;                    // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     VehicleLandedShakeIntensityCurve;                  // 0x01A8(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxSecondsToDampenVehicleHit;                      // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarScaledCurve                     VehicleHitShakeIntensityCurve;                     // 0x0240(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarDynamicCameraShakeEffect        VehicleImpactShakeEffect;                          // 0x02D0(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDelMarDynamicCameraShakeEffect        WallImpactShakeEffect;                             // 0x0370(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDelMarDynamicCameraShakeEffect        WallNoRedirectImpactShakeEffect;                   // 0x0410(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDelMarDynamicCameraShakeEffect        BaseAccelerationShakeEffect;                       // 0x04B0(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TScriptInterface<class IDelMarVehicleInterface> Vehicle;                                           // 0x0550(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerController>   CachedPlayerController;                            // 0x0560(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCameraShakeIntensitySettingsChanged(class UFortClientSettingsRecord* Settings);
	void OnHazardHit();
	void OnJumpActivated();
	void OnVehicleHitVehicle(float Magnitude, const struct FVector& WorldLocation);
	void OnVehicleHitWall(float Magnitude, const struct FVector& WorldLocation, float ForwardRotationDegrees);
	void OnVehicleLanded(float LandingForce, bool bLandedKickflip);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCameraShakeComponent">();
	}
	static class UDelMarCameraShakeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCameraShakeComponent>();
	}
};
static_assert(alignof(UDelMarCameraShakeComponent) == 0x000008, "Wrong alignment on UDelMarCameraShakeComponent");
static_assert(sizeof(UDelMarCameraShakeComponent) == 0x000570, "Wrong size on UDelMarCameraShakeComponent");
static_assert(offsetof(UDelMarCameraShakeComponent, ShakeIntensitySettingMap) == 0x0000A0, "Member 'UDelMarCameraShakeComponent::ShakeIntensitySettingMap' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, JumpShakeEffect) == 0x0000F0, "Member 'UDelMarCameraShakeComponent::JumpShakeEffect' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, HazardShakeEffect) == 0x0000F8, "Member 'UDelMarCameraShakeComponent::HazardShakeEffect' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, bUseVehicleLandedKickflipShake) == 0x000100, "Member 'UDelMarCameraShakeComponent::bUseVehicleLandedKickflipShake' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, VehicleLandedKickflipShake) == 0x000108, "Member 'UDelMarCameraShakeComponent::VehicleLandedKickflipShake' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, VehicleLandedKickflipShakeIntensityCurve) == 0x000110, "Member 'UDelMarCameraShakeComponent::VehicleLandedKickflipShakeIntensityCurve' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, VehicleLandedCameraShakeEffect) == 0x0001A0, "Member 'UDelMarCameraShakeComponent::VehicleLandedCameraShakeEffect' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, VehicleLandedShakeIntensityCurve) == 0x0001A8, "Member 'UDelMarCameraShakeComponent::VehicleLandedShakeIntensityCurve' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, MaxSecondsToDampenVehicleHit) == 0x000238, "Member 'UDelMarCameraShakeComponent::MaxSecondsToDampenVehicleHit' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, VehicleHitShakeIntensityCurve) == 0x000240, "Member 'UDelMarCameraShakeComponent::VehicleHitShakeIntensityCurve' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, VehicleImpactShakeEffect) == 0x0002D0, "Member 'UDelMarCameraShakeComponent::VehicleImpactShakeEffect' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, WallImpactShakeEffect) == 0x000370, "Member 'UDelMarCameraShakeComponent::WallImpactShakeEffect' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, WallNoRedirectImpactShakeEffect) == 0x000410, "Member 'UDelMarCameraShakeComponent::WallNoRedirectImpactShakeEffect' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, BaseAccelerationShakeEffect) == 0x0004B0, "Member 'UDelMarCameraShakeComponent::BaseAccelerationShakeEffect' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, Vehicle) == 0x000550, "Member 'UDelMarCameraShakeComponent::Vehicle' has a wrong offset!");
static_assert(offsetof(UDelMarCameraShakeComponent, CachedPlayerController) == 0x000560, "Member 'UDelMarCameraShakeComponent::CachedPlayerController' has a wrong offset!");

// Class DelMarCore.DelMarVehicleConfigs
// 0x18C0 (0x2208 - 0x0948)
class UDelMarVehicleConfigs final : public UFortPhysicsVehicleConfigs
{
public:
	struct FDelMarVehicleCollisionConfig          Collision;                                         // 0x0948(0x0218)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDelMarVehicleBodySetup*                DefaultBodySetup;                                  // 0x0B60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDelMarVehicleBodySetupMap*             BodySetupMap;                                      // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarVehicleDriveSetup               DriveSetup;                                        // 0x0B70(0x0360)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDelMarPhysMatAttributeMap*             PhysMatAttributeMap;                               // 0x0ED0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarVehicleRigidBodyConfig          RigidBody;                                         // 0x0ED8(0x0040)(Edit, BlueprintVisible, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_Terrain           Terrain;                                           // 0x0F18(0x0020)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_WorldBonusSpeed   WorldBonusSpeed;                                   // 0x0F38(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_AutoAerialRotation AerialRotation;                                    // 0x0F68(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_AirControl        AirControl;                                        // 0x1008(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_AirFreestyle      AirFreestyle;                                      // 0x10D8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_AirThrottle       AirThrottle;                                       // 0x1108(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_AutoUpright       AutoUpright;                                       // 0x11A8(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleDraftingConfig           Drafting;                                          // 0x11CC(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FC[0x4];                                     // 0x11FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarVehicleDriftConfig              Drift;                                             // 0x1200(0x0718)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleDriftBoostConfig         DriftBoost;                                        // 0x1918(0x01D8)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_Gravity           Gravity;                                           // 0x1AF0(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_Jump              Jump;                                              // 0x1B0C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B24[0x4];                                     // 0x1B24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarVehicleConfig_Kickflip          Kickflip;                                          // 0x1B28(0x0150)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleOversteerConfig          Oversteer;                                         // 0x1C78(0x0138)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_Reattachment      Reattachment;                                      // 0x1DB0(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_Rubberbanding     Rubberbanding;                                     // 0x1E50(0x01B8)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_StartlineBoost    StartlineBoost;                                    // 0x2008(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_Strafe            Strafe;                                            // 0x20B0(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20CC[0x4];                                     // 0x20CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarVehicleTurboConfig              Turbo;                                             // 0x20D0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDelMarVehicleConfig_Underthrust       Underthrust;                                       // 0x2140(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleConfigs">();
	}
	static class UDelMarVehicleConfigs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleConfigs>();
	}
};
static_assert(alignof(UDelMarVehicleConfigs) == 0x000008, "Wrong alignment on UDelMarVehicleConfigs");
static_assert(sizeof(UDelMarVehicleConfigs) == 0x002208, "Wrong size on UDelMarVehicleConfigs");
static_assert(offsetof(UDelMarVehicleConfigs, Collision) == 0x000948, "Member 'UDelMarVehicleConfigs::Collision' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, DefaultBodySetup) == 0x000B60, "Member 'UDelMarVehicleConfigs::DefaultBodySetup' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, BodySetupMap) == 0x000B68, "Member 'UDelMarVehicleConfigs::BodySetupMap' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, DriveSetup) == 0x000B70, "Member 'UDelMarVehicleConfigs::DriveSetup' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, PhysMatAttributeMap) == 0x000ED0, "Member 'UDelMarVehicleConfigs::PhysMatAttributeMap' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, RigidBody) == 0x000ED8, "Member 'UDelMarVehicleConfigs::RigidBody' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Terrain) == 0x000F18, "Member 'UDelMarVehicleConfigs::Terrain' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, WorldBonusSpeed) == 0x000F38, "Member 'UDelMarVehicleConfigs::WorldBonusSpeed' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, AerialRotation) == 0x000F68, "Member 'UDelMarVehicleConfigs::AerialRotation' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, AirControl) == 0x001008, "Member 'UDelMarVehicleConfigs::AirControl' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, AirFreestyle) == 0x0010D8, "Member 'UDelMarVehicleConfigs::AirFreestyle' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, AirThrottle) == 0x001108, "Member 'UDelMarVehicleConfigs::AirThrottle' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, AutoUpright) == 0x0011A8, "Member 'UDelMarVehicleConfigs::AutoUpright' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Drafting) == 0x0011CC, "Member 'UDelMarVehicleConfigs::Drafting' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Drift) == 0x001200, "Member 'UDelMarVehicleConfigs::Drift' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, DriftBoost) == 0x001918, "Member 'UDelMarVehicleConfigs::DriftBoost' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Gravity) == 0x001AF0, "Member 'UDelMarVehicleConfigs::Gravity' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Jump) == 0x001B0C, "Member 'UDelMarVehicleConfigs::Jump' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Kickflip) == 0x001B28, "Member 'UDelMarVehicleConfigs::Kickflip' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Oversteer) == 0x001C78, "Member 'UDelMarVehicleConfigs::Oversteer' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Reattachment) == 0x001DB0, "Member 'UDelMarVehicleConfigs::Reattachment' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Rubberbanding) == 0x001E50, "Member 'UDelMarVehicleConfigs::Rubberbanding' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, StartlineBoost) == 0x002008, "Member 'UDelMarVehicleConfigs::StartlineBoost' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Strafe) == 0x0020B0, "Member 'UDelMarVehicleConfigs::Strafe' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Turbo) == 0x0020D0, "Member 'UDelMarVehicleConfigs::Turbo' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleConfigs, Underthrust) == 0x002140, "Member 'UDelMarVehicleConfigs::Underthrust' has a wrong offset!");

// Class DelMarCore.DelMarVehicleCosmeticComponent
// 0x0050 (0x00F0 - 0x00A0)
class UDelMarVehicleCosmeticComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ADelMarCosmeticActor* CosmeticActor)> OnCosmeticActorSpawned;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllCosmeticActorsSpawned;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           StaticCosmeticActorClasses;                        // 0x00C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ADelMarCosmeticActor>> AllowedServerCosmeticActorClasses;                 // 0x00D0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ADelMarCosmeticActor*>           SpawnedCosmeticActors;                             // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	class ADelMarCosmeticActor* GetCosmeticActor(TSubclassOf<class ADelMarCosmeticActor> CosmeticClass, bool bLookForChildClasses) const;
	TArray<class ADelMarCosmeticActor*> GetCosmeticActors(TSubclassOf<class ADelMarCosmeticActor> CosmeticClass, bool bLookForChildClasses) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleCosmeticComponent">();
	}
	static class UDelMarVehicleCosmeticComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleCosmeticComponent>();
	}
};
static_assert(alignof(UDelMarVehicleCosmeticComponent) == 0x000008, "Wrong alignment on UDelMarVehicleCosmeticComponent");
static_assert(sizeof(UDelMarVehicleCosmeticComponent) == 0x0000F0, "Wrong size on UDelMarVehicleCosmeticComponent");
static_assert(offsetof(UDelMarVehicleCosmeticComponent, OnCosmeticActorSpawned) == 0x0000A0, "Member 'UDelMarVehicleCosmeticComponent::OnCosmeticActorSpawned' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCosmeticComponent, OnAllCosmeticActorsSpawned) == 0x0000B0, "Member 'UDelMarVehicleCosmeticComponent::OnAllCosmeticActorsSpawned' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCosmeticComponent, StaticCosmeticActorClasses) == 0x0000C0, "Member 'UDelMarVehicleCosmeticComponent::StaticCosmeticActorClasses' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCosmeticComponent, AllowedServerCosmeticActorClasses) == 0x0000D0, "Member 'UDelMarVehicleCosmeticComponent::AllowedServerCosmeticActorClasses' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleCosmeticComponent, SpawnedCosmeticActors) == 0x0000E0, "Member 'UDelMarVehicleCosmeticComponent::SpawnedCosmeticActors' has a wrong offset!");

// Class DelMarCore.DelMarVehicleForceFeedbackComponent
// 0x0358 (0x03F8 - 0x00A0)
class UDelMarVehicleForceFeedbackComponent final : public UControllerComponent
{
public:
	struct FDelMarDynamicForceFeedbackEffect      DrivingForceFeedback;                              // 0x00A0(0x0128)(Edit, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   JumpForceFeedbackEffect;                           // 0x01C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   OversteerLeftForceFeedbackEffect;                  // 0x01D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   OversteerRightForceFeedbackEffect;                 // 0x01D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UForceFeedbackEffect*>           LandingForceFeedbackEffects;                       // 0x01E0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     LandingForceLevelLookupCurve;                      // 0x01F0(0x0088)(Edit, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   TurboForceFeedbackEffect;                          // 0x0278(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarDynamicForceFeedbackEffect      DriftForceFeedback;                                // 0x0280(0x0128)(Edit, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   DriftUncontrolledForceFeedbackEffect;              // 0x03A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   DriftBoostForceFeedbackEffect;                     // 0x03B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   DriftTractionForceFeedback;                        // 0x03B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTractionDriftShakeAngle;                        // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   HazardHitForceFeedback;                            // 0x03C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IDelMarVehicleInterface> Vehicle;                                           // 0x03D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class APlayerController>       CachedPlayerController;                            // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UForceFeedbackEffect>    CurrentOversteerForceFeedbackEffect;               // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLoadingScreenVisibilityChanged(bool bVisibility);
	void OnDriftActivated();
	void OnDriftBoostActivated();
	void OnDriftBoostDeactivated();
	void OnDriftControlChanged(bool bIsDriftControlled);
	void OnDriftDeactivated();
	void OnHazardHit();
	void OnJumpActivated();
	void OnTurboActivated();
	void OnTurboDeactivated();
	void OnUnderthrustActivated();
	void OnUnderthrustDeactivated();
	void OnVehicleLanded(float LandingForce, bool bLandedKickflip);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleForceFeedbackComponent">();
	}
	static class UDelMarVehicleForceFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleForceFeedbackComponent>();
	}
};
static_assert(alignof(UDelMarVehicleForceFeedbackComponent) == 0x000008, "Wrong alignment on UDelMarVehicleForceFeedbackComponent");
static_assert(sizeof(UDelMarVehicleForceFeedbackComponent) == 0x0003F8, "Wrong size on UDelMarVehicleForceFeedbackComponent");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, DrivingForceFeedback) == 0x0000A0, "Member 'UDelMarVehicleForceFeedbackComponent::DrivingForceFeedback' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, JumpForceFeedbackEffect) == 0x0001C8, "Member 'UDelMarVehicleForceFeedbackComponent::JumpForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, OversteerLeftForceFeedbackEffect) == 0x0001D0, "Member 'UDelMarVehicleForceFeedbackComponent::OversteerLeftForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, OversteerRightForceFeedbackEffect) == 0x0001D8, "Member 'UDelMarVehicleForceFeedbackComponent::OversteerRightForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, LandingForceFeedbackEffects) == 0x0001E0, "Member 'UDelMarVehicleForceFeedbackComponent::LandingForceFeedbackEffects' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, LandingForceLevelLookupCurve) == 0x0001F0, "Member 'UDelMarVehicleForceFeedbackComponent::LandingForceLevelLookupCurve' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, TurboForceFeedbackEffect) == 0x000278, "Member 'UDelMarVehicleForceFeedbackComponent::TurboForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, DriftForceFeedback) == 0x000280, "Member 'UDelMarVehicleForceFeedbackComponent::DriftForceFeedback' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, DriftUncontrolledForceFeedbackEffect) == 0x0003A8, "Member 'UDelMarVehicleForceFeedbackComponent::DriftUncontrolledForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, DriftBoostForceFeedbackEffect) == 0x0003B0, "Member 'UDelMarVehicleForceFeedbackComponent::DriftBoostForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, DriftTractionForceFeedback) == 0x0003B8, "Member 'UDelMarVehicleForceFeedbackComponent::DriftTractionForceFeedback' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, MaxTractionDriftShakeAngle) == 0x0003C0, "Member 'UDelMarVehicleForceFeedbackComponent::MaxTractionDriftShakeAngle' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, HazardHitForceFeedback) == 0x0003C8, "Member 'UDelMarVehicleForceFeedbackComponent::HazardHitForceFeedback' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, Vehicle) == 0x0003D0, "Member 'UDelMarVehicleForceFeedbackComponent::Vehicle' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, CachedPlayerController) == 0x0003E0, "Member 'UDelMarVehicleForceFeedbackComponent::CachedPlayerController' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleForceFeedbackComponent, CurrentOversteerForceFeedbackEffect) == 0x0003E8, "Member 'UDelMarVehicleForceFeedbackComponent::CurrentOversteerForceFeedbackEffect' has a wrong offset!");

// Class DelMarCore.DelMarVehicleMovementSet
// 0x0078 (0x00A8 - 0x0030)
class UDelMarVehicleMovementSet final : public UFortAttributeSet
{
public:
	struct FFortGameplayAttributeData             AccelMultiplier;                                   // 0x0030(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             bVehicleThrottleDisabled;                          // 0x0058(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             BonusSpeed;                                        // 0x0080(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_AccelMultiplier(const struct FFortGameplayAttributeData& OldSpeedMultiplier);
	void OnRep_BonusSpeed(const struct FFortGameplayAttributeData& OldBonusSpeed);
	void OnRep_VehicleThrottleDisabled(const struct FFortGameplayAttributeData& OldInputDisabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarVehicleMovementSet">();
	}
	static class UDelMarVehicleMovementSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarVehicleMovementSet>();
	}
};
static_assert(alignof(UDelMarVehicleMovementSet) == 0x000008, "Wrong alignment on UDelMarVehicleMovementSet");
static_assert(sizeof(UDelMarVehicleMovementSet) == 0x0000A8, "Wrong size on UDelMarVehicleMovementSet");
static_assert(offsetof(UDelMarVehicleMovementSet, AccelMultiplier) == 0x000030, "Member 'UDelMarVehicleMovementSet::AccelMultiplier' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleMovementSet, bVehicleThrottleDisabled) == 0x000058, "Member 'UDelMarVehicleMovementSet::bVehicleThrottleDisabled' has a wrong offset!");
static_assert(offsetof(UDelMarVehicleMovementSet, BonusSpeed) == 0x000080, "Member 'UDelMarVehicleMovementSet::BonusSpeed' has a wrong offset!");

}

