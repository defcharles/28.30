#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mover

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "NetworkPrediction_classes.hpp"
#include "Mover_structs.hpp"
#include "AnimGraphRuntime_classes.hpp"


namespace SDK
{

// Class Mover.CommonLegacyMovementSettings
// 0x0050 (0x0078 - 0x0028)
class UCommonLegacyMovementSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GroundMovementModeName;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AirMovementModeName;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSlopeCosine;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorSweepDistance;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSeparateBrakingFriction : 1;                   // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrakingFriction;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactor;                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deceleration;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningRate;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningBoost;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpUpwardsSpeed;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimmingStartImmersionDepth;                       // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimmingIdealImmersionDepth;                       // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimmingStopImmersionDepth;                        // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonLegacyMovementSettings">();
	}
	static class UCommonLegacyMovementSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonLegacyMovementSettings>();
	}
};
static_assert(alignof(UCommonLegacyMovementSettings) == 0x000008, "Wrong alignment on UCommonLegacyMovementSettings");
static_assert(sizeof(UCommonLegacyMovementSettings) == 0x000078, "Wrong size on UCommonLegacyMovementSettings");
static_assert(offsetof(UCommonLegacyMovementSettings, GroundMovementModeName) == 0x000030, "Member 'UCommonLegacyMovementSettings::GroundMovementModeName' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, AirMovementModeName) == 0x000034, "Member 'UCommonLegacyMovementSettings::AirMovementModeName' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, MaxWalkSlopeCosine) == 0x000038, "Member 'UCommonLegacyMovementSettings::MaxWalkSlopeCosine' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, FloorSweepDistance) == 0x00003C, "Member 'UCommonLegacyMovementSettings::FloorSweepDistance' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, MaxStepHeight) == 0x000040, "Member 'UCommonLegacyMovementSettings::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, MaxSpeed) == 0x000044, "Member 'UCommonLegacyMovementSettings::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, GroundFriction) == 0x000048, "Member 'UCommonLegacyMovementSettings::GroundFriction' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, BrakingFriction) == 0x000050, "Member 'UCommonLegacyMovementSettings::BrakingFriction' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, BrakingFrictionFactor) == 0x000054, "Member 'UCommonLegacyMovementSettings::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, Deceleration) == 0x000058, "Member 'UCommonLegacyMovementSettings::Deceleration' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, Acceleration) == 0x00005C, "Member 'UCommonLegacyMovementSettings::Acceleration' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, TurningRate) == 0x000060, "Member 'UCommonLegacyMovementSettings::TurningRate' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, TurningBoost) == 0x000064, "Member 'UCommonLegacyMovementSettings::TurningBoost' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, JumpUpwardsSpeed) == 0x000068, "Member 'UCommonLegacyMovementSettings::JumpUpwardsSpeed' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, SwimmingStartImmersionDepth) == 0x00006C, "Member 'UCommonLegacyMovementSettings::SwimmingStartImmersionDepth' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, SwimmingIdealImmersionDepth) == 0x000070, "Member 'UCommonLegacyMovementSettings::SwimmingIdealImmersionDepth' has a wrong offset!");
static_assert(offsetof(UCommonLegacyMovementSettings, SwimmingStopImmersionDepth) == 0x000074, "Member 'UCommonLegacyMovementSettings::SwimmingStopImmersionDepth' has a wrong offset!");

// Class Mover.TurnGeneratorInterface
// 0x0000 (0x0028 - 0x0028)
class ITurnGeneratorInterface final : public IInterface
{
public:
	struct FRotator GetTurn(const struct FRotator& TargetOrientation, const struct FMoverTickStartData& FullStartState, const struct FMoverDefaultSyncState& MoverState, const struct FMoverTimeStep& TimeStep, const struct FProposedMove& ProposedMove, class UMoverBlackboard* SimBlackboard);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurnGeneratorInterface">();
	}
	static class ITurnGeneratorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITurnGeneratorInterface>();
	}
};
static_assert(alignof(ITurnGeneratorInterface) == 0x000008, "Wrong alignment on ITurnGeneratorInterface");
static_assert(sizeof(ITurnGeneratorInterface) == 0x000028, "Wrong size on ITurnGeneratorInterface");

// Class Mover.LinearTurnGenerator
// 0x0018 (0x0040 - 0x0028)
class ULinearTurnGenerator final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadingRate;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRate;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollRate;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LinearTurnGenerator">();
	}
	static class ULinearTurnGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULinearTurnGenerator>();
	}
};
static_assert(alignof(ULinearTurnGenerator) == 0x000008, "Wrong alignment on ULinearTurnGenerator");
static_assert(sizeof(ULinearTurnGenerator) == 0x000040, "Wrong size on ULinearTurnGenerator");
static_assert(offsetof(ULinearTurnGenerator, HeadingRate) == 0x000030, "Member 'ULinearTurnGenerator::HeadingRate' has a wrong offset!");
static_assert(offsetof(ULinearTurnGenerator, PitchRate) == 0x000034, "Member 'ULinearTurnGenerator::PitchRate' has a wrong offset!");
static_assert(offsetof(ULinearTurnGenerator, RollRate) == 0x000038, "Member 'ULinearTurnGenerator::RollRate' has a wrong offset!");

// Class Mover.ExactDampedTurnGenerator
// 0x0010 (0x0038 - 0x0028)
class UExactDampedTurnGenerator final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HalfLifeSeconds;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExactDampedTurnGenerator">();
	}
	static class UExactDampedTurnGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExactDampedTurnGenerator>();
	}
};
static_assert(alignof(UExactDampedTurnGenerator) == 0x000008, "Wrong alignment on UExactDampedTurnGenerator");
static_assert(sizeof(UExactDampedTurnGenerator) == 0x000038, "Wrong size on UExactDampedTurnGenerator");
static_assert(offsetof(UExactDampedTurnGenerator, HalfLifeSeconds) == 0x000030, "Member 'UExactDampedTurnGenerator::HalfLifeSeconds' has a wrong offset!");

// Class Mover.BlueprintableTurnGenerator
// 0x0008 (0x0030 - 0x0028)
class UBlueprintableTurnGenerator final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintableTurnGenerator">();
	}
	static class UBlueprintableTurnGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintableTurnGenerator>();
	}
};
static_assert(alignof(UBlueprintableTurnGenerator) == 0x000008, "Wrong alignment on UBlueprintableTurnGenerator");
static_assert(sizeof(UBlueprintableTurnGenerator) == 0x000030, "Wrong size on UBlueprintableTurnGenerator");

// Class Mover.MoverBackendLiaisonInterface
// 0x0000 (0x0028 - 0x0028)
class IMoverBackendLiaisonInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverBackendLiaisonInterface">();
	}
	static class IMoverBackendLiaisonInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMoverBackendLiaisonInterface>();
	}
};
static_assert(alignof(IMoverBackendLiaisonInterface) == 0x000008, "Wrong alignment on IMoverBackendLiaisonInterface");
static_assert(sizeof(IMoverBackendLiaisonInterface) == 0x000028, "Wrong size on IMoverBackendLiaisonInterface");

// Class Mover.MoverBasePawn
// 0x0008 (0x0320 - 0x0318)
class AMoverBasePawn final : public APawn
{
public:
	class UMoverComponent*                        CharacterMotionComponent;                          // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UMoverComponent* GetMoverComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverBasePawn">();
	}
	static class AMoverBasePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoverBasePawn>();
	}
};
static_assert(alignof(AMoverBasePawn) == 0x000008, "Wrong alignment on AMoverBasePawn");
static_assert(sizeof(AMoverBasePawn) == 0x000320, "Wrong size on AMoverBasePawn");
static_assert(offsetof(AMoverBasePawn, CharacterMotionComponent) == 0x000318, "Member 'AMoverBasePawn::CharacterMotionComponent' has a wrong offset!");

// Class Mover.MoverBlackboard
// 0x0050 (0x0078 - 0x0028)
class UMoverBlackboard final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverBlackboard">();
	}
	static class UMoverBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoverBlackboard>();
	}
};
static_assert(alignof(UMoverBlackboard) == 0x000008, "Wrong alignment on UMoverBlackboard");
static_assert(sizeof(UMoverBlackboard) == 0x000078, "Wrong size on UMoverBlackboard");

// Class Mover.MoverDataModelBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UMoverDataModelBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetLocationFromSyncState(const struct FMoverDefaultSyncState& SyncState);
	static struct FVector GetMoveDirectionIntentFromInputs(const struct FKinematicDefaultInputs& Inputs);
	static struct FVector GetMoveDirectionIntentFromSyncState(const struct FMoverDefaultSyncState& SyncState);
	static struct FRotator GetOrientationFromSyncState(const struct FMoverDefaultSyncState& SyncState);
	static struct FVector GetVelocityFromSyncState(const struct FMoverDefaultSyncState& SyncState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverDataModelBlueprintLibrary">();
	}
	static class UMoverDataModelBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoverDataModelBlueprintLibrary>();
	}
};
static_assert(alignof(UMoverDataModelBlueprintLibrary) == 0x000008, "Wrong alignment on UMoverDataModelBlueprintLibrary");
static_assert(sizeof(UMoverDataModelBlueprintLibrary) == 0x000028, "Wrong size on UMoverDataModelBlueprintLibrary");

// Class Mover.MoverDebugComponent
// 0x0078 (0x0118 - 0x00A0)
class UMoverDebugComponent final : public UActorComponent
{
public:
	float                                         LookaheadSeconds;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LookaheadSamplesPerSecond;                         // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTrajectory;                                   // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTrail;                                        // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCorrections;                                  // 0x00AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x1];                                       // 0x00AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HistoryTrackingSeconds;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HistorySamplesPerSecond;                           // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x64];                                      // 0x00B4(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHistoryTrackingRollback(const struct FMoverTimeStep& NewTimeStep, const struct FMoverTimeStep& InvalidatedTimeStep);
	void OnMovementSimRollback(const struct FMoverTimeStep& NewTimeStep, const struct FMoverTimeStep& InvalidatedTimeStep);
	void OnMovementSimTick(const struct FMoverTimeStep& TimeStep);
	void SetHistoryTracking(float SecondsToTrack, float SamplesPerSecond);

	TArray<struct FTrajectorySampleInfo> GetFutureTrajectory(float FutureSeconds, float SamplesPerSecond) const;
	TArray<struct FTrajectorySampleInfo> GetPastTrajectory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverDebugComponent">();
	}
	static class UMoverDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoverDebugComponent>();
	}
};
static_assert(alignof(UMoverDebugComponent) == 0x000008, "Wrong alignment on UMoverDebugComponent");
static_assert(sizeof(UMoverDebugComponent) == 0x000118, "Wrong size on UMoverDebugComponent");
static_assert(offsetof(UMoverDebugComponent, LookaheadSeconds) == 0x0000A0, "Member 'UMoverDebugComponent::LookaheadSeconds' has a wrong offset!");
static_assert(offsetof(UMoverDebugComponent, LookaheadSamplesPerSecond) == 0x0000A4, "Member 'UMoverDebugComponent::LookaheadSamplesPerSecond' has a wrong offset!");
static_assert(offsetof(UMoverDebugComponent, bShowTrajectory) == 0x0000A8, "Member 'UMoverDebugComponent::bShowTrajectory' has a wrong offset!");
static_assert(offsetof(UMoverDebugComponent, bShowTrail) == 0x0000A9, "Member 'UMoverDebugComponent::bShowTrail' has a wrong offset!");
static_assert(offsetof(UMoverDebugComponent, bShowCorrections) == 0x0000AA, "Member 'UMoverDebugComponent::bShowCorrections' has a wrong offset!");
static_assert(offsetof(UMoverDebugComponent, HistoryTrackingSeconds) == 0x0000AC, "Member 'UMoverDebugComponent::HistoryTrackingSeconds' has a wrong offset!");
static_assert(offsetof(UMoverDebugComponent, HistorySamplesPerSecond) == 0x0000B0, "Member 'UMoverDebugComponent::HistorySamplesPerSecond' has a wrong offset!");

// Class Mover.MoverDeveloperSettings
// 0x0008 (0x0038 - 0x0030)
class UMoverDeveloperSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	int32                                         MaxTimesToRefundSubstep;                           // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverDeveloperSettings">();
	}
	static class UMoverDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoverDeveloperSettings>();
	}
};
static_assert(alignof(UMoverDeveloperSettings) == 0x000008, "Wrong alignment on UMoverDeveloperSettings");
static_assert(sizeof(UMoverDeveloperSettings) == 0x000038, "Wrong size on UMoverDeveloperSettings");
static_assert(offsetof(UMoverDeveloperSettings, MaxTimesToRefundSubstep) == 0x000030, "Member 'UMoverDeveloperSettings::MaxTimesToRefundSubstep' has a wrong offset!");

// Class Mover.MoverNetworkPhysicsLiaisonComponent
// 0x0068 (0x0108 - 0x00A0)
class UMoverNetworkPhysicsLiaisonComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x68];                                      // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverNetworkPhysicsLiaisonComponent">();
	}
	static class UMoverNetworkPhysicsLiaisonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoverNetworkPhysicsLiaisonComponent>();
	}
};
static_assert(alignof(UMoverNetworkPhysicsLiaisonComponent) == 0x000008, "Wrong alignment on UMoverNetworkPhysicsLiaisonComponent");
static_assert(sizeof(UMoverNetworkPhysicsLiaisonComponent) == 0x000108, "Wrong size on UMoverNetworkPhysicsLiaisonComponent");

// Class Mover.MoverNetworkPredictionLiaisonComponent
// 0x0010 (0x02A0 - 0x0290)
class UMoverNetworkPredictionLiaisonComponent final : public UNetworkPredictionComponent
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverNetworkPredictionLiaisonComponent">();
	}
	static class UMoverNetworkPredictionLiaisonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoverNetworkPredictionLiaisonComponent>();
	}
};
static_assert(alignof(UMoverNetworkPredictionLiaisonComponent) == 0x000010, "Wrong alignment on UMoverNetworkPredictionLiaisonComponent");
static_assert(sizeof(UMoverNetworkPredictionLiaisonComponent) == 0x0002A0, "Wrong size on UMoverNetworkPredictionLiaisonComponent");

// Class Mover.MoverInputProducerInterface
// 0x0000 (0x0028 - 0x0028)
class IMoverInputProducerInterface final : public IInterface
{
public:
	void ProduceInput(int32 SimTimeMs, struct FMoverInputCmdContext* InputCmdResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverInputProducerInterface">();
	}
	static class IMoverInputProducerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMoverInputProducerInterface>();
	}
};
static_assert(alignof(IMoverInputProducerInterface) == 0x000008, "Wrong alignment on IMoverInputProducerInterface");
static_assert(sizeof(IMoverInputProducerInterface) == 0x000028, "Wrong size on IMoverInputProducerInterface");

// Class Mover.MoverDataCollectionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMoverDataCollectionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void K2_AddDataToCollection(struct FMoverDataCollection& Collection, const int32& SourceAsRawBytes);
	static void K2_GetDataFromCollection(bool* DidSucceed, const struct FMoverDataCollection& Collection, int32* TargetAsRawBytes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverDataCollectionLibrary">();
	}
	static class UMoverDataCollectionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoverDataCollectionLibrary>();
	}
};
static_assert(alignof(UMoverDataCollectionLibrary) == 0x000008, "Wrong alignment on UMoverDataCollectionLibrary");
static_assert(sizeof(UMoverDataCollectionLibrary) == 0x000028, "Wrong size on UMoverDataCollectionLibrary");

// Class Mover.PhysicsCharacterMovementModeInterface
// 0x0000 (0x0028 - 0x0028)
class IPhysicsCharacterMovementModeInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsCharacterMovementModeInterface">();
	}
	static class IPhysicsCharacterMovementModeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPhysicsCharacterMovementModeInterface>();
	}
};
static_assert(alignof(IPhysicsCharacterMovementModeInterface) == 0x000008, "Wrong alignment on IPhysicsCharacterMovementModeInterface");
static_assert(sizeof(IPhysicsCharacterMovementModeInterface) == 0x000028, "Wrong size on IPhysicsCharacterMovementModeInterface");

// Class Mover.BaseMovementMode
// 0x0010 (0x0038 - 0x0028)
class UBaseMovementMode : public UObject
{
public:
	TSubclassOf<class UObject>                    SharedSettingsClass;                               // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnRegistered(const class FName ModeName);
	struct FMoverTickEndData K2_OnSimulationTick(const struct FSimulationTickParams& Params_0);
	void K2_OnUnregistered();

	const class UMoverBlackboard* GetBlackboard() const;
	class UMoverBlackboard* GetBlackboard_Mutable() const;
	class UMoverComponent* GetMoverComponent() const;
	struct FProposedMove K2_OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMovementMode">();
	}
	static class UBaseMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseMovementMode>();
	}
};
static_assert(alignof(UBaseMovementMode) == 0x000008, "Wrong alignment on UBaseMovementMode");
static_assert(sizeof(UBaseMovementMode) == 0x000038, "Wrong size on UBaseMovementMode");
static_assert(offsetof(UBaseMovementMode, SharedSettingsClass) == 0x000028, "Member 'UBaseMovementMode::SharedSettingsClass' has a wrong offset!");

// Class Mover.FallingMode
// 0x0038 (0x0070 - 0x0038)
class UFallingMode : public UBaseMovementMode
{
public:
	TMulticastInlineDelegate<void(class FName& NextMovementModeName, struct FHitResult& HitResult)> OnLanded;                                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         AirControlPercentage;                              // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingDeceleration;                               // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverTerminalSpeedFallingDeceleration;              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerminalMovementPlaneSpeed;                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldClampTerminalVerticalSpeed;                 // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalFallingDeceleration;                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerminalVerticalSpeed;                             // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState);

	void OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const;
	void ProcessLanded(const struct FFloorCheckResult& FloorResult, struct FVector* Velocity, struct FRelativeBaseInfo* BaseInfo, struct FMoverTickEndData* TickEndData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingMode">();
	}
	static class UFallingMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingMode>();
	}
};
static_assert(alignof(UFallingMode) == 0x000008, "Wrong alignment on UFallingMode");
static_assert(sizeof(UFallingMode) == 0x000070, "Wrong size on UFallingMode");
static_assert(offsetof(UFallingMode, OnLanded) == 0x000038, "Member 'UFallingMode::OnLanded' has a wrong offset!");
static_assert(offsetof(UFallingMode, AirControlPercentage) == 0x000048, "Member 'UFallingMode::AirControlPercentage' has a wrong offset!");
static_assert(offsetof(UFallingMode, FallingDeceleration) == 0x00004C, "Member 'UFallingMode::FallingDeceleration' has a wrong offset!");
static_assert(offsetof(UFallingMode, OverTerminalSpeedFallingDeceleration) == 0x000050, "Member 'UFallingMode::OverTerminalSpeedFallingDeceleration' has a wrong offset!");
static_assert(offsetof(UFallingMode, TerminalMovementPlaneSpeed) == 0x000054, "Member 'UFallingMode::TerminalMovementPlaneSpeed' has a wrong offset!");
static_assert(offsetof(UFallingMode, bShouldClampTerminalVerticalSpeed) == 0x000058, "Member 'UFallingMode::bShouldClampTerminalVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UFallingMode, VerticalFallingDeceleration) == 0x00005C, "Member 'UFallingMode::VerticalFallingDeceleration' has a wrong offset!");
static_assert(offsetof(UFallingMode, TerminalVerticalSpeed) == 0x000060, "Member 'UFallingMode::TerminalVerticalSpeed' has a wrong offset!");

// Class Mover.FlyingMode
// 0x0008 (0x0040 - 0x0038)
class UFlyingMode final : public UBaseMovementMode
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState);

	void OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlyingMode">();
	}
	static class UFlyingMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlyingMode>();
	}
};
static_assert(alignof(UFlyingMode) == 0x000008, "Wrong alignment on UFlyingMode");
static_assert(sizeof(UFlyingMode) == 0x000040, "Wrong size on UFlyingMode");

// Class Mover.SwimmingMode
// 0x0008 (0x0040 - 0x0038)
class USwimmingMode : public UBaseMovementMode
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState);

	void OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwimmingMode">();
	}
	static class USwimmingMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwimmingMode>();
	}
};
static_assert(alignof(USwimmingMode) == 0x000008, "Wrong alignment on USwimmingMode");
static_assert(sizeof(USwimmingMode) == 0x000040, "Wrong size on USwimmingMode");

// Class Mover.WalkingMode
// 0x0010 (0x0048 - 0x0038)
class UWalkingMode : public UBaseMovementMode
{
public:
	class UObject*                                TurnGenerator;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState);

	void OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalkingMode">();
	}
	static class UWalkingMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalkingMode>();
	}
};
static_assert(alignof(UWalkingMode) == 0x000008, "Wrong alignment on UWalkingMode");
static_assert(sizeof(UWalkingMode) == 0x000048, "Wrong size on UWalkingMode");
static_assert(offsetof(UWalkingMode, TurnGenerator) == 0x000038, "Member 'UWalkingMode::TurnGenerator' has a wrong offset!");

// Class Mover.MovementBaseUtils
// 0x0000 (0x0028 - 0x0028)
class UMovementBaseUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool GetMovementBaseTransform(const class UPrimitiveComponent* MovementBase, const class FName BoneName, struct FVector* OutLocation, struct FQuat* OutQuat);
	static bool IsADynamicBase(const class UPrimitiveComponent* MovementBase);
	static bool TransformBasedDirectionToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& LocalDirection, struct FVector* OutDirectionWorldSpace);
	static bool TransformBasedLocationToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& LocalLocation, struct FVector* OutLocationWorldSpace);
	static bool TransformBasedRotatorToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FRotator& LocalRotator, struct FRotator* OutWorldSpaceRotator);
	static void TransformDirectionToLocal(const struct FQuat& BaseQuat, const struct FVector& WorldSpaceDirection, struct FVector* OutLocalDirection);
	static void TransformDirectionToWorld(const struct FQuat& BaseQuat, const struct FVector& LocalDirection, struct FVector* OutDirectionWorldSpace);
	static void TransformLocationToLocal(const struct FVector& BasePos, const struct FQuat& BaseQuat, const struct FVector& WorldSpaceLocation, struct FVector* OutLocalLocation);
	static void TransformLocationToWorld(const struct FVector& BasePos, const struct FQuat& BaseQuat, const struct FVector& LocalLocation, struct FVector* OutLocationWorldSpace);
	static void TransformRotatorToLocal(const struct FQuat& BaseQuat, const struct FRotator& WorldSpaceRotator, struct FRotator* OutLocalRotator);
	static void TransformRotatorToWorld(const struct FQuat& BaseQuat, const struct FRotator& LocalRotator, struct FRotator* OutWorldSpaceRotator);
	static bool TransformWorldDirectionToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& WorldSpaceDirection, struct FVector* OutLocalDirection);
	static bool TransformWorldLocationToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& WorldSpaceLocation, struct FVector* OutLocalLocation);
	static bool TransformWorldRotatorToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FRotator& WorldSpaceRotator, struct FRotator* OutLocalRotator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementBaseUtils">();
	}
	static class UMovementBaseUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementBaseUtils>();
	}
};
static_assert(alignof(UMovementBaseUtils) == 0x000008, "Wrong alignment on UMovementBaseUtils");
static_assert(sizeof(UMovementBaseUtils) == 0x000028, "Wrong size on UMovementBaseUtils");

// Class Mover.MovementUtils
// 0x0000 (0x0028 - 0x0028)
class UMovementUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool CanEscapeGravity(const struct FVector& PriorVelocity, const struct FVector& NewVelocity, const struct FVector& GravityAccel, float DeltaSeconds);
	static bool CanStepUpOnHitSurface(const struct FHitResult& Hit);
	static struct FRotator ComputeAngularVelocity(const struct FRotator& From, const struct FRotator& To, float DeltaSeconds, float TurningRateLimit);
	static struct FProposedMove ComputeControlledFreeMove(const struct FFreeMoveParams& InParams);
	static struct FProposedMove ComputeControlledGroundMove(const struct FGroundMoveParams& InParams);
	static struct FVector ComputeDeflectedMoveOntoRamp(const struct FVector& OrigMoveDelta, const struct FHitResult& RampHitResult, float MaxWalkSlopeCosine, const bool bHitFromLineTrace);
	static struct FVector ComputeDirectionIntent(const struct FVector& MoveInput, EMoveInputType MoveInputType);
	static struct FVector ComputeSlideDelta(const struct FVector& Delta, const float PctOfDeltaToMove, const struct FVector& Normal, const struct FHitResult& Hit);
	static struct FVector ComputeVelocity(const struct FComputeVelocityParams& InParams);
	static struct FVector ComputeVelocityFromGravity(const struct FVector& GravityAccel, float DeltaSeconds);
	static struct FVector ComputeVelocityFromPositions(const struct FVector& FromPos, const struct FVector& ToPos, float DeltaSeconds);
	static struct FVector ConstrainToPlane(const struct FVector& Vector, const struct FPlane& MovementPlane, bool bMaintainMagnitude);
	static bool IsExceedingMaxSpeed(const struct FVector& Velocity, float InMaxSpeed);
	static bool IsHitSurfaceWalkable(const struct FHitResult& Hit, float MaxWalkSlopeCosine);
	static bool IsValidLandingSpot(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, const struct FVector& Location, const struct FHitResult& Hit, float FloorSweepDistance, float MaxWalkSlopeCosine, struct FFloorCheckResult* OutFloorResult);
	static float TryMoveToFallAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, float FloorSweepDistance, float MaxWalkSlopeCosine, struct FFloorCheckResult* OutFloorResult, struct FMovementRecord* MoveRecord);
	static float TryMoveToSlideAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, struct FMovementRecord* MoveRecord);
	static bool TrySafeMoveUpdatedComponent(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, const struct FVector& Delta, const struct FQuat& NewRotation, bool bSweep, struct FHitResult* OutHit, ETeleportType Teleport, struct FMovementRecord* MoveRecord);
	static float TryWalkToSlideAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, struct FMovementRecord* MoveRecord, float MaxWalkSlopeCosine);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementUtils">();
	}
	static class UMovementUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementUtils>();
	}
};
static_assert(alignof(UMovementUtils) == 0x000008, "Wrong alignment on UMovementUtils");
static_assert(sizeof(UMovementUtils) == 0x000028, "Wrong size on UMovementUtils");

// Class Mover.PlayMoverMontageCallbackProxy
// 0x0000 (0x00A8 - 0x00A8)
class UPlayMoverMontageCallbackProxy final : public UPlayMontageCallbackProxy
{
public:
	static class UPlayMoverMontageCallbackProxy* CreateProxyObjectForPlayMoverMontage(class UMoverComponent* InMoverComponent, class UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, class FName StartingSection);

	void OnMoverMontageEnded(class FName IgnoredNotifyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayMoverMontageCallbackProxy">();
	}
	static class UPlayMoverMontageCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayMoverMontageCallbackProxy>();
	}
};
static_assert(alignof(UPlayMoverMontageCallbackProxy) == 0x000008, "Wrong alignment on UPlayMoverMontageCallbackProxy");
static_assert(sizeof(UPlayMoverMontageCallbackProxy) == 0x0000A8, "Wrong size on UPlayMoverMontageCallbackProxy");

// Class Mover.MovementSettingsInterface
// 0x0000 (0x0028 - 0x0028)
class IMovementSettingsInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementSettingsInterface">();
	}
	static class IMovementSettingsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovementSettingsInterface>();
	}
};
static_assert(alignof(IMovementSettingsInterface) == 0x000008, "Wrong alignment on IMovementSettingsInterface");
static_assert(sizeof(IMovementSettingsInterface) == 0x000028, "Wrong size on IMovementSettingsInterface");

// Class Mover.NullMovementMode
// 0x0000 (0x0038 - 0x0038)
class UNullMovementMode final : public UBaseMovementMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NullMovementMode">();
	}
	static class UNullMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNullMovementMode>();
	}
};
static_assert(alignof(UNullMovementMode) == 0x000008, "Wrong alignment on UNullMovementMode");
static_assert(sizeof(UNullMovementMode) == 0x000038, "Wrong size on UNullMovementMode");

// Class Mover.MovementModeStateMachine
// 0x0070 (0x0098 - 0x0028)
class UMovementModeStateMachine final : public UObject
{
public:
	TMap<class FName, class UBaseMovementMode*>   Modes;                                             // 0x0028(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementModeStateMachine">();
	}
	static class UMovementModeStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementModeStateMachine>();
	}
};
static_assert(alignof(UMovementModeStateMachine) == 0x000008, "Wrong alignment on UMovementModeStateMachine");
static_assert(sizeof(UMovementModeStateMachine) == 0x000098, "Wrong size on UMovementModeStateMachine");
static_assert(offsetof(UMovementModeStateMachine, Modes) == 0x000028, "Member 'UMovementModeStateMachine::Modes' has a wrong offset!");

// Class Mover.MoverComponent
// 0x01A8 (0x0248 - 0x00A0)
class UMoverComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(struct FMoverTimeStep& TimeStep, struct FMoverInputCmdContext& InputCmd)> OnPreSimulationTick;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FMoverTimeStep& TimeStep)> OnPostSimulationTick;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FMoverTimeStep& CurrentTimeStep, struct FMoverTimeStep& ExpungedTimeStep)> OnPostSimulationRollback;                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FMoverOnImpactParams& ImpactParams)> OnImpact;                                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName& PreviousMovementModeName, class FName& NewMovementModeName)> OnMovementModeChanged;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            BackendClass;                                      // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UBaseMovementMode*>   MovementModes;                                     // 0x00F8(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   StartingMovementMode;                              // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                InputProducer;                                     // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        UpdatedComponent;                                  // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    UpdatedPrimitive;                                  // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x88];                                     // 0x0168(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        SharedSettings;                                    // 0x01F0(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bHasGravityOverride;                               // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GravityAccelOverride;                              // 0x0208(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMovementModeStateMachine*              ModeFSM;                                           // 0x0228(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoverBlackboard*                       SimBlackboard;                                     // 0x0230(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleImpact(struct FMoverOnImpactParams* ImpactParams);
	void K2_QueueLayeredMove(const int32& MoveAsRawData);
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void PhysicsVolumeChanged(class APhysicsVolume* NewVolume);
	void QueueNextMode(class FName DesiredModeName, bool bShouldReenter);
	void SetGravityOverride(bool bOverrideGravity, const struct FVector& GravityAcceleration);

	class UBaseMovementMode* FindMovementMode(TSubclassOf<class UBaseMovementMode> MovementMode) const;
	const class UObject* FindSharedSettings_BP(TSubclassOf<class UObject> SharedSetting) const;
	class UObject* FindSharedSettings_Mutable_BP(TSubclassOf<class UObject> SharedSetting) const;
	struct FVector GetGravityAcceleration() const;
	const struct FMoverInputCmdContext GetLastInputCmd() const;
	class UPrimitiveComponent* GetMovementBase() const;
	class FName GetMovementBaseBoneName() const;
	struct FVector GetMovementIntent() const;
	class FName GetMovementModeName() const;
	const struct FMoverSyncState GetSyncState() const;
	struct FRotator GetTargetOrientation() const;
	struct FVector GetUpDirection() const;
	struct FVector GetVelocity() const;
	bool HasValidCachedInputCmd() const;
	bool HasValidCachedState() const;
	bool IsAirborne() const;
	bool IsFalling() const;
	bool IsOnGround() const;
	bool IsSlopeSliding() const;
	bool TryGetFloorCheckHitResult(struct FHitResult* OutHitResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoverComponent">();
	}
	static class UMoverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoverComponent>();
	}
};
static_assert(alignof(UMoverComponent) == 0x000008, "Wrong alignment on UMoverComponent");
static_assert(sizeof(UMoverComponent) == 0x000248, "Wrong size on UMoverComponent");
static_assert(offsetof(UMoverComponent, OnPreSimulationTick) == 0x0000A0, "Member 'UMoverComponent::OnPreSimulationTick' has a wrong offset!");
static_assert(offsetof(UMoverComponent, OnPostSimulationTick) == 0x0000B0, "Member 'UMoverComponent::OnPostSimulationTick' has a wrong offset!");
static_assert(offsetof(UMoverComponent, OnPostSimulationRollback) == 0x0000C0, "Member 'UMoverComponent::OnPostSimulationRollback' has a wrong offset!");
static_assert(offsetof(UMoverComponent, OnImpact) == 0x0000D0, "Member 'UMoverComponent::OnImpact' has a wrong offset!");
static_assert(offsetof(UMoverComponent, OnMovementModeChanged) == 0x0000E0, "Member 'UMoverComponent::OnMovementModeChanged' has a wrong offset!");
static_assert(offsetof(UMoverComponent, BackendClass) == 0x0000F0, "Member 'UMoverComponent::BackendClass' has a wrong offset!");
static_assert(offsetof(UMoverComponent, MovementModes) == 0x0000F8, "Member 'UMoverComponent::MovementModes' has a wrong offset!");
static_assert(offsetof(UMoverComponent, StartingMovementMode) == 0x000148, "Member 'UMoverComponent::StartingMovementMode' has a wrong offset!");
static_assert(offsetof(UMoverComponent, InputProducer) == 0x000150, "Member 'UMoverComponent::InputProducer' has a wrong offset!");
static_assert(offsetof(UMoverComponent, UpdatedComponent) == 0x000158, "Member 'UMoverComponent::UpdatedComponent' has a wrong offset!");
static_assert(offsetof(UMoverComponent, UpdatedPrimitive) == 0x000160, "Member 'UMoverComponent::UpdatedPrimitive' has a wrong offset!");
static_assert(offsetof(UMoverComponent, SharedSettings) == 0x0001F0, "Member 'UMoverComponent::SharedSettings' has a wrong offset!");
static_assert(offsetof(UMoverComponent, bHasGravityOverride) == 0x000200, "Member 'UMoverComponent::bHasGravityOverride' has a wrong offset!");
static_assert(offsetof(UMoverComponent, GravityAccelOverride) == 0x000208, "Member 'UMoverComponent::GravityAccelOverride' has a wrong offset!");
static_assert(offsetof(UMoverComponent, ModeFSM) == 0x000228, "Member 'UMoverComponent::ModeFSM' has a wrong offset!");
static_assert(offsetof(UMoverComponent, SimBlackboard) == 0x000230, "Member 'UMoverComponent::SimBlackboard' has a wrong offset!");

// Class Mover.PhysicsDrivenFallingMode
// 0x0018 (0x0088 - 0x0070)
class UPhysicsDrivenFallingMode final : public UFallingMode
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TwistTorqueLimit;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingTorqueLimit;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHeight;                                      // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsDrivenFallingMode">();
	}
	static class UPhysicsDrivenFallingMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsDrivenFallingMode>();
	}
};
static_assert(alignof(UPhysicsDrivenFallingMode) == 0x000008, "Wrong alignment on UPhysicsDrivenFallingMode");
static_assert(sizeof(UPhysicsDrivenFallingMode) == 0x000088, "Wrong size on UPhysicsDrivenFallingMode");
static_assert(offsetof(UPhysicsDrivenFallingMode, TwistTorqueLimit) == 0x000078, "Member 'UPhysicsDrivenFallingMode::TwistTorqueLimit' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenFallingMode, SwingTorqueLimit) == 0x00007C, "Member 'UPhysicsDrivenFallingMode::SwingTorqueLimit' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenFallingMode, TargetHeight) == 0x000080, "Member 'UPhysicsDrivenFallingMode::TargetHeight' has a wrong offset!");

// Class Mover.PhysicsDrivenSwimmingMode
// 0x0008 (0x0048 - 0x0040)
class UPhysicsDrivenSwimmingMode final : public USwimmingMode
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsDrivenSwimmingMode">();
	}
	static class UPhysicsDrivenSwimmingMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsDrivenSwimmingMode>();
	}
};
static_assert(alignof(UPhysicsDrivenSwimmingMode) == 0x000008, "Wrong alignment on UPhysicsDrivenSwimmingMode");
static_assert(sizeof(UPhysicsDrivenSwimmingMode) == 0x000048, "Wrong size on UPhysicsDrivenSwimmingMode");

// Class Mover.PhysicsDrivenWalkingMode
// 0x0030 (0x0078 - 0x0048)
class UPhysicsDrivenWalkingMode final : public UWalkingMode
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadialForceLimit;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrictionForceLimit;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistTorqueLimit;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingTorqueLimit;                                  // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHeight;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDamping;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FractionalVelocityToTarget;                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FractionalDownwardVelocityToTarget;                // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxUnsupportedTimeBeforeFalling;                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsDrivenWalkingMode">();
	}
	static class UPhysicsDrivenWalkingMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsDrivenWalkingMode>();
	}
};
static_assert(alignof(UPhysicsDrivenWalkingMode) == 0x000008, "Wrong alignment on UPhysicsDrivenWalkingMode");
static_assert(sizeof(UPhysicsDrivenWalkingMode) == 0x000078, "Wrong size on UPhysicsDrivenWalkingMode");
static_assert(offsetof(UPhysicsDrivenWalkingMode, RadialForceLimit) == 0x000050, "Member 'UPhysicsDrivenWalkingMode::RadialForceLimit' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenWalkingMode, FrictionForceLimit) == 0x000054, "Member 'UPhysicsDrivenWalkingMode::FrictionForceLimit' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenWalkingMode, TwistTorqueLimit) == 0x000058, "Member 'UPhysicsDrivenWalkingMode::TwistTorqueLimit' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenWalkingMode, SwingTorqueLimit) == 0x00005C, "Member 'UPhysicsDrivenWalkingMode::SwingTorqueLimit' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenWalkingMode, TargetHeight) == 0x000060, "Member 'UPhysicsDrivenWalkingMode::TargetHeight' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenWalkingMode, GroundDamping) == 0x000064, "Member 'UPhysicsDrivenWalkingMode::GroundDamping' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenWalkingMode, FractionalVelocityToTarget) == 0x000068, "Member 'UPhysicsDrivenWalkingMode::FractionalVelocityToTarget' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenWalkingMode, FractionalDownwardVelocityToTarget) == 0x00006C, "Member 'UPhysicsDrivenWalkingMode::FractionalDownwardVelocityToTarget' has a wrong offset!");
static_assert(offsetof(UPhysicsDrivenWalkingMode, MaxUnsupportedTimeBeforeFalling) == 0x000070, "Member 'UPhysicsDrivenWalkingMode::MaxUnsupportedTimeBeforeFalling' has a wrong offset!");

// Class Mover.PhysicsMoverManager
// 0x0020 (0x0050 - 0x0030)
class UPhysicsMoverManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsMoverManager">();
	}
	static class UPhysicsMoverManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsMoverManager>();
	}
};
static_assert(alignof(UPhysicsMoverManager) == 0x000008, "Wrong alignment on UPhysicsMoverManager");
static_assert(sizeof(UPhysicsMoverManager) == 0x000050, "Wrong size on UPhysicsMoverManager");

}

