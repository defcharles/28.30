#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DelMarCore

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "FortniteGame_structs.hpp"


namespace SDK
{

// Enum DelMarCore.EDelmarDraftingState
// NumValues: 0x0005
enum class EDelmarDraftingState : uint8
{
	NotActive                                = 0,
	HasTarget                                = 1,
	GainingSpeed                             = 2,
	GracePeriod                              = 3,
	LosingSpeed                              = 4,
};

// Enum DelMarCore.EDelMarVehicleDriftState
// NumValues: 0x0007
enum class EDelMarVehicleDriftState : uint8
{
	NotDrifting                              = 0,
	Drifting                                 = 1,
	InitialKick                              = 2,
	SwapKick                                 = 3,
	ExitVelocity                             = 4,
	ExitForward                              = 5,
	ForcedDrift                              = 6,
};

// Enum DelMarCore.EDelMarTurboZoneState
// NumValues: 0x0006
enum class EDelMarTurboZoneState : uint8
{
	None                                     = 0,
	Visible                                  = 1,
	Failed                                   = 2,
	Active                                   = 3,
	Success                                  = 4,
	Missed                                   = 5,
};

// Enum DelMarCore.EDelMarVehicleForwardState
// NumValues: 0x0004
enum class EDelMarVehicleForwardState : uint8
{
	None                                     = 0,
	ForwardAccel                             = 1,
	Braking                                  = 2,
	Reversing                                = 3,
};

// Enum DelMarCore.EDelMarSplineMovementType
// NumValues: 0x0003
enum class EDelMarSplineMovementType : uint8
{
	OneShot                                  = 0,
	Repeat                                   = 1,
	PingPong                                 = 2,
};

// Enum DelMarCore.EDelMarFloatOperation
// NumValues: 0x0008
enum class EDelMarFloatOperation : uint8
{
	DMFO_Set                                 = 0,
	DMFO_Add                                 = 1,
	DMFO_Subtract                            = 2,
	DMFO_Multiply                            = 3,
	DMFO_BaseMultiply                        = 4,
	DMFO_Divide                              = 5,
	DMFO_Min                                 = 6,
	DMFO_Max                                 = 7,
};

// Enum DelMarCore.EDelMarModifierStackingPolicy
// NumValues: 0x0003
enum class EDelMarModifierStackingPolicy : uint8
{
	DMSP_Allow                               = 0,
	DMSP_DontAdd                             = 1,
	DMSP_ClearOthers                         = 2,
};

// Enum DelMarCore.EDelMarGlobalLeaderboardType
// NumValues: 0x0003
enum class EDelMarGlobalLeaderboardType : uint8
{
	Top                                      = 0,
	Focused                                  = 1,
	Friend                                   = 2,
};

// Enum DelMarCore.EDelMarNetModel
// NumValues: 0x0002
enum class EDelMarNetModel : uint8
{
	ClientAuthoritative                      = 0,
	ChaosRollback                            = 1,
};

// Enum DelMarCore.EDelMarJellyHazardProcessorInfo
// NumValues: 0x0003
enum class EDelMarJellyHazardProcessorInfo : uint32
{
	None                                     = 0,
	WithoutJellyHazardHit                    = 1,
	WithJellyHazardHit                       = 2,
};

// Enum DelMarCore.EDelMarDemolishedProcessorInfo
// NumValues: 0x0003
enum class EDelMarDemolishedProcessorInfo : uint32
{
	None                                     = 0,
	WithoutDemolish                          = 1,
	WithDemolish                             = 2,
};

// Enum DelMarCore.EDelMarPositionChangeInfo
// NumValues: 0x0003
enum class EDelMarPositionChangeInfo : uint8
{
	None                                     = 0,
	PassPlayer                               = 1,
	PassedByPlayer                           = 2,
};

// Enum DelMarCore.EDelMarPlaylistTypeInfo
// NumValues: 0x0003
enum class EDelMarPlaylistTypeInfo : uint8
{
	Any                                      = 0,
	Casual                                   = 1,
	Ranked                                   = 2,
};

// Enum DelMarCore.EDelMarPhysicsRate
// NumValues: 0x0003
enum class EDelMarPhysicsRate : uint8
{
	ThirtyHz                                 = 0,
	SixtyHz                                  = 1,
	OneHundredTwentyHz                       = 2,
};

// Enum DelMarCore.EDelMarSplineGenerationMode
// NumValues: 0x0002
enum class EDelMarSplineGenerationMode : uint8
{
	PerSplinePoint                           = 0,
	UserAmount                               = 1,
};

// Enum DelMarCore.EDelMarRaceMode
// NumValues: 0x0005
enum class EDelMarRaceMode : uint8
{
	ChallengeMode                            = 0,
	CompetitiveMode                          = 1,
	DeathRaceMode                            = 2,
	TutorialRaceMode                         = 3,
	Invalid                                  = 4,
};

// Enum DelMarCore.EDelMarInvertSteerMethod
// NumValues: 0x0005
enum class EDelMarInvertSteerMethod : uint8
{
	CeilingAngle                             = 0,
	CeilingTimeDelay                         = 1,
	CeilingReleaseInput                      = 2,
	Never                                    = 3,
	Always                                   = 4,
};

// Enum DelMarCore.EDelMarKickflipDirection
// NumValues: 0x0009
enum class EDelMarKickflipDirection : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	UpLeft                                   = 5,
	DownLeft                                 = 6,
	UpRight                                  = 7,
	DownRight                                = 8,
};

// Enum DelMarCore.EDelMarVehicleWheelIndex
// NumValues: 0x0005
enum class EDelMarVehicleWheelIndex : uint8
{
	FrontLeft                                = 0,
	FrontRight                               = 1,
	BackLeft                                 = 2,
	BackRight                                = 3,
	Num                                      = 4,
};

// Enum DelMarCore.EMixModifierTarget
// NumValues: 0x0003
enum class EMixModifierTarget : uint8
{
	Volume                                   = 0,
	Pitch                                    = 1,
	LowpassFrequency                         = 2,
};

// Enum DelMarCore.EDelMarCheckpointMeshType
// NumValues: 0x0003
enum class EDelMarCheckpointMeshType : uint8
{
	Default                                  = 0,
	StartLine                                = 1,
	FinishLine                               = 2,
};

// Enum DelMarCore.EDelMarTimerDirection
// NumValues: 0x0002
enum class EDelMarTimerDirection : uint8
{
	CountUp                                  = 0,
	CountDown                                = 1,
};

// Enum DelMarCore.EDelMarPostRaceVote
// NumValues: 0x0004
enum class EDelMarPostRaceVote : uint8
{
	Unset                                    = 0,
	PlayAgain                                = 1,
	NextMap                                  = 2,
	MAX                                      = 3,
};

// Enum DelMarCore.EDelMarVehicleCollisionOverrideSetting
// NumValues: 0x0004
enum class EDelMarVehicleCollisionOverrideSetting : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	Unset                                    = 2,
	Max                                      = 3,
};

// Enum DelMarCore.EDelMarRaceSpawnMode
// NumValues: 0x0004
enum class EDelMarRaceSpawnMode : uint8
{
	SpawnAtMostRecentSplinePoint             = 0,
	SpawnAtMostRecentCheckpoint              = 1,
	SpawnAtRaceStart                         = 2,
	NoAutomaticRespawn                       = 3,
};

// Enum DelMarCore.EDelMarPostMatchFlows
// NumValues: 0x0002
enum class EDelMarPostMatchFlows : uint8
{
	PlayTogetherFlow                         = 0,
	PlayTrackFlow                            = 1,
};

// Enum DelMarCore.EDelMarPostMatchState
// NumValues: 0x000A
enum class EDelMarPostMatchState : uint8
{
	WaitingForParty                          = 0,
	WaitingForLobby                          = 1,
	StartingNextRace                         = 2,
	MatchmakingStarted                       = 3,
	MatchmakingSucceeded                     = 4,
	MatchmakingFailed                        = 5,
	Idle                                     = 6,
	Failed                                   = 7,
	Completed                                = 8,
	INVALID                                  = 9,
};

// ScriptStruct DelMarCore.DelMarAIDifficultySpawnInfo
// 0x0008 (0x0008 - 0x0000)
struct FDelMarAIDifficultySpawnInfo final
{
public:
	int32                                         SkillLevel;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotFillPercentage;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarAIDifficultySpawnInfo) == 0x000004, "Wrong alignment on FDelMarAIDifficultySpawnInfo");
static_assert(sizeof(FDelMarAIDifficultySpawnInfo) == 0x000008, "Wrong size on FDelMarAIDifficultySpawnInfo");
static_assert(offsetof(FDelMarAIDifficultySpawnInfo, SkillLevel) == 0x000000, "Member 'FDelMarAIDifficultySpawnInfo::SkillLevel' has a wrong offset!");
static_assert(offsetof(FDelMarAIDifficultySpawnInfo, BotFillPercentage) == 0x000004, "Member 'FDelMarAIDifficultySpawnInfo::BotFillPercentage' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarAIMMRSpawnDataTableRow
// 0x0020 (0x0028 - 0x0008)
struct FDelMarAIMMRSpawnDataTableRow final : public FTableRowBase
{
public:
	int32                                         MMRBracketLow;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MMRBracketHigh;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallbackSkillLevel;                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDelMarAIDifficultySpawnInfo>   BotSpawnInfo;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarAIMMRSpawnDataTableRow) == 0x000008, "Wrong alignment on FDelMarAIMMRSpawnDataTableRow");
static_assert(sizeof(FDelMarAIMMRSpawnDataTableRow) == 0x000028, "Wrong size on FDelMarAIMMRSpawnDataTableRow");
static_assert(offsetof(FDelMarAIMMRSpawnDataTableRow, MMRBracketLow) == 0x000008, "Member 'FDelMarAIMMRSpawnDataTableRow::MMRBracketLow' has a wrong offset!");
static_assert(offsetof(FDelMarAIMMRSpawnDataTableRow, MMRBracketHigh) == 0x00000C, "Member 'FDelMarAIMMRSpawnDataTableRow::MMRBracketHigh' has a wrong offset!");
static_assert(offsetof(FDelMarAIMMRSpawnDataTableRow, FallbackSkillLevel) == 0x000010, "Member 'FDelMarAIMMRSpawnDataTableRow::FallbackSkillLevel' has a wrong offset!");
static_assert(offsetof(FDelMarAIMMRSpawnDataTableRow, BotSpawnInfo) == 0x000018, "Member 'FDelMarAIMMRSpawnDataTableRow::BotSpawnInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Ability
// 0x0008 (0x0008 - 0x0000)
struct FDelMarVehicleReplicatedState_Ability
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         duration;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Ability) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_Ability");
static_assert(sizeof(FDelMarVehicleReplicatedState_Ability) == 0x000008, "Wrong size on FDelMarVehicleReplicatedState_Ability");
static_assert(offsetof(FDelMarVehicleReplicatedState_Ability, bActive) == 0x000000, "Member 'FDelMarVehicleReplicatedState_Ability::bActive' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Ability, duration) == 0x000004, "Member 'FDelMarVehicleReplicatedState_Ability::duration' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Reattachment
// 0x0020 (0x0028 - 0x0008)
struct FDelMarVehicleReplicatedState_Reattachment final : public FDelMarVehicleReplicatedState_Ability
{
public:
	struct FVector_NetQuantizeNormal              AttachmentDirection;                               // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanActivate;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleReplicatedState_Reattachment) == 0x000008, "Wrong alignment on FDelMarVehicleReplicatedState_Reattachment");
static_assert(sizeof(FDelMarVehicleReplicatedState_Reattachment) == 0x000028, "Wrong size on FDelMarVehicleReplicatedState_Reattachment");
static_assert(offsetof(FDelMarVehicleReplicatedState_Reattachment, AttachmentDirection) == 0x000008, "Member 'FDelMarVehicleReplicatedState_Reattachment::AttachmentDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Reattachment, bCanActivate) == 0x000020, "Member 'FDelMarVehicleReplicatedState_Reattachment::bCanActivate' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarAIVehicleCosmeticSlotDataTableInfo
// 0x0040 (0x0040 - 0x0000)
struct FDelMarAIVehicleCosmeticSlotDataTableInfo final
{
public:
	TSoftObjectPtr<class UCosmeticLoadoutSlotTemplate> SlotTemplate;                                      // 0x0000(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              VehicleSlotCosmeticDataTable;                      // 0x0020(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarAIVehicleCosmeticSlotDataTableInfo) == 0x000008, "Wrong alignment on FDelMarAIVehicleCosmeticSlotDataTableInfo");
static_assert(sizeof(FDelMarAIVehicleCosmeticSlotDataTableInfo) == 0x000040, "Wrong size on FDelMarAIVehicleCosmeticSlotDataTableInfo");
static_assert(offsetof(FDelMarAIVehicleCosmeticSlotDataTableInfo, SlotTemplate) == 0x000000, "Member 'FDelMarAIVehicleCosmeticSlotDataTableInfo::SlotTemplate' has a wrong offset!");
static_assert(offsetof(FDelMarAIVehicleCosmeticSlotDataTableInfo, VehicleSlotCosmeticDataTable) == 0x000020, "Member 'FDelMarAIVehicleCosmeticSlotDataTableInfo::VehicleSlotCosmeticDataTable' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarCosmeticLoadoutSlotData
// 0x0040 (0x0040 - 0x0000)
struct FDelMarCosmeticLoadoutSlotData final
{
public:
	TSoftObjectPtr<class UCosmeticLoadoutSlotTemplate> SlotTemplate;                                      // 0x0000(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 EquippedItemDefinitionObject;                      // 0x0020(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarCosmeticLoadoutSlotData) == 0x000008, "Wrong alignment on FDelMarCosmeticLoadoutSlotData");
static_assert(sizeof(FDelMarCosmeticLoadoutSlotData) == 0x000040, "Wrong size on FDelMarCosmeticLoadoutSlotData");
static_assert(offsetof(FDelMarCosmeticLoadoutSlotData, SlotTemplate) == 0x000000, "Member 'FDelMarCosmeticLoadoutSlotData::SlotTemplate' has a wrong offset!");
static_assert(offsetof(FDelMarCosmeticLoadoutSlotData, EquippedItemDefinitionObject) == 0x000020, "Member 'FDelMarCosmeticLoadoutSlotData::EquippedItemDefinitionObject' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleInPersistent
// 0x07D0 (0x0970 - 0x01A0)
struct alignas(0x10) FDelMarVehicleInPersistent final : public FFortVehicleInPersistent
{
public:
	uint8                                         Pad_1A0[0x7D0];                                    // 0x01A0(0x07D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleInPersistent) == 0x000010, "Wrong alignment on FDelMarVehicleInPersistent");
static_assert(sizeof(FDelMarVehicleInPersistent) == 0x000970, "Wrong size on FDelMarVehicleInPersistent");

// ScriptStruct DelMarCore.DelMarAIVehicleCosmeticLoadoutSetDataTableRow
// 0x0018 (0x0020 - 0x0008)
struct FDelMarAIVehicleCosmeticLoadoutSetDataTableRow final : public FTableRowBase
{
public:
	TArray<struct FDelMarCosmeticLoadoutSlotData> LoadoutSlots;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarAIVehicleCosmeticLoadoutSetDataTableRow) == 0x000008, "Wrong alignment on FDelMarAIVehicleCosmeticLoadoutSetDataTableRow");
static_assert(sizeof(FDelMarAIVehicleCosmeticLoadoutSetDataTableRow) == 0x000020, "Wrong size on FDelMarAIVehicleCosmeticLoadoutSetDataTableRow");
static_assert(offsetof(FDelMarAIVehicleCosmeticLoadoutSetDataTableRow, LoadoutSlots) == 0x000008, "Member 'FDelMarAIVehicleCosmeticLoadoutSetDataTableRow::LoadoutSlots' has a wrong offset!");
static_assert(offsetof(FDelMarAIVehicleCosmeticLoadoutSetDataTableRow, Weight) == 0x000018, "Member 'FDelMarAIVehicleCosmeticLoadoutSetDataTableRow::Weight' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarAIVehicleCosmeticSlotDataTableRow
// 0x0028 (0x0030 - 0x0008)
struct FDelMarAIVehicleCosmeticSlotDataTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UObject>                 EquippedItemDefinitionObject;                      // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarAIVehicleCosmeticSlotDataTableRow) == 0x000008, "Wrong alignment on FDelMarAIVehicleCosmeticSlotDataTableRow");
static_assert(sizeof(FDelMarAIVehicleCosmeticSlotDataTableRow) == 0x000030, "Wrong size on FDelMarAIVehicleCosmeticSlotDataTableRow");
static_assert(offsetof(FDelMarAIVehicleCosmeticSlotDataTableRow, EquippedItemDefinitionObject) == 0x000008, "Member 'FDelMarAIVehicleCosmeticSlotDataTableRow::EquippedItemDefinitionObject' has a wrong offset!");
static_assert(offsetof(FDelMarAIVehicleCosmeticSlotDataTableRow, Weight) == 0x000028, "Member 'FDelMarAIVehicleCosmeticSlotDataTableRow::Weight' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Underthrust
// 0x0004 (0x000C - 0x0008)
struct FDelMarVehicleReplicatedState_Underthrust final : public FDelMarVehicleReplicatedState_Ability
{
public:
	float                                         RemainingThrustSeconds;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Underthrust) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_Underthrust");
static_assert(sizeof(FDelMarVehicleReplicatedState_Underthrust) == 0x00000C, "Wrong size on FDelMarVehicleReplicatedState_Underthrust");
static_assert(offsetof(FDelMarVehicleReplicatedState_Underthrust, RemainingThrustSeconds) == 0x000008, "Member 'FDelMarVehicleReplicatedState_Underthrust::RemainingThrustSeconds' has a wrong offset!");

// ScriptStruct DelMarCore.AvoidanceInfo
// 0x0080 (0x0080 - 0x0000)
struct FAvoidanceInfo final
{
public:
	TMap<TWeakObjectPtr<class AActor>, class UDriveHazardInfo*> DriveHazardInfoMap;                                // 0x0000(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UDriveHazardInfo*>               NonJumpableDriveHazardInfos;                       // 0x0050(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UDriveHazardInfo*>               JumpableDriveHazardInfos;                          // 0x0060(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvoidanceInfo) == 0x000008, "Wrong alignment on FAvoidanceInfo");
static_assert(sizeof(FAvoidanceInfo) == 0x000080, "Wrong size on FAvoidanceInfo");
static_assert(offsetof(FAvoidanceInfo, DriveHazardInfoMap) == 0x000000, "Member 'FAvoidanceInfo::DriveHazardInfoMap' has a wrong offset!");
static_assert(offsetof(FAvoidanceInfo, NonJumpableDriveHazardInfos) == 0x000050, "Member 'FAvoidanceInfo::NonJumpableDriveHazardInfos' has a wrong offset!");
static_assert(offsetof(FAvoidanceInfo, JumpableDriveHazardInfos) == 0x000060, "Member 'FAvoidanceInfo::JumpableDriveHazardInfos' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarCosmeticSlotInfo
// 0x0060 (0x0060 - 0x0000)
struct FDelMarCosmeticSlotInfo final
{
public:
	struct FGameplayTag                           SlotTag;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SlotName;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ShortDescription;                                  // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCanBeEmpty;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              UnassignedPreviewImage;                            // 0x0040(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarCosmeticSlotInfo) == 0x000008, "Wrong alignment on FDelMarCosmeticSlotInfo");
static_assert(sizeof(FDelMarCosmeticSlotInfo) == 0x000060, "Wrong size on FDelMarCosmeticSlotInfo");
static_assert(offsetof(FDelMarCosmeticSlotInfo, SlotTag) == 0x000000, "Member 'FDelMarCosmeticSlotInfo::SlotTag' has a wrong offset!");
static_assert(offsetof(FDelMarCosmeticSlotInfo, SlotName) == 0x000008, "Member 'FDelMarCosmeticSlotInfo::SlotName' has a wrong offset!");
static_assert(offsetof(FDelMarCosmeticSlotInfo, ShortDescription) == 0x000020, "Member 'FDelMarCosmeticSlotInfo::ShortDescription' has a wrong offset!");
static_assert(offsetof(FDelMarCosmeticSlotInfo, bCanBeEmpty) == 0x000038, "Member 'FDelMarCosmeticSlotInfo::bCanBeEmpty' has a wrong offset!");
static_assert(offsetof(FDelMarCosmeticSlotInfo, UnassignedPreviewImage) == 0x000040, "Member 'FDelMarCosmeticSlotInfo::UnassignedPreviewImage' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Kickflip
// 0x0058 (0x0060 - 0x0008)
struct FDelMarVehicleReplicatedState_Kickflip final : public FDelMarVehicleReplicatedState_Ability
{
public:
	struct FVector_NetQuantizeNormal              RelativeUpDirection;                               // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              KickDirection;                                     // 0x0020(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftSide;                                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTakeLongestRoll;                                  // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateTowardsVelocity;                            // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStartLongRoll;                                 // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingRollSign;                                  // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickflipKeybindPressTime;                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivationCharges;                                 // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              StartingPrimaryDirection;                          // 0x0048(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Kickflip) == 0x000008, "Wrong alignment on FDelMarVehicleReplicatedState_Kickflip");
static_assert(sizeof(FDelMarVehicleReplicatedState_Kickflip) == 0x000060, "Wrong size on FDelMarVehicleReplicatedState_Kickflip");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, RelativeUpDirection) == 0x000008, "Member 'FDelMarVehicleReplicatedState_Kickflip::RelativeUpDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, KickDirection) == 0x000020, "Member 'FDelMarVehicleReplicatedState_Kickflip::KickDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, bLeftSide) == 0x000038, "Member 'FDelMarVehicleReplicatedState_Kickflip::bLeftSide' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, bTakeLongestRoll) == 0x000039, "Member 'FDelMarVehicleReplicatedState_Kickflip::bTakeLongestRoll' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, bRotateTowardsVelocity) == 0x00003A, "Member 'FDelMarVehicleReplicatedState_Kickflip::bRotateTowardsVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, bCanStartLongRoll) == 0x00003B, "Member 'FDelMarVehicleReplicatedState_Kickflip::bCanStartLongRoll' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, StartingRollSign) == 0x00003C, "Member 'FDelMarVehicleReplicatedState_Kickflip::StartingRollSign' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, KickflipKeybindPressTime) == 0x000040, "Member 'FDelMarVehicleReplicatedState_Kickflip::KickflipKeybindPressTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, ActivationCharges) == 0x000044, "Member 'FDelMarVehicleReplicatedState_Kickflip::ActivationCharges' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Kickflip, StartingPrimaryDirection) == 0x000048, "Member 'FDelMarVehicleReplicatedState_Kickflip::StartingPrimaryDirection' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_DriverInteractionAdded
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDelMarEvent_DriverInteractionAdded final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_DriverInteractionAdded) == 0x000004, "Wrong alignment on FDelMarEvent_DriverInteractionAdded");
static_assert(sizeof(FDelMarEvent_DriverInteractionAdded) == 0x000008, "Wrong size on FDelMarEvent_DriverInteractionAdded");

// ScriptStruct DelMarCore.DelMarEventRouterExt
// 0x0018 (0x0018 - 0x0000)
struct FDelMarEventRouterExt final
{
public:
	bool                                          bWorldIsTearingDown;                               // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayEventRouterComponent*          EventRouter;                                       // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                EventRouterContextObject;                          // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEventRouterExt) == 0x000008, "Wrong alignment on FDelMarEventRouterExt");
static_assert(sizeof(FDelMarEventRouterExt) == 0x000018, "Wrong size on FDelMarEventRouterExt");
static_assert(offsetof(FDelMarEventRouterExt, bWorldIsTearingDown) == 0x000000, "Member 'FDelMarEventRouterExt::bWorldIsTearingDown' has a wrong offset!");
static_assert(offsetof(FDelMarEventRouterExt, EventRouter) == 0x000008, "Member 'FDelMarEventRouterExt::EventRouter' has a wrong offset!");
static_assert(offsetof(FDelMarEventRouterExt, EventRouterContextObject) == 0x000010, "Member 'FDelMarEventRouterExt::EventRouterContextObject' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleInContinuous
// 0x0000 (0x0040 - 0x0040)
struct FDelMarVehicleInContinuous final : public FFortAthenaVehicleInputState
{
};
static_assert(alignof(FDelMarVehicleInContinuous) == 0x000008, "Wrong alignment on FDelMarVehicleInContinuous");
static_assert(sizeof(FDelMarVehicleInContinuous) == 0x000040, "Wrong size on FDelMarVehicleInContinuous");

// ScriptStruct DelMarCore.DelMarGameplayStateChangedEvent
// 0x0008 (0x0008 - 0x0000)
struct FDelMarGameplayStateChangedEvent final
{
public:
	struct FGameplayTag                           PrevStateId;                                       // 0x0000(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NewStateId;                                        // 0x0004(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarGameplayStateChangedEvent) == 0x000004, "Wrong alignment on FDelMarGameplayStateChangedEvent");
static_assert(sizeof(FDelMarGameplayStateChangedEvent) == 0x000008, "Wrong size on FDelMarGameplayStateChangedEvent");
static_assert(offsetof(FDelMarGameplayStateChangedEvent, PrevStateId) == 0x000000, "Member 'FDelMarGameplayStateChangedEvent::PrevStateId' has a wrong offset!");
static_assert(offsetof(FDelMarGameplayStateChangedEvent, NewStateId) == 0x000004, "Member 'FDelMarGameplayStateChangedEvent::NewStateId' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_ResetRace
// 0x0001 (0x0001 - 0x0000)
struct FDelMarEvent_ResetRace final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_ResetRace) == 0x000001, "Wrong alignment on FDelMarEvent_ResetRace");
static_assert(sizeof(FDelMarEvent_ResetRace) == 0x000001, "Wrong size on FDelMarEvent_ResetRace");

// ScriptStruct DelMarCore.DelMarVerbMessageBase
// 0x00C0 (0x0138 - 0x0078)
struct FDelMarVerbMessageBase : public FVerbMessage
{
public:
	struct FSubjectTagsPair                       LevelDescriptionId;                                // 0x0078(0x0038)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FSubjectTagsPair                       GameModeId;                                        // 0x00B0(0x0038)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FSubjectTagsPair                       VehicleTags;                                       // 0x00E8(0x0038)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	EDelMarPlaylistTypeInfo                       RankedPlaylistInfo;                                // 0x0120(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortVerb_ObjectWrapper>        Cosmetics;                                         // 0x0128(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDelMarVerbMessageBase) == 0x000008, "Wrong alignment on FDelMarVerbMessageBase");
static_assert(sizeof(FDelMarVerbMessageBase) == 0x000138, "Wrong size on FDelMarVerbMessageBase");
static_assert(offsetof(FDelMarVerbMessageBase, LevelDescriptionId) == 0x000078, "Member 'FDelMarVerbMessageBase::LevelDescriptionId' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessageBase, GameModeId) == 0x0000B0, "Member 'FDelMarVerbMessageBase::GameModeId' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessageBase, VehicleTags) == 0x0000E8, "Member 'FDelMarVerbMessageBase::VehicleTags' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessageBase, RankedPlaylistInfo) == 0x000120, "Member 'FDelMarVerbMessageBase::RankedPlaylistInfo' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessageBase, Cosmetics) == 0x000128, "Member 'FDelMarVerbMessageBase::Cosmetics' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_BonusTurboActivated
// 0x0000 (0x0138 - 0x0138)
struct FDelMarVerbMessage_BonusTurboActivated final : public FDelMarVerbMessageBase
{
};
static_assert(alignof(FDelMarVerbMessage_BonusTurboActivated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_BonusTurboActivated");
static_assert(sizeof(FDelMarVerbMessage_BonusTurboActivated) == 0x000138, "Wrong size on FDelMarVerbMessage_BonusTurboActivated");

// ScriptStruct DelMarCore.DelMarEvent_ResetRun
// 0x0001 (0x0001 - 0x0000)
struct FDelMarEvent_ResetRun final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_ResetRun) == 0x000001, "Wrong alignment on FDelMarEvent_ResetRun");
static_assert(sizeof(FDelMarEvent_ResetRun) == 0x000001, "Wrong size on FDelMarEvent_ResetRun");

// ScriptStruct DelMarCore.DelMarEvent_RaceFinished
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FDelMarEvent_RaceFinished final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_RaceFinished) == 0x000008, "Wrong alignment on FDelMarEvent_RaceFinished");
static_assert(sizeof(FDelMarEvent_RaceFinished) == 0x000008, "Wrong size on FDelMarEvent_RaceFinished");

// ScriptStruct DelMarCore.DelMarVehicleOutContinuous
// 0x0160 (0x01B0 - 0x0050)
struct alignas(0x10) FDelMarVehicleOutContinuous final : public FFortVehicleOutContinuous
{
public:
	uint8                                         Pad_50[0x160];                                     // 0x0050(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleOutContinuous) == 0x000010, "Wrong alignment on FDelMarVehicleOutContinuous");
static_assert(sizeof(FDelMarVehicleOutContinuous) == 0x0001B0, "Wrong size on FDelMarVehicleOutContinuous");

// ScriptStruct DelMarCore.DelMarEvent_FirstPlayerFinishedCountdown
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDelMarEvent_FirstPlayerFinishedCountdown final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_FirstPlayerFinishedCountdown) == 0x000008, "Wrong alignment on FDelMarEvent_FirstPlayerFinishedCountdown");
static_assert(sizeof(FDelMarEvent_FirstPlayerFinishedCountdown) == 0x000010, "Wrong size on FDelMarEvent_FirstPlayerFinishedCountdown");

// ScriptStruct DelMarCore.DelMarEvent_RaceActive
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FDelMarEvent_RaceActive final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_RaceActive) == 0x000008, "Wrong alignment on FDelMarEvent_RaceActive");
static_assert(sizeof(FDelMarEvent_RaceActive) == 0x000008, "Wrong size on FDelMarEvent_RaceActive");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_AirControl
// 0x0004 (0x000C - 0x0008)
struct FDelMarVehicleReplicatedState_AirControl final : public FDelMarVehicleReplicatedState_Ability
{
public:
	float                                         AerialDivingBonusSpeed;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_AirControl) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_AirControl");
static_assert(sizeof(FDelMarVehicleReplicatedState_AirControl) == 0x00000C, "Wrong size on FDelMarVehicleReplicatedState_AirControl");
static_assert(offsetof(FDelMarVehicleReplicatedState_AirControl, AerialDivingBonusSpeed) == 0x000008, "Member 'FDelMarVehicleReplicatedState_AirControl::AerialDivingBonusSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_RunActive
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDelMarEvent_RunActive final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_RunActive) == 0x000008, "Wrong alignment on FDelMarEvent_RunActive");
static_assert(sizeof(FDelMarEvent_RunActive) == 0x000010, "Wrong size on FDelMarEvent_RunActive");

// ScriptStruct DelMarCore.DelMarEvent_OvertimeActive
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FDelMarEvent_OvertimeActive final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_OvertimeActive) == 0x000008, "Wrong alignment on FDelMarEvent_OvertimeActive");
static_assert(sizeof(FDelMarEvent_OvertimeActive) == 0x000008, "Wrong size on FDelMarEvent_OvertimeActive");

// ScriptStruct DelMarCore.DelMarEvent_CountdownActive
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FDelMarEvent_CountdownActive final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_CountdownActive) == 0x000008, "Wrong alignment on FDelMarEvent_CountdownActive");
static_assert(sizeof(FDelMarEvent_CountdownActive) == 0x000020, "Wrong size on FDelMarEvent_CountdownActive");

// ScriptStruct DelMarCore.DelMarEvent_PlayerFinishedRace
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDelMarEvent_PlayerFinishedRace final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_PlayerFinishedRace) == 0x000008, "Wrong alignment on FDelMarEvent_PlayerFinishedRace");
static_assert(sizeof(FDelMarEvent_PlayerFinishedRace) == 0x000018, "Wrong size on FDelMarEvent_PlayerFinishedRace");

// ScriptStruct DelMarCore.DelMarVerbMessage_HighestSpeedUpdated
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_HighestSpeedUpdated final : public FDelMarVerbMessageBase
{
public:
	float                                         HighestSpeed;                                      // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_HighestSpeedUpdated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_HighestSpeedUpdated");
static_assert(sizeof(FDelMarVerbMessage_HighestSpeedUpdated) == 0x000140, "Wrong size on FDelMarVerbMessage_HighestSpeedUpdated");
static_assert(offsetof(FDelMarVerbMessage_HighestSpeedUpdated, HighestSpeed) == 0x000138, "Member 'FDelMarVerbMessage_HighestSpeedUpdated::HighestSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_RacerStateChanged
// 0x0010 (0x0010 - 0x0000)
struct FDelMarEvent_RacerStateChanged final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PrevStateId;                                       // 0x0008(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NewStateId;                                        // 0x000C(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_RacerStateChanged) == 0x000004, "Wrong alignment on FDelMarEvent_RacerStateChanged");
static_assert(sizeof(FDelMarEvent_RacerStateChanged) == 0x000010, "Wrong size on FDelMarEvent_RacerStateChanged");
static_assert(offsetof(FDelMarEvent_RacerStateChanged, PrevStateId) == 0x000008, "Member 'FDelMarEvent_RacerStateChanged::PrevStateId' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_RacerStateChanged, NewStateId) == 0x00000C, "Member 'FDelMarEvent_RacerStateChanged::NewStateId' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_PlayerBecomeSpectator
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDelMarEvent_PlayerBecomeSpectator final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_PlayerBecomeSpectator) == 0x000004, "Wrong alignment on FDelMarEvent_PlayerBecomeSpectator");
static_assert(sizeof(FDelMarEvent_PlayerBecomeSpectator) == 0x000008, "Wrong size on FDelMarEvent_PlayerBecomeSpectator");

// ScriptStruct DelMarCore.DelMarVerbMessage_BoostPadHit
// 0x0000 (0x0138 - 0x0138)
struct FDelMarVerbMessage_BoostPadHit final : public FDelMarVerbMessageBase
{
};
static_assert(alignof(FDelMarVerbMessage_BoostPadHit) == 0x000008, "Wrong alignment on FDelMarVerbMessage_BoostPadHit");
static_assert(sizeof(FDelMarVerbMessage_BoostPadHit) == 0x000138, "Wrong size on FDelMarVerbMessage_BoostPadHit");

// ScriptStruct DelMarCore.DelMarEvent_RaceManagerInitialized
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDelMarEvent_RaceManagerInitialized final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_RaceManagerInitialized) == 0x000004, "Wrong alignment on FDelMarEvent_RaceManagerInitialized");
static_assert(sizeof(FDelMarEvent_RaceManagerInitialized) == 0x000008, "Wrong size on FDelMarEvent_RaceManagerInitialized");

// ScriptStruct DelMarCore.DelMarEvent_VehicleAssignedToPawn
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDelMarEvent_VehicleAssignedToPawn final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_VehicleAssignedToPawn) == 0x000004, "Wrong alignment on FDelMarEvent_VehicleAssignedToPawn");
static_assert(sizeof(FDelMarEvent_VehicleAssignedToPawn) == 0x000008, "Wrong size on FDelMarEvent_VehicleAssignedToPawn");

// ScriptStruct DelMarCore.DelMarVehicleNetworkInput
// 0x0048 (0x0048 - 0x0000)
struct FDelMarVehicleNetworkInput final
{
public:
	int32                                         FrameNum;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarVehicleInContinuous             Input;                                             // 0x0008(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleNetworkInput) == 0x000008, "Wrong alignment on FDelMarVehicleNetworkInput");
static_assert(sizeof(FDelMarVehicleNetworkInput) == 0x000048, "Wrong size on FDelMarVehicleNetworkInput");
static_assert(offsetof(FDelMarVehicleNetworkInput, FrameNum) == 0x000000, "Member 'FDelMarVehicleNetworkInput::FrameNum' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleNetworkInput, Input) == 0x000008, "Member 'FDelMarVehicleNetworkInput::Input' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_ServerRaceStartCountdownTime
// 0x0008 (0x0008 - 0x0000)
struct FDelMarEvent_ServerRaceStartCountdownTime final
{
public:
	double                                        ServerTime;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_ServerRaceStartCountdownTime) == 0x000008, "Wrong alignment on FDelMarEvent_ServerRaceStartCountdownTime");
static_assert(sizeof(FDelMarEvent_ServerRaceStartCountdownTime) == 0x000008, "Wrong size on FDelMarEvent_ServerRaceStartCountdownTime");
static_assert(offsetof(FDelMarEvent_ServerRaceStartCountdownTime, ServerTime) == 0x000000, "Member 'FDelMarEvent_ServerRaceStartCountdownTime::ServerTime' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_ServerPostRaceEndTime
// 0x0008 (0x0008 - 0x0000)
struct FDelMarEvent_ServerPostRaceEndTime final
{
public:
	double                                        ServerTime;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_ServerPostRaceEndTime) == 0x000008, "Wrong alignment on FDelMarEvent_ServerPostRaceEndTime");
static_assert(sizeof(FDelMarEvent_ServerPostRaceEndTime) == 0x000008, "Wrong size on FDelMarEvent_ServerPostRaceEndTime");
static_assert(offsetof(FDelMarEvent_ServerPostRaceEndTime, ServerTime) == 0x000000, "Member 'FDelMarEvent_ServerPostRaceEndTime::ServerTime' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarScaledCurve
// 0x0090 (0x0090 - 0x0000)
struct FDelMarScaledCurve final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0008(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarScaledCurve) == 0x000008, "Wrong alignment on FDelMarScaledCurve");
static_assert(sizeof(FDelMarScaledCurve) == 0x000090, "Wrong size on FDelMarScaledCurve");
static_assert(offsetof(FDelMarScaledCurve, Scale) == 0x000000, "Member 'FDelMarScaledCurve::Scale' has a wrong offset!");
static_assert(offsetof(FDelMarScaledCurve, Curve) == 0x000008, "Member 'FDelMarScaledCurve::Curve' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_AirThrottle
// 0x00A0 (0x00A0 - 0x0000)
struct FDelMarVehicleConfig_AirThrottle final
{
public:
	struct FDelMarScaledCurve                     AccelerationScalarCurve;                           // 0x0000(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         AerialSpeedCap;                                    // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverCapSpeedLossPerSecond;                         // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialSlowdownImmunitySeconds;                     // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNoThrottleSlowdown;                          // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleConfig_AirThrottle) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_AirThrottle");
static_assert(sizeof(FDelMarVehicleConfig_AirThrottle) == 0x0000A0, "Wrong size on FDelMarVehicleConfig_AirThrottle");
static_assert(offsetof(FDelMarVehicleConfig_AirThrottle, AccelerationScalarCurve) == 0x000000, "Member 'FDelMarVehicleConfig_AirThrottle::AccelerationScalarCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirThrottle, AerialSpeedCap) == 0x000090, "Member 'FDelMarVehicleConfig_AirThrottle::AerialSpeedCap' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirThrottle, OverCapSpeedLossPerSecond) == 0x000094, "Member 'FDelMarVehicleConfig_AirThrottle::OverCapSpeedLossPerSecond' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirThrottle, AerialSlowdownImmunitySeconds) == 0x000098, "Member 'FDelMarVehicleConfig_AirThrottle::AerialSlowdownImmunitySeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirThrottle, bApplyNoThrottleSlowdown) == 0x00009C, "Member 'FDelMarVehicleConfig_AirThrottle::bApplyNoThrottleSlowdown' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_VehicleDemolished
// 0x000C (0x000C - 0x0000)
struct FDelMarEvent_VehicleDemolished final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CausedByTag;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_VehicleDemolished) == 0x000004, "Wrong alignment on FDelMarEvent_VehicleDemolished");
static_assert(sizeof(FDelMarEvent_VehicleDemolished) == 0x00000C, "Wrong size on FDelMarEvent_VehicleDemolished");
static_assert(offsetof(FDelMarEvent_VehicleDemolished, CausedByTag) == 0x000008, "Member 'FDelMarEvent_VehicleDemolished::CausedByTag' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_VehicleWrongwayStatus
// 0x0001 (0x0001 - 0x0000)
struct FDelMarEvent_VehicleWrongwayStatus final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_VehicleWrongwayStatus) == 0x000001, "Wrong alignment on FDelMarEvent_VehicleWrongwayStatus");
static_assert(sizeof(FDelMarEvent_VehicleWrongwayStatus) == 0x000001, "Wrong size on FDelMarEvent_VehicleWrongwayStatus");

// ScriptStruct DelMarCore.DelMarVerbMessage_RunComplete
// 0x0018 (0x0150 - 0x0138)
struct FDelMarVerbMessage_RunComplete final : public FDelMarVerbMessageBase
{
public:
	double                                        FinishTime;                                        // 0x0138(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         FinalPlacement;                                    // 0x0140(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDelMarJellyHazardProcessorInfo               JellyHazardInfo;                                   // 0x0144(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDelMarDemolishedProcessorInfo                DemolishedInfo;                                    // 0x0148(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_RunComplete) == 0x000008, "Wrong alignment on FDelMarVerbMessage_RunComplete");
static_assert(sizeof(FDelMarVerbMessage_RunComplete) == 0x000150, "Wrong size on FDelMarVerbMessage_RunComplete");
static_assert(offsetof(FDelMarVerbMessage_RunComplete, FinishTime) == 0x000138, "Member 'FDelMarVerbMessage_RunComplete::FinishTime' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RunComplete, FinalPlacement) == 0x000140, "Member 'FDelMarVerbMessage_RunComplete::FinalPlacement' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RunComplete, JellyHazardInfo) == 0x000144, "Member 'FDelMarVerbMessage_RunComplete::JellyHazardInfo' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RunComplete, DemolishedInfo) == 0x000148, "Member 'FDelMarVerbMessage_RunComplete::DemolishedInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_MissedCheckpointDemoCountdown
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FDelMarEvent_MissedCheckpointDemoCountdown final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_MissedCheckpointDemoCountdown) == 0x000008, "Wrong alignment on FDelMarEvent_MissedCheckpointDemoCountdown");
static_assert(sizeof(FDelMarEvent_MissedCheckpointDemoCountdown) == 0x000008, "Wrong size on FDelMarEvent_MissedCheckpointDemoCountdown");

// ScriptStruct DelMarCore.DelMarEvent_ReturnToTrackDemoCountdown
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FDelMarEvent_ReturnToTrackDemoCountdown final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_ReturnToTrackDemoCountdown) == 0x000008, "Wrong alignment on FDelMarEvent_ReturnToTrackDemoCountdown");
static_assert(sizeof(FDelMarEvent_ReturnToTrackDemoCountdown) == 0x000008, "Wrong size on FDelMarEvent_ReturnToTrackDemoCountdown");

// ScriptStruct DelMarCore.DelMarVehicleConfig_Kickflip
// 0x0150 (0x0150 - 0x0000)
struct FDelMarVehicleConfig_Kickflip final
{
public:
	float                                         DirectionalSensitivity;                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryDirectionalSensitivity;                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDiagonalKickDirection;                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumWheelsForLanding;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumActivationCharges;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinActiveSecondsToReactivate;                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinActiveTime;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActiveLateralTime;                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActiveUpwardTime;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActiveDownwardTime;                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowGroundedKickflips;                           // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundedKickflipForce;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralVelocity;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     LateralVelocityScalarCurve;                        // 0x0038(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MinForwardSpeedForLateralScalar;                   // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLateralVelocityCancelled;                       // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardVerticalVelocity;                            // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownwardVerticalVelocity;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralVerticalForce;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDamping;                                   // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTorque;                                    // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTorqueIncomingCollision;                   // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedToRotateYaw;                               // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticalYawLandingDegrees;                      // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLateralYawLandingDegrees;                       // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticalNormalLandingDegrees;                   // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLateralNormalLandingDegrees;                    // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLongRollTimeCheck;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLongRollTimeCheckDownwardKick;                  // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLongRollDegrees;                                // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDegreesToCompleteRoll;                          // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastTorqueDistanceCheck;                           // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStartingDirectionWhenLanding;                  // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PredictionTickInterval;                            // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationRedirectSeconds;                      // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationDistanceLateral;                      // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationDistanceUpward;                       // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationDistanceDownward;                     // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplySuctionToSurfaces;                           // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuctionVelocity;                                   // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSuctionPerSecond;                               // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuctionDistanceCheck;                              // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAdditionalVelocitySuctionDistance;              // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             SuctionChannel;                                    // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxForwardVelocityDegreeDifference;                // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedForPrimaryForwardRotation;                 // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGroundedDirectionDegrees;                       // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleConfig_Kickflip) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_Kickflip");
static_assert(sizeof(FDelMarVehicleConfig_Kickflip) == 0x000150, "Wrong size on FDelMarVehicleConfig_Kickflip");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, DirectionalSensitivity) == 0x000000, "Member 'FDelMarVehicleConfig_Kickflip::DirectionalSensitivity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, SecondaryDirectionalSensitivity) == 0x000004, "Member 'FDelMarVehicleConfig_Kickflip::SecondaryDirectionalSensitivity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, bAllowDiagonalKickDirection) == 0x000008, "Member 'FDelMarVehicleConfig_Kickflip::bAllowDiagonalKickDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, NumWheelsForLanding) == 0x00000C, "Member 'FDelMarVehicleConfig_Kickflip::NumWheelsForLanding' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, NumActivationCharges) == 0x000010, "Member 'FDelMarVehicleConfig_Kickflip::NumActivationCharges' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MinActiveSecondsToReactivate) == 0x000014, "Member 'FDelMarVehicleConfig_Kickflip::MinActiveSecondsToReactivate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MinActiveTime) == 0x000018, "Member 'FDelMarVehicleConfig_Kickflip::MinActiveTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxActiveLateralTime) == 0x00001C, "Member 'FDelMarVehicleConfig_Kickflip::MaxActiveLateralTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxActiveUpwardTime) == 0x000020, "Member 'FDelMarVehicleConfig_Kickflip::MaxActiveUpwardTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxActiveDownwardTime) == 0x000024, "Member 'FDelMarVehicleConfig_Kickflip::MaxActiveDownwardTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, CooldownTime) == 0x000028, "Member 'FDelMarVehicleConfig_Kickflip::CooldownTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, bAllowGroundedKickflips) == 0x00002C, "Member 'FDelMarVehicleConfig_Kickflip::bAllowGroundedKickflips' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, GroundedKickflipForce) == 0x000030, "Member 'FDelMarVehicleConfig_Kickflip::GroundedKickflipForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, LateralVelocity) == 0x000034, "Member 'FDelMarVehicleConfig_Kickflip::LateralVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, LateralVelocityScalarCurve) == 0x000038, "Member 'FDelMarVehicleConfig_Kickflip::LateralVelocityScalarCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MinForwardSpeedForLateralScalar) == 0x0000C8, "Member 'FDelMarVehicleConfig_Kickflip::MinForwardSpeedForLateralScalar' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxLateralVelocityCancelled) == 0x0000CC, "Member 'FDelMarVehicleConfig_Kickflip::MaxLateralVelocityCancelled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, UpwardVerticalVelocity) == 0x0000D0, "Member 'FDelMarVehicleConfig_Kickflip::UpwardVerticalVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, DownwardVerticalVelocity) == 0x0000D4, "Member 'FDelMarVehicleConfig_Kickflip::DownwardVerticalVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, LateralVerticalForce) == 0x0000D8, "Member 'FDelMarVehicleConfig_Kickflip::LateralVerticalForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, RotationDamping) == 0x0000DC, "Member 'FDelMarVehicleConfig_Kickflip::RotationDamping' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, RotationTorque) == 0x0000E0, "Member 'FDelMarVehicleConfig_Kickflip::RotationTorque' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, RotationTorqueIncomingCollision) == 0x0000E4, "Member 'FDelMarVehicleConfig_Kickflip::RotationTorqueIncomingCollision' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MinSpeedToRotateYaw) == 0x0000E8, "Member 'FDelMarVehicleConfig_Kickflip::MinSpeedToRotateYaw' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxVerticalYawLandingDegrees) == 0x0000EC, "Member 'FDelMarVehicleConfig_Kickflip::MaxVerticalYawLandingDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxLateralYawLandingDegrees) == 0x0000F0, "Member 'FDelMarVehicleConfig_Kickflip::MaxLateralYawLandingDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxVerticalNormalLandingDegrees) == 0x0000F4, "Member 'FDelMarVehicleConfig_Kickflip::MaxVerticalNormalLandingDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxLateralNormalLandingDegrees) == 0x0000F8, "Member 'FDelMarVehicleConfig_Kickflip::MaxLateralNormalLandingDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MinLongRollTimeCheck) == 0x0000FC, "Member 'FDelMarVehicleConfig_Kickflip::MinLongRollTimeCheck' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MinLongRollTimeCheckDownwardKick) == 0x000100, "Member 'FDelMarVehicleConfig_Kickflip::MinLongRollTimeCheckDownwardKick' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxLongRollDegrees) == 0x000104, "Member 'FDelMarVehicleConfig_Kickflip::MaxLongRollDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MinDegreesToCompleteRoll) == 0x000108, "Member 'FDelMarVehicleConfig_Kickflip::MinDegreesToCompleteRoll' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, FastTorqueDistanceCheck) == 0x00010C, "Member 'FDelMarVehicleConfig_Kickflip::FastTorqueDistanceCheck' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, bUseStartingDirectionWhenLanding) == 0x000110, "Member 'FDelMarVehicleConfig_Kickflip::bUseStartingDirectionWhenLanding' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, PredictionTickInterval) == 0x000114, "Member 'FDelMarVehicleConfig_Kickflip::PredictionTickInterval' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxSimulationRedirectSeconds) == 0x000118, "Member 'FDelMarVehicleConfig_Kickflip::MaxSimulationRedirectSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxSimulationDistanceLateral) == 0x00011C, "Member 'FDelMarVehicleConfig_Kickflip::MaxSimulationDistanceLateral' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxSimulationDistanceUpward) == 0x000120, "Member 'FDelMarVehicleConfig_Kickflip::MaxSimulationDistanceUpward' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxSimulationDistanceDownward) == 0x000124, "Member 'FDelMarVehicleConfig_Kickflip::MaxSimulationDistanceDownward' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, bApplySuctionToSurfaces) == 0x000128, "Member 'FDelMarVehicleConfig_Kickflip::bApplySuctionToSurfaces' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, SuctionVelocity) == 0x00012C, "Member 'FDelMarVehicleConfig_Kickflip::SuctionVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxSuctionPerSecond) == 0x000130, "Member 'FDelMarVehicleConfig_Kickflip::MaxSuctionPerSecond' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, SuctionDistanceCheck) == 0x000134, "Member 'FDelMarVehicleConfig_Kickflip::SuctionDistanceCheck' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxAdditionalVelocitySuctionDistance) == 0x000138, "Member 'FDelMarVehicleConfig_Kickflip::MaxAdditionalVelocitySuctionDistance' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, SuctionChannel) == 0x00013C, "Member 'FDelMarVehicleConfig_Kickflip::SuctionChannel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxForwardVelocityDegreeDifference) == 0x000140, "Member 'FDelMarVehicleConfig_Kickflip::MaxForwardVelocityDegreeDifference' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MinSpeedForPrimaryForwardRotation) == 0x000144, "Member 'FDelMarVehicleConfig_Kickflip::MinSpeedForPrimaryForwardRotation' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Kickflip, MaxGroundedDirectionDegrees) == 0x000148, "Member 'FDelMarVehicleConfig_Kickflip::MaxGroundedDirectionDegrees' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_TrackedPlayerReadyStates
// 0x0020 (0x0020 - 0x0000)
struct FDelMarEvent_TrackedPlayerReadyStates final
{
public:
	TArray<TWeakObjectPtr<class AFortPlayerState>> ReadyPlayers;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AFortPlayerState>> UnreadyPlayers;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_TrackedPlayerReadyStates) == 0x000008, "Wrong alignment on FDelMarEvent_TrackedPlayerReadyStates");
static_assert(sizeof(FDelMarEvent_TrackedPlayerReadyStates) == 0x000020, "Wrong size on FDelMarEvent_TrackedPlayerReadyStates");
static_assert(offsetof(FDelMarEvent_TrackedPlayerReadyStates, ReadyPlayers) == 0x000000, "Member 'FDelMarEvent_TrackedPlayerReadyStates::ReadyPlayers' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_TrackedPlayerReadyStates, UnreadyPlayers) == 0x000010, "Member 'FDelMarEvent_TrackedPlayerReadyStates::UnreadyPlayers' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_LoadedPlayerStates
// 0x0008 (0x0008 - 0x0000)
struct FDelMarEvent_LoadedPlayerStates final
{
public:
	int32                                         NumLoadedPlayers;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalPlayers;                                      // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_LoadedPlayerStates) == 0x000004, "Wrong alignment on FDelMarEvent_LoadedPlayerStates");
static_assert(sizeof(FDelMarEvent_LoadedPlayerStates) == 0x000008, "Wrong size on FDelMarEvent_LoadedPlayerStates");
static_assert(offsetof(FDelMarEvent_LoadedPlayerStates, NumLoadedPlayers) == 0x000000, "Member 'FDelMarEvent_LoadedPlayerStates::NumLoadedPlayers' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LoadedPlayerStates, TotalPlayers) == 0x000004, "Member 'FDelMarEvent_LoadedPlayerStates::TotalPlayers' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_AirControl
// 0x00D0 (0x00D0 - 0x0000)
struct FDelMarVehicleConfig_AirControl final
{
public:
	float                                         MaxPitchAdjustmentForwardSpeed;                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarScaledCurve                     LateralTurnRateCurve;                              // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         UnderthrustTurnRate;                               // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRedirectDuringKickflip;                      // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowVerticalRedirectDuringVerticalKickflip;      // 0x009D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LateralKickflipScalar;                             // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalTurnRate;                                  // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalTurnRateAboveHorizon;                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSteerInput;                                     // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchVerticalDegreesFromWorldDown;              // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchVerticalDegreesFromWorldDown;              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialDivingBonusEnabled;                         // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPitchForAerialDivingBonus;                      // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAerialDivingBonusSpeed;                         // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAerialDivingBonusSpeed;                         // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialDivingBonusSpeedChangeRate;                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialDivingBonusSpeedDecayRate;                   // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleConfig_AirControl) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_AirControl");
static_assert(sizeof(FDelMarVehicleConfig_AirControl) == 0x0000D0, "Wrong size on FDelMarVehicleConfig_AirControl");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, MaxPitchAdjustmentForwardSpeed) == 0x000000, "Member 'FDelMarVehicleConfig_AirControl::MaxPitchAdjustmentForwardSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, LateralTurnRateCurve) == 0x000008, "Member 'FDelMarVehicleConfig_AirControl::LateralTurnRateCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, UnderthrustTurnRate) == 0x000098, "Member 'FDelMarVehicleConfig_AirControl::UnderthrustTurnRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, bAllowRedirectDuringKickflip) == 0x00009C, "Member 'FDelMarVehicleConfig_AirControl::bAllowRedirectDuringKickflip' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, bAllowVerticalRedirectDuringVerticalKickflip) == 0x00009D, "Member 'FDelMarVehicleConfig_AirControl::bAllowVerticalRedirectDuringVerticalKickflip' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, LateralKickflipScalar) == 0x0000A0, "Member 'FDelMarVehicleConfig_AirControl::LateralKickflipScalar' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, VerticalTurnRate) == 0x0000A4, "Member 'FDelMarVehicleConfig_AirControl::VerticalTurnRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, VerticalTurnRateAboveHorizon) == 0x0000A8, "Member 'FDelMarVehicleConfig_AirControl::VerticalTurnRateAboveHorizon' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, MinSteerInput) == 0x0000AC, "Member 'FDelMarVehicleConfig_AirControl::MinSteerInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, MinPitchVerticalDegreesFromWorldDown) == 0x0000B0, "Member 'FDelMarVehicleConfig_AirControl::MinPitchVerticalDegreesFromWorldDown' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, MaxPitchVerticalDegreesFromWorldDown) == 0x0000B4, "Member 'FDelMarVehicleConfig_AirControl::MaxPitchVerticalDegreesFromWorldDown' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, bAerialDivingBonusEnabled) == 0x0000B8, "Member 'FDelMarVehicleConfig_AirControl::bAerialDivingBonusEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, MinPitchForAerialDivingBonus) == 0x0000BC, "Member 'FDelMarVehicleConfig_AirControl::MinPitchForAerialDivingBonus' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, MaxAerialDivingBonusSpeed) == 0x0000C0, "Member 'FDelMarVehicleConfig_AirControl::MaxAerialDivingBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, MinAerialDivingBonusSpeed) == 0x0000C4, "Member 'FDelMarVehicleConfig_AirControl::MinAerialDivingBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, AerialDivingBonusSpeedChangeRate) == 0x0000C8, "Member 'FDelMarVehicleConfig_AirControl::AerialDivingBonusSpeedChangeRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirControl, AerialDivingBonusSpeedDecayRate) == 0x0000CC, "Member 'FDelMarVehicleConfig_AirControl::AerialDivingBonusSpeedDecayRate' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_LoadingScreenData
// 0x0010 (0x0010 - 0x0000)
struct FDelMarEvent_LoadingScreenData final
{
public:
	class UDelMarLevelDataAsset*                  LevelData;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RaceMode;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_LoadingScreenData) == 0x000008, "Wrong alignment on FDelMarEvent_LoadingScreenData");
static_assert(sizeof(FDelMarEvent_LoadingScreenData) == 0x000010, "Wrong size on FDelMarEvent_LoadingScreenData");
static_assert(offsetof(FDelMarEvent_LoadingScreenData, LevelData) == 0x000000, "Member 'FDelMarEvent_LoadingScreenData::LevelData' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LoadingScreenData, RaceMode) == 0x000008, "Member 'FDelMarEvent_LoadingScreenData::RaceMode' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_DialogRequest
// 0x0004 (0x0004 - 0x0000)
struct FDelMarEvent_DialogRequest final
{
public:
	struct FGameplayTag                           DialogTag;                                         // 0x0000(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_DialogRequest) == 0x000004, "Wrong alignment on FDelMarEvent_DialogRequest");
static_assert(sizeof(FDelMarEvent_DialogRequest) == 0x000004, "Wrong size on FDelMarEvent_DialogRequest");
static_assert(offsetof(FDelMarEvent_DialogRequest, DialogTag) == 0x000000, "Member 'FDelMarEvent_DialogRequest::DialogTag' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_RaceFinished
// 0x0018 (0x0150 - 0x0138)
struct FDelMarVerbMessage_RaceFinished final : public FDelMarVerbMessageBase
{
public:
	double                                        FinishTime;                                        // 0x0138(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         FinalPlacement;                                    // 0x0140(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         PlayerRank;                                        // 0x0141(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EDelMarJellyHazardProcessorInfo               JellyHazardInfo;                                   // 0x0144(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDelMarDemolishedProcessorInfo                DemolishedInfo;                                    // 0x0148(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_RaceFinished) == 0x000008, "Wrong alignment on FDelMarVerbMessage_RaceFinished");
static_assert(sizeof(FDelMarVerbMessage_RaceFinished) == 0x000150, "Wrong size on FDelMarVerbMessage_RaceFinished");
static_assert(offsetof(FDelMarVerbMessage_RaceFinished, FinishTime) == 0x000138, "Member 'FDelMarVerbMessage_RaceFinished::FinishTime' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RaceFinished, FinalPlacement) == 0x000140, "Member 'FDelMarVerbMessage_RaceFinished::FinalPlacement' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RaceFinished, PlayerRank) == 0x000141, "Member 'FDelMarVerbMessage_RaceFinished::PlayerRank' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RaceFinished, JellyHazardInfo) == 0x000144, "Member 'FDelMarVerbMessage_RaceFinished::JellyHazardInfo' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RaceFinished, DemolishedInfo) == 0x000148, "Member 'FDelMarVerbMessage_RaceFinished::DemolishedInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_SetTutorialHint
// 0x0060 (0x0060 - 0x0000)
struct FDelMarEvent_SetTutorialHint final
{
public:
	class FText                                   KBMText;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GamepadText;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TouchText;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInputAction*>                   AssociatedInputActions;                            // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_SetTutorialHint) == 0x000008, "Wrong alignment on FDelMarEvent_SetTutorialHint");
static_assert(sizeof(FDelMarEvent_SetTutorialHint) == 0x000060, "Wrong size on FDelMarEvent_SetTutorialHint");
static_assert(offsetof(FDelMarEvent_SetTutorialHint, KBMText) == 0x000000, "Member 'FDelMarEvent_SetTutorialHint::KBMText' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetTutorialHint, GamepadText) == 0x000018, "Member 'FDelMarEvent_SetTutorialHint::GamepadText' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetTutorialHint, TouchText) == 0x000030, "Member 'FDelMarEvent_SetTutorialHint::TouchText' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetTutorialHint, DisplayTime) == 0x000048, "Member 'FDelMarEvent_SetTutorialHint::DisplayTime' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetTutorialHint, Priority) == 0x00004C, "Member 'FDelMarEvent_SetTutorialHint::Priority' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetTutorialHint, AssociatedInputActions) == 0x000050, "Member 'FDelMarEvent_SetTutorialHint::AssociatedInputActions' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_SetTutorialAnnouncement
// 0x0058 (0x0058 - 0x0000)
struct FDelMarEvent_SetTutorialAnnouncement final
{
public:
	class FText                                   KBMText;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GamepadText;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TouchText;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UInputAction*>                   AssociatedInputActions;                            // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_SetTutorialAnnouncement) == 0x000008, "Wrong alignment on FDelMarEvent_SetTutorialAnnouncement");
static_assert(sizeof(FDelMarEvent_SetTutorialAnnouncement) == 0x000058, "Wrong size on FDelMarEvent_SetTutorialAnnouncement");
static_assert(offsetof(FDelMarEvent_SetTutorialAnnouncement, KBMText) == 0x000000, "Member 'FDelMarEvent_SetTutorialAnnouncement::KBMText' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetTutorialAnnouncement, GamepadText) == 0x000018, "Member 'FDelMarEvent_SetTutorialAnnouncement::GamepadText' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetTutorialAnnouncement, TouchText) == 0x000030, "Member 'FDelMarEvent_SetTutorialAnnouncement::TouchText' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetTutorialAnnouncement, AssociatedInputActions) == 0x000048, "Member 'FDelMarEvent_SetTutorialAnnouncement::AssociatedInputActions' has a wrong offset!");

// ScriptStruct DelMarCore.AudioMixModifier
// 0x0098 (0x0098 - 0x0000)
struct FAudioMixModifier final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMixModifierTarget                            Target;                                            // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultValue;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0010(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioMixModifier) == 0x000008, "Wrong alignment on FAudioMixModifier");
static_assert(sizeof(FAudioMixModifier) == 0x000098, "Wrong size on FAudioMixModifier");
static_assert(offsetof(FAudioMixModifier, ParamName) == 0x000000, "Member 'FAudioMixModifier::ParamName' has a wrong offset!");
static_assert(offsetof(FAudioMixModifier, Target) == 0x000004, "Member 'FAudioMixModifier::Target' has a wrong offset!");
static_assert(offsetof(FAudioMixModifier, DefaultValue) == 0x000008, "Member 'FAudioMixModifier::DefaultValue' has a wrong offset!");
static_assert(offsetof(FAudioMixModifier, Curve) == 0x000010, "Member 'FAudioMixModifier::Curve' has a wrong offset!");

// ScriptStruct DelMarCore.AudioMixModifierGroup
// 0x0018 (0x0018 - 0x0000)
struct FAudioMixModifierGroup final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAudioMixModifier>              Modifiers;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioMixModifierGroup) == 0x000008, "Wrong alignment on FAudioMixModifierGroup");
static_assert(sizeof(FAudioMixModifierGroup) == 0x000018, "Wrong size on FAudioMixModifierGroup");
static_assert(offsetof(FAudioMixModifierGroup, GroupName) == 0x000000, "Member 'FAudioMixModifierGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FAudioMixModifierGroup, Modifiers) == 0x000008, "Member 'FAudioMixModifierGroup::Modifiers' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_MidTutorialModal
// 0x0001 (0x0001 - 0x0000)
struct FDelMarEvent_MidTutorialModal final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_MidTutorialModal) == 0x000001, "Wrong alignment on FDelMarEvent_MidTutorialModal");
static_assert(sizeof(FDelMarEvent_MidTutorialModal) == 0x000001, "Wrong size on FDelMarEvent_MidTutorialModal");

// ScriptStruct DelMarCore.DelMarEvent_SetControlsText
// 0x0030 (0x0030 - 0x0000)
struct FDelMarEvent_SetControlsText final
{
public:
	class FText                                   KBMText;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GamepadText;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_SetControlsText) == 0x000008, "Wrong alignment on FDelMarEvent_SetControlsText");
static_assert(sizeof(FDelMarEvent_SetControlsText) == 0x000030, "Wrong size on FDelMarEvent_SetControlsText");
static_assert(offsetof(FDelMarEvent_SetControlsText, KBMText) == 0x000000, "Member 'FDelMarEvent_SetControlsText::KBMText' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SetControlsText, GamepadText) == 0x000018, "Member 'FDelMarEvent_SetControlsText::GamepadText' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_StartlineBoostActivated
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_StartlineBoostActivated final : public FDelMarVerbMessageBase
{
public:
	float                                         StartLineBoostPercent;                             // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_StartlineBoostActivated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_StartlineBoostActivated");
static_assert(sizeof(FDelMarVerbMessage_StartlineBoostActivated) == 0x000140, "Wrong size on FDelMarVerbMessage_StartlineBoostActivated");
static_assert(offsetof(FDelMarVerbMessage_StartlineBoostActivated, StartLineBoostPercent) == 0x000138, "Member 'FDelMarVerbMessage_StartlineBoostActivated::StartLineBoostPercent' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_CheckpointPassed_ParallelPath
// 0x0010 (0x0010 - 0x0000)
struct FDelMarEvent_CheckpointPassed_ParallelPath final
{
public:
	class ADelMarCheckpoint*                      CurrentCheckPoint;                                 // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckpointIndexForLap;                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_CheckpointPassed_ParallelPath) == 0x000008, "Wrong alignment on FDelMarEvent_CheckpointPassed_ParallelPath");
static_assert(sizeof(FDelMarEvent_CheckpointPassed_ParallelPath) == 0x000010, "Wrong size on FDelMarEvent_CheckpointPassed_ParallelPath");
static_assert(offsetof(FDelMarEvent_CheckpointPassed_ParallelPath, CurrentCheckPoint) == 0x000000, "Member 'FDelMarEvent_CheckpointPassed_ParallelPath::CurrentCheckPoint' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_CheckpointPassed_ParallelPath, CheckpointIndexForLap) == 0x000008, "Member 'FDelMarEvent_CheckpointPassed_ParallelPath::CheckpointIndexForLap' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_CheckpointPassedOutOfOrder_ParallelPath
// 0x0008 (0x0008 - 0x0000)
struct FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath final
{
public:
	class ADelMarCheckpoint*                      CurrentCheckPoint;                                 // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath) == 0x000008, "Wrong alignment on FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath");
static_assert(sizeof(FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath) == 0x000008, "Wrong size on FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath");
static_assert(offsetof(FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath, CurrentCheckPoint) == 0x000000, "Member 'FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath::CurrentCheckPoint' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_PlacementUpdated
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_PlacementUpdated final : public FDelMarVerbMessageBase
{
public:
	uint8                                         CurrentPosition;                                   // 0x0138(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDelMarPositionChangeInfo                     PositionChangeInfo;                                // 0x0139(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13A[0x6];                                      // 0x013A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_PlacementUpdated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_PlacementUpdated");
static_assert(sizeof(FDelMarVerbMessage_PlacementUpdated) == 0x000140, "Wrong size on FDelMarVerbMessage_PlacementUpdated");
static_assert(offsetof(FDelMarVerbMessage_PlacementUpdated, CurrentPosition) == 0x000138, "Member 'FDelMarVerbMessage_PlacementUpdated::CurrentPosition' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_PlacementUpdated, PositionChangeInfo) == 0x000139, "Member 'FDelMarVerbMessage_PlacementUpdated::PositionChangeInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_TeleportEnteredEvent
// 0x0010 (0x0010 - 0x0000)
struct FDelMarEvent_TeleportEnteredEvent final
{
public:
	class ADelMarCheckpoint*                      CheckpointEntered;                                 // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnteredInFinalLap;                                // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_TeleportEnteredEvent) == 0x000008, "Wrong alignment on FDelMarEvent_TeleportEnteredEvent");
static_assert(sizeof(FDelMarEvent_TeleportEnteredEvent) == 0x000010, "Wrong size on FDelMarEvent_TeleportEnteredEvent");
static_assert(offsetof(FDelMarEvent_TeleportEnteredEvent, CheckpointEntered) == 0x000000, "Member 'FDelMarEvent_TeleportEnteredEvent::CheckpointEntered' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_TeleportEnteredEvent, bEnteredInFinalLap) == 0x000008, "Member 'FDelMarEvent_TeleportEnteredEvent::bEnteredInFinalLap' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_TeleportExitedEvent
// 0x0008 (0x0008 - 0x0000)
struct FDelMarEvent_TeleportExitedEvent final
{
public:
	class ADelMarCheckpoint*                      CheckpointExited;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_TeleportExitedEvent) == 0x000008, "Wrong alignment on FDelMarEvent_TeleportExitedEvent");
static_assert(sizeof(FDelMarEvent_TeleportExitedEvent) == 0x000008, "Wrong size on FDelMarEvent_TeleportExitedEvent");
static_assert(offsetof(FDelMarEvent_TeleportExitedEvent, CheckpointExited) == 0x000000, "Member 'FDelMarEvent_TeleportExitedEvent::CheckpointExited' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_VehicleLanded
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_VehicleLanded final : public FDelMarVerbMessageBase
{
public:
	float                                         TimeInAir;                                         // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_VehicleLanded) == 0x000008, "Wrong alignment on FDelMarVerbMessage_VehicleLanded");
static_assert(sizeof(FDelMarVerbMessage_VehicleLanded) == 0x000140, "Wrong size on FDelMarVerbMessage_VehicleLanded");
static_assert(offsetof(FDelMarVerbMessage_VehicleLanded, TimeInAir) == 0x000138, "Member 'FDelMarVerbMessage_VehicleLanded::TimeInAir' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_SectionComplete_ParallelPath
// 0x0020 (0x0020 - 0x0000)
struct FDelMarEvent_SectionComplete_ParallelPath final
{
public:
	int32                                         ActiveLap;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADelMarCheckpoint*                      CompletedCheckpoint;                               // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADelMarCheckpoint*                      CurrentCheckPoint;                                 // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CompletedSectionTime;                              // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_SectionComplete_ParallelPath) == 0x000008, "Wrong alignment on FDelMarEvent_SectionComplete_ParallelPath");
static_assert(sizeof(FDelMarEvent_SectionComplete_ParallelPath) == 0x000020, "Wrong size on FDelMarEvent_SectionComplete_ParallelPath");
static_assert(offsetof(FDelMarEvent_SectionComplete_ParallelPath, ActiveLap) == 0x000000, "Member 'FDelMarEvent_SectionComplete_ParallelPath::ActiveLap' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SectionComplete_ParallelPath, SectionIndex) == 0x000004, "Member 'FDelMarEvent_SectionComplete_ParallelPath::SectionIndex' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SectionComplete_ParallelPath, CompletedCheckpoint) == 0x000008, "Member 'FDelMarEvent_SectionComplete_ParallelPath::CompletedCheckpoint' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SectionComplete_ParallelPath, CurrentCheckPoint) == 0x000010, "Member 'FDelMarEvent_SectionComplete_ParallelPath::CurrentCheckPoint' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SectionComplete_ParallelPath, CompletedSectionTime) == 0x000018, "Member 'FDelMarEvent_SectionComplete_ParallelPath::CompletedSectionTime' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_LapComplete
// 0x0020 (0x0020 - 0x0000)
struct FDelMarEvent_LapComplete final
{
public:
	class AFortPlayerState*                       PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompletedLap;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLap;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalLaps;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        CompletedLapTime;                                  // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_LapComplete) == 0x000008, "Wrong alignment on FDelMarEvent_LapComplete");
static_assert(sizeof(FDelMarEvent_LapComplete) == 0x000020, "Wrong size on FDelMarEvent_LapComplete");
static_assert(offsetof(FDelMarEvent_LapComplete, PlayerState) == 0x000000, "Member 'FDelMarEvent_LapComplete::PlayerState' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LapComplete, CompletedLap) == 0x000008, "Member 'FDelMarEvent_LapComplete::CompletedLap' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LapComplete, CurrentLap) == 0x00000C, "Member 'FDelMarEvent_LapComplete::CurrentLap' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LapComplete, TotalLaps) == 0x000010, "Member 'FDelMarEvent_LapComplete::TotalLaps' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LapComplete, CompletedLapTime) == 0x000018, "Member 'FDelMarEvent_LapComplete::CompletedLapTime' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarLoadout
// 0x0050 (0x0050 - 0x0000)
struct FDelMarLoadout final
{
public:
	TMap<struct FGameplayTag, class UDelMarCosmeticItemDefinition*> Items;                                             // 0x0000(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDelMarLoadout) == 0x000008, "Wrong alignment on FDelMarLoadout");
static_assert(sizeof(FDelMarLoadout) == 0x000050, "Wrong size on FDelMarLoadout");
static_assert(offsetof(FDelMarLoadout, Items) == 0x000000, "Member 'FDelMarLoadout::Items' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarLapRecord
// 0x0018 (0x0018 - 0x0000)
struct FDelMarLapRecord final
{
public:
	double                                        LapDuration;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<double>                                SectionTimes;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarLapRecord) == 0x000008, "Wrong alignment on FDelMarLapRecord");
static_assert(sizeof(FDelMarLapRecord) == 0x000018, "Wrong size on FDelMarLapRecord");
static_assert(offsetof(FDelMarLapRecord, LapDuration) == 0x000000, "Member 'FDelMarLapRecord::LapDuration' has a wrong offset!");
static_assert(offsetof(FDelMarLapRecord, SectionTimes) == 0x000008, "Member 'FDelMarLapRecord::SectionTimes' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarRunRecord
// 0x0020 (0x0020 - 0x0000)
struct FDelMarRunRecord final
{
public:
	double                                        RunDuration;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RunStartTimestamp;                                 // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDelMarLapRecord>               LapRecords;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarRunRecord) == 0x000008, "Wrong alignment on FDelMarRunRecord");
static_assert(sizeof(FDelMarRunRecord) == 0x000020, "Wrong size on FDelMarRunRecord");
static_assert(offsetof(FDelMarRunRecord, RunDuration) == 0x000000, "Member 'FDelMarRunRecord::RunDuration' has a wrong offset!");
static_assert(offsetof(FDelMarRunRecord, RunStartTimestamp) == 0x000008, "Member 'FDelMarRunRecord::RunStartTimestamp' has a wrong offset!");
static_assert(offsetof(FDelMarRunRecord, LapRecords) == 0x000010, "Member 'FDelMarRunRecord::LapRecords' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_LapRecorded
// 0x0030 (0x0030 - 0x0000)
struct FDelMarEvent_LapRecorded final
{
public:
	int32                                         CompletedLap;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarRunRecord                       CurrentRunRecord;                                  // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	float                                         BestSingleLapTime;                                 // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewLapRecord;                                   // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_LapRecorded) == 0x000008, "Wrong alignment on FDelMarEvent_LapRecorded");
static_assert(sizeof(FDelMarEvent_LapRecorded) == 0x000030, "Wrong size on FDelMarEvent_LapRecorded");
static_assert(offsetof(FDelMarEvent_LapRecorded, CompletedLap) == 0x000000, "Member 'FDelMarEvent_LapRecorded::CompletedLap' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LapRecorded, CurrentRunRecord) == 0x000008, "Member 'FDelMarEvent_LapRecorded::CurrentRunRecord' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LapRecorded, BestSingleLapTime) == 0x000028, "Member 'FDelMarEvent_LapRecorded::BestSingleLapTime' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_LapRecorded, bIsNewLapRecord) == 0x00002C, "Member 'FDelMarEvent_LapRecorded::bIsNewLapRecord' has a wrong offset!");

// ScriptStruct DelMarCore.CheckpointTrackDistance
// 0x0018 (0x0018 - 0x0000)
struct FCheckpointTrackDistance final
{
public:
	class ADelMarTrack*                           Track;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryDistance;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalDistance;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCheckpointTrackDistance) == 0x000008, "Wrong alignment on FCheckpointTrackDistance");
static_assert(sizeof(FCheckpointTrackDistance) == 0x000018, "Wrong size on FCheckpointTrackDistance");
static_assert(offsetof(FCheckpointTrackDistance, Track) == 0x000000, "Member 'FCheckpointTrackDistance::Track' has a wrong offset!");
static_assert(offsetof(FCheckpointTrackDistance, PrimaryDistance) == 0x000008, "Member 'FCheckpointTrackDistance::PrimaryDistance' has a wrong offset!");
static_assert(offsetof(FCheckpointTrackDistance, LocalDistance) == 0x00000C, "Member 'FCheckpointTrackDistance::LocalDistance' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_SectionRecorded
// 0x0050 (0x0050 - 0x0000)
struct FDelMarEvent_SectionRecorded final
{
public:
	int32                                         ActiveLap;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarRunRecord                       BestSectionsRunRecord;                             // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FDelMarRunRecord                       CurrentRunRecord;                                  // 0x0028(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          bIsNewSectionRecord;                               // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_SectionRecorded) == 0x000008, "Wrong alignment on FDelMarEvent_SectionRecorded");
static_assert(sizeof(FDelMarEvent_SectionRecorded) == 0x000050, "Wrong size on FDelMarEvent_SectionRecorded");
static_assert(offsetof(FDelMarEvent_SectionRecorded, ActiveLap) == 0x000000, "Member 'FDelMarEvent_SectionRecorded::ActiveLap' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SectionRecorded, SectionIndex) == 0x000004, "Member 'FDelMarEvent_SectionRecorded::SectionIndex' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SectionRecorded, BestSectionsRunRecord) == 0x000008, "Member 'FDelMarEvent_SectionRecorded::BestSectionsRunRecord' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SectionRecorded, CurrentRunRecord) == 0x000028, "Member 'FDelMarEvent_SectionRecorded::CurrentRunRecord' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_SectionRecorded, bIsNewSectionRecord) == 0x000048, "Member 'FDelMarEvent_SectionRecorded::bIsNewSectionRecord' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_UnderthrustPercentUsed
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_UnderthrustPercentUsed final : public FDelMarVerbMessageBase
{
public:
	float                                         PercentUsed;                                       // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_UnderthrustPercentUsed) == 0x000008, "Wrong alignment on FDelMarVerbMessage_UnderthrustPercentUsed");
static_assert(sizeof(FDelMarVerbMessage_UnderthrustPercentUsed) == 0x000140, "Wrong size on FDelMarVerbMessage_UnderthrustPercentUsed");
static_assert(offsetof(FDelMarVerbMessage_UnderthrustPercentUsed, PercentUsed) == 0x000138, "Member 'FDelMarVerbMessage_UnderthrustPercentUsed::PercentUsed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_RunRecorded
// 0x0050 (0x0050 - 0x0000)
struct FDelMarEvent_RunRecorded final
{
public:
	class AFortPlayerState*                       PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarRunRecord                       CurrentRunRecord;                                  // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FDelMarRunRecord                       BestRunRecord;                                     // 0x0028(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          bIsNewBestRun;                                     // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_RunRecorded) == 0x000008, "Wrong alignment on FDelMarEvent_RunRecorded");
static_assert(sizeof(FDelMarEvent_RunRecorded) == 0x000050, "Wrong size on FDelMarEvent_RunRecorded");
static_assert(offsetof(FDelMarEvent_RunRecorded, PlayerState) == 0x000000, "Member 'FDelMarEvent_RunRecorded::PlayerState' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_RunRecorded, CurrentRunRecord) == 0x000008, "Member 'FDelMarEvent_RunRecorded::CurrentRunRecord' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_RunRecorded, BestRunRecord) == 0x000028, "Member 'FDelMarEvent_RunRecorded::BestRunRecord' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_RunRecorded, bIsNewBestRun) == 0x000048, "Member 'FDelMarEvent_RunRecorded::bIsNewBestRun' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_NuxConnectedHintActionPerformed
// 0x0008 (0x0008 - 0x0000)
struct FDelMarEvent_NuxConnectedHintActionPerformed final
{
public:
	struct FGameplayTag                           HintTypeTag;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDidPerformAction;                                 // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_NuxConnectedHintActionPerformed) == 0x000004, "Wrong alignment on FDelMarEvent_NuxConnectedHintActionPerformed");
static_assert(sizeof(FDelMarEvent_NuxConnectedHintActionPerformed) == 0x000008, "Wrong size on FDelMarEvent_NuxConnectedHintActionPerformed");
static_assert(offsetof(FDelMarEvent_NuxConnectedHintActionPerformed, HintTypeTag) == 0x000000, "Member 'FDelMarEvent_NuxConnectedHintActionPerformed::HintTypeTag' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_NuxConnectedHintActionPerformed, bDidPerformAction) == 0x000004, "Member 'FDelMarEvent_NuxConnectedHintActionPerformed::bDidPerformAction' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarTimeDelayedState
// 0x0008 (0x0008 - 0x0000)
struct FDelMarTimeDelayedState final
{
public:
	struct FGameplayTag                           Name;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarTimeDelayedState) == 0x000004, "Wrong alignment on FDelMarTimeDelayedState");
static_assert(sizeof(FDelMarTimeDelayedState) == 0x000008, "Wrong size on FDelMarTimeDelayedState");
static_assert(offsetof(FDelMarTimeDelayedState, Name) == 0x000000, "Member 'FDelMarTimeDelayedState::Name' has a wrong offset!");
static_assert(offsetof(FDelMarTimeDelayedState, duration) == 0x000004, "Member 'FDelMarTimeDelayedState::duration' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_RaceModeSet
// 0x0004 (0x0004 - 0x0000)
struct FDelMarEvent_RaceModeSet final
{
public:
	struct FGameplayTag                           RaceModeTag;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_RaceModeSet) == 0x000004, "Wrong alignment on FDelMarEvent_RaceModeSet");
static_assert(sizeof(FDelMarEvent_RaceModeSet) == 0x000004, "Wrong size on FDelMarEvent_RaceModeSet");
static_assert(offsetof(FDelMarEvent_RaceModeSet, RaceModeTag) == 0x000000, "Member 'FDelMarEvent_RaceModeSet::RaceModeTag' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarGlobalLeaderboardEntry
// 0x0040 (0x0040 - 0x0000)
struct FDelMarGlobalLeaderboardEntry final
{
public:
	class FString                                 PlayerAccountId;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RunDuration;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Rank;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Percentile;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalPlayer;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarGlobalLeaderboardEntry) == 0x000008, "Wrong alignment on FDelMarGlobalLeaderboardEntry");
static_assert(sizeof(FDelMarGlobalLeaderboardEntry) == 0x000040, "Wrong size on FDelMarGlobalLeaderboardEntry");
static_assert(offsetof(FDelMarGlobalLeaderboardEntry, PlayerAccountId) == 0x000000, "Member 'FDelMarGlobalLeaderboardEntry::PlayerAccountId' has a wrong offset!");
static_assert(offsetof(FDelMarGlobalLeaderboardEntry, PlayerName) == 0x000010, "Member 'FDelMarGlobalLeaderboardEntry::PlayerName' has a wrong offset!");
static_assert(offsetof(FDelMarGlobalLeaderboardEntry, RunDuration) == 0x000020, "Member 'FDelMarGlobalLeaderboardEntry::RunDuration' has a wrong offset!");
static_assert(offsetof(FDelMarGlobalLeaderboardEntry, Rank) == 0x000028, "Member 'FDelMarGlobalLeaderboardEntry::Rank' has a wrong offset!");
static_assert(offsetof(FDelMarGlobalLeaderboardEntry, Percentile) == 0x000030, "Member 'FDelMarGlobalLeaderboardEntry::Percentile' has a wrong offset!");
static_assert(offsetof(FDelMarGlobalLeaderboardEntry, bIsLocalPlayer) == 0x000038, "Member 'FDelMarGlobalLeaderboardEntry::bIsLocalPlayer' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_GlobalLeaderboardNewPersonalBest
// 0x0048 (0x0048 - 0x0000)
struct FDelMarEvent_GlobalLeaderboardNewPersonalBest final
{
public:
	TWeakObjectPtr<class AFortPlayerState>        Player;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarGlobalLeaderboardEntry          PersonalBest;                                      // 0x0008(0x0040)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_GlobalLeaderboardNewPersonalBest) == 0x000008, "Wrong alignment on FDelMarEvent_GlobalLeaderboardNewPersonalBest");
static_assert(sizeof(FDelMarEvent_GlobalLeaderboardNewPersonalBest) == 0x000048, "Wrong size on FDelMarEvent_GlobalLeaderboardNewPersonalBest");
static_assert(offsetof(FDelMarEvent_GlobalLeaderboardNewPersonalBest, Player) == 0x000000, "Member 'FDelMarEvent_GlobalLeaderboardNewPersonalBest::Player' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_GlobalLeaderboardNewPersonalBest, PersonalBest) == 0x000008, "Member 'FDelMarEvent_GlobalLeaderboardNewPersonalBest::PersonalBest' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarFinalRacePositionEntry
// 0x0010 (0x0010 - 0x0000)
struct FDelMarFinalRacePositionEntry final
{
public:
	TWeakObjectPtr<class AFortPlayerState>        PlayerState;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RunTime;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarFinalRacePositionEntry) == 0x000008, "Wrong alignment on FDelMarFinalRacePositionEntry");
static_assert(sizeof(FDelMarFinalRacePositionEntry) == 0x000010, "Wrong size on FDelMarFinalRacePositionEntry");
static_assert(offsetof(FDelMarFinalRacePositionEntry, PlayerState) == 0x000000, "Member 'FDelMarFinalRacePositionEntry::PlayerState' has a wrong offset!");
static_assert(offsetof(FDelMarFinalRacePositionEntry, RunTime) == 0x000008, "Member 'FDelMarFinalRacePositionEntry::RunTime' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_MatchmakingStateChanged
// 0x0001 (0x0001 - 0x0000)
struct FDelMarEvent_MatchmakingStateChanged final
{
public:
	uint8                                         NewPostMatchState;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEvent_MatchmakingStateChanged) == 0x000001, "Wrong alignment on FDelMarEvent_MatchmakingStateChanged");
static_assert(sizeof(FDelMarEvent_MatchmakingStateChanged) == 0x000001, "Wrong size on FDelMarEvent_MatchmakingStateChanged");
static_assert(offsetof(FDelMarEvent_MatchmakingStateChanged, NewPostMatchState) == 0x000000, "Member 'FDelMarEvent_MatchmakingStateChanged::NewPostMatchState' has a wrong offset!");

// ScriptStruct DelMarCore.PhysicalMaterialAttributes_X
// 0x0010 (0x0010 - 0x0000)
struct FPhysicalMaterialAttributes_X final
{
public:
	TArray<class UDelMarPhysMatAttribute*>        Attributes;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicalMaterialAttributes_X) == 0x000008, "Wrong alignment on FPhysicalMaterialAttributes_X");
static_assert(sizeof(FPhysicalMaterialAttributes_X) == 0x000010, "Wrong size on FPhysicalMaterialAttributes_X");
static_assert(offsetof(FPhysicalMaterialAttributes_X, Attributes) == 0x000000, "Member 'FPhysicalMaterialAttributes_X::Attributes' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_PostRaceReturnToLobbySelected
// 0x0001 (0x0001 - 0x0000)
struct FDelMarEvent_PostRaceReturnToLobbySelected final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_PostRaceReturnToLobbySelected) == 0x000001, "Wrong alignment on FDelMarEvent_PostRaceReturnToLobbySelected");
static_assert(sizeof(FDelMarEvent_PostRaceReturnToLobbySelected) == 0x000001, "Wrong size on FDelMarEvent_PostRaceReturnToLobbySelected");

// ScriptStruct DelMarCore.DelMarEvent_PostRaceNextRaceSelected
// 0x0001 (0x0001 - 0x0000)
struct FDelMarEvent_PostRaceNextRaceSelected final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_PostRaceNextRaceSelected) == 0x000001, "Wrong alignment on FDelMarEvent_PostRaceNextRaceSelected");
static_assert(sizeof(FDelMarEvent_PostRaceNextRaceSelected) == 0x000001, "Wrong size on FDelMarEvent_PostRaceNextRaceSelected");

// ScriptStruct DelMarCore.DelMarVehicleCameraSettings
// 0x001C (0x001C - 0x0000)
struct FDelMarVehicleCameraSettings final
{
public:
	float                                         FOV;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pitch;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelSpeed;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionSpeed;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleCameraSettings) == 0x000004, "Wrong alignment on FDelMarVehicleCameraSettings");
static_assert(sizeof(FDelMarVehicleCameraSettings) == 0x00001C, "Wrong size on FDelMarVehicleCameraSettings");
static_assert(offsetof(FDelMarVehicleCameraSettings, FOV) == 0x000000, "Member 'FDelMarVehicleCameraSettings::FOV' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCameraSettings, Height) == 0x000004, "Member 'FDelMarVehicleCameraSettings::Height' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCameraSettings, pitch) == 0x000008, "Member 'FDelMarVehicleCameraSettings::pitch' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCameraSettings, Distance) == 0x00000C, "Member 'FDelMarVehicleCameraSettings::Distance' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCameraSettings, Stiffness) == 0x000010, "Member 'FDelMarVehicleCameraSettings::Stiffness' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCameraSettings, SwivelSpeed) == 0x000014, "Member 'FDelMarVehicleCameraSettings::SwivelSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCameraSettings, TransitionSpeed) == 0x000018, "Member 'FDelMarVehicleCameraSettings::TransitionSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarFloatModifier
// 0x0014 (0x0014 - 0x0000)
struct FDelMarFloatModifier final
{
public:
	class FName                                   Category;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarFloatOperation                         Operation;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarModifierStackingPolicy                 StackingPolicy;                                    // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Handle;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarFloatModifier) == 0x000004, "Wrong alignment on FDelMarFloatModifier");
static_assert(sizeof(FDelMarFloatModifier) == 0x000014, "Wrong size on FDelMarFloatModifier");
static_assert(offsetof(FDelMarFloatModifier, Category) == 0x000000, "Member 'FDelMarFloatModifier::Category' has a wrong offset!");
static_assert(offsetof(FDelMarFloatModifier, Priority) == 0x000004, "Member 'FDelMarFloatModifier::Priority' has a wrong offset!");
static_assert(offsetof(FDelMarFloatModifier, Value) == 0x000008, "Member 'FDelMarFloatModifier::Value' has a wrong offset!");
static_assert(offsetof(FDelMarFloatModifier, Operation) == 0x00000C, "Member 'FDelMarFloatModifier::Operation' has a wrong offset!");
static_assert(offsetof(FDelMarFloatModifier, StackingPolicy) == 0x00000D, "Member 'FDelMarFloatModifier::StackingPolicy' has a wrong offset!");
static_assert(offsetof(FDelMarFloatModifier, Handle) == 0x000010, "Member 'FDelMarFloatModifier::Handle' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarFloatAttribute
// 0x0030 (0x0030 - 0x0000)
struct FDelMarFloatAttribute final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalValue;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMin;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinValue;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMax;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxValue;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDelMarFloatModifier>           Modifiers;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrentHandleIdx;                                  // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarFloatAttribute) == 0x000008, "Wrong alignment on FDelMarFloatAttribute");
static_assert(sizeof(FDelMarFloatAttribute) == 0x000030, "Wrong size on FDelMarFloatAttribute");
static_assert(offsetof(FDelMarFloatAttribute, BaseValue) == 0x000000, "Member 'FDelMarFloatAttribute::BaseValue' has a wrong offset!");
static_assert(offsetof(FDelMarFloatAttribute, FinalValue) == 0x000004, "Member 'FDelMarFloatAttribute::FinalValue' has a wrong offset!");
static_assert(offsetof(FDelMarFloatAttribute, bClampMin) == 0x000008, "Member 'FDelMarFloatAttribute::bClampMin' has a wrong offset!");
static_assert(offsetof(FDelMarFloatAttribute, MinValue) == 0x00000C, "Member 'FDelMarFloatAttribute::MinValue' has a wrong offset!");
static_assert(offsetof(FDelMarFloatAttribute, bClampMax) == 0x000010, "Member 'FDelMarFloatAttribute::bClampMax' has a wrong offset!");
static_assert(offsetof(FDelMarFloatAttribute, MaxValue) == 0x000014, "Member 'FDelMarFloatAttribute::MaxValue' has a wrong offset!");
static_assert(offsetof(FDelMarFloatAttribute, Modifiers) == 0x000018, "Member 'FDelMarFloatAttribute::Modifiers' has a wrong offset!");
static_assert(offsetof(FDelMarFloatAttribute, CurrentHandleIdx) == 0x000028, "Member 'FDelMarFloatAttribute::CurrentHandleIdx' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_BonusSpeedAbility
// 0x0004 (0x000C - 0x0008)
struct FDelMarVehicleReplicatedState_BonusSpeedAbility : public FDelMarVehicleReplicatedState_Ability
{
public:
	float                                         AppliedBonusSpeed;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_BonusSpeedAbility) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_BonusSpeedAbility");
static_assert(sizeof(FDelMarVehicleReplicatedState_BonusSpeedAbility) == 0x00000C, "Wrong size on FDelMarVehicleReplicatedState_BonusSpeedAbility");
static_assert(offsetof(FDelMarVehicleReplicatedState_BonusSpeedAbility, AppliedBonusSpeed) == 0x000008, "Member 'FDelMarVehicleReplicatedState_BonusSpeedAbility::AppliedBonusSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.GhostReplayFrame
// 0x0050 (0x0050 - 0x0000)
struct FGhostReplayFrame final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Time;                                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGhostReplayFrame) == 0x000010, "Wrong alignment on FGhostReplayFrame");
static_assert(sizeof(FGhostReplayFrame) == 0x000050, "Wrong size on FGhostReplayFrame");
static_assert(offsetof(FGhostReplayFrame, Location) == 0x000000, "Member 'FGhostReplayFrame::Location' has a wrong offset!");
static_assert(offsetof(FGhostReplayFrame, Rotation) == 0x000020, "Member 'FGhostReplayFrame::Rotation' has a wrong offset!");
static_assert(offsetof(FGhostReplayFrame, Time) == 0x000040, "Member 'FGhostReplayFrame::Time' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarLeaderboardSettings
// 0x0020 (0x0020 - 0x0000)
struct FDelMarLeaderboardSettings final
{
public:
	class FString                                 EventId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WindowId;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarLeaderboardSettings) == 0x000008, "Wrong alignment on FDelMarLeaderboardSettings");
static_assert(sizeof(FDelMarLeaderboardSettings) == 0x000020, "Wrong size on FDelMarLeaderboardSettings");
static_assert(offsetof(FDelMarLeaderboardSettings, EventId) == 0x000000, "Member 'FDelMarLeaderboardSettings::EventId' has a wrong offset!");
static_assert(offsetof(FDelMarLeaderboardSettings, WindowId) == 0x000010, "Member 'FDelMarLeaderboardSettings::WindowId' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarStateOverride
// 0x0028 (0x0028 - 0x0000)
struct FDelMarStateOverride final
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0000(0x0004)(Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   StateClass;                                        // 0x0008(0x0020)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarStateOverride) == 0x000008, "Wrong alignment on FDelMarStateOverride");
static_assert(sizeof(FDelMarStateOverride) == 0x000028, "Wrong size on FDelMarStateOverride");
static_assert(offsetof(FDelMarStateOverride, StateTag) == 0x000000, "Member 'FDelMarStateOverride::StateTag' has a wrong offset!");
static_assert(offsetof(FDelMarStateOverride, StateClass) == 0x000008, "Member 'FDelMarStateOverride::StateClass' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarInputAction
// 0x0010 (0x0010 - 0x0000)
struct FDelMarInputAction final
{
public:
	class UInputAction*                           Action;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DisabledTag;                                       // 0x0008(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarInputAction) == 0x000008, "Wrong alignment on FDelMarInputAction");
static_assert(sizeof(FDelMarInputAction) == 0x000010, "Wrong size on FDelMarInputAction");
static_assert(offsetof(FDelMarInputAction, Action) == 0x000000, "Member 'FDelMarInputAction::Action' has a wrong offset!");
static_assert(offsetof(FDelMarInputAction, DisabledTag) == 0x000008, "Member 'FDelMarInputAction::DisabledTag' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarInputMappingContextData
// 0x0010 (0x0010 - 0x0000)
struct FDelMarInputMappingContextData final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortInputMappingContext*               MappingContext;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarInputMappingContextData) == 0x000008, "Wrong alignment on FDelMarInputMappingContextData");
static_assert(sizeof(FDelMarInputMappingContextData) == 0x000010, "Wrong size on FDelMarInputMappingContextData");
static_assert(offsetof(FDelMarInputMappingContextData, Priority) == 0x000000, "Member 'FDelMarInputMappingContextData::Priority' has a wrong offset!");
static_assert(offsetof(FDelMarInputMappingContextData, MappingContext) == 0x000008, "Member 'FDelMarInputMappingContextData::MappingContext' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_DriftBoost
// 0x0014 (0x0020 - 0x000C)
struct FDelMarVehicleReplicatedState_DriftBoost final : public FDelMarVehicleReplicatedState_BonusSpeedAbility
{
public:
	float                                         AccumulatedDriftBoostSeconds;                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedWaitingPeriodSeconds;                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalEarnedBonusSpeed;                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueuedBonusSpeed;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueuedBoostExtraSeconds;                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_DriftBoost) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_DriftBoost");
static_assert(sizeof(FDelMarVehicleReplicatedState_DriftBoost) == 0x000020, "Wrong size on FDelMarVehicleReplicatedState_DriftBoost");
static_assert(offsetof(FDelMarVehicleReplicatedState_DriftBoost, AccumulatedDriftBoostSeconds) == 0x00000C, "Member 'FDelMarVehicleReplicatedState_DriftBoost::AccumulatedDriftBoostSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_DriftBoost, AccumulatedWaitingPeriodSeconds) == 0x000010, "Member 'FDelMarVehicleReplicatedState_DriftBoost::AccumulatedWaitingPeriodSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_DriftBoost, TotalEarnedBonusSpeed) == 0x000014, "Member 'FDelMarVehicleReplicatedState_DriftBoost::TotalEarnedBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_DriftBoost, QueuedBonusSpeed) == 0x000018, "Member 'FDelMarVehicleReplicatedState_DriftBoost::QueuedBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_DriftBoost, QueuedBoostExtraSeconds) == 0x00001C, "Member 'FDelMarVehicleReplicatedState_DriftBoost::QueuedBoostExtraSeconds' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarActivatedInput
// 0x0020 (0x0020 - 0x0000)
struct FDelMarActivatedInput final
{
public:
	class UInputAction*                           Action;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarActivatedInput) == 0x000008, "Wrong alignment on FDelMarActivatedInput");
static_assert(sizeof(FDelMarActivatedInput) == 0x000020, "Wrong size on FDelMarActivatedInput");
static_assert(offsetof(FDelMarActivatedInput, Action) == 0x000000, "Member 'FDelMarActivatedInput::Action' has a wrong offset!");
static_assert(offsetof(FDelMarActivatedInput, Value) == 0x000008, "Member 'FDelMarActivatedInput::Value' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarActivatedInputFrame
// 0x0018 (0x0018 - 0x0000)
struct FDelMarActivatedInputFrame final
{
public:
	float                                         duration;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDelMarActivatedInput>          Inputs;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarActivatedInputFrame) == 0x000008, "Wrong alignment on FDelMarActivatedInputFrame");
static_assert(sizeof(FDelMarActivatedInputFrame) == 0x000018, "Wrong size on FDelMarActivatedInputFrame");
static_assert(offsetof(FDelMarActivatedInputFrame, duration) == 0x000000, "Member 'FDelMarActivatedInputFrame::duration' has a wrong offset!");
static_assert(offsetof(FDelMarActivatedInputFrame, Inputs) == 0x000008, "Member 'FDelMarActivatedInputFrame::Inputs' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarKickflipSimulationResult
// 0x0120 (0x0120 - 0x0000)
struct FDelMarKickflipSimulationResult final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  VehicleLandingRotation;                            // 0x00F0(0x0020)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidLandingRotation;                             // 0x0110(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriveableSurfaceHit;                              // 0x0111(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x2];                                      // 0x0112(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuctionVelocityUsed;                               // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceTravelled;                                 // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarKickflipSimulationResult) == 0x000010, "Wrong alignment on FDelMarKickflipSimulationResult");
static_assert(sizeof(FDelMarKickflipSimulationResult) == 0x000120, "Wrong size on FDelMarKickflipSimulationResult");
static_assert(offsetof(FDelMarKickflipSimulationResult, Hit) == 0x000000, "Member 'FDelMarKickflipSimulationResult::Hit' has a wrong offset!");
static_assert(offsetof(FDelMarKickflipSimulationResult, VehicleLandingRotation) == 0x0000F0, "Member 'FDelMarKickflipSimulationResult::VehicleLandingRotation' has a wrong offset!");
static_assert(offsetof(FDelMarKickflipSimulationResult, bValidLandingRotation) == 0x000110, "Member 'FDelMarKickflipSimulationResult::bValidLandingRotation' has a wrong offset!");
static_assert(offsetof(FDelMarKickflipSimulationResult, bDriveableSurfaceHit) == 0x000111, "Member 'FDelMarKickflipSimulationResult::bDriveableSurfaceHit' has a wrong offset!");
static_assert(offsetof(FDelMarKickflipSimulationResult, SuctionVelocityUsed) == 0x000114, "Member 'FDelMarKickflipSimulationResult::SuctionVelocityUsed' has a wrong offset!");
static_assert(offsetof(FDelMarKickflipSimulationResult, ElapsedTime) == 0x000118, "Member 'FDelMarKickflipSimulationResult::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FDelMarKickflipSimulationResult, DistanceTravelled) == 0x00011C, "Member 'FDelMarKickflipSimulationResult::DistanceTravelled' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarDisabledInputData
// 0x0010 (0x0010 - 0x0000)
struct FDelMarDisabledInputData final
{
public:
	float                                         duration;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarDisabledInputData) == 0x000008, "Wrong alignment on FDelMarDisabledInputData");
static_assert(sizeof(FDelMarDisabledInputData) == 0x000010, "Wrong size on FDelMarDisabledInputData");
static_assert(offsetof(FDelMarDisabledInputData, duration) == 0x000000, "Member 'FDelMarDisabledInputData::duration' has a wrong offset!");
static_assert(offsetof(FDelMarDisabledInputData, EffectClass) == 0x000008, "Member 'FDelMarDisabledInputData::EffectClass' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilterBase
// 0x00F0 (0x0190 - 0x00A0)
struct FDelMarObjectiveFilterBase : public FObjectiveFilter
{
public:
	struct FObjectiveSubjectTags                  LevelDescriptionId;                                // 0x00A0(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FObjectiveSubjectTags                  GameModeId;                                        // 0x00E8(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FObjectiveSubjectTags                  VehicleTags;                                       // 0x0130(0x0048)(Edit, NativeAccessSpecifierPublic)
	EDelMarPlaylistTypeInfo                       RequiredPlaylistTypeInfo;                          // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDelMarCosmeticItemDefinition>> RequiredCosmetics;                                 // 0x0180(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilterBase) == 0x000008, "Wrong alignment on FDelMarObjectiveFilterBase");
static_assert(sizeof(FDelMarObjectiveFilterBase) == 0x000190, "Wrong size on FDelMarObjectiveFilterBase");
static_assert(offsetof(FDelMarObjectiveFilterBase, LevelDescriptionId) == 0x0000A0, "Member 'FDelMarObjectiveFilterBase::LevelDescriptionId' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilterBase, GameModeId) == 0x0000E8, "Member 'FDelMarObjectiveFilterBase::GameModeId' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilterBase, VehicleTags) == 0x000130, "Member 'FDelMarObjectiveFilterBase::VehicleTags' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilterBase, RequiredPlaylistTypeInfo) == 0x000178, "Member 'FDelMarObjectiveFilterBase::RequiredPlaylistTypeInfo' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilterBase, RequiredCosmetics) == 0x000180, "Member 'FDelMarObjectiveFilterBase::RequiredCosmetics' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarRandomRange
// 0x0008 (0x0008 - 0x0000)
struct FDelMarRandomRange final
{
public:
	float                                         MinValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarRandomRange) == 0x000004, "Wrong alignment on FDelMarRandomRange");
static_assert(sizeof(FDelMarRandomRange) == 0x000008, "Wrong size on FDelMarRandomRange");
static_assert(offsetof(FDelMarRandomRange, MinValue) == 0x000000, "Member 'FDelMarRandomRange::MinValue' has a wrong offset!");
static_assert(offsetof(FDelMarRandomRange, MaxValue) == 0x000004, "Member 'FDelMarRandomRange::MaxValue' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_BeatPlayers
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_BeatPlayers final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_BeatPlayers) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_BeatPlayers");
static_assert(sizeof(FDelMarObjectiveFilter_BeatPlayers) == 0x000190, "Wrong size on FDelMarObjectiveFilter_BeatPlayers");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_BonusTurboActivated
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_BonusTurboActivated final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_BonusTurboActivated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_BonusTurboActivated");
static_assert(sizeof(FDelMarObjectiveFilter_BonusTurboActivated) == 0x000190, "Wrong size on FDelMarObjectiveFilter_BonusTurboActivated");

// ScriptStruct DelMarCore.DelMarVehicleDriveSetup
// 0x0360 (0x0360 - 0x0000)
struct FDelMarVehicleDriveSetup final
{
public:
	float                                         MaxBaseForwardSpeed;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarScaledCurve                     DriveAccel;                                        // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     TargetSpeedMaxAccelCurve;                          // 0x0098(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         TargetSpeedAerialFriction;                         // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowBrakingInAir;                                // 0x012C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrakeAccel;                                        // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopSpeed;                                         // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleBrakeFactor;                                   // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedToResetTargetSpeedDirection;               // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     SteerAngleCurve;                                   // 0x0140(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FRuntimeFloatCurve>             SteerAngleCurveOverrides;                          // 0x01C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     LatFrictionCurve;                                  // 0x01D8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     WheelsGroundedFrictionCurve;                       // 0x0268(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MaxForwardSpeedToIgnoreLandingSpeed;               // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxKickflipLandingSeconds;                         // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlipAngle;                                      // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkydiveVerticalVelocitySensitivity;                // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkydiveVerticalPitchSensitivity;                   // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StableSpeedMinGroundedTime;                        // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInAirTimeStableLanding;                         // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWheelsForActivelyLanding;                       // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAerialSpeedForPrimaryDirection;                 // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardMaxSpeed;                                   // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardMaxLandingSpeed;                             // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardMaxSpeed;                                    // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLandingAngularVelocity;                         // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCeilingDegrees;                                 // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCeilingDegrees;                                 // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialCeilingDegrees;                              // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInvertedControlSteering;                        // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCeilingSecondsToInvertControls;                 // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelPushForce;                                    // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedForVelocityDirection;                      // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinZSpeedForUpwardDirection;                       // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalOrientationSensitivity;                    // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInactiveLandedFlipTime;                         // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWheelsForWheelsOnGround;                        // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDownDegreesForForwardDirection;                 // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNormalizedForwardSpeed;                         // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNormalizedBonusSpeed;                           // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleDriveSetup) == 0x000008, "Wrong alignment on FDelMarVehicleDriveSetup");
static_assert(sizeof(FDelMarVehicleDriveSetup) == 0x000360, "Wrong size on FDelMarVehicleDriveSetup");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxBaseForwardSpeed) == 0x000000, "Member 'FDelMarVehicleDriveSetup::MaxBaseForwardSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, DriveAccel) == 0x000008, "Member 'FDelMarVehicleDriveSetup::DriveAccel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, TargetSpeedMaxAccelCurve) == 0x000098, "Member 'FDelMarVehicleDriveSetup::TargetSpeedMaxAccelCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, TargetSpeedAerialFriction) == 0x000128, "Member 'FDelMarVehicleDriveSetup::TargetSpeedAerialFriction' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, bAllowBrakingInAir) == 0x00012C, "Member 'FDelMarVehicleDriveSetup::bAllowBrakingInAir' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, BrakeAccel) == 0x000130, "Member 'FDelMarVehicleDriveSetup::BrakeAccel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, StopSpeed) == 0x000134, "Member 'FDelMarVehicleDriveSetup::StopSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, IdleBrakeFactor) == 0x000138, "Member 'FDelMarVehicleDriveSetup::IdleBrakeFactor' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxSpeedToResetTargetSpeedDirection) == 0x00013C, "Member 'FDelMarVehicleDriveSetup::MaxSpeedToResetTargetSpeedDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, SteerAngleCurve) == 0x000140, "Member 'FDelMarVehicleDriveSetup::SteerAngleCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, SteerAngleCurveOverrides) == 0x0001C8, "Member 'FDelMarVehicleDriveSetup::SteerAngleCurveOverrides' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, LatFrictionCurve) == 0x0001D8, "Member 'FDelMarVehicleDriveSetup::LatFrictionCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, WheelsGroundedFrictionCurve) == 0x000268, "Member 'FDelMarVehicleDriveSetup::WheelsGroundedFrictionCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxForwardSpeedToIgnoreLandingSpeed) == 0x0002F0, "Member 'FDelMarVehicleDriveSetup::MaxForwardSpeedToIgnoreLandingSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxKickflipLandingSeconds) == 0x0002F4, "Member 'FDelMarVehicleDriveSetup::MaxKickflipLandingSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MinSlipAngle) == 0x0002F8, "Member 'FDelMarVehicleDriveSetup::MinSlipAngle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, SkydiveVerticalVelocitySensitivity) == 0x0002FC, "Member 'FDelMarVehicleDriveSetup::SkydiveVerticalVelocitySensitivity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, SkydiveVerticalPitchSensitivity) == 0x000300, "Member 'FDelMarVehicleDriveSetup::SkydiveVerticalPitchSensitivity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, StableSpeedMinGroundedTime) == 0x000304, "Member 'FDelMarVehicleDriveSetup::StableSpeedMinGroundedTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MinInAirTimeStableLanding) == 0x000308, "Member 'FDelMarVehicleDriveSetup::MinInAirTimeStableLanding' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, NumWheelsForActivelyLanding) == 0x00030C, "Member 'FDelMarVehicleDriveSetup::NumWheelsForActivelyLanding' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MinAerialSpeedForPrimaryDirection) == 0x000310, "Member 'FDelMarVehicleDriveSetup::MinAerialSpeedForPrimaryDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, ForwardMaxSpeed) == 0x000314, "Member 'FDelMarVehicleDriveSetup::ForwardMaxSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, UpwardMaxLandingSpeed) == 0x000318, "Member 'FDelMarVehicleDriveSetup::UpwardMaxLandingSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, UpwardMaxSpeed) == 0x00031C, "Member 'FDelMarVehicleDriveSetup::UpwardMaxSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxLandingAngularVelocity) == 0x000320, "Member 'FDelMarVehicleDriveSetup::MaxLandingAngularVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MinCeilingDegrees) == 0x000324, "Member 'FDelMarVehicleDriveSetup::MinCeilingDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxCeilingDegrees) == 0x000328, "Member 'FDelMarVehicleDriveSetup::MaxCeilingDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, AerialCeilingDegrees) == 0x00032C, "Member 'FDelMarVehicleDriveSetup::AerialCeilingDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxInvertedControlSteering) == 0x000330, "Member 'FDelMarVehicleDriveSetup::MaxInvertedControlSteering' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MinCeilingSecondsToInvertControls) == 0x000334, "Member 'FDelMarVehicleDriveSetup::MinCeilingSecondsToInvertControls' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, WheelPushForce) == 0x000338, "Member 'FDelMarVehicleDriveSetup::WheelPushForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MinSpeedForVelocityDirection) == 0x00033C, "Member 'FDelMarVehicleDriveSetup::MinSpeedForVelocityDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MinZSpeedForUpwardDirection) == 0x000340, "Member 'FDelMarVehicleDriveSetup::MinZSpeedForUpwardDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, VerticalOrientationSensitivity) == 0x000344, "Member 'FDelMarVehicleDriveSetup::VerticalOrientationSensitivity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxInactiveLandedFlipTime) == 0x000348, "Member 'FDelMarVehicleDriveSetup::MaxInactiveLandedFlipTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, NumWheelsForWheelsOnGround) == 0x00034C, "Member 'FDelMarVehicleDriveSetup::NumWheelsForWheelsOnGround' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MinDownDegreesForForwardDirection) == 0x000350, "Member 'FDelMarVehicleDriveSetup::MinDownDegreesForForwardDirection' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxNormalizedForwardSpeed) == 0x000354, "Member 'FDelMarVehicleDriveSetup::MaxNormalizedForwardSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriveSetup, MaxNormalizedBonusSpeed) == 0x000358, "Member 'FDelMarVehicleDriveSetup::MaxNormalizedBonusSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_BoostPadBonusSpeedEnded
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_BoostPadBonusSpeedEnded final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_BoostPadBonusSpeedEnded) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_BoostPadBonusSpeedEnded");
static_assert(sizeof(FDelMarObjectiveFilter_BoostPadBonusSpeedEnded) == 0x000190, "Wrong size on FDelMarObjectiveFilter_BoostPadBonusSpeedEnded");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_BoostPadHit
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_BoostPadHit final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_BoostPadHit) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_BoostPadHit");
static_assert(sizeof(FDelMarObjectiveFilter_BoostPadHit) == 0x000190, "Wrong size on FDelMarObjectiveFilter_BoostPadHit");

// ScriptStruct DelMarCore.DelMarDynamicCameraShakeEffect
// 0x00A0 (0x00A0 - 0x0000)
struct FDelMarDynamicCameraShakeEffect final
{
public:
	TSubclassOf<class UCameraShakeBase>           CameraShakeClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCameraShakeBase>        CameraShakeInstance;                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     ShakeIntensityCurve;                               // 0x0010(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         CurrentShakeIntensity;                             // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarDynamicCameraShakeEffect) == 0x000008, "Wrong alignment on FDelMarDynamicCameraShakeEffect");
static_assert(sizeof(FDelMarDynamicCameraShakeEffect) == 0x0000A0, "Wrong size on FDelMarDynamicCameraShakeEffect");
static_assert(offsetof(FDelMarDynamicCameraShakeEffect, CameraShakeClass) == 0x000000, "Member 'FDelMarDynamicCameraShakeEffect::CameraShakeClass' has a wrong offset!");
static_assert(offsetof(FDelMarDynamicCameraShakeEffect, CameraShakeInstance) == 0x000008, "Member 'FDelMarDynamicCameraShakeEffect::CameraShakeInstance' has a wrong offset!");
static_assert(offsetof(FDelMarDynamicCameraShakeEffect, ShakeIntensityCurve) == 0x000010, "Member 'FDelMarDynamicCameraShakeEffect::ShakeIntensityCurve' has a wrong offset!");
static_assert(offsetof(FDelMarDynamicCameraShakeEffect, CurrentShakeIntensity) == 0x000098, "Member 'FDelMarDynamicCameraShakeEffect::CurrentShakeIntensity' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_DistanceTraveled
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_DistanceTraveled final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_DistanceTraveled) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_DistanceTraveled");
static_assert(sizeof(FDelMarObjectiveFilter_DistanceTraveled) == 0x000190, "Wrong size on FDelMarObjectiveFilter_DistanceTraveled");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_DraftActivated
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_DraftActivated final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_DraftActivated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_DraftActivated");
static_assert(sizeof(FDelMarObjectiveFilter_DraftActivated) == 0x000190, "Wrong size on FDelMarObjectiveFilter_DraftActivated");

// ScriptStruct DelMarCore.DelMarRubberbandingConfig
// 0x0028 (0x0028 - 0x0000)
struct FDelMarRubberbandingConfig final
{
public:
	bool                                          bRubberbandingEnabled;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPackDistance;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPackDistance;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PackDistanceOffset;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceFromPack;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromPack;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayersForPackDistance;                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPackDistanceGainedPerSecond;                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPackDistanceLostPerSecond;                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBonusSpeedScalar;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarRubberbandingConfig) == 0x000004, "Wrong alignment on FDelMarRubberbandingConfig");
static_assert(sizeof(FDelMarRubberbandingConfig) == 0x000028, "Wrong size on FDelMarRubberbandingConfig");
static_assert(offsetof(FDelMarRubberbandingConfig, bRubberbandingEnabled) == 0x000000, "Member 'FDelMarRubberbandingConfig::bRubberbandingEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, MinPackDistance) == 0x000004, "Member 'FDelMarRubberbandingConfig::MinPackDistance' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, MaxPackDistance) == 0x000008, "Member 'FDelMarRubberbandingConfig::MaxPackDistance' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, PackDistanceOffset) == 0x00000C, "Member 'FDelMarRubberbandingConfig::PackDistanceOffset' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, MinDistanceFromPack) == 0x000010, "Member 'FDelMarRubberbandingConfig::MinDistanceFromPack' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, MaxDistanceFromPack) == 0x000014, "Member 'FDelMarRubberbandingConfig::MaxDistanceFromPack' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, NumPlayersForPackDistance) == 0x000018, "Member 'FDelMarRubberbandingConfig::NumPlayersForPackDistance' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, MaxPackDistanceGainedPerSecond) == 0x00001C, "Member 'FDelMarRubberbandingConfig::MaxPackDistanceGainedPerSecond' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, MaxPackDistanceLostPerSecond) == 0x000020, "Member 'FDelMarRubberbandingConfig::MaxPackDistanceLostPerSecond' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingConfig, MaxBonusSpeedScalar) == 0x000024, "Member 'FDelMarRubberbandingConfig::MaxBonusSpeedScalar' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarRubberbandingMMRConfig
// 0x0030 (0x0030 - 0x0000)
struct FDelMarRubberbandingMMRConfig final
{
public:
	float                                         MinMmr;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMmr;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarRubberbandingConfig             RubberbandingConfig;                               // 0x0008(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarRubberbandingMMRConfig) == 0x000004, "Wrong alignment on FDelMarRubberbandingMMRConfig");
static_assert(sizeof(FDelMarRubberbandingMMRConfig) == 0x000030, "Wrong size on FDelMarRubberbandingMMRConfig");
static_assert(offsetof(FDelMarRubberbandingMMRConfig, MinMmr) == 0x000000, "Member 'FDelMarRubberbandingMMRConfig::MinMmr' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingMMRConfig, MaxMmr) == 0x000004, "Member 'FDelMarRubberbandingMMRConfig::MaxMmr' has a wrong offset!");
static_assert(offsetof(FDelMarRubberbandingMMRConfig, RubberbandingConfig) == 0x000008, "Member 'FDelMarRubberbandingMMRConfig::RubberbandingConfig' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_DriftBoostActivated
// 0x0020 (0x01B0 - 0x0190)
struct FDelMarObjectiveFilter_DriftBoostActivated final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredDriftBoostPercent;                         // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_DriftBoostActivated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_DriftBoostActivated");
static_assert(sizeof(FDelMarObjectiveFilter_DriftBoostActivated) == 0x0001B0, "Wrong size on FDelMarObjectiveFilter_DriftBoostActivated");
static_assert(offsetof(FDelMarObjectiveFilter_DriftBoostActivated, RequiredDriftBoostPercent) == 0x000190, "Member 'FDelMarObjectiveFilter_DriftBoostActivated::RequiredDriftBoostPercent' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_DriftBoostDeactivated
// 0x0020 (0x01B0 - 0x0190)
struct FDelMarObjectiveFilter_DriftBoostDeactivated final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredTotalDistance;                             // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_DriftBoostDeactivated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_DriftBoostDeactivated");
static_assert(sizeof(FDelMarObjectiveFilter_DriftBoostDeactivated) == 0x0001B0, "Wrong size on FDelMarObjectiveFilter_DriftBoostDeactivated");
static_assert(offsetof(FDelMarObjectiveFilter_DriftBoostDeactivated, RequiredTotalDistance) == 0x000190, "Member 'FDelMarObjectiveFilter_DriftBoostDeactivated::RequiredTotalDistance' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarWorldBonusSpeedSourceCap
// 0x0008 (0x0008 - 0x0000)
struct FDelMarWorldBonusSpeedSourceCap final
{
public:
	struct FGameplayTag                           Source;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCap;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarWorldBonusSpeedSourceCap) == 0x000004, "Wrong alignment on FDelMarWorldBonusSpeedSourceCap");
static_assert(sizeof(FDelMarWorldBonusSpeedSourceCap) == 0x000008, "Wrong size on FDelMarWorldBonusSpeedSourceCap");
static_assert(offsetof(FDelMarWorldBonusSpeedSourceCap, Source) == 0x000000, "Member 'FDelMarWorldBonusSpeedSourceCap::Source' has a wrong offset!");
static_assert(offsetof(FDelMarWorldBonusSpeedSourceCap, StackCap) == 0x000004, "Member 'FDelMarWorldBonusSpeedSourceCap::StackCap' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_DriftComplete
// 0x0020 (0x01B0 - 0x0190)
struct FDelMarObjectiveFilter_DriftComplete final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredDriftDuration;                             // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_DriftComplete) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_DriftComplete");
static_assert(sizeof(FDelMarObjectiveFilter_DriftComplete) == 0x0001B0, "Wrong size on FDelMarObjectiveFilter_DriftComplete");
static_assert(offsetof(FDelMarObjectiveFilter_DriftComplete, RequiredDriftDuration) == 0x000190, "Member 'FDelMarObjectiveFilter_DriftComplete::RequiredDriftDuration' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_HighestSpeedUpdated
// 0x0020 (0x01B0 - 0x0190)
struct FDelMarObjectiveFilter_HighestSpeedUpdated final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredHighestSpeed;                              // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_HighestSpeedUpdated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_HighestSpeedUpdated");
static_assert(sizeof(FDelMarObjectiveFilter_HighestSpeedUpdated) == 0x0001B0, "Wrong size on FDelMarObjectiveFilter_HighestSpeedUpdated");
static_assert(offsetof(FDelMarObjectiveFilter_HighestSpeedUpdated, RequiredHighestSpeed) == 0x000190, "Member 'FDelMarObjectiveFilter_HighestSpeedUpdated::RequiredHighestSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_Rubberbanding
// 0x01B8 (0x01B8 - 0x0000)
struct FDelMarVehicleConfig_Rubberbanding final
{
public:
	float                                         MinSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBonusSpeedLostPerSecond;                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     MaxBonusSpeedGainedPerSecond;                      // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     MaxBonusSpeed;                                     // 0x0098(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     MaxSpeed;                                          // 0x0128(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleConfig_Rubberbanding) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_Rubberbanding");
static_assert(sizeof(FDelMarVehicleConfig_Rubberbanding) == 0x0001B8, "Wrong size on FDelMarVehicleConfig_Rubberbanding");
static_assert(offsetof(FDelMarVehicleConfig_Rubberbanding, MinSpeed) == 0x000000, "Member 'FDelMarVehicleConfig_Rubberbanding::MinSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Rubberbanding, MaxBonusSpeedLostPerSecond) == 0x000004, "Member 'FDelMarVehicleConfig_Rubberbanding::MaxBonusSpeedLostPerSecond' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Rubberbanding, MaxBonusSpeedGainedPerSecond) == 0x000008, "Member 'FDelMarVehicleConfig_Rubberbanding::MaxBonusSpeedGainedPerSecond' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Rubberbanding, MaxBonusSpeed) == 0x000098, "Member 'FDelMarVehicleConfig_Rubberbanding::MaxBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Rubberbanding, MaxSpeed) == 0x000128, "Member 'FDelMarVehicleConfig_Rubberbanding::MaxSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_InitialTurboActivated
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_InitialTurboActivated final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_InitialTurboActivated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_InitialTurboActivated");
static_assert(sizeof(FDelMarObjectiveFilter_InitialTurboActivated) == 0x000190, "Wrong size on FDelMarObjectiveFilter_InitialTurboActivated");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_Kickflipped
// 0x0008 (0x0198 - 0x0190)
struct FDelMarObjectiveFilter_Kickflipped final : public FDelMarObjectiveFilterBase
{
public:
	EDelMarKickflipDirection                      RequiredKickflipDirection;                         // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarObjectiveFilter_Kickflipped) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_Kickflipped");
static_assert(sizeof(FDelMarObjectiveFilter_Kickflipped) == 0x000198, "Wrong size on FDelMarObjectiveFilter_Kickflipped");
static_assert(offsetof(FDelMarObjectiveFilter_Kickflipped, RequiredKickflipDirection) == 0x000190, "Member 'FDelMarObjectiveFilter_Kickflipped::RequiredKickflipDirection' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleDriftConfig
// 0x0718 (0x0718 - 0x0000)
struct FDelMarVehicleDriftConfig final
{
public:
	float                                         MinSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDirectedDriftTime;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInAirTime;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialDriftNoKeybindGracePeriod;                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForcedDriftTime;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinKickDriftActiveSeconds;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSteerWhenKicking;                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinForcedSteerWhenKicking;                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickCooldownSeconds;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateDriftOnStrafeEnd;                         // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateDriftOnLanding;                           // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateDriftOnKickflipLanding;                   // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateExitDriftTime;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSteerInput;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFullThrottleInput;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFullSteerInput;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFullDriftInput;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForcedDriftSteer;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialTorqueImpulse;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwapDirectionImpulse;                              // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAccelInDriftDir;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAccelNoSteer;                                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAccelNotInDriftDir;                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAccelChangeDir;                              // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAccelDampening;                              // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAccelWithKick;                               // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAccelWithKickV2;                             // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAccelForcedDrift;                            // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueAgainstExit;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationSpeedWithThrottle;                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationSpeedNoThrottle;                        // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationSpeedWithKick;                          // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationSpeedSwapDirections;                    // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDriftDegrees;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDriftDegrees;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitDriftDegrees;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproachDistance;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeakForwardSpeedDegrees;                           // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickRedirectRate;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickRedirectRateV2;                                // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForcedDriftRedirectRate;                           // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSteerRedirectInput;                             // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     NonKickRedirectRateCurve;                          // 0x00A0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     VelocityRedirectAngleCurveControlled;              // 0x0130(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     VelocityRedirectAgainstAngleCurveControlled;       // 0x01C0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     VelocityRedirectAngleCurveNoSteer;                 // 0x0250(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     VelocityRedirectAngleCurveUncontrolled;            // 0x02E0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     VelocityRedirectAngleCurveKickback;                // 0x0370(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     VelocityRedirectAngleCurveKickbackV2;              // 0x0400(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         PeakSpeedIncreaseDegrees;                          // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccelSpeed;                                     // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     AccelerationScalarCurve;                           // 0x0498(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     AdditionalSpeedLossNoThrottle;                     // 0x0528(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MaxControlledDriftRatio;                           // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarScaledCurve                     ControlledSpeedCapBySlipAngle;                     // 0x05C0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     ControlledSpeedCapDecelRate;                       // 0x0650(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         UncontrolledSpeedCap;                              // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UncontrolledSpeedLoss;                             // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitVelocityMaxDegrees;                            // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitKickEndMaxDegrees;                             // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitVelocityTorqueAccel;                           // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitVelocityMaxRotationSpeed;                      // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitForwardMaxDegrees;                             // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitForwardTorqueSteer;                            // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitForwardMaxRotation;                            // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitForwardTargetRedirectRate;                     // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitForwardRedirectRate;                           // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxExitForwardLandingSpeed;                        // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnforceThrottleForControlledDrift;                // 0x0710(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_711[0x7];                                      // 0x0711(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleDriftConfig) == 0x000008, "Wrong alignment on FDelMarVehicleDriftConfig");
static_assert(sizeof(FDelMarVehicleDriftConfig) == 0x000718, "Wrong size on FDelMarVehicleDriftConfig");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinSpeed) == 0x000000, "Member 'FDelMarVehicleDriftConfig::MinSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinDirectedDriftTime) == 0x000004, "Member 'FDelMarVehicleDriftConfig::MinDirectedDriftTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinInAirTime) == 0x000008, "Member 'FDelMarVehicleDriftConfig::MinInAirTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, AerialDriftNoKeybindGracePeriod) == 0x00000C, "Member 'FDelMarVehicleDriftConfig::AerialDriftNoKeybindGracePeriod' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxForcedDriftTime) == 0x000010, "Member 'FDelMarVehicleDriftConfig::MaxForcedDriftTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinKickDriftActiveSeconds) == 0x000014, "Member 'FDelMarVehicleDriftConfig::MinKickDriftActiveSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, bForceSteerWhenKicking) == 0x000018, "Member 'FDelMarVehicleDriftConfig::bForceSteerWhenKicking' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinForcedSteerWhenKicking) == 0x00001C, "Member 'FDelMarVehicleDriftConfig::MinForcedSteerWhenKicking' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, KickCooldownSeconds) == 0x000020, "Member 'FDelMarVehicleDriftConfig::KickCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, bActivateDriftOnStrafeEnd) == 0x000024, "Member 'FDelMarVehicleDriftConfig::bActivateDriftOnStrafeEnd' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, bActivateDriftOnLanding) == 0x000025, "Member 'FDelMarVehicleDriftConfig::bActivateDriftOnLanding' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, bActivateDriftOnKickflipLanding) == 0x000026, "Member 'FDelMarVehicleDriftConfig::bActivateDriftOnKickflipLanding' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ActivateExitDriftTime) == 0x000028, "Member 'FDelMarVehicleDriftConfig::ActivateExitDriftTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinSteerInput) == 0x00002C, "Member 'FDelMarVehicleDriftConfig::MinSteerInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinFullThrottleInput) == 0x000030, "Member 'FDelMarVehicleDriftConfig::MinFullThrottleInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinFullSteerInput) == 0x000034, "Member 'FDelMarVehicleDriftConfig::MinFullSteerInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinFullDriftInput) == 0x000038, "Member 'FDelMarVehicleDriftConfig::MinFullDriftInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ForcedDriftSteer) == 0x00003C, "Member 'FDelMarVehicleDriftConfig::ForcedDriftSteer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, InitialTorqueImpulse) == 0x000040, "Member 'FDelMarVehicleDriftConfig::InitialTorqueImpulse' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, SwapDirectionImpulse) == 0x000044, "Member 'FDelMarVehicleDriftConfig::SwapDirectionImpulse' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAccelInDriftDir) == 0x000048, "Member 'FDelMarVehicleDriftConfig::TorqueAccelInDriftDir' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAccelNoSteer) == 0x00004C, "Member 'FDelMarVehicleDriftConfig::TorqueAccelNoSteer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAccelNotInDriftDir) == 0x000050, "Member 'FDelMarVehicleDriftConfig::TorqueAccelNotInDriftDir' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAccelChangeDir) == 0x000054, "Member 'FDelMarVehicleDriftConfig::TorqueAccelChangeDir' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAccelDampening) == 0x000058, "Member 'FDelMarVehicleDriftConfig::TorqueAccelDampening' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAccelWithKick) == 0x00005C, "Member 'FDelMarVehicleDriftConfig::TorqueAccelWithKick' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAccelWithKickV2) == 0x000060, "Member 'FDelMarVehicleDriftConfig::TorqueAccelWithKickV2' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAccelForcedDrift) == 0x000064, "Member 'FDelMarVehicleDriftConfig::TorqueAccelForcedDrift' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, TorqueAgainstExit) == 0x000068, "Member 'FDelMarVehicleDriftConfig::TorqueAgainstExit' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxRotationSpeedWithThrottle) == 0x00006C, "Member 'FDelMarVehicleDriftConfig::MaxRotationSpeedWithThrottle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxRotationSpeedNoThrottle) == 0x000070, "Member 'FDelMarVehicleDriftConfig::MaxRotationSpeedNoThrottle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxRotationSpeedWithKick) == 0x000074, "Member 'FDelMarVehicleDriftConfig::MaxRotationSpeedWithKick' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxRotationSpeedSwapDirections) == 0x000078, "Member 'FDelMarVehicleDriftConfig::MaxRotationSpeedSwapDirections' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinDriftDegrees) == 0x00007C, "Member 'FDelMarVehicleDriftConfig::MinDriftDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxDriftDegrees) == 0x000080, "Member 'FDelMarVehicleDriftConfig::MaxDriftDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitDriftDegrees) == 0x000084, "Member 'FDelMarVehicleDriftConfig::ExitDriftDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ApproachDistance) == 0x000088, "Member 'FDelMarVehicleDriftConfig::ApproachDistance' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, PeakForwardSpeedDegrees) == 0x00008C, "Member 'FDelMarVehicleDriftConfig::PeakForwardSpeedDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, KickRedirectRate) == 0x000090, "Member 'FDelMarVehicleDriftConfig::KickRedirectRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, KickRedirectRateV2) == 0x000094, "Member 'FDelMarVehicleDriftConfig::KickRedirectRateV2' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ForcedDriftRedirectRate) == 0x000098, "Member 'FDelMarVehicleDriftConfig::ForcedDriftRedirectRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MinSteerRedirectInput) == 0x00009C, "Member 'FDelMarVehicleDriftConfig::MinSteerRedirectInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, NonKickRedirectRateCurve) == 0x0000A0, "Member 'FDelMarVehicleDriftConfig::NonKickRedirectRateCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, VelocityRedirectAngleCurveControlled) == 0x000130, "Member 'FDelMarVehicleDriftConfig::VelocityRedirectAngleCurveControlled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, VelocityRedirectAgainstAngleCurveControlled) == 0x0001C0, "Member 'FDelMarVehicleDriftConfig::VelocityRedirectAgainstAngleCurveControlled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, VelocityRedirectAngleCurveNoSteer) == 0x000250, "Member 'FDelMarVehicleDriftConfig::VelocityRedirectAngleCurveNoSteer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, VelocityRedirectAngleCurveUncontrolled) == 0x0002E0, "Member 'FDelMarVehicleDriftConfig::VelocityRedirectAngleCurveUncontrolled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, VelocityRedirectAngleCurveKickback) == 0x000370, "Member 'FDelMarVehicleDriftConfig::VelocityRedirectAngleCurveKickback' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, VelocityRedirectAngleCurveKickbackV2) == 0x000400, "Member 'FDelMarVehicleDriftConfig::VelocityRedirectAngleCurveKickbackV2' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, PeakSpeedIncreaseDegrees) == 0x000490, "Member 'FDelMarVehicleDriftConfig::PeakSpeedIncreaseDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxAccelSpeed) == 0x000494, "Member 'FDelMarVehicleDriftConfig::MaxAccelSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, AccelerationScalarCurve) == 0x000498, "Member 'FDelMarVehicleDriftConfig::AccelerationScalarCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, AdditionalSpeedLossNoThrottle) == 0x000528, "Member 'FDelMarVehicleDriftConfig::AdditionalSpeedLossNoThrottle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxControlledDriftRatio) == 0x0005B8, "Member 'FDelMarVehicleDriftConfig::MaxControlledDriftRatio' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ControlledSpeedCapBySlipAngle) == 0x0005C0, "Member 'FDelMarVehicleDriftConfig::ControlledSpeedCapBySlipAngle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ControlledSpeedCapDecelRate) == 0x000650, "Member 'FDelMarVehicleDriftConfig::ControlledSpeedCapDecelRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, UncontrolledSpeedCap) == 0x0006E0, "Member 'FDelMarVehicleDriftConfig::UncontrolledSpeedCap' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, UncontrolledSpeedLoss) == 0x0006E4, "Member 'FDelMarVehicleDriftConfig::UncontrolledSpeedLoss' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitVelocityMaxDegrees) == 0x0006E8, "Member 'FDelMarVehicleDriftConfig::ExitVelocityMaxDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitKickEndMaxDegrees) == 0x0006EC, "Member 'FDelMarVehicleDriftConfig::ExitKickEndMaxDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitVelocityTorqueAccel) == 0x0006F0, "Member 'FDelMarVehicleDriftConfig::ExitVelocityTorqueAccel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitVelocityMaxRotationSpeed) == 0x0006F4, "Member 'FDelMarVehicleDriftConfig::ExitVelocityMaxRotationSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitForwardMaxDegrees) == 0x0006F8, "Member 'FDelMarVehicleDriftConfig::ExitForwardMaxDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitForwardTorqueSteer) == 0x0006FC, "Member 'FDelMarVehicleDriftConfig::ExitForwardTorqueSteer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitForwardMaxRotation) == 0x000700, "Member 'FDelMarVehicleDriftConfig::ExitForwardMaxRotation' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitForwardTargetRedirectRate) == 0x000704, "Member 'FDelMarVehicleDriftConfig::ExitForwardTargetRedirectRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, ExitForwardRedirectRate) == 0x000708, "Member 'FDelMarVehicleDriftConfig::ExitForwardRedirectRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, MaxExitForwardLandingSpeed) == 0x00070C, "Member 'FDelMarVehicleDriftConfig::MaxExitForwardLandingSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftConfig, bEnforceThrottleForControlledDrift) == 0x000710, "Member 'FDelMarVehicleDriftConfig::bEnforceThrottleForControlledDrift' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_LapComplete
// 0x0040 (0x01D0 - 0x0190)
struct FDelMarObjectiveFilter_LapComplete final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredLapCompleteTime;                           // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            RequiredLapCount;                                  // 0x01B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            RequiredLapPlacement;                              // 0x01C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_LapComplete) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_LapComplete");
static_assert(sizeof(FDelMarObjectiveFilter_LapComplete) == 0x0001D0, "Wrong size on FDelMarObjectiveFilter_LapComplete");
static_assert(offsetof(FDelMarObjectiveFilter_LapComplete, RequiredLapCompleteTime) == 0x000190, "Member 'FDelMarObjectiveFilter_LapComplete::RequiredLapCompleteTime' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_LapComplete, RequiredLapCount) == 0x0001B0, "Member 'FDelMarObjectiveFilter_LapComplete::RequiredLapCount' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_LapComplete, RequiredLapPlacement) == 0x0001C0, "Member 'FDelMarObjectiveFilter_LapComplete::RequiredLapPlacement' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_PlacementUpdated
// 0x0018 (0x01A8 - 0x0190)
struct FDelMarObjectiveFilter_PlacementUpdated final : public FDelMarObjectiveFilterBase
{
public:
	struct FInt32Range                            RequiredCurrentPosition;                           // 0x0190(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarPositionChangeInfo                     RequiredPositionChangeInfo;                        // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarObjectiveFilter_PlacementUpdated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_PlacementUpdated");
static_assert(sizeof(FDelMarObjectiveFilter_PlacementUpdated) == 0x0001A8, "Wrong size on FDelMarObjectiveFilter_PlacementUpdated");
static_assert(offsetof(FDelMarObjectiveFilter_PlacementUpdated, RequiredCurrentPosition) == 0x000190, "Member 'FDelMarObjectiveFilter_PlacementUpdated::RequiredCurrentPosition' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_PlacementUpdated, RequiredPositionChangeInfo) == 0x0001A0, "Member 'FDelMarObjectiveFilter_PlacementUpdated::RequiredPositionChangeInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleLandingLevel
// 0x0008 (0x0008 - 0x0000)
struct FDelMarVehicleLandingLevel final
{
public:
	float                                         MinForce;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedChange;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleLandingLevel) == 0x000004, "Wrong alignment on FDelMarVehicleLandingLevel");
static_assert(sizeof(FDelMarVehicleLandingLevel) == 0x000008, "Wrong size on FDelMarVehicleLandingLevel");
static_assert(offsetof(FDelMarVehicleLandingLevel, MinForce) == 0x000000, "Member 'FDelMarVehicleLandingLevel::MinForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleLandingLevel, SpeedChange) == 0x000004, "Member 'FDelMarVehicleLandingLevel::SpeedChange' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_PlayedDelMarExperience
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_PlayedDelMarExperience final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_PlayedDelMarExperience) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_PlayedDelMarExperience");
static_assert(sizeof(FDelMarObjectiveFilter_PlayedDelMarExperience) == 0x000190, "Wrong size on FDelMarObjectiveFilter_PlayedDelMarExperience");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_RaceFinished
// 0x0048 (0x01D8 - 0x0190)
struct FDelMarObjectiveFilter_RaceFinished final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredFinishTime;                                // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            RequiredFinalPlacement;                            // 0x01B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            RequiredPlayerCompetitiveRank;                     // 0x01C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarJellyHazardProcessorInfo               RequiredJellyHazardInfo;                           // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarDemolishedProcessorInfo                RequiredDemolishedInfo;                            // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_RaceFinished) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_RaceFinished");
static_assert(sizeof(FDelMarObjectiveFilter_RaceFinished) == 0x0001D8, "Wrong size on FDelMarObjectiveFilter_RaceFinished");
static_assert(offsetof(FDelMarObjectiveFilter_RaceFinished, RequiredFinishTime) == 0x000190, "Member 'FDelMarObjectiveFilter_RaceFinished::RequiredFinishTime' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RaceFinished, RequiredFinalPlacement) == 0x0001B0, "Member 'FDelMarObjectiveFilter_RaceFinished::RequiredFinalPlacement' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RaceFinished, RequiredPlayerCompetitiveRank) == 0x0001C0, "Member 'FDelMarObjectiveFilter_RaceFinished::RequiredPlayerCompetitiveRank' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RaceFinished, RequiredJellyHazardInfo) == 0x0001D0, "Member 'FDelMarObjectiveFilter_RaceFinished::RequiredJellyHazardInfo' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RaceFinished, RequiredDemolishedInfo) == 0x0001D4, "Member 'FDelMarObjectiveFilter_RaceFinished::RequiredDemolishedInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_Terrain
// 0x0020 (0x0020 - 0x0000)
struct FDelMarVehicleConfig_Terrain final
{
public:
	float                                         TargetSpeedPenaltyCooldownSeconds;                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWheelsTargetSpeedPenalty;                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoGripBrakeFactorWithThrottle;                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinForwardSpeedPercentage;                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             NonDriveableActorClasses;                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleConfig_Terrain) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_Terrain");
static_assert(sizeof(FDelMarVehicleConfig_Terrain) == 0x000020, "Wrong size on FDelMarVehicleConfig_Terrain");
static_assert(offsetof(FDelMarVehicleConfig_Terrain, TargetSpeedPenaltyCooldownSeconds) == 0x000000, "Member 'FDelMarVehicleConfig_Terrain::TargetSpeedPenaltyCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Terrain, NumWheelsTargetSpeedPenalty) == 0x000004, "Member 'FDelMarVehicleConfig_Terrain::NumWheelsTargetSpeedPenalty' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Terrain, NoGripBrakeFactorWithThrottle) == 0x000008, "Member 'FDelMarVehicleConfig_Terrain::NoGripBrakeFactorWithThrottle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Terrain, MinForwardSpeedPercentage) == 0x00000C, "Member 'FDelMarVehicleConfig_Terrain::MinForwardSpeedPercentage' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Terrain, NonDriveableActorClasses) == 0x000010, "Member 'FDelMarVehicleConfig_Terrain::NonDriveableActorClasses' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_RankAchieved
// 0x0010 (0x01A0 - 0x0190)
struct FDelMarObjectiveFilter_RankAchieved final : public FDelMarObjectiveFilterBase
{
public:
	struct FInt32Range                            RequiredRank;                                      // 0x0190(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_RankAchieved) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_RankAchieved");
static_assert(sizeof(FDelMarObjectiveFilter_RankAchieved) == 0x0001A0, "Wrong size on FDelMarObjectiveFilter_RankAchieved");
static_assert(offsetof(FDelMarObjectiveFilter_RankAchieved, RequiredRank) == 0x000190, "Member 'FDelMarObjectiveFilter_RankAchieved::RequiredRank' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_RunComplete
// 0x0038 (0x01C8 - 0x0190)
struct FDelMarObjectiveFilter_RunComplete final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredFinishTime;                                // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            RequiredFinalPlacement;                            // 0x01B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarJellyHazardProcessorInfo               RequiredJellyHazardInfo;                           // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarDemolishedProcessorInfo                RequiredDemolishedInfo;                            // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_RunComplete) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_RunComplete");
static_assert(sizeof(FDelMarObjectiveFilter_RunComplete) == 0x0001C8, "Wrong size on FDelMarObjectiveFilter_RunComplete");
static_assert(offsetof(FDelMarObjectiveFilter_RunComplete, RequiredFinishTime) == 0x000190, "Member 'FDelMarObjectiveFilter_RunComplete::RequiredFinishTime' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RunComplete, RequiredFinalPlacement) == 0x0001B0, "Member 'FDelMarObjectiveFilter_RunComplete::RequiredFinalPlacement' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RunComplete, RequiredJellyHazardInfo) == 0x0001C0, "Member 'FDelMarObjectiveFilter_RunComplete::RequiredJellyHazardInfo' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RunComplete, RequiredDemolishedInfo) == 0x0001C4, "Member 'FDelMarObjectiveFilter_RunComplete::RequiredDemolishedInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_AutoUpright
// 0x0024 (0x0024 - 0x0000)
struct FDelMarVehicleConfig_AutoUpright final
{
public:
	float                                         RotationTorque;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDamping;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinActiveSeconds;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinActiveSecondsGrounded;                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelsOnGroundChangedDelaySeconds;                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAngularVelocity;                             // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDegreesFromVehicleUpThreshold;                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinThrottleForWheelRotation;                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowActiveStateOnGround;                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleConfig_AutoUpright) == 0x000004, "Wrong alignment on FDelMarVehicleConfig_AutoUpright");
static_assert(sizeof(FDelMarVehicleConfig_AutoUpright) == 0x000024, "Wrong size on FDelMarVehicleConfig_AutoUpright");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, RotationTorque) == 0x000000, "Member 'FDelMarVehicleConfig_AutoUpright::RotationTorque' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, RotationDamping) == 0x000004, "Member 'FDelMarVehicleConfig_AutoUpright::RotationDamping' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, MinActiveSeconds) == 0x000008, "Member 'FDelMarVehicleConfig_AutoUpright::MinActiveSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, MinActiveSecondsGrounded) == 0x00000C, "Member 'FDelMarVehicleConfig_AutoUpright::MinActiveSecondsGrounded' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, WheelsOnGroundChangedDelaySeconds) == 0x000010, "Member 'FDelMarVehicleConfig_AutoUpright::WheelsOnGroundChangedDelaySeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, bClearAngularVelocity) == 0x000014, "Member 'FDelMarVehicleConfig_AutoUpright::bClearAngularVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, MinDegreesFromVehicleUpThreshold) == 0x000018, "Member 'FDelMarVehicleConfig_AutoUpright::MinDegreesFromVehicleUpThreshold' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, MinThrottleForWheelRotation) == 0x00001C, "Member 'FDelMarVehicleConfig_AutoUpright::MinThrottleForWheelRotation' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoUpright, bAllowActiveStateOnGround) == 0x000020, "Member 'FDelMarVehicleConfig_AutoUpright::bAllowActiveStateOnGround' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_RunCompleteTest
// 0x0038 (0x01C8 - 0x0190)
struct FDelMarObjectiveFilter_RunCompleteTest final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredFinishTime;                                // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            RequiredFinalPlacement;                            // 0x01B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarJellyHazardProcessorInfo               RequiredJellyHazardInfo;                           // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarDemolishedProcessorInfo                RequiredDemolishedInfo;                            // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_RunCompleteTest) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_RunCompleteTest");
static_assert(sizeof(FDelMarObjectiveFilter_RunCompleteTest) == 0x0001C8, "Wrong size on FDelMarObjectiveFilter_RunCompleteTest");
static_assert(offsetof(FDelMarObjectiveFilter_RunCompleteTest, RequiredFinishTime) == 0x000190, "Member 'FDelMarObjectiveFilter_RunCompleteTest::RequiredFinishTime' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RunCompleteTest, RequiredFinalPlacement) == 0x0001B0, "Member 'FDelMarObjectiveFilter_RunCompleteTest::RequiredFinalPlacement' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RunCompleteTest, RequiredJellyHazardInfo) == 0x0001C0, "Member 'FDelMarObjectiveFilter_RunCompleteTest::RequiredJellyHazardInfo' has a wrong offset!");
static_assert(offsetof(FDelMarObjectiveFilter_RunCompleteTest, RequiredDemolishedInfo) == 0x0001C4, "Member 'FDelMarObjectiveFilter_RunCompleteTest::RequiredDemolishedInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_StartlineBoostActivated
// 0x0020 (0x01B0 - 0x0190)
struct FDelMarObjectiveFilter_StartlineBoostActivated final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredStartlineBoostPercent;                     // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_StartlineBoostActivated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_StartlineBoostActivated");
static_assert(sizeof(FDelMarObjectiveFilter_StartlineBoostActivated) == 0x0001B0, "Wrong size on FDelMarObjectiveFilter_StartlineBoostActivated");
static_assert(offsetof(FDelMarObjectiveFilter_StartlineBoostActivated, RequiredStartlineBoostPercent) == 0x000190, "Member 'FDelMarObjectiveFilter_StartlineBoostActivated::RequiredStartlineBoostPercent' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_Strafe
// 0x001C (0x001C - 0x0000)
struct FDelMarVehicleConfig_Strafe final
{
public:
	float                                         InitialVelocityForce;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelocityRelative;                                 // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSteerInput;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeybindPressLandedBufferSeconds;                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActiveSeconds;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaceStartCooldownSeconds;                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownSeconds;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleConfig_Strafe) == 0x000004, "Wrong alignment on FDelMarVehicleConfig_Strafe");
static_assert(sizeof(FDelMarVehicleConfig_Strafe) == 0x00001C, "Wrong size on FDelMarVehicleConfig_Strafe");
static_assert(offsetof(FDelMarVehicleConfig_Strafe, InitialVelocityForce) == 0x000000, "Member 'FDelMarVehicleConfig_Strafe::InitialVelocityForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Strafe, bVelocityRelative) == 0x000004, "Member 'FDelMarVehicleConfig_Strafe::bVelocityRelative' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Strafe, MinSteerInput) == 0x000008, "Member 'FDelMarVehicleConfig_Strafe::MinSteerInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Strafe, KeybindPressLandedBufferSeconds) == 0x00000C, "Member 'FDelMarVehicleConfig_Strafe::KeybindPressLandedBufferSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Strafe, MaxActiveSeconds) == 0x000010, "Member 'FDelMarVehicleConfig_Strafe::MaxActiveSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Strafe, RaceStartCooldownSeconds) == 0x000014, "Member 'FDelMarVehicleConfig_Strafe::RaceStartCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Strafe, CooldownSeconds) == 0x000018, "Member 'FDelMarVehicleConfig_Strafe::CooldownSeconds' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_UnderthrustDeactivated
// 0x0020 (0x01B0 - 0x0190)
struct FDelMarObjectiveFilter_UnderthrustDeactivated final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredPercentUsed;                               // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_UnderthrustDeactivated) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_UnderthrustDeactivated");
static_assert(sizeof(FDelMarObjectiveFilter_UnderthrustDeactivated) == 0x0001B0, "Wrong size on FDelMarObjectiveFilter_UnderthrustDeactivated");
static_assert(offsetof(FDelMarObjectiveFilter_UnderthrustDeactivated, RequiredPercentUsed) == 0x000190, "Member 'FDelMarObjectiveFilter_UnderthrustDeactivated::RequiredPercentUsed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_UnderthrustPercentUsed
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_UnderthrustPercentUsed final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_UnderthrustPercentUsed) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_UnderthrustPercentUsed");
static_assert(sizeof(FDelMarObjectiveFilter_UnderthrustPercentUsed) == 0x000190, "Wrong size on FDelMarObjectiveFilter_UnderthrustPercentUsed");

// ScriptStruct DelMarCore.DelMarVehicleDraftingConfig
// 0x0030 (0x0030 - 0x0000)
struct FDelMarVehicleDraftingConfig final
{
public:
	float                                         TraceDistance;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinEligibleDistance;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHorizontalDegreesToDraftTarget;                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticalDegreesToDraftTarget;                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             LineOfSightChannel;                                // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpeedToStartDrafting;                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NumSecondsToActivateDrafting;                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NumForgivenessSeconds;                             // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NumGracePeriodSeconds;                             // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NumSecondsToMaxBonusSpeed;                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBonusSpeed;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NumSpeedRemovalSeconds;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleDraftingConfig) == 0x000004, "Wrong alignment on FDelMarVehicleDraftingConfig");
static_assert(sizeof(FDelMarVehicleDraftingConfig) == 0x000030, "Wrong size on FDelMarVehicleDraftingConfig");
static_assert(offsetof(FDelMarVehicleDraftingConfig, TraceDistance) == 0x000000, "Member 'FDelMarVehicleDraftingConfig::TraceDistance' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, MinEligibleDistance) == 0x000004, "Member 'FDelMarVehicleDraftingConfig::MinEligibleDistance' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, MaxHorizontalDegreesToDraftTarget) == 0x000008, "Member 'FDelMarVehicleDraftingConfig::MaxHorizontalDegreesToDraftTarget' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, MaxVerticalDegreesToDraftTarget) == 0x00000C, "Member 'FDelMarVehicleDraftingConfig::MaxVerticalDegreesToDraftTarget' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, LineOfSightChannel) == 0x000010, "Member 'FDelMarVehicleDraftingConfig::LineOfSightChannel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, MinSpeedToStartDrafting) == 0x000014, "Member 'FDelMarVehicleDraftingConfig::MinSpeedToStartDrafting' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, NumSecondsToActivateDrafting) == 0x000018, "Member 'FDelMarVehicleDraftingConfig::NumSecondsToActivateDrafting' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, NumForgivenessSeconds) == 0x00001C, "Member 'FDelMarVehicleDraftingConfig::NumForgivenessSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, NumGracePeriodSeconds) == 0x000020, "Member 'FDelMarVehicleDraftingConfig::NumGracePeriodSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, NumSecondsToMaxBonusSpeed) == 0x000024, "Member 'FDelMarVehicleDraftingConfig::NumSecondsToMaxBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, MaxBonusSpeed) == 0x000028, "Member 'FDelMarVehicleDraftingConfig::MaxBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDraftingConfig, NumSpeedRemovalSeconds) == 0x00002C, "Member 'FDelMarVehicleDraftingConfig::NumSpeedRemovalSeconds' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_VehicleJumped
// 0x0000 (0x0190 - 0x0190)
struct FDelMarObjectiveFilter_VehicleJumped final : public FDelMarObjectiveFilterBase
{
};
static_assert(alignof(FDelMarObjectiveFilter_VehicleJumped) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_VehicleJumped");
static_assert(sizeof(FDelMarObjectiveFilter_VehicleJumped) == 0x000190, "Wrong size on FDelMarObjectiveFilter_VehicleJumped");

// ScriptStruct DelMarCore.DelMarObjectiveFilter_VehicleLanded
// 0x0020 (0x01B0 - 0x0190)
struct FDelMarObjectiveFilter_VehicleLanded final : public FDelMarObjectiveFilterBase
{
public:
	struct FDoubleRange                           RequiredTimeInAir;                                 // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarObjectiveFilter_VehicleLanded) == 0x000008, "Wrong alignment on FDelMarObjectiveFilter_VehicleLanded");
static_assert(sizeof(FDelMarObjectiveFilter_VehicleLanded) == 0x0001B0, "Wrong size on FDelMarObjectiveFilter_VehicleLanded");
static_assert(offsetof(FDelMarObjectiveFilter_VehicleLanded, RequiredTimeInAir) == 0x000190, "Member 'FDelMarObjectiveFilter_VehicleLanded::RequiredTimeInAir' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarAnalyticsPlayerRaceData
// 0x0038 (0x0038 - 0x0000)
struct FDelMarAnalyticsPlayerRaceData final
{
public:
	class AFortPlayerController*                  DriverPC;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x30];                                       // 0x0008(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarAnalyticsPlayerRaceData) == 0x000008, "Wrong alignment on FDelMarAnalyticsPlayerRaceData");
static_assert(sizeof(FDelMarAnalyticsPlayerRaceData) == 0x000038, "Wrong size on FDelMarAnalyticsPlayerRaceData");
static_assert(offsetof(FDelMarAnalyticsPlayerRaceData, DriverPC) == 0x000000, "Member 'FDelMarAnalyticsPlayerRaceData::DriverPC' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarProxyMeshMaterialInfo
// 0x0010 (0x0010 - 0x0000)
struct FDelMarProxyMeshMaterialInfo final
{
public:
	TArray<class UMaterialInstanceDynamic*>       MaterialArray;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarProxyMeshMaterialInfo) == 0x000008, "Wrong alignment on FDelMarProxyMeshMaterialInfo");
static_assert(sizeof(FDelMarProxyMeshMaterialInfo) == 0x000010, "Wrong size on FDelMarProxyMeshMaterialInfo");
static_assert(offsetof(FDelMarProxyMeshMaterialInfo, MaterialArray) == 0x000000, "Member 'FDelMarProxyMeshMaterialInfo::MaterialArray' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarMusicTrack
// 0x0020 (0x0020 - 0x0000)
struct FDelMarMusicTrack final
{
public:
	class USoundWave*                             StartLineIntro;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             MainTrack;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             MainTrack_LowSpec;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BPM;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarMusicTrack) == 0x000008, "Wrong alignment on FDelMarMusicTrack");
static_assert(sizeof(FDelMarMusicTrack) == 0x000020, "Wrong size on FDelMarMusicTrack");
static_assert(offsetof(FDelMarMusicTrack, StartLineIntro) == 0x000000, "Member 'FDelMarMusicTrack::StartLineIntro' has a wrong offset!");
static_assert(offsetof(FDelMarMusicTrack, MainTrack) == 0x000008, "Member 'FDelMarMusicTrack::MainTrack' has a wrong offset!");
static_assert(offsetof(FDelMarMusicTrack, MainTrack_LowSpec) == 0x000010, "Member 'FDelMarMusicTrack::MainTrack_LowSpec' has a wrong offset!");
static_assert(offsetof(FDelMarMusicTrack, BPM) == 0x000018, "Member 'FDelMarMusicTrack::BPM' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_MusicPlaylistUpdated
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FDelMarEvent_MusicPlaylistUpdated final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_MusicPlaylistUpdated) == 0x000004, "Wrong alignment on FDelMarEvent_MusicPlaylistUpdated");
static_assert(sizeof(FDelMarEvent_MusicPlaylistUpdated) == 0x00000C, "Wrong size on FDelMarEvent_MusicPlaylistUpdated");

// ScriptStruct DelMarCore.DelMarVehicleAbilityConfig
// 0x0011 (0x0011 - 0x0000)
struct FDelMarVehicleAbilityConfig final
{
public:
	bool                                          bAirControlEnabled;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAirFreestyleEnabled;                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAirThrottleEnabled;                               // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAerialRotationEnabled;                        // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUprightEnabled;                               // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDraftingEnabled;                                  // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriftEnabled;                                     // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriftBoostEnabled;                                // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfiniteUnderthrustEnabled;                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpEnabled;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKickflipEnabled;                                  // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOversteerEnabled;                                 // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReattachmentEnabled;                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartlineBoostEnabled;                            // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStrafeEnabled;                                    // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurboEnabled;                                     // 0x000F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnderthrustEnabled;                               // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleAbilityConfig) == 0x000001, "Wrong alignment on FDelMarVehicleAbilityConfig");
static_assert(sizeof(FDelMarVehicleAbilityConfig) == 0x000011, "Wrong size on FDelMarVehicleAbilityConfig");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bAirControlEnabled) == 0x000000, "Member 'FDelMarVehicleAbilityConfig::bAirControlEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bAirFreestyleEnabled) == 0x000001, "Member 'FDelMarVehicleAbilityConfig::bAirFreestyleEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bAirThrottleEnabled) == 0x000002, "Member 'FDelMarVehicleAbilityConfig::bAirThrottleEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bAutoAerialRotationEnabled) == 0x000003, "Member 'FDelMarVehicleAbilityConfig::bAutoAerialRotationEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bAutoUprightEnabled) == 0x000004, "Member 'FDelMarVehicleAbilityConfig::bAutoUprightEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bDraftingEnabled) == 0x000005, "Member 'FDelMarVehicleAbilityConfig::bDraftingEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bDriftEnabled) == 0x000006, "Member 'FDelMarVehicleAbilityConfig::bDriftEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bDriftBoostEnabled) == 0x000007, "Member 'FDelMarVehicleAbilityConfig::bDriftBoostEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bInfiniteUnderthrustEnabled) == 0x000008, "Member 'FDelMarVehicleAbilityConfig::bInfiniteUnderthrustEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bJumpEnabled) == 0x000009, "Member 'FDelMarVehicleAbilityConfig::bJumpEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bKickflipEnabled) == 0x00000A, "Member 'FDelMarVehicleAbilityConfig::bKickflipEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bOversteerEnabled) == 0x00000B, "Member 'FDelMarVehicleAbilityConfig::bOversteerEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bReattachmentEnabled) == 0x00000C, "Member 'FDelMarVehicleAbilityConfig::bReattachmentEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bStartlineBoostEnabled) == 0x00000D, "Member 'FDelMarVehicleAbilityConfig::bStartlineBoostEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bStrafeEnabled) == 0x00000E, "Member 'FDelMarVehicleAbilityConfig::bStrafeEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bTurboEnabled) == 0x00000F, "Member 'FDelMarVehicleAbilityConfig::bTurboEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAbilityConfig, bUnderthrustEnabled) == 0x000010, "Member 'FDelMarVehicleAbilityConfig::bUnderthrustEnabled' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarTutorialSection
// 0x00B0 (0x00B0 - 0x0000)
struct FDelMarTutorialSection final
{
public:
	float                                         FinishTargetTime;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADelMarStartLineActor*                  StartLine;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADelMarStartLineActor*                  FinishLine;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DisabledActors;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InputDisabledTags;                                 // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FDelMarVehicleAbilityConfig            VehicleAbilityConfig;                              // 0x0048(0x0011)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartingTurboCharges;                              // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarEvent_SetControlsText           ControlsText;                                      // 0x0078(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DialogTag;                                         // 0x00A8(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCountdown;                                    // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarTutorialSection) == 0x000008, "Wrong alignment on FDelMarTutorialSection");
static_assert(sizeof(FDelMarTutorialSection) == 0x0000B0, "Wrong size on FDelMarTutorialSection");
static_assert(offsetof(FDelMarTutorialSection, FinishTargetTime) == 0x000000, "Member 'FDelMarTutorialSection::FinishTargetTime' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, StartLine) == 0x000008, "Member 'FDelMarTutorialSection::StartLine' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, FinishLine) == 0x000010, "Member 'FDelMarTutorialSection::FinishLine' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, DisabledActors) == 0x000018, "Member 'FDelMarTutorialSection::DisabledActors' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, InputDisabledTags) == 0x000028, "Member 'FDelMarTutorialSection::InputDisabledTags' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, VehicleAbilityConfig) == 0x000048, "Member 'FDelMarTutorialSection::VehicleAbilityConfig' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, StartingTurboCharges) == 0x00005C, "Member 'FDelMarTutorialSection::StartingTurboCharges' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, Title) == 0x000060, "Member 'FDelMarTutorialSection::Title' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, ControlsText) == 0x000078, "Member 'FDelMarTutorialSection::ControlsText' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, DialogTag) == 0x0000A8, "Member 'FDelMarTutorialSection::DialogTag' has a wrong offset!");
static_assert(offsetof(FDelMarTutorialSection, bSkipCountdown) == 0x0000AC, "Member 'FDelMarTutorialSection::bSkipCountdown' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEvent_TutorialSectionChanged
// 0x00B8 (0x00B8 - 0x0000)
struct FDelMarEvent_TutorialSectionChanged final
{
public:
	struct FDelMarTutorialSection                 CurrentSection;                                    // 0x0000(0x00B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CurrentSectionIndex;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarEvent_TutorialSectionChanged) == 0x000008, "Wrong alignment on FDelMarEvent_TutorialSectionChanged");
static_assert(sizeof(FDelMarEvent_TutorialSectionChanged) == 0x0000B8, "Wrong size on FDelMarEvent_TutorialSectionChanged");
static_assert(offsetof(FDelMarEvent_TutorialSectionChanged, CurrentSection) == 0x000000, "Member 'FDelMarEvent_TutorialSectionChanged::CurrentSection' has a wrong offset!");
static_assert(offsetof(FDelMarEvent_TutorialSectionChanged, CurrentSectionIndex) == 0x0000B0, "Member 'FDelMarEvent_TutorialSectionChanged::CurrentSectionIndex' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarHintText
// 0x0048 (0x0048 - 0x0000)
struct FDelMarHintText final
{
public:
	class FText                                   KBMText;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GamepadText;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TouchText;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarHintText) == 0x000008, "Wrong alignment on FDelMarHintText");
static_assert(sizeof(FDelMarHintText) == 0x000048, "Wrong size on FDelMarHintText");
static_assert(offsetof(FDelMarHintText, KBMText) == 0x000000, "Member 'FDelMarHintText::KBMText' has a wrong offset!");
static_assert(offsetof(FDelMarHintText, GamepadText) == 0x000018, "Member 'FDelMarHintText::GamepadText' has a wrong offset!");
static_assert(offsetof(FDelMarHintText, TouchText) == 0x000030, "Member 'FDelMarHintText::TouchText' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleSuspensionConfig
// 0x0014 (0x0014 - 0x0000)
struct FDelMarVehicleSuspensionConfig final
{
public:
	float                                         MaxRaise;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDrop;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampingCompression;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampingRelaxation;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleSuspensionConfig) == 0x000004, "Wrong alignment on FDelMarVehicleSuspensionConfig");
static_assert(sizeof(FDelMarVehicleSuspensionConfig) == 0x000014, "Wrong size on FDelMarVehicleSuspensionConfig");
static_assert(offsetof(FDelMarVehicleSuspensionConfig, MaxRaise) == 0x000000, "Member 'FDelMarVehicleSuspensionConfig::MaxRaise' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleSuspensionConfig, MaxDrop) == 0x000004, "Member 'FDelMarVehicleSuspensionConfig::MaxDrop' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleSuspensionConfig, Stiffness) == 0x000008, "Member 'FDelMarVehicleSuspensionConfig::Stiffness' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleSuspensionConfig, DampingCompression) == 0x00000C, "Member 'FDelMarVehicleSuspensionConfig::DampingCompression' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleSuspensionConfig, DampingRelaxation) == 0x000010, "Member 'FDelMarVehicleSuspensionConfig::DampingRelaxation' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleAxleConfig
// 0x002C (0x002C - 0x0000)
struct FDelMarVehicleAxleConfig final
{
public:
	float                                         TranslateX;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslateY;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslateZ;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelRadius;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleHitboxHeight;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestDistanceZ;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarVehicleSuspensionConfig         Suspension;                                        // 0x0018(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleAxleConfig) == 0x000004, "Wrong alignment on FDelMarVehicleAxleConfig");
static_assert(sizeof(FDelMarVehicleAxleConfig) == 0x00002C, "Wrong size on FDelMarVehicleAxleConfig");
static_assert(offsetof(FDelMarVehicleAxleConfig, TranslateX) == 0x000000, "Member 'FDelMarVehicleAxleConfig::TranslateX' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAxleConfig, TranslateY) == 0x000004, "Member 'FDelMarVehicleAxleConfig::TranslateY' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAxleConfig, TranslateZ) == 0x000008, "Member 'FDelMarVehicleAxleConfig::TranslateZ' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAxleConfig, WheelRadius) == 0x00000C, "Member 'FDelMarVehicleAxleConfig::WheelRadius' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAxleConfig, VehicleHitboxHeight) == 0x000010, "Member 'FDelMarVehicleAxleConfig::VehicleHitboxHeight' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAxleConfig, RestDistanceZ) == 0x000014, "Member 'FDelMarVehicleAxleConfig::RestDistanceZ' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleAxleConfig, Suspension) == 0x000018, "Member 'FDelMarVehicleAxleConfig::Suspension' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarCameraFloatProperty
// 0x00B0 (0x00B0 - 0x0000)
struct FDelMarCameraFloatProperty final
{
public:
	bool                                          bEvaluateInputOnCurve;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccumulateInput;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         InterpLambda;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayLambda;                                       // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            ClampedRange;                                      // 0x0098(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarCameraFloatProperty) == 0x000008, "Wrong alignment on FDelMarCameraFloatProperty");
static_assert(sizeof(FDelMarCameraFloatProperty) == 0x0000B0, "Wrong size on FDelMarCameraFloatProperty");
static_assert(offsetof(FDelMarCameraFloatProperty, bEvaluateInputOnCurve) == 0x000000, "Member 'FDelMarCameraFloatProperty::bEvaluateInputOnCurve' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatProperty, bAccumulateInput) == 0x000001, "Member 'FDelMarCameraFloatProperty::bAccumulateInput' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatProperty, Curve) == 0x000008, "Member 'FDelMarCameraFloatProperty::Curve' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatProperty, InterpLambda) == 0x000090, "Member 'FDelMarCameraFloatProperty::InterpLambda' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatProperty, DecayLambda) == 0x000094, "Member 'FDelMarCameraFloatProperty::DecayLambda' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatProperty, ClampedRange) == 0x000098, "Member 'FDelMarCameraFloatProperty::ClampedRange' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarCameraFloatBlendedProperty
// 0x01D0 (0x01D0 - 0x0000)
struct FDelMarCameraFloatBlendedProperty final
{
public:
	bool                                          bEvaluateInputOnCurve;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     InputCurve;                                        // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         ActiveValue;                                       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemapOutputValue;                                 // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     RemapCurve;                                        // 0x0098(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         BlendInLambda;                                     // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutLambda;                                    // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBlendOutCurve;                                 // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     BlendOutLambdaCurve;                               // 0x0130(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x14];                                     // 0x01BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarCameraFloatBlendedProperty) == 0x000008, "Wrong alignment on FDelMarCameraFloatBlendedProperty");
static_assert(sizeof(FDelMarCameraFloatBlendedProperty) == 0x0001D0, "Wrong size on FDelMarCameraFloatBlendedProperty");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, bEvaluateInputOnCurve) == 0x000000, "Member 'FDelMarCameraFloatBlendedProperty::bEvaluateInputOnCurve' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, InputCurve) == 0x000008, "Member 'FDelMarCameraFloatBlendedProperty::InputCurve' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, ActiveValue) == 0x000090, "Member 'FDelMarCameraFloatBlendedProperty::ActiveValue' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, bRemapOutputValue) == 0x000094, "Member 'FDelMarCameraFloatBlendedProperty::bRemapOutputValue' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, RemapCurve) == 0x000098, "Member 'FDelMarCameraFloatBlendedProperty::RemapCurve' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, BlendInLambda) == 0x000120, "Member 'FDelMarCameraFloatBlendedProperty::BlendInLambda' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, BlendOutLambda) == 0x000124, "Member 'FDelMarCameraFloatBlendedProperty::BlendOutLambda' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, bUseBlendOutCurve) == 0x000128, "Member 'FDelMarCameraFloatBlendedProperty::bUseBlendOutCurve' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, BlendOutLambdaCurve) == 0x000130, "Member 'FDelMarCameraFloatBlendedProperty::BlendOutLambdaCurve' has a wrong offset!");
static_assert(offsetof(FDelMarCameraFloatBlendedProperty, Tolerance) == 0x0001B8, "Member 'FDelMarCameraFloatBlendedProperty::Tolerance' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplay_InputState_RL
// 0x0020 (0x0020 - 0x0000)
struct FDelMarVehicleReplay_InputState_RL final
{
public:
	float                                         Throttle;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Steer;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pitch;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeForward;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeRight;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandbrake;                                        // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJump;                                             // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBoost;                                            // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleReplay_InputState_RL) == 0x000004, "Wrong alignment on FDelMarVehicleReplay_InputState_RL");
static_assert(sizeof(FDelMarVehicleReplay_InputState_RL) == 0x000020, "Wrong size on FDelMarVehicleReplay_InputState_RL");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, Throttle) == 0x000000, "Member 'FDelMarVehicleReplay_InputState_RL::Throttle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, Steer) == 0x000004, "Member 'FDelMarVehicleReplay_InputState_RL::Steer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, pitch) == 0x000008, "Member 'FDelMarVehicleReplay_InputState_RL::pitch' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, Yaw) == 0x00000C, "Member 'FDelMarVehicleReplay_InputState_RL::Yaw' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, Roll) == 0x000010, "Member 'FDelMarVehicleReplay_InputState_RL::Roll' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, DodgeForward) == 0x000014, "Member 'FDelMarVehicleReplay_InputState_RL::DodgeForward' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, DodgeRight) == 0x000018, "Member 'FDelMarVehicleReplay_InputState_RL::DodgeRight' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, bHandbrake) == 0x00001C, "Member 'FDelMarVehicleReplay_InputState_RL::bHandbrake' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, bJump) == 0x00001D, "Member 'FDelMarVehicleReplay_InputState_RL::bJump' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_RL, bBoost) == 0x00001E, "Member 'FDelMarVehicleReplay_InputState_RL::bBoost' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplay_InputState_DM
// 0x0008 (0x0008 - 0x0000)
struct FDelMarVehicleReplay_InputState_DM final
{
public:
	float                                         AerialPitch;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrift;                                            // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroundedFlip;                                     // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKickflip;                                         // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShunt;                                            // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplay_InputState_DM) == 0x000004, "Wrong alignment on FDelMarVehicleReplay_InputState_DM");
static_assert(sizeof(FDelMarVehicleReplay_InputState_DM) == 0x000008, "Wrong size on FDelMarVehicleReplay_InputState_DM");
static_assert(offsetof(FDelMarVehicleReplay_InputState_DM, AerialPitch) == 0x000000, "Member 'FDelMarVehicleReplay_InputState_DM::AerialPitch' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_DM, bDrift) == 0x000004, "Member 'FDelMarVehicleReplay_InputState_DM::bDrift' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_DM, bGroundedFlip) == 0x000005, "Member 'FDelMarVehicleReplay_InputState_DM::bGroundedFlip' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_DM, bKickflip) == 0x000006, "Member 'FDelMarVehicleReplay_InputState_DM::bKickflip' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_InputState_DM, bShunt) == 0x000007, "Member 'FDelMarVehicleReplay_InputState_DM::bShunt' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplay_RigidBodyState
// 0x0070 (0x0070 - 0x0000)
struct FDelMarVehicleReplay_RigidBodyState final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinearVelocity;                                    // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplay_RigidBodyState) == 0x000010, "Wrong alignment on FDelMarVehicleReplay_RigidBodyState");
static_assert(sizeof(FDelMarVehicleReplay_RigidBodyState) == 0x000070, "Wrong size on FDelMarVehicleReplay_RigidBodyState");
static_assert(offsetof(FDelMarVehicleReplay_RigidBodyState, Location) == 0x000000, "Member 'FDelMarVehicleReplay_RigidBodyState::Location' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_RigidBodyState, Rotation) == 0x000020, "Member 'FDelMarVehicleReplay_RigidBodyState::Rotation' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_RigidBodyState, LinearVelocity) == 0x000040, "Member 'FDelMarVehicleReplay_RigidBodyState::LinearVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_RigidBodyState, AngularVelocity) == 0x000058, "Member 'FDelMarVehicleReplay_RigidBodyState::AngularVelocity' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplay_FrameData
// 0x00B0 (0x00B0 - 0x0000)
struct FDelMarVehicleReplay_FrameData final
{
public:
	int32                                         FrameCaptureIndex;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SecondsSinceCountdownFinished;                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplay_InputState_RL     Input;                                             // 0x0010(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplay_InputState_DM     Input_DM;                                          // 0x0030(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarVehicleReplay_RigidBodyState    PreSimRBState;                                     // 0x0040(0x0070)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplay_FrameData) == 0x000010, "Wrong alignment on FDelMarVehicleReplay_FrameData");
static_assert(sizeof(FDelMarVehicleReplay_FrameData) == 0x0000B0, "Wrong size on FDelMarVehicleReplay_FrameData");
static_assert(offsetof(FDelMarVehicleReplay_FrameData, FrameCaptureIndex) == 0x000000, "Member 'FDelMarVehicleReplay_FrameData::FrameCaptureIndex' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_FrameData, SecondsSinceCountdownFinished) == 0x000008, "Member 'FDelMarVehicleReplay_FrameData::SecondsSinceCountdownFinished' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_FrameData, Input) == 0x000010, "Member 'FDelMarVehicleReplay_FrameData::Input' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_FrameData, Input_DM) == 0x000030, "Member 'FDelMarVehicleReplay_FrameData::Input_DM' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplay_FrameData, PreSimRBState) == 0x000040, "Member 'FDelMarVehicleReplay_FrameData::PreSimRBState' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleCachedContact
// 0x0070 (0x0070 - 0x0000)
struct FDelMarVehicleCachedContact final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Impulse;                                           // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DeltaVelocity;                                     // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVehicleContact;                                   // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriveableContact;                                 // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0064(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleCachedContact) == 0x000008, "Wrong alignment on FDelMarVehicleCachedContact");
static_assert(sizeof(FDelMarVehicleCachedContact) == 0x000070, "Wrong size on FDelMarVehicleCachedContact");
static_assert(offsetof(FDelMarVehicleCachedContact, Location) == 0x000000, "Member 'FDelMarVehicleCachedContact::Location' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCachedContact, Normal) == 0x000018, "Member 'FDelMarVehicleCachedContact::Normal' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCachedContact, Impulse) == 0x000030, "Member 'FDelMarVehicleCachedContact::Impulse' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCachedContact, DeltaVelocity) == 0x000048, "Member 'FDelMarVehicleCachedContact::DeltaVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCachedContact, bVehicleContact) == 0x000060, "Member 'FDelMarVehicleCachedContact::bVehicleContact' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCachedContact, bDriveableContact) == 0x000061, "Member 'FDelMarVehicleCachedContact::bDriveableContact' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCachedContact, Component) == 0x000064, "Member 'FDelMarVehicleCachedContact::Component' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarWorldBonusSpeedStack
// 0x0024 (0x0024 - 0x0000)
struct FDelMarWorldBonusSpeedStack final
{
public:
	struct FGameplayTag                           Source;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusSpeed;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyForce;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  ActorSource;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0xC];                                       // 0x0018(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarWorldBonusSpeedStack) == 0x000004, "Wrong alignment on FDelMarWorldBonusSpeedStack");
static_assert(sizeof(FDelMarWorldBonusSpeedStack) == 0x000024, "Wrong size on FDelMarWorldBonusSpeedStack");
static_assert(offsetof(FDelMarWorldBonusSpeedStack, Source) == 0x000000, "Member 'FDelMarWorldBonusSpeedStack::Source' has a wrong offset!");
static_assert(offsetof(FDelMarWorldBonusSpeedStack, BonusSpeed) == 0x000004, "Member 'FDelMarWorldBonusSpeedStack::BonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarWorldBonusSpeedStack, duration) == 0x000008, "Member 'FDelMarWorldBonusSpeedStack::duration' has a wrong offset!");
static_assert(offsetof(FDelMarWorldBonusSpeedStack, bApplyForce) == 0x00000C, "Member 'FDelMarWorldBonusSpeedStack::bApplyForce' has a wrong offset!");
static_assert(offsetof(FDelMarWorldBonusSpeedStack, ActorSource) == 0x000010, "Member 'FDelMarWorldBonusSpeedStack::ActorSource' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarWorldBonusSpeedGroup
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDelMarWorldBonusSpeedGroup final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarWorldBonusSpeedGroup) == 0x000008, "Wrong alignment on FDelMarWorldBonusSpeedGroup");
static_assert(sizeof(FDelMarWorldBonusSpeedGroup) == 0x000018, "Wrong size on FDelMarWorldBonusSpeedGroup");

// ScriptStruct DelMarCore.DelMarVehicleLandingData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FDelMarVehicleLandingData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleLandingData) == 0x000004, "Wrong alignment on FDelMarVehicleLandingData");
static_assert(sizeof(FDelMarVehicleLandingData) == 0x00000C, "Wrong size on FDelMarVehicleLandingData");

// ScriptStruct DelMarCore.DelMarVehicleSkydivingData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDelMarVehicleSkydivingData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleSkydivingData) == 0x000004, "Wrong alignment on FDelMarVehicleSkydivingData");
static_assert(sizeof(FDelMarVehicleSkydivingData) == 0x000008, "Wrong size on FDelMarVehicleSkydivingData");

// ScriptStruct DelMarCore.DelMarStartlineBoostData
// 0x0010 (0x0010 - 0x0000)
struct FDelMarStartlineBoostData final
{
public:
	bool                                          bFailed;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReactionSeconds;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunStartTime;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalSeconds;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarStartlineBoostData) == 0x000004, "Wrong alignment on FDelMarStartlineBoostData");
static_assert(sizeof(FDelMarStartlineBoostData) == 0x000010, "Wrong size on FDelMarStartlineBoostData");
static_assert(offsetof(FDelMarStartlineBoostData, bFailed) == 0x000000, "Member 'FDelMarStartlineBoostData::bFailed' has a wrong offset!");
static_assert(offsetof(FDelMarStartlineBoostData, ReactionSeconds) == 0x000004, "Member 'FDelMarStartlineBoostData::ReactionSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarStartlineBoostData, RunStartTime) == 0x000008, "Member 'FDelMarStartlineBoostData::RunStartTime' has a wrong offset!");
static_assert(offsetof(FDelMarStartlineBoostData, IntervalSeconds) == 0x00000C, "Member 'FDelMarStartlineBoostData::IntervalSeconds' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_AutoUpright
// 0x0018 (0x0020 - 0x0008)
struct FDelMarVehicleReplicatedState_AutoUpright final : public FDelMarVehicleReplicatedState_Ability
{
public:
	struct FVector_NetQuantizeNormal              TargetVehicleUp;                                   // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_AutoUpright) == 0x000008, "Wrong alignment on FDelMarVehicleReplicatedState_AutoUpright");
static_assert(sizeof(FDelMarVehicleReplicatedState_AutoUpright) == 0x000020, "Wrong size on FDelMarVehicleReplicatedState_AutoUpright");
static_assert(offsetof(FDelMarVehicleReplicatedState_AutoUpright, TargetVehicleUp) == 0x000008, "Member 'FDelMarVehicleReplicatedState_AutoUpright::TargetVehicleUp' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Drafting
// 0x000C (0x0018 - 0x000C)
struct FDelMarVehicleReplicatedState_Drafting final : public FDelMarVehicleReplicatedState_BonusSpeedAbility
{
public:
	float                                         AccumulatedLosingSpeedSeconds;                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedStartDraftingSeconds;                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalEarnedBonusSpeed;                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Drafting) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_Drafting");
static_assert(sizeof(FDelMarVehicleReplicatedState_Drafting) == 0x000018, "Wrong size on FDelMarVehicleReplicatedState_Drafting");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drafting, AccumulatedLosingSpeedSeconds) == 0x00000C, "Member 'FDelMarVehicleReplicatedState_Drafting::AccumulatedLosingSpeedSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drafting, AccumulatedStartDraftingSeconds) == 0x000010, "Member 'FDelMarVehicleReplicatedState_Drafting::AccumulatedStartDraftingSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drafting, TotalEarnedBonusSpeed) == 0x000014, "Member 'FDelMarVehicleReplicatedState_Drafting::TotalEarnedBonusSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Drift
// 0x0028 (0x0030 - 0x0008)
struct FDelMarVehicleReplicatedState_Drift final : public FDelMarVehicleReplicatedState_Ability
{
public:
	float                                         CurrentRotationAngle;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarVehicleDriftState                      DriftState;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetDriftSide;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 InitialImpulseTorque;                              // 0x0018(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Drift) == 0x000008, "Wrong alignment on FDelMarVehicleReplicatedState_Drift");
static_assert(sizeof(FDelMarVehicleReplicatedState_Drift) == 0x000030, "Wrong size on FDelMarVehicleReplicatedState_Drift");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drift, CurrentRotationAngle) == 0x000008, "Member 'FDelMarVehicleReplicatedState_Drift::CurrentRotationAngle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drift, DriftState) == 0x00000C, "Member 'FDelMarVehicleReplicatedState_Drift::DriftState' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drift, TargetDriftSide) == 0x000010, "Member 'FDelMarVehicleReplicatedState_Drift::TargetDriftSide' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drift, InitialImpulseTorque) == 0x000018, "Member 'FDelMarVehicleReplicatedState_Drift::InitialImpulseTorque' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Drive
// 0x0030 (0x0030 - 0x0000)
struct FDelMarVehicleReplicatedState_Drive final
{
public:
	float                                         BaseTargetSpeed;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertedSteeringActive;                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         bDisableDriveForces;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bDisableWheelFriction;                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              LastAverageWheelWorldContactNormal;                // 0x0010(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumLandingSpeed;                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleReplicatedState_Drive) == 0x000008, "Wrong alignment on FDelMarVehicleReplicatedState_Drive");
static_assert(sizeof(FDelMarVehicleReplicatedState_Drive) == 0x000030, "Wrong size on FDelMarVehicleReplicatedState_Drive");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drive, BaseTargetSpeed) == 0x000000, "Member 'FDelMarVehicleReplicatedState_Drive::BaseTargetSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drive, bInvertedSteeringActive) == 0x000004, "Member 'FDelMarVehicleReplicatedState_Drive::bInvertedSteeringActive' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drive, bDisableDriveForces) == 0x000008, "Member 'FDelMarVehicleReplicatedState_Drive::bDisableDriveForces' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drive, bDisableWheelFriction) == 0x00000C, "Member 'FDelMarVehicleReplicatedState_Drive::bDisableWheelFriction' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drive, LastAverageWheelWorldContactNormal) == 0x000010, "Member 'FDelMarVehicleReplicatedState_Drive::LastAverageWheelWorldContactNormal' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Drive, MinimumLandingSpeed) == 0x000028, "Member 'FDelMarVehicleReplicatedState_Drive::MinimumLandingSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Oversteer
// 0x0004 (0x0004 - 0x0000)
struct FDelMarVehicleReplicatedState_Oversteer final
{
public:
	float                                         AccumulatedSteer;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Oversteer) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_Oversteer");
static_assert(sizeof(FDelMarVehicleReplicatedState_Oversteer) == 0x000004, "Wrong size on FDelMarVehicleReplicatedState_Oversteer");
static_assert(offsetof(FDelMarVehicleReplicatedState_Oversteer, AccumulatedSteer) == 0x000000, "Member 'FDelMarVehicleReplicatedState_Oversteer::AccumulatedSteer' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Rubberbanding
// 0x0004 (0x0004 - 0x0000)
struct FDelMarVehicleReplicatedState_Rubberbanding final
{
public:
	float                                         AppliedBonusSpeed;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Rubberbanding) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_Rubberbanding");
static_assert(sizeof(FDelMarVehicleReplicatedState_Rubberbanding) == 0x000004, "Wrong size on FDelMarVehicleReplicatedState_Rubberbanding");
static_assert(offsetof(FDelMarVehicleReplicatedState_Rubberbanding, AppliedBonusSpeed) == 0x000000, "Member 'FDelMarVehicleReplicatedState_Rubberbanding::AppliedBonusSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_StartlineBoost
// 0x0008 (0x0014 - 0x000C)
struct FDelMarVehicleReplicatedState_StartlineBoost final : public FDelMarVehicleReplicatedState_BonusSpeedAbility
{
public:
	float                                         PercentageMaxBonusSpeedEarned;                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFailedAttempt;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleReplicatedState_StartlineBoost) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_StartlineBoost");
static_assert(sizeof(FDelMarVehicleReplicatedState_StartlineBoost) == 0x000014, "Wrong size on FDelMarVehicleReplicatedState_StartlineBoost");
static_assert(offsetof(FDelMarVehicleReplicatedState_StartlineBoost, PercentageMaxBonusSpeedEarned) == 0x00000C, "Member 'FDelMarVehicleReplicatedState_StartlineBoost::PercentageMaxBonusSpeedEarned' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_StartlineBoost, bFailedAttempt) == 0x000010, "Member 'FDelMarVehicleReplicatedState_StartlineBoost::bFailedAttempt' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Turbo
// 0x000C (0x0018 - 0x000C)
struct FDelMarVehicleReplicatedState_Turbo final : public FDelMarVehicleReplicatedState_BonusSpeedAbility
{
public:
	int32                                         LastBonusZoneInteractionIndex;                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccessfulBonusZone;                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalActiveSeconds;                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Turbo) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_Turbo");
static_assert(sizeof(FDelMarVehicleReplicatedState_Turbo) == 0x000018, "Wrong size on FDelMarVehicleReplicatedState_Turbo");
static_assert(offsetof(FDelMarVehicleReplicatedState_Turbo, LastBonusZoneInteractionIndex) == 0x00000C, "Member 'FDelMarVehicleReplicatedState_Turbo::LastBonusZoneInteractionIndex' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Turbo, bSuccessfulBonusZone) == 0x000010, "Member 'FDelMarVehicleReplicatedState_Turbo::bSuccessfulBonusZone' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Turbo, AdditionalActiveSeconds) == 0x000014, "Member 'FDelMarVehicleReplicatedState_Turbo::AdditionalActiveSeconds' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState_Strafe
// 0x0008 (0x0010 - 0x0008)
struct FDelMarVehicleReplicatedState_Strafe final : public FDelMarVehicleReplicatedState_Ability
{
public:
	bool                                          bLeftSide;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrafeKeybindPressTime;                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState_Strafe) == 0x000004, "Wrong alignment on FDelMarVehicleReplicatedState_Strafe");
static_assert(sizeof(FDelMarVehicleReplicatedState_Strafe) == 0x000010, "Wrong size on FDelMarVehicleReplicatedState_Strafe");
static_assert(offsetof(FDelMarVehicleReplicatedState_Strafe, bLeftSide) == 0x000008, "Member 'FDelMarVehicleReplicatedState_Strafe::bLeftSide' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState_Strafe, StrafeKeybindPressTime) == 0x00000C, "Member 'FDelMarVehicleReplicatedState_Strafe::StrafeKeybindPressTime' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarInputBufferData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FDelMarInputBufferData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarInputBufferData) == 0x000004, "Wrong alignment on FDelMarInputBufferData");
static_assert(sizeof(FDelMarInputBufferData) == 0x000018, "Wrong size on FDelMarInputBufferData");

// ScriptStruct DelMarCore.DelMarVehicleReplicatedState
// 0x0290 (0x0290 - 0x0000)
struct FDelMarVehicleReplicatedState final
{
public:
	int32                                         FrameNum;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarVehicleInContinuous             Input;                                             // 0x0008(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigidBodyState                        RBState;                                           // 0x0050(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_AutoUpright AutoUpright;                                       // 0x00D0(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Drafting Drafting;                                          // 0x00F0(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Drift    Drift;                                             // 0x0108(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_DriftBoost DriftBoost;                                        // 0x0138(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Drive    Drive;                                             // 0x0158(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Ability  Jump;                                              // 0x0188(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Kickflip Kickflip;                                          // 0x0190(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Oversteer Oversteer;                                         // 0x01F0(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarVehicleReplicatedState_Reattachment Reattachment;                                      // 0x01F8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Rubberbanding Rubberbanding;                                     // 0x0220(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_StartlineBoost StartlineBoost;                                    // 0x0224(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Strafe   Strafe;                                            // 0x0238(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Turbo    Turbo;                                             // 0x0248(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_Underthrust Underthrust;                                       // 0x0260(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarVehicleReplicatedState_AirControl AirControl;                                        // 0x026C(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDelMarInputBufferData                 BufferData;                                        // 0x0278(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleReplicatedState) == 0x000010, "Wrong alignment on FDelMarVehicleReplicatedState");
static_assert(sizeof(FDelMarVehicleReplicatedState) == 0x000290, "Wrong size on FDelMarVehicleReplicatedState");
static_assert(offsetof(FDelMarVehicleReplicatedState, FrameNum) == 0x000000, "Member 'FDelMarVehicleReplicatedState::FrameNum' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Input) == 0x000008, "Member 'FDelMarVehicleReplicatedState::Input' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, RBState) == 0x000050, "Member 'FDelMarVehicleReplicatedState::RBState' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, AutoUpright) == 0x0000D0, "Member 'FDelMarVehicleReplicatedState::AutoUpright' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Drafting) == 0x0000F0, "Member 'FDelMarVehicleReplicatedState::Drafting' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Drift) == 0x000108, "Member 'FDelMarVehicleReplicatedState::Drift' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, DriftBoost) == 0x000138, "Member 'FDelMarVehicleReplicatedState::DriftBoost' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Drive) == 0x000158, "Member 'FDelMarVehicleReplicatedState::Drive' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Jump) == 0x000188, "Member 'FDelMarVehicleReplicatedState::Jump' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Kickflip) == 0x000190, "Member 'FDelMarVehicleReplicatedState::Kickflip' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Oversteer) == 0x0001F0, "Member 'FDelMarVehicleReplicatedState::Oversteer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Reattachment) == 0x0001F8, "Member 'FDelMarVehicleReplicatedState::Reattachment' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Rubberbanding) == 0x000220, "Member 'FDelMarVehicleReplicatedState::Rubberbanding' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, StartlineBoost) == 0x000224, "Member 'FDelMarVehicleReplicatedState::StartlineBoost' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Strafe) == 0x000238, "Member 'FDelMarVehicleReplicatedState::Strafe' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Turbo) == 0x000248, "Member 'FDelMarVehicleReplicatedState::Turbo' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, Underthrust) == 0x000260, "Member 'FDelMarVehicleReplicatedState::Underthrust' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, AirControl) == 0x00026C, "Member 'FDelMarVehicleReplicatedState::AirControl' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleReplicatedState, BufferData) == 0x000278, "Member 'FDelMarVehicleReplicatedState::BufferData' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleInternalPersistent
// 0x0A20 (0x0B00 - 0x00E0)
struct alignas(0x10) FDelMarVehicleInternalPersistent final : public FFortVehicleInternalPersistent
{
public:
	uint8                                         Pad_E0[0xA20];                                     // 0x00E0(0x0A20)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleInternalPersistent) == 0x000010, "Wrong alignment on FDelMarVehicleInternalPersistent");
static_assert(sizeof(FDelMarVehicleInternalPersistent) == 0x000B00, "Wrong size on FDelMarVehicleInternalPersistent");

// ScriptStruct DelMarCore.DelMarVehicleOutPersistent
// 0x0A08 (0x0A30 - 0x0028)
struct alignas(0x10) FDelMarVehicleOutPersistent final : public FFortVehicleOutPersistent
{
public:
	uint8                                         Pad_28[0xA08];                                     // 0x0028(0x0A08)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleOutPersistent) == 0x000010, "Wrong alignment on FDelMarVehicleOutPersistent");
static_assert(sizeof(FDelMarVehicleOutPersistent) == 0x000A30, "Wrong size on FDelMarVehicleOutPersistent");

// ScriptStruct DelMarCore.DelMarVehicleSpawnInfo
// 0x0010 (0x0010 - 0x0000)
struct FDelMarVehicleSpawnInfo final
{
public:
	bool                                          bFirstVehicleForPlayer;                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviousVehicleDemolished;                        // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ServerSpawnTime;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleSpawnInfo) == 0x000008, "Wrong alignment on FDelMarVehicleSpawnInfo");
static_assert(sizeof(FDelMarVehicleSpawnInfo) == 0x000010, "Wrong size on FDelMarVehicleSpawnInfo");
static_assert(offsetof(FDelMarVehicleSpawnInfo, bFirstVehicleForPlayer) == 0x000000, "Member 'FDelMarVehicleSpawnInfo::bFirstVehicleForPlayer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleSpawnInfo, bPreviousVehicleDemolished) == 0x000001, "Member 'FDelMarVehicleSpawnInfo::bPreviousVehicleDemolished' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleSpawnInfo, ServerSpawnTime) == 0x000008, "Member 'FDelMarVehicleSpawnInfo::ServerSpawnTime' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_BeatPlayers
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_BeatPlayers final : public FDelMarVerbMessageBase
{
public:
	uint8                                         AmountOfPlayersBeat;                               // 0x0138(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_BeatPlayers) == 0x000008, "Wrong alignment on FDelMarVerbMessage_BeatPlayers");
static_assert(sizeof(FDelMarVerbMessage_BeatPlayers) == 0x000140, "Wrong size on FDelMarVerbMessage_BeatPlayers");
static_assert(offsetof(FDelMarVerbMessage_BeatPlayers, AmountOfPlayersBeat) == 0x000138, "Member 'FDelMarVerbMessage_BeatPlayers::AmountOfPlayersBeat' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_BoostPadBonusSpeedEnded
// 0x0000 (0x0138 - 0x0138)
struct FDelMarVerbMessage_BoostPadBonusSpeedEnded final : public FDelMarVerbMessageBase
{
};
static_assert(alignof(FDelMarVerbMessage_BoostPadBonusSpeedEnded) == 0x000008, "Wrong alignment on FDelMarVerbMessage_BoostPadBonusSpeedEnded");
static_assert(sizeof(FDelMarVerbMessage_BoostPadBonusSpeedEnded) == 0x000138, "Wrong size on FDelMarVerbMessage_BoostPadBonusSpeedEnded");

// ScriptStruct DelMarCore.DelMarVerbMessage_DistanceTraveled
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_DistanceTraveled final : public FDelMarVerbMessageBase
{
public:
	float                                         TotalDistance;                                     // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_DistanceTraveled) == 0x000008, "Wrong alignment on FDelMarVerbMessage_DistanceTraveled");
static_assert(sizeof(FDelMarVerbMessage_DistanceTraveled) == 0x000140, "Wrong size on FDelMarVerbMessage_DistanceTraveled");
static_assert(offsetof(FDelMarVerbMessage_DistanceTraveled, TotalDistance) == 0x000138, "Member 'FDelMarVerbMessage_DistanceTraveled::TotalDistance' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_DraftActivated
// 0x0000 (0x0138 - 0x0138)
struct FDelMarVerbMessage_DraftActivated final : public FDelMarVerbMessageBase
{
};
static_assert(alignof(FDelMarVerbMessage_DraftActivated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_DraftActivated");
static_assert(sizeof(FDelMarVerbMessage_DraftActivated) == 0x000138, "Wrong size on FDelMarVerbMessage_DraftActivated");

// ScriptStruct DelMarCore.DelMarVerbMessage_DriftBoostActivated
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_DriftBoostActivated final : public FDelMarVerbMessageBase
{
public:
	float                                         DriftBoostPercent;                                 // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_DriftBoostActivated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_DriftBoostActivated");
static_assert(sizeof(FDelMarVerbMessage_DriftBoostActivated) == 0x000140, "Wrong size on FDelMarVerbMessage_DriftBoostActivated");
static_assert(offsetof(FDelMarVerbMessage_DriftBoostActivated, DriftBoostPercent) == 0x000138, "Member 'FDelMarVerbMessage_DriftBoostActivated::DriftBoostPercent' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_DriftBoostDeactivated
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_DriftBoostDeactivated final : public FDelMarVerbMessageBase
{
public:
	float                                         TotalDistance;                                     // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_DriftBoostDeactivated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_DriftBoostDeactivated");
static_assert(sizeof(FDelMarVerbMessage_DriftBoostDeactivated) == 0x000140, "Wrong size on FDelMarVerbMessage_DriftBoostDeactivated");
static_assert(offsetof(FDelMarVerbMessage_DriftBoostDeactivated, TotalDistance) == 0x000138, "Member 'FDelMarVerbMessage_DriftBoostDeactivated::TotalDistance' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_DriftComplete
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_DriftComplete final : public FDelMarVerbMessageBase
{
public:
	float                                         DriftDuration;                                     // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_DriftComplete) == 0x000008, "Wrong alignment on FDelMarVerbMessage_DriftComplete");
static_assert(sizeof(FDelMarVerbMessage_DriftComplete) == 0x000140, "Wrong size on FDelMarVerbMessage_DriftComplete");
static_assert(offsetof(FDelMarVerbMessage_DriftComplete, DriftDuration) == 0x000138, "Member 'FDelMarVerbMessage_DriftComplete::DriftDuration' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_InitialTurboActivated
// 0x0000 (0x0138 - 0x0138)
struct FDelMarVerbMessage_InitialTurboActivated final : public FDelMarVerbMessageBase
{
};
static_assert(alignof(FDelMarVerbMessage_InitialTurboActivated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_InitialTurboActivated");
static_assert(sizeof(FDelMarVerbMessage_InitialTurboActivated) == 0x000138, "Wrong size on FDelMarVerbMessage_InitialTurboActivated");

// ScriptStruct DelMarCore.DelMarVerbMessage_Kickflipped
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_Kickflipped final : public FDelMarVerbMessageBase
{
public:
	EDelMarKickflipDirection                      Direction;                                         // 0x0138(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_Kickflipped) == 0x000008, "Wrong alignment on FDelMarVerbMessage_Kickflipped");
static_assert(sizeof(FDelMarVerbMessage_Kickflipped) == 0x000140, "Wrong size on FDelMarVerbMessage_Kickflipped");
static_assert(offsetof(FDelMarVerbMessage_Kickflipped, Direction) == 0x000138, "Member 'FDelMarVerbMessage_Kickflipped::Direction' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_LapComplete
// 0x0010 (0x0148 - 0x0138)
struct FDelMarVerbMessage_LapComplete final : public FDelMarVerbMessageBase
{
public:
	double                                        LapCompleteTime;                                   // 0x0138(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         LapCount;                                          // 0x0140(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         LapPlacement;                                      // 0x0141(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_142[0x6];                                      // 0x0142(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_LapComplete) == 0x000008, "Wrong alignment on FDelMarVerbMessage_LapComplete");
static_assert(sizeof(FDelMarVerbMessage_LapComplete) == 0x000148, "Wrong size on FDelMarVerbMessage_LapComplete");
static_assert(offsetof(FDelMarVerbMessage_LapComplete, LapCompleteTime) == 0x000138, "Member 'FDelMarVerbMessage_LapComplete::LapCompleteTime' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_LapComplete, LapCount) == 0x000140, "Member 'FDelMarVerbMessage_LapComplete::LapCount' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_LapComplete, LapPlacement) == 0x000141, "Member 'FDelMarVerbMessage_LapComplete::LapPlacement' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_PlayedDelMarExperience
// 0x0000 (0x0138 - 0x0138)
struct FDelMarVerbMessage_PlayedDelMarExperience final : public FDelMarVerbMessageBase
{
};
static_assert(alignof(FDelMarVerbMessage_PlayedDelMarExperience) == 0x000008, "Wrong alignment on FDelMarVerbMessage_PlayedDelMarExperience");
static_assert(sizeof(FDelMarVerbMessage_PlayedDelMarExperience) == 0x000138, "Wrong size on FDelMarVerbMessage_PlayedDelMarExperience");

// ScriptStruct DelMarCore.DelMarVerbMessage_RankAchieved
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_RankAchieved final : public FDelMarVerbMessageBase
{
public:
	int32                                         RankAchieved;                                      // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_RankAchieved) == 0x000008, "Wrong alignment on FDelMarVerbMessage_RankAchieved");
static_assert(sizeof(FDelMarVerbMessage_RankAchieved) == 0x000140, "Wrong size on FDelMarVerbMessage_RankAchieved");
static_assert(offsetof(FDelMarVerbMessage_RankAchieved, RankAchieved) == 0x000138, "Member 'FDelMarVerbMessage_RankAchieved::RankAchieved' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_RunCompleteTest
// 0x0018 (0x0150 - 0x0138)
struct FDelMarVerbMessage_RunCompleteTest final : public FDelMarVerbMessageBase
{
public:
	double                                        FinishTime;                                        // 0x0138(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         FinalPlacement;                                    // 0x0140(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDelMarJellyHazardProcessorInfo               JellyHazardInfo;                                   // 0x0144(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDelMarDemolishedProcessorInfo                DemolishedInfo;                                    // 0x0148(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_RunCompleteTest) == 0x000008, "Wrong alignment on FDelMarVerbMessage_RunCompleteTest");
static_assert(sizeof(FDelMarVerbMessage_RunCompleteTest) == 0x000150, "Wrong size on FDelMarVerbMessage_RunCompleteTest");
static_assert(offsetof(FDelMarVerbMessage_RunCompleteTest, FinishTime) == 0x000138, "Member 'FDelMarVerbMessage_RunCompleteTest::FinishTime' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RunCompleteTest, FinalPlacement) == 0x000140, "Member 'FDelMarVerbMessage_RunCompleteTest::FinalPlacement' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RunCompleteTest, JellyHazardInfo) == 0x000144, "Member 'FDelMarVerbMessage_RunCompleteTest::JellyHazardInfo' has a wrong offset!");
static_assert(offsetof(FDelMarVerbMessage_RunCompleteTest, DemolishedInfo) == 0x000148, "Member 'FDelMarVerbMessage_RunCompleteTest::DemolishedInfo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_UnderthrustDeactivated
// 0x0008 (0x0140 - 0x0138)
struct FDelMarVerbMessage_UnderthrustDeactivated final : public FDelMarVerbMessageBase
{
public:
	float                                         PercentUsed;                                       // 0x0138(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVerbMessage_UnderthrustDeactivated) == 0x000008, "Wrong alignment on FDelMarVerbMessage_UnderthrustDeactivated");
static_assert(sizeof(FDelMarVerbMessage_UnderthrustDeactivated) == 0x000140, "Wrong size on FDelMarVerbMessage_UnderthrustDeactivated");
static_assert(offsetof(FDelMarVerbMessage_UnderthrustDeactivated, PercentUsed) == 0x000138, "Member 'FDelMarVerbMessage_UnderthrustDeactivated::PercentUsed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVerbMessage_VehicleJumped
// 0x0000 (0x0138 - 0x0138)
struct FDelMarVerbMessage_VehicleJumped final : public FDelMarVerbMessageBase
{
};
static_assert(alignof(FDelMarVerbMessage_VehicleJumped) == 0x000008, "Wrong alignment on FDelMarVerbMessage_VehicleJumped");
static_assert(sizeof(FDelMarVerbMessage_VehicleJumped) == 0x000138, "Wrong size on FDelMarVerbMessage_VehicleJumped");

// ScriptStruct DelMarCore.DelMarRankedInfo
// 0x0018 (0x0018 - 0x0000)
struct FDelMarRankedInfo final
{
public:
	class FString                                 RankType;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentRank;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarRankedInfo) == 0x000008, "Wrong alignment on FDelMarRankedInfo");
static_assert(sizeof(FDelMarRankedInfo) == 0x000018, "Wrong size on FDelMarRankedInfo");
static_assert(offsetof(FDelMarRankedInfo, RankType) == 0x000000, "Member 'FDelMarRankedInfo::RankType' has a wrong offset!");
static_assert(offsetof(FDelMarRankedInfo, CurrentRank) == 0x000010, "Member 'FDelMarRankedInfo::CurrentRank' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarTerrainData
// 0x0018 (0x0018 - 0x0000)
struct FDelMarTerrainData final
{
public:
	float                                         MaxForwardSpeedPercentage;                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationMultiplier;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecelerationMultiplier;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteerMultiplier;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlipMultiplier;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSpeedPenalty;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarTerrainData) == 0x000004, "Wrong alignment on FDelMarTerrainData");
static_assert(sizeof(FDelMarTerrainData) == 0x000018, "Wrong size on FDelMarTerrainData");
static_assert(offsetof(FDelMarTerrainData, MaxForwardSpeedPercentage) == 0x000000, "Member 'FDelMarTerrainData::MaxForwardSpeedPercentage' has a wrong offset!");
static_assert(offsetof(FDelMarTerrainData, AccelerationMultiplier) == 0x000004, "Member 'FDelMarTerrainData::AccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(FDelMarTerrainData, DecelerationMultiplier) == 0x000008, "Member 'FDelMarTerrainData::DecelerationMultiplier' has a wrong offset!");
static_assert(offsetof(FDelMarTerrainData, SteerMultiplier) == 0x00000C, "Member 'FDelMarTerrainData::SteerMultiplier' has a wrong offset!");
static_assert(offsetof(FDelMarTerrainData, SlipMultiplier) == 0x000010, "Member 'FDelMarTerrainData::SlipMultiplier' has a wrong offset!");
static_assert(offsetof(FDelMarTerrainData, TargetSpeedPenalty) == 0x000014, "Member 'FDelMarTerrainData::TargetSpeedPenalty' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarEliminationMMRCountPair
// 0x0008 (0x0008 - 0x0000)
struct FDelMarEliminationMMRCountPair final
{
public:
	int32                                         MaxMmr;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayersToEliminate;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarEliminationMMRCountPair) == 0x000004, "Wrong alignment on FDelMarEliminationMMRCountPair");
static_assert(sizeof(FDelMarEliminationMMRCountPair) == 0x000008, "Wrong size on FDelMarEliminationMMRCountPair");
static_assert(offsetof(FDelMarEliminationMMRCountPair, MaxMmr) == 0x000000, "Member 'FDelMarEliminationMMRCountPair::MaxMmr' has a wrong offset!");
static_assert(offsetof(FDelMarEliminationMMRCountPair, PlayersToEliminate) == 0x000004, "Member 'FDelMarEliminationMMRCountPair::PlayersToEliminate' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarReplicatedLoadout
// 0x0010 (0x0010 - 0x0000)
struct FDelMarReplicatedLoadout final
{
public:
	TArray<class UDelMarCosmeticItemDefinition*>  Items;                                             // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarReplicatedLoadout) == 0x000008, "Wrong alignment on FDelMarReplicatedLoadout");
static_assert(sizeof(FDelMarReplicatedLoadout) == 0x000010, "Wrong size on FDelMarReplicatedLoadout");
static_assert(offsetof(FDelMarReplicatedLoadout, Items) == 0x000000, "Member 'FDelMarReplicatedLoadout::Items' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarLeaderboardConfig
// 0x0020 (0x0020 - 0x0000)
struct FDelMarLeaderboardConfig final
{
public:
	class FString                                 EventId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WindowId;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarLeaderboardConfig) == 0x000008, "Wrong alignment on FDelMarLeaderboardConfig");
static_assert(sizeof(FDelMarLeaderboardConfig) == 0x000020, "Wrong size on FDelMarLeaderboardConfig");
static_assert(offsetof(FDelMarLeaderboardConfig, EventId) == 0x000000, "Member 'FDelMarLeaderboardConfig::EventId' has a wrong offset!");
static_assert(offsetof(FDelMarLeaderboardConfig, WindowId) == 0x000010, "Member 'FDelMarLeaderboardConfig::WindowId' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarNetworkInputPacket
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDelMarNetworkInputPacket final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarNetworkInputPacket) == 0x000008, "Wrong alignment on FDelMarNetworkInputPacket");
static_assert(sizeof(FDelMarNetworkInputPacket) == 0x000018, "Wrong size on FDelMarNetworkInputPacket");

// ScriptStruct DelMarCore.DelMarMapStatus
// 0x0010 (0x0010 - 0x0000)
struct FDelMarMapStatus final
{
public:
	class UDelMarLevelDataAsset*                  MapAsset;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenPlayed;                                    // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarMapStatus) == 0x000008, "Wrong alignment on FDelMarMapStatus");
static_assert(sizeof(FDelMarMapStatus) == 0x000010, "Wrong size on FDelMarMapStatus");
static_assert(offsetof(FDelMarMapStatus, MapAsset) == 0x000000, "Member 'FDelMarMapStatus::MapAsset' has a wrong offset!");
static_assert(offsetof(FDelMarMapStatus, bHasBeenPlayed) == 0x000008, "Member 'FDelMarMapStatus::bHasBeenPlayed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarMapSet
// 0x0018 (0x0018 - 0x0000)
struct FDelMarMapSet final
{
public:
	bool                                          bShouldConsiderValid;                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayLevelsRandomly;                               // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRepeat;                                     // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDelMarMapStatus>               Levels;                                            // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarMapSet) == 0x000008, "Wrong alignment on FDelMarMapSet");
static_assert(sizeof(FDelMarMapSet) == 0x000018, "Wrong size on FDelMarMapSet");
static_assert(offsetof(FDelMarMapSet, bShouldConsiderValid) == 0x000000, "Member 'FDelMarMapSet::bShouldConsiderValid' has a wrong offset!");
static_assert(offsetof(FDelMarMapSet, bPlayLevelsRandomly) == 0x000001, "Member 'FDelMarMapSet::bPlayLevelsRandomly' has a wrong offset!");
static_assert(offsetof(FDelMarMapSet, bShouldRepeat) == 0x000002, "Member 'FDelMarMapSet::bShouldRepeat' has a wrong offset!");
static_assert(offsetof(FDelMarMapSet, Levels) == 0x000008, "Member 'FDelMarMapSet::Levels' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarDeathRaceConfig
// 0x0018 (0x0018 - 0x0000)
struct FDelMarDeathRaceConfig final
{
public:
	TArray<int32>                                 PlacementPointsMap;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ScoreThresholdToEndMatch;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarDeathRaceConfig) == 0x000008, "Wrong alignment on FDelMarDeathRaceConfig");
static_assert(sizeof(FDelMarDeathRaceConfig) == 0x000018, "Wrong size on FDelMarDeathRaceConfig");
static_assert(offsetof(FDelMarDeathRaceConfig, PlacementPointsMap) == 0x000000, "Member 'FDelMarDeathRaceConfig::PlacementPointsMap' has a wrong offset!");
static_assert(offsetof(FDelMarDeathRaceConfig, ScoreThresholdToEndMatch) == 0x000010, "Member 'FDelMarDeathRaceConfig::ScoreThresholdToEndMatch' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarPositionValue
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDelMarPositionValue final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarPositionValue) == 0x000008, "Wrong alignment on FDelMarPositionValue");
static_assert(sizeof(FDelMarPositionValue) == 0x000010, "Wrong size on FDelMarPositionValue");

// ScriptStruct DelMarCore.DelMarVehicleRuntimeConfig
// 0x0014 (0x0014 - 0x0000)
struct FDelMarVehicleRuntimeConfig final
{
public:
	bool                                          bCollisionDemosEnabled;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDemolishActionEnabled;                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RequiredDemolishActionDuration;                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleDisablesVehicleCollision;                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsToSetIdle;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDelMarVehicleCollisionOverrideSetting        VehicleCollisionsGlobalOverride;                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleRuntimeConfig) == 0x000004, "Wrong alignment on FDelMarVehicleRuntimeConfig");
static_assert(sizeof(FDelMarVehicleRuntimeConfig) == 0x000014, "Wrong size on FDelMarVehicleRuntimeConfig");
static_assert(offsetof(FDelMarVehicleRuntimeConfig, bCollisionDemosEnabled) == 0x000000, "Member 'FDelMarVehicleRuntimeConfig::bCollisionDemosEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRuntimeConfig, bDemolishActionEnabled) == 0x000001, "Member 'FDelMarVehicleRuntimeConfig::bDemolishActionEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRuntimeConfig, RequiredDemolishActionDuration) == 0x000004, "Member 'FDelMarVehicleRuntimeConfig::RequiredDemolishActionDuration' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRuntimeConfig, bIdleDisablesVehicleCollision) == 0x000008, "Member 'FDelMarVehicleRuntimeConfig::bIdleDisablesVehicleCollision' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRuntimeConfig, SecondsToSetIdle) == 0x00000C, "Member 'FDelMarVehicleRuntimeConfig::SecondsToSetIdle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRuntimeConfig, VehicleCollisionsGlobalOverride) == 0x000010, "Member 'FDelMarVehicleRuntimeConfig::VehicleCollisionsGlobalOverride' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarRespawnConfig
// 0x0010 (0x0010 - 0x0000)
struct FDelMarRespawnConfig final
{
public:
	EDelMarRaceSpawnMode                          SpawnMode;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTracesToDetermineRespawn;                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespawnInvulnerabilityEnabled;                    // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnInvulnerabilitySeconds;                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespawnCollisionProtectionEnabled;                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnCollisionProtectionSeconds;                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarRespawnConfig) == 0x000004, "Wrong alignment on FDelMarRespawnConfig");
static_assert(sizeof(FDelMarRespawnConfig) == 0x000010, "Wrong size on FDelMarRespawnConfig");
static_assert(offsetof(FDelMarRespawnConfig, SpawnMode) == 0x000000, "Member 'FDelMarRespawnConfig::SpawnMode' has a wrong offset!");
static_assert(offsetof(FDelMarRespawnConfig, bUseTracesToDetermineRespawn) == 0x000001, "Member 'FDelMarRespawnConfig::bUseTracesToDetermineRespawn' has a wrong offset!");
static_assert(offsetof(FDelMarRespawnConfig, bRespawnInvulnerabilityEnabled) == 0x000002, "Member 'FDelMarRespawnConfig::bRespawnInvulnerabilityEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarRespawnConfig, RespawnInvulnerabilitySeconds) == 0x000004, "Member 'FDelMarRespawnConfig::RespawnInvulnerabilitySeconds' has a wrong offset!");
static_assert(offsetof(FDelMarRespawnConfig, bRespawnCollisionProtectionEnabled) == 0x000008, "Member 'FDelMarRespawnConfig::bRespawnCollisionProtectionEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarRespawnConfig, RespawnCollisionProtectionSeconds) == 0x00000C, "Member 'FDelMarRespawnConfig::RespawnCollisionProtectionSeconds' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarMatchmakingConfig
// 0x0014 (0x0014 - 0x0000)
struct FDelMarMatchmakingConfig final
{
public:
	float                                         MaxLoadWaitSeconds;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadWaitBufferSeconds;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchStartDelaySeconds;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchInProgressBackFillEnabled;                   // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSecondsRemainingForBackfill;                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarMatchmakingConfig) == 0x000004, "Wrong alignment on FDelMarMatchmakingConfig");
static_assert(sizeof(FDelMarMatchmakingConfig) == 0x000014, "Wrong size on FDelMarMatchmakingConfig");
static_assert(offsetof(FDelMarMatchmakingConfig, MaxLoadWaitSeconds) == 0x000000, "Member 'FDelMarMatchmakingConfig::MaxLoadWaitSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarMatchmakingConfig, LoadWaitBufferSeconds) == 0x000004, "Member 'FDelMarMatchmakingConfig::LoadWaitBufferSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarMatchmakingConfig, MatchStartDelaySeconds) == 0x000008, "Member 'FDelMarMatchmakingConfig::MatchStartDelaySeconds' has a wrong offset!");
static_assert(offsetof(FDelMarMatchmakingConfig, bMatchInProgressBackFillEnabled) == 0x00000C, "Member 'FDelMarMatchmakingConfig::bMatchInProgressBackFillEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarMatchmakingConfig, MinSecondsRemainingForBackfill) == 0x000010, "Member 'FDelMarMatchmakingConfig::MinSecondsRemainingForBackfill' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarStartlineConfig
// 0x0028 (0x0028 - 0x0000)
struct FDelMarStartlineConfig final
{
public:
	bool                                          bEnableDynamicStartline;                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialCountdownDelayTime;                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequestCountdownDelayTime;                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultIntervalSeconds;                            // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDelMarRandomRange>             IntervalRanges;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CountdownIntervalNum;                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarStartlineConfig) == 0x000008, "Wrong alignment on FDelMarStartlineConfig");
static_assert(sizeof(FDelMarStartlineConfig) == 0x000028, "Wrong size on FDelMarStartlineConfig");
static_assert(offsetof(FDelMarStartlineConfig, bEnableDynamicStartline) == 0x000000, "Member 'FDelMarStartlineConfig::bEnableDynamicStartline' has a wrong offset!");
static_assert(offsetof(FDelMarStartlineConfig, InitialCountdownDelayTime) == 0x000004, "Member 'FDelMarStartlineConfig::InitialCountdownDelayTime' has a wrong offset!");
static_assert(offsetof(FDelMarStartlineConfig, RequestCountdownDelayTime) == 0x000008, "Member 'FDelMarStartlineConfig::RequestCountdownDelayTime' has a wrong offset!");
static_assert(offsetof(FDelMarStartlineConfig, DefaultIntervalSeconds) == 0x00000C, "Member 'FDelMarStartlineConfig::DefaultIntervalSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarStartlineConfig, IntervalRanges) == 0x000010, "Member 'FDelMarStartlineConfig::IntervalRanges' has a wrong offset!");
static_assert(offsetof(FDelMarStartlineConfig, CountdownIntervalNum) == 0x000020, "Member 'FDelMarStartlineConfig::CountdownIntervalNum' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarStateMachineConfig
// 0x0010 (0x0010 - 0x0000)
struct FDelMarStateMachineConfig final
{
public:
	TArray<struct FDelMarStateOverride>           StateOverrides;                                    // 0x0000(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarStateMachineConfig) == 0x000008, "Wrong alignment on FDelMarStateMachineConfig");
static_assert(sizeof(FDelMarStateMachineConfig) == 0x000010, "Wrong size on FDelMarStateMachineConfig");
static_assert(offsetof(FDelMarStateMachineConfig, StateOverrides) == 0x000000, "Member 'FDelMarStateMachineConfig::StateOverrides' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarThrottledValue
// 0x0008 (0x0008 - 0x0000)
struct FDelMarThrottledValue final
{
public:
	float                                         RiseRate;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallRate;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarThrottledValue) == 0x000004, "Wrong alignment on FDelMarThrottledValue");
static_assert(sizeof(FDelMarThrottledValue) == 0x000008, "Wrong size on FDelMarThrottledValue");
static_assert(offsetof(FDelMarThrottledValue, RiseRate) == 0x000000, "Member 'FDelMarThrottledValue::RiseRate' has a wrong offset!");
static_assert(offsetof(FDelMarThrottledValue, FallRate) == 0x000004, "Member 'FDelMarThrottledValue::FallRate' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarTurboBonusZone
// 0x0008 (0x0008 - 0x0000)
struct FDelMarTurboBonusZone final
{
public:
	float                                         ZoneStartTime;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneEndTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarTurboBonusZone) == 0x000004, "Wrong alignment on FDelMarTurboBonusZone");
static_assert(sizeof(FDelMarTurboBonusZone) == 0x000008, "Wrong size on FDelMarTurboBonusZone");
static_assert(offsetof(FDelMarTurboBonusZone, ZoneStartTime) == 0x000000, "Member 'FDelMarTurboBonusZone::ZoneStartTime' has a wrong offset!");
static_assert(offsetof(FDelMarTurboBonusZone, ZoneEndTime) == 0x000004, "Member 'FDelMarTurboBonusZone::ZoneEndTime' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleRigidBodyConfig
// 0x0040 (0x0040 - 0x0000)
struct FDelMarVehicleRigidBodyConfig final
{
public:
	bool                                          bApplyGlobalBodySettings;                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearDamping;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleMass;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotifyRigidBodyCollisions;                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothEdgeCollisionsEnabled;                      // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCCD;                                           // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CenterOfMassOffset;                                // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuspensionIgnoresBodyCollision;                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLinearSpeed;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularSpeed;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleRigidBodyConfig) == 0x000008, "Wrong alignment on FDelMarVehicleRigidBodyConfig");
static_assert(sizeof(FDelMarVehicleRigidBodyConfig) == 0x000040, "Wrong size on FDelMarVehicleRigidBodyConfig");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, bApplyGlobalBodySettings) == 0x000000, "Member 'FDelMarVehicleRigidBodyConfig::bApplyGlobalBodySettings' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, LinearDamping) == 0x000004, "Member 'FDelMarVehicleRigidBodyConfig::LinearDamping' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, AngularDamping) == 0x000008, "Member 'FDelMarVehicleRigidBodyConfig::AngularDamping' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, VehicleMass) == 0x00000C, "Member 'FDelMarVehicleRigidBodyConfig::VehicleMass' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, bNotifyRigidBodyCollisions) == 0x000010, "Member 'FDelMarVehicleRigidBodyConfig::bNotifyRigidBodyCollisions' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, bSmoothEdgeCollisionsEnabled) == 0x000011, "Member 'FDelMarVehicleRigidBodyConfig::bSmoothEdgeCollisionsEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, bUseCCD) == 0x000012, "Member 'FDelMarVehicleRigidBodyConfig::bUseCCD' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, CenterOfMassOffset) == 0x000018, "Member 'FDelMarVehicleRigidBodyConfig::CenterOfMassOffset' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, bSuspensionIgnoresBodyCollision) == 0x000030, "Member 'FDelMarVehicleRigidBodyConfig::bSuspensionIgnoresBodyCollision' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, MaxLinearSpeed) == 0x000034, "Member 'FDelMarVehicleRigidBodyConfig::MaxLinearSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleRigidBodyConfig, MaxAngularSpeed) == 0x000038, "Member 'FDelMarVehicleRigidBodyConfig::MaxAngularSpeed' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleCollisionConfig
// 0x0218 (0x0218 - 0x0000)
struct FDelMarVehicleCollisionConfig final
{
public:
	float                                         MinWallAngleDegrees;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenSpeedLossHits;                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedForTargetSpeedReduction;                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveBumpTime;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     SpeedReductionPercentageCurve;                     // 0x0010(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     AerialSpeedReductionPercentageCurve;               // 0x00A0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     WallTargetRedirectAngleDegreesCurve;               // 0x0130(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         WallTargetRedirectPercent;                         // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallTargetRedirectDriftPercent;                    // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallDriftHeadOnThresholdDegrees;                   // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallHeadOnDriftRedirectAngleDegrees;               // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallTargetRedirectHeadOnDriftPercent;              // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriftTargetAngleDegrees;                           // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrivingTargetAngleDegrees;                         // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGroundedDemolitionSpeed;                        // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAerialDemolitionSpeed;                          // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGroundedDemolitionAngleDegrees;                 // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAerialDemolitionAngleDegrees;                   // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParallelCollisionThresholdDegrees;                 // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadOnCollisionThresholdDegrees;                   // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BumperToBumperThresholdDegrees;                    // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BumpToBumperSpeedPenalty;                          // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactNormalToVehicleRightThresholdDegrees;       // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackDirectionThresholdDegrees;                    // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackTraceLength;                                  // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TrackTraceChannel;                                 // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCounterWorldHitImpulses;                          // 0x0209(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCounterVehicleHitImpulses;                        // 0x020A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B[0x1];                                      // 0x020B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VehicleHitImpulseScalar;                           // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleHitDriftImpulseScalar;                      // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleCollisionConfig) == 0x000008, "Wrong alignment on FDelMarVehicleCollisionConfig");
static_assert(sizeof(FDelMarVehicleCollisionConfig) == 0x000218, "Wrong size on FDelMarVehicleCollisionConfig");
static_assert(offsetof(FDelMarVehicleCollisionConfig, MinWallAngleDegrees) == 0x000000, "Member 'FDelMarVehicleCollisionConfig::MinWallAngleDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, MinTimeBetweenSpeedLossHits) == 0x000004, "Member 'FDelMarVehicleCollisionConfig::MinTimeBetweenSpeedLossHits' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, MinSpeedForTargetSpeedReduction) == 0x000008, "Member 'FDelMarVehicleCollisionConfig::MinSpeedForTargetSpeedReduction' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, ActiveBumpTime) == 0x00000C, "Member 'FDelMarVehicleCollisionConfig::ActiveBumpTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, SpeedReductionPercentageCurve) == 0x000010, "Member 'FDelMarVehicleCollisionConfig::SpeedReductionPercentageCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, AerialSpeedReductionPercentageCurve) == 0x0000A0, "Member 'FDelMarVehicleCollisionConfig::AerialSpeedReductionPercentageCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, WallTargetRedirectAngleDegreesCurve) == 0x000130, "Member 'FDelMarVehicleCollisionConfig::WallTargetRedirectAngleDegreesCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, WallTargetRedirectPercent) == 0x0001C0, "Member 'FDelMarVehicleCollisionConfig::WallTargetRedirectPercent' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, WallTargetRedirectDriftPercent) == 0x0001C4, "Member 'FDelMarVehicleCollisionConfig::WallTargetRedirectDriftPercent' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, WallDriftHeadOnThresholdDegrees) == 0x0001C8, "Member 'FDelMarVehicleCollisionConfig::WallDriftHeadOnThresholdDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, WallHeadOnDriftRedirectAngleDegrees) == 0x0001CC, "Member 'FDelMarVehicleCollisionConfig::WallHeadOnDriftRedirectAngleDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, WallTargetRedirectHeadOnDriftPercent) == 0x0001D0, "Member 'FDelMarVehicleCollisionConfig::WallTargetRedirectHeadOnDriftPercent' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, DriftTargetAngleDegrees) == 0x0001D4, "Member 'FDelMarVehicleCollisionConfig::DriftTargetAngleDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, DrivingTargetAngleDegrees) == 0x0001D8, "Member 'FDelMarVehicleCollisionConfig::DrivingTargetAngleDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, MinGroundedDemolitionSpeed) == 0x0001DC, "Member 'FDelMarVehicleCollisionConfig::MinGroundedDemolitionSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, MinAerialDemolitionSpeed) == 0x0001E0, "Member 'FDelMarVehicleCollisionConfig::MinAerialDemolitionSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, MaxGroundedDemolitionAngleDegrees) == 0x0001E4, "Member 'FDelMarVehicleCollisionConfig::MaxGroundedDemolitionAngleDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, MaxAerialDemolitionAngleDegrees) == 0x0001E8, "Member 'FDelMarVehicleCollisionConfig::MaxAerialDemolitionAngleDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, ParallelCollisionThresholdDegrees) == 0x0001EC, "Member 'FDelMarVehicleCollisionConfig::ParallelCollisionThresholdDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, HeadOnCollisionThresholdDegrees) == 0x0001F0, "Member 'FDelMarVehicleCollisionConfig::HeadOnCollisionThresholdDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, BumperToBumperThresholdDegrees) == 0x0001F4, "Member 'FDelMarVehicleCollisionConfig::BumperToBumperThresholdDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, BumpToBumperSpeedPenalty) == 0x0001F8, "Member 'FDelMarVehicleCollisionConfig::BumpToBumperSpeedPenalty' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, ContactNormalToVehicleRightThresholdDegrees) == 0x0001FC, "Member 'FDelMarVehicleCollisionConfig::ContactNormalToVehicleRightThresholdDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, TrackDirectionThresholdDegrees) == 0x000200, "Member 'FDelMarVehicleCollisionConfig::TrackDirectionThresholdDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, TrackTraceLength) == 0x000204, "Member 'FDelMarVehicleCollisionConfig::TrackTraceLength' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, TrackTraceChannel) == 0x000208, "Member 'FDelMarVehicleCollisionConfig::TrackTraceChannel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, bCounterWorldHitImpulses) == 0x000209, "Member 'FDelMarVehicleCollisionConfig::bCounterWorldHitImpulses' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, bCounterVehicleHitImpulses) == 0x00020A, "Member 'FDelMarVehicleCollisionConfig::bCounterVehicleHitImpulses' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, VehicleHitImpulseScalar) == 0x00020C, "Member 'FDelMarVehicleCollisionConfig::VehicleHitImpulseScalar' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleCollisionConfig, VehicleHitDriftImpulseScalar) == 0x000210, "Member 'FDelMarVehicleCollisionConfig::VehicleHitDriftImpulseScalar' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleDriftBoostConfig
// 0x01D8 (0x01D8 - 0x0000)
struct FDelMarVehicleDriftBoostConfig final
{
public:
	float                                         MaxDriftBoostRatio;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBonusSpeed;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     BonusSpeedPercentageCurve;                         // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         WaitingPeriodSeconds;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDriftBoostSeconds;                              // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     PotentialDriftBoostPercentageCurve;                // 0x00A0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MaxNumActiveBonusSpeedSeconds;                     // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarScaledCurve                     DriftBoostDurationCurve;                           // 0x0138(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         BonusSpeedDecaySeconds;                            // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PotentialRemovalRate;                              // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnforceThrottleForDriftBoost;                     // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueuedBoostImpulseScalar;                          // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleDriftBoostConfig) == 0x000008, "Wrong alignment on FDelMarVehicleDriftBoostConfig");
static_assert(sizeof(FDelMarVehicleDriftBoostConfig) == 0x0001D8, "Wrong size on FDelMarVehicleDriftBoostConfig");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, MaxDriftBoostRatio) == 0x000000, "Member 'FDelMarVehicleDriftBoostConfig::MaxDriftBoostRatio' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, MaxBonusSpeed) == 0x000004, "Member 'FDelMarVehicleDriftBoostConfig::MaxBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, BonusSpeedPercentageCurve) == 0x000008, "Member 'FDelMarVehicleDriftBoostConfig::BonusSpeedPercentageCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, WaitingPeriodSeconds) == 0x000098, "Member 'FDelMarVehicleDriftBoostConfig::WaitingPeriodSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, MaxDriftBoostSeconds) == 0x00009C, "Member 'FDelMarVehicleDriftBoostConfig::MaxDriftBoostSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, PotentialDriftBoostPercentageCurve) == 0x0000A0, "Member 'FDelMarVehicleDriftBoostConfig::PotentialDriftBoostPercentageCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, MaxNumActiveBonusSpeedSeconds) == 0x000130, "Member 'FDelMarVehicleDriftBoostConfig::MaxNumActiveBonusSpeedSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, DriftBoostDurationCurve) == 0x000138, "Member 'FDelMarVehicleDriftBoostConfig::DriftBoostDurationCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, BonusSpeedDecaySeconds) == 0x0001C8, "Member 'FDelMarVehicleDriftBoostConfig::BonusSpeedDecaySeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, PotentialRemovalRate) == 0x0001CC, "Member 'FDelMarVehicleDriftBoostConfig::PotentialRemovalRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, bEnforceThrottleForDriftBoost) == 0x0001D0, "Member 'FDelMarVehicleDriftBoostConfig::bEnforceThrottleForDriftBoost' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleDriftBoostConfig, QueuedBoostImpulseScalar) == 0x0001D4, "Member 'FDelMarVehicleDriftBoostConfig::QueuedBoostImpulseScalar' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleOversteerConfig
// 0x0138 (0x0138 - 0x0000)
struct FDelMarVehicleOversteerConfig final
{
public:
	float                                         MinInput;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccumulatedSteer;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     CappedAccumulatedSteerCurve;                       // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     AccumulatedSteerRateCurve;                         // 0x0098(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         AccumulatedSteerDecayRate;                         // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriftImpulseForce;                                 // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeed;                                          // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDecayAccumulatedSteer;                            // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAccumulatedSteerOnDrift;                     // 0x0135(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136[0x2];                                      // 0x0136(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleOversteerConfig) == 0x000008, "Wrong alignment on FDelMarVehicleOversteerConfig");
static_assert(sizeof(FDelMarVehicleOversteerConfig) == 0x000138, "Wrong size on FDelMarVehicleOversteerConfig");
static_assert(offsetof(FDelMarVehicleOversteerConfig, MinInput) == 0x000000, "Member 'FDelMarVehicleOversteerConfig::MinInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleOversteerConfig, MaxAccumulatedSteer) == 0x000004, "Member 'FDelMarVehicleOversteerConfig::MaxAccumulatedSteer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleOversteerConfig, CappedAccumulatedSteerCurve) == 0x000008, "Member 'FDelMarVehicleOversteerConfig::CappedAccumulatedSteerCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleOversteerConfig, AccumulatedSteerRateCurve) == 0x000098, "Member 'FDelMarVehicleOversteerConfig::AccumulatedSteerRateCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleOversteerConfig, AccumulatedSteerDecayRate) == 0x000128, "Member 'FDelMarVehicleOversteerConfig::AccumulatedSteerDecayRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleOversteerConfig, DriftImpulseForce) == 0x00012C, "Member 'FDelMarVehicleOversteerConfig::DriftImpulseForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleOversteerConfig, MinSpeed) == 0x000130, "Member 'FDelMarVehicleOversteerConfig::MinSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleOversteerConfig, bDecayAccumulatedSteer) == 0x000134, "Member 'FDelMarVehicleOversteerConfig::bDecayAccumulatedSteer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleOversteerConfig, bClearAccumulatedSteerOnDrift) == 0x000135, "Member 'FDelMarVehicleOversteerConfig::bClearAccumulatedSteerOnDrift' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleTurboConfig
// 0x0070 (0x0070 - 0x0000)
struct FDelMarVehicleTurboConfig final
{
public:
	float                                         MaxActiveTimeSeconds;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownSeconds;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialImpulseForce;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBaseTargetSpeed;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarFloatModifier                   TargetSpeedModifier;                               // 0x0010(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDelMarTurboBonusZone>          BonusZones;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BonusZoneImpulseForce;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusZoneSpeedDecaySeconds;                        // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuccessfulBonusZoneHitSeconds;                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproachingBonusZoneSeconds;                       // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMissingZoneSeconds;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNumCharges;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeRegenRateSeconds;                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaceStartCharges;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LapCompleteCharges;                                // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurboGainedForDriftBoostPotential;                 // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurboGainedPerSecondAtMaxDriftPotential;           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTurboChargesFromDrift;                          // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTerrainInvulnerabilityDuringTurbo;                // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleTurboConfig) == 0x000008, "Wrong alignment on FDelMarVehicleTurboConfig");
static_assert(sizeof(FDelMarVehicleTurboConfig) == 0x000070, "Wrong size on FDelMarVehicleTurboConfig");
static_assert(offsetof(FDelMarVehicleTurboConfig, MaxActiveTimeSeconds) == 0x000000, "Member 'FDelMarVehicleTurboConfig::MaxActiveTimeSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, CooldownSeconds) == 0x000004, "Member 'FDelMarVehicleTurboConfig::CooldownSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, InitialImpulseForce) == 0x000008, "Member 'FDelMarVehicleTurboConfig::InitialImpulseForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, MinBaseTargetSpeed) == 0x00000C, "Member 'FDelMarVehicleTurboConfig::MinBaseTargetSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, TargetSpeedModifier) == 0x000010, "Member 'FDelMarVehicleTurboConfig::TargetSpeedModifier' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, BonusZones) == 0x000028, "Member 'FDelMarVehicleTurboConfig::BonusZones' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, BonusZoneImpulseForce) == 0x000038, "Member 'FDelMarVehicleTurboConfig::BonusZoneImpulseForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, BonusZoneSpeedDecaySeconds) == 0x00003C, "Member 'FDelMarVehicleTurboConfig::BonusZoneSpeedDecaySeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, SuccessfulBonusZoneHitSeconds) == 0x000040, "Member 'FDelMarVehicleTurboConfig::SuccessfulBonusZoneHitSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, ApproachingBonusZoneSeconds) == 0x000044, "Member 'FDelMarVehicleTurboConfig::ApproachingBonusZoneSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, MaxMissingZoneSeconds) == 0x000048, "Member 'FDelMarVehicleTurboConfig::MaxMissingZoneSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, MaxNumCharges) == 0x00004C, "Member 'FDelMarVehicleTurboConfig::MaxNumCharges' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, ChargeRegenRateSeconds) == 0x000050, "Member 'FDelMarVehicleTurboConfig::ChargeRegenRateSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, RaceStartCharges) == 0x000054, "Member 'FDelMarVehicleTurboConfig::RaceStartCharges' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, LapCompleteCharges) == 0x000058, "Member 'FDelMarVehicleTurboConfig::LapCompleteCharges' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, TurboGainedForDriftBoostPotential) == 0x00005C, "Member 'FDelMarVehicleTurboConfig::TurboGainedForDriftBoostPotential' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, TurboGainedPerSecondAtMaxDriftPotential) == 0x000060, "Member 'FDelMarVehicleTurboConfig::TurboGainedPerSecondAtMaxDriftPotential' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, MaxTurboChargesFromDrift) == 0x000064, "Member 'FDelMarVehicleTurboConfig::MaxTurboChargesFromDrift' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleTurboConfig, bTerrainInvulnerabilityDuringTurbo) == 0x000068, "Member 'FDelMarVehicleTurboConfig::bTerrainInvulnerabilityDuringTurbo' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_StartlineBoost
// 0x00A8 (0x00A8 - 0x0000)
struct FDelMarVehicleConfig_StartlineBoost final
{
public:
	float                                         MaxBonusSpeed;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelMarScaledCurve                     PercentageMaxBonusSpeedEarned;                     // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         BoostGainSeconds;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostDurationSeconds;                              // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnforceForwardThrottle;                           // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleConfig_StartlineBoost) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_StartlineBoost");
static_assert(sizeof(FDelMarVehicleConfig_StartlineBoost) == 0x0000A8, "Wrong size on FDelMarVehicleConfig_StartlineBoost");
static_assert(offsetof(FDelMarVehicleConfig_StartlineBoost, MaxBonusSpeed) == 0x000000, "Member 'FDelMarVehicleConfig_StartlineBoost::MaxBonusSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_StartlineBoost, PercentageMaxBonusSpeedEarned) == 0x000008, "Member 'FDelMarVehicleConfig_StartlineBoost::PercentageMaxBonusSpeedEarned' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_StartlineBoost, BoostGainSeconds) == 0x000098, "Member 'FDelMarVehicleConfig_StartlineBoost::BoostGainSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_StartlineBoost, BoostDurationSeconds) == 0x00009C, "Member 'FDelMarVehicleConfig_StartlineBoost::BoostDurationSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_StartlineBoost, bEnforceForwardThrottle) == 0x0000A0, "Member 'FDelMarVehicleConfig_StartlineBoost::bEnforceForwardThrottle' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_Underthrust
// 0x00C8 (0x00C8 - 0x0000)
struct FDelMarVehicleConfig_Underthrust final
{
public:
	float                                         UpwardAccel;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardAccel;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxUpwardSpeed;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForwardSpeed;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndThrustForce;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxThrustSeconds;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardSpeedCap;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedReduction;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedCapSecondsBuffer;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinJumpActiveSecondsBeforeActivating;              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     FallingUpsideDownThrustDampeningPercentage;        // 0x0028(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bVehicleRelativeWithFreestyle;                     // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinUpwardAccel;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralRelativeAccel;                              // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleConfig_Underthrust) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_Underthrust");
static_assert(sizeof(FDelMarVehicleConfig_Underthrust) == 0x0000C8, "Wrong size on FDelMarVehicleConfig_Underthrust");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, UpwardAccel) == 0x000000, "Member 'FDelMarVehicleConfig_Underthrust::UpwardAccel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, ForwardAccel) == 0x000004, "Member 'FDelMarVehicleConfig_Underthrust::ForwardAccel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, MaxUpwardSpeed) == 0x000008, "Member 'FDelMarVehicleConfig_Underthrust::MaxUpwardSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, MaxForwardSpeed) == 0x00000C, "Member 'FDelMarVehicleConfig_Underthrust::MaxForwardSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, EndThrustForce) == 0x000010, "Member 'FDelMarVehicleConfig_Underthrust::EndThrustForce' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, MaxThrustSeconds) == 0x000014, "Member 'FDelMarVehicleConfig_Underthrust::MaxThrustSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, ForwardSpeedCap) == 0x000018, "Member 'FDelMarVehicleConfig_Underthrust::ForwardSpeedCap' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, MaxSpeedReduction) == 0x00001C, "Member 'FDelMarVehicleConfig_Underthrust::MaxSpeedReduction' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, SpeedCapSecondsBuffer) == 0x000020, "Member 'FDelMarVehicleConfig_Underthrust::SpeedCapSecondsBuffer' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, MinJumpActiveSecondsBeforeActivating) == 0x000024, "Member 'FDelMarVehicleConfig_Underthrust::MinJumpActiveSecondsBeforeActivating' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, FallingUpsideDownThrustDampeningPercentage) == 0x000028, "Member 'FDelMarVehicleConfig_Underthrust::FallingUpsideDownThrustDampeningPercentage' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, bVehicleRelativeWithFreestyle) == 0x0000B8, "Member 'FDelMarVehicleConfig_Underthrust::bVehicleRelativeWithFreestyle' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, MinUpwardAccel) == 0x0000BC, "Member 'FDelMarVehicleConfig_Underthrust::MinUpwardAccel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Underthrust, LateralRelativeAccel) == 0x0000C0, "Member 'FDelMarVehicleConfig_Underthrust::LateralRelativeAccel' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_AirFreestyle
// 0x0030 (0x0030 - 0x0000)
struct FDelMarVehicleConfig_AirFreestyle final
{
public:
	struct FVector                                TorqueAccel;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TorqueDamping;                                     // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleConfig_AirFreestyle) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_AirFreestyle");
static_assert(sizeof(FDelMarVehicleConfig_AirFreestyle) == 0x000030, "Wrong size on FDelMarVehicleConfig_AirFreestyle");
static_assert(offsetof(FDelMarVehicleConfig_AirFreestyle, TorqueAccel) == 0x000000, "Member 'FDelMarVehicleConfig_AirFreestyle::TorqueAccel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AirFreestyle, TorqueDamping) == 0x000018, "Member 'FDelMarVehicleConfig_AirFreestyle::TorqueDamping' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_AutoAerialRotation
// 0x00A0 (0x00A0 - 0x0000)
struct FDelMarVehicleConfig_AutoAerialRotation final
{
public:
	struct FVector                                StabilizationDampingFactor;                        // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StabilizationFactor;                               // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRotationThreshold;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpsideDownRollTorque;                              // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpsideDownRollDamping;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRollInput;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteerRollOffsetDegrees;                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchInput;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxUserPitchOffsetDegrees;                         // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralPitchOffsetDegrees;                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnderthrustPitchDegrees;                           // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinThrottleInput;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxUserThrottleOffsetDegrees;                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawTorque;                                         // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxRotationSpeed;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinApproachTargetScalar;                           // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinForwardSpeedForYawRotation;                     // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSteerInputForForwardStateTurning;               // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardStateTurnRate;                              // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandingAssistanceEnabled;                         // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             LandingCollisionChannel;                           // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandingDetectionSeconds;                           // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLandingDetectionDistance;                       // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingSurfaceNormalMaxDegrees;                    // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingRotationAmplifier;                          // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleConfig_AutoAerialRotation) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_AutoAerialRotation");
static_assert(sizeof(FDelMarVehicleConfig_AutoAerialRotation) == 0x0000A0, "Wrong size on FDelMarVehicleConfig_AutoAerialRotation");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, StabilizationDampingFactor) == 0x000000, "Member 'FDelMarVehicleConfig_AutoAerialRotation::StabilizationDampingFactor' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, StabilizationFactor) == 0x000018, "Member 'FDelMarVehicleConfig_AutoAerialRotation::StabilizationFactor' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, IdleRotationThreshold) == 0x000030, "Member 'FDelMarVehicleConfig_AutoAerialRotation::IdleRotationThreshold' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, UpsideDownRollTorque) == 0x000034, "Member 'FDelMarVehicleConfig_AutoAerialRotation::UpsideDownRollTorque' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, UpsideDownRollDamping) == 0x000038, "Member 'FDelMarVehicleConfig_AutoAerialRotation::UpsideDownRollDamping' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MinRollInput) == 0x00003C, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MinRollInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, SteerRollOffsetDegrees) == 0x000040, "Member 'FDelMarVehicleConfig_AutoAerialRotation::SteerRollOffsetDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MinPitchInput) == 0x000044, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MinPitchInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MaxUserPitchOffsetDegrees) == 0x000048, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MaxUserPitchOffsetDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, LateralPitchOffsetDegrees) == 0x00004C, "Member 'FDelMarVehicleConfig_AutoAerialRotation::LateralPitchOffsetDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, UnderthrustPitchDegrees) == 0x000050, "Member 'FDelMarVehicleConfig_AutoAerialRotation::UnderthrustPitchDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MinThrottleInput) == 0x000054, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MinThrottleInput' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MaxUserThrottleOffsetDegrees) == 0x000058, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MaxUserThrottleOffsetDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, YawTorque) == 0x00005C, "Member 'FDelMarVehicleConfig_AutoAerialRotation::YawTorque' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MaxRotationSpeed) == 0x000060, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MaxRotationSpeed' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MinApproachTargetScalar) == 0x000078, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MinApproachTargetScalar' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MinForwardSpeedForYawRotation) == 0x00007C, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MinForwardSpeedForYawRotation' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MinSteerInputForForwardStateTurning) == 0x000080, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MinSteerInputForForwardStateTurning' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, ForwardStateTurnRate) == 0x000084, "Member 'FDelMarVehicleConfig_AutoAerialRotation::ForwardStateTurnRate' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, bLandingAssistanceEnabled) == 0x000088, "Member 'FDelMarVehicleConfig_AutoAerialRotation::bLandingAssistanceEnabled' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, LandingCollisionChannel) == 0x000089, "Member 'FDelMarVehicleConfig_AutoAerialRotation::LandingCollisionChannel' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, LandingDetectionSeconds) == 0x00008C, "Member 'FDelMarVehicleConfig_AutoAerialRotation::LandingDetectionSeconds' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, MinLandingDetectionDistance) == 0x000090, "Member 'FDelMarVehicleConfig_AutoAerialRotation::MinLandingDetectionDistance' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, LandingSurfaceNormalMaxDegrees) == 0x000094, "Member 'FDelMarVehicleConfig_AutoAerialRotation::LandingSurfaceNormalMaxDegrees' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_AutoAerialRotation, LandingRotationAmplifier) == 0x000098, "Member 'FDelMarVehicleConfig_AutoAerialRotation::LandingRotationAmplifier' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_Jump
// 0x0018 (0x0018 - 0x0000)
struct FDelMarVehicleConfig_Jump final
{
public:
	float                                         MinJumpTime;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpVelocity;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardVelocity;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchTorque;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndThrustForce;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleConfig_Jump) == 0x000004, "Wrong alignment on FDelMarVehicleConfig_Jump");
static_assert(sizeof(FDelMarVehicleConfig_Jump) == 0x000018, "Wrong size on FDelMarVehicleConfig_Jump");
static_assert(offsetof(FDelMarVehicleConfig_Jump, MinJumpTime) == 0x000000, "Member 'FDelMarVehicleConfig_Jump::MinJumpTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Jump, MaxJumpTime) == 0x000004, "Member 'FDelMarVehicleConfig_Jump::MaxJumpTime' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Jump, JumpVelocity) == 0x000008, "Member 'FDelMarVehicleConfig_Jump::JumpVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Jump, ForwardVelocity) == 0x00000C, "Member 'FDelMarVehicleConfig_Jump::ForwardVelocity' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Jump, PitchTorque) == 0x000010, "Member 'FDelMarVehicleConfig_Jump::PitchTorque' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Jump, EndThrustForce) == 0x000014, "Member 'FDelMarVehicleConfig_Jump::EndThrustForce' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_Gravity
// 0x001C (0x001C - 0x0000)
struct FDelMarVehicleConfig_Gravity final
{
public:
	float                                         ForceScaleCeiling;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceScaleWall;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceScaleGround;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialGravityForceMultiplier;                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoyoteTimeDuration;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinWheelsForStickySurfaces;                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCounterGravityInKickflipSuctionDirection;         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleConfig_Gravity) == 0x000004, "Wrong alignment on FDelMarVehicleConfig_Gravity");
static_assert(sizeof(FDelMarVehicleConfig_Gravity) == 0x00001C, "Wrong size on FDelMarVehicleConfig_Gravity");
static_assert(offsetof(FDelMarVehicleConfig_Gravity, ForceScaleCeiling) == 0x000000, "Member 'FDelMarVehicleConfig_Gravity::ForceScaleCeiling' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Gravity, ForceScaleWall) == 0x000004, "Member 'FDelMarVehicleConfig_Gravity::ForceScaleWall' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Gravity, ForceScaleGround) == 0x000008, "Member 'FDelMarVehicleConfig_Gravity::ForceScaleGround' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Gravity, AerialGravityForceMultiplier) == 0x00000C, "Member 'FDelMarVehicleConfig_Gravity::AerialGravityForceMultiplier' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Gravity, CoyoteTimeDuration) == 0x000010, "Member 'FDelMarVehicleConfig_Gravity::CoyoteTimeDuration' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Gravity, MinWheelsForStickySurfaces) == 0x000014, "Member 'FDelMarVehicleConfig_Gravity::MinWheelsForStickySurfaces' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Gravity, bCounterGravityInKickflipSuctionDirection) == 0x000018, "Member 'FDelMarVehicleConfig_Gravity::bCounterGravityInKickflipSuctionDirection' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_Reattachment
// 0x00A0 (0x00A0 - 0x0000)
struct FDelMarVehicleConfig_Reattachment final
{
public:
	float                                         SurfaceTraceDistance;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReattachmentForceAmount;                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDelMarScaledCurve                     ReattachmentForceScalarCurve;                      // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ECollisionChannel                             ReattachmentChannel;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarVehicleConfig_Reattachment) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_Reattachment");
static_assert(sizeof(FDelMarVehicleConfig_Reattachment) == 0x0000A0, "Wrong size on FDelMarVehicleConfig_Reattachment");
static_assert(offsetof(FDelMarVehicleConfig_Reattachment, SurfaceTraceDistance) == 0x000000, "Member 'FDelMarVehicleConfig_Reattachment::SurfaceTraceDistance' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Reattachment, ReattachmentForceAmount) == 0x000004, "Member 'FDelMarVehicleConfig_Reattachment::ReattachmentForceAmount' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Reattachment, ReattachmentForceScalarCurve) == 0x000008, "Member 'FDelMarVehicleConfig_Reattachment::ReattachmentForceScalarCurve' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_Reattachment, ReattachmentChannel) == 0x000098, "Member 'FDelMarVehicleConfig_Reattachment::ReattachmentChannel' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarVehicleConfig_WorldBonusSpeed
// 0x0030 (0x0030 - 0x0000)
struct FDelMarVehicleConfig_WorldBonusSpeed final
{
public:
	TArray<struct FDelMarWorldBonusSpeedSourceCap> BonusSpeedSourceCaps;                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaxBonusSpeedPerStack;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStackDuration;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StackCooldown;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             WorldBonusSpeedActors;                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelMarVehicleConfig_WorldBonusSpeed) == 0x000008, "Wrong alignment on FDelMarVehicleConfig_WorldBonusSpeed");
static_assert(sizeof(FDelMarVehicleConfig_WorldBonusSpeed) == 0x000030, "Wrong size on FDelMarVehicleConfig_WorldBonusSpeed");
static_assert(offsetof(FDelMarVehicleConfig_WorldBonusSpeed, BonusSpeedSourceCaps) == 0x000000, "Member 'FDelMarVehicleConfig_WorldBonusSpeed::BonusSpeedSourceCaps' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_WorldBonusSpeed, MaxBonusSpeedPerStack) == 0x000010, "Member 'FDelMarVehicleConfig_WorldBonusSpeed::MaxBonusSpeedPerStack' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_WorldBonusSpeed, MaxStackDuration) == 0x000014, "Member 'FDelMarVehicleConfig_WorldBonusSpeed::MaxStackDuration' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_WorldBonusSpeed, StackCooldown) == 0x000018, "Member 'FDelMarVehicleConfig_WorldBonusSpeed::StackCooldown' has a wrong offset!");
static_assert(offsetof(FDelMarVehicleConfig_WorldBonusSpeed, WorldBonusSpeedActors) == 0x000020, "Member 'FDelMarVehicleConfig_WorldBonusSpeed::WorldBonusSpeedActors' has a wrong offset!");

// ScriptStruct DelMarCore.DelMarDynamicForceFeedbackEffect
// 0x0128 (0x0128 - 0x0000)
struct FDelMarDynamicForceFeedbackEffect final
{
public:
	struct FForceFeedbackChannelDetails           Effect;                                            // 0x0000(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     IntensityAmplifierCurve;                           // 0x0090(0x0088)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelMarDynamicForceFeedbackEffect) == 0x000008, "Wrong alignment on FDelMarDynamicForceFeedbackEffect");
static_assert(sizeof(FDelMarDynamicForceFeedbackEffect) == 0x000128, "Wrong size on FDelMarDynamicForceFeedbackEffect");
static_assert(offsetof(FDelMarDynamicForceFeedbackEffect, Effect) == 0x000000, "Member 'FDelMarDynamicForceFeedbackEffect::Effect' has a wrong offset!");
static_assert(offsetof(FDelMarDynamicForceFeedbackEffect, IntensityAmplifierCurve) == 0x000090, "Member 'FDelMarDynamicForceFeedbackEffect::IntensityAmplifierCurve' has a wrong offset!");

}

