#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ItemizationCoreRuntime

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "VerseGameplayTags_structs.hpp"
#include "ItemizationCoreRuntime_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "McpProfileSys_classes.hpp"


namespace SDK
{

// Class ItemizationCoreRuntime.InventoryDefinition
// 0x0048 (0x0078 - 0x0030)
class UInventoryDefinition : public UDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0030(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint16                                        Slots;                                             // 0x0060(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PickupPriority;                                    // 0x0062(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemRequirements*                      ItemRequirements;                                  // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableItemStacking;                               // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireUniqueItemDefinitionPerStack;              // 0x0071(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryDefinition">();
	}
	static class UInventoryDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryDefinition>();
	}
};
static_assert(alignof(UInventoryDefinition) == 0x000008, "Wrong alignment on UInventoryDefinition");
static_assert(sizeof(UInventoryDefinition) == 0x000078, "Wrong size on UInventoryDefinition");
static_assert(offsetof(UInventoryDefinition, Name_0) == 0x000030, "Member 'UInventoryDefinition::Name_0' has a wrong offset!");
static_assert(offsetof(UInventoryDefinition, Description) == 0x000048, "Member 'UInventoryDefinition::Description' has a wrong offset!");
static_assert(offsetof(UInventoryDefinition, Slots) == 0x000060, "Member 'UInventoryDefinition::Slots' has a wrong offset!");
static_assert(offsetof(UInventoryDefinition, PickupPriority) == 0x000062, "Member 'UInventoryDefinition::PickupPriority' has a wrong offset!");
static_assert(offsetof(UInventoryDefinition, ItemRequirements) == 0x000068, "Member 'UInventoryDefinition::ItemRequirements' has a wrong offset!");
static_assert(offsetof(UInventoryDefinition, bEnableItemStacking) == 0x000070, "Member 'UInventoryDefinition::bEnableItemStacking' has a wrong offset!");
static_assert(offsetof(UInventoryDefinition, bRequireUniqueItemDefinitionPerStack) == 0x000071, "Member 'UInventoryDefinition::bRequireUniqueItemDefinitionPerStack' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemizationWorldSubsystem
// 0x00A8 (0x00D8 - 0x0030)
class UItemizationWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemizationPersistenceManagerBase*     ItemizationPersistenceManager;                     // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInventoryComponentDestroyed(const class UInventoryComponent* InventoryComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemizationWorldSubsystem">();
	}
	static class UItemizationWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemizationWorldSubsystem>();
	}
};
static_assert(alignof(UItemizationWorldSubsystem) == 0x000008, "Wrong alignment on UItemizationWorldSubsystem");
static_assert(sizeof(UItemizationWorldSubsystem) == 0x0000D8, "Wrong size on UItemizationWorldSubsystem");
static_assert(offsetof(UItemizationWorldSubsystem, ItemizationPersistenceManager) == 0x0000D0, "Member 'UItemizationWorldSubsystem::ItemizationPersistenceManager' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponentBase
// 0x0000 (0x0028 - 0x0028)
class UItemComponentBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentBase">();
	}
	static class UItemComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentBase>();
	}
};
static_assert(alignof(UItemComponentBase) == 0x000008, "Wrong alignment on UItemComponentBase");
static_assert(sizeof(UItemComponentBase) == 0x000028, "Wrong size on UItemComponentBase");

// Class ItemizationCoreRuntime.ItemComponent_Pickup
// 0x0040 (0x0068 - 0x0028)
class UItemComponent_Pickup final : public UItemComponentBase
{
public:
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0028(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0048(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponent_Pickup">();
	}
	static class UItemComponent_Pickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponent_Pickup>();
	}
};
static_assert(alignof(UItemComponent_Pickup) == 0x000008, "Wrong alignment on UItemComponent_Pickup");
static_assert(sizeof(UItemComponent_Pickup) == 0x000068, "Wrong size on UItemComponent_Pickup");
static_assert(offsetof(UItemComponent_Pickup, SkeletalMesh) == 0x000028, "Member 'UItemComponent_Pickup::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UItemComponent_Pickup, StaticMesh) == 0x000048, "Member 'UItemComponent_Pickup::StaticMesh' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemPickup
// 0x0028 (0x02B8 - 0x0290)
class AItemPickup : public AActor
{
public:
	class UCapsuleComponent*                      TouchCapsule;                                      // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemDefinitionBase*                    ItemDefinition;                                    // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         Amount;                                            // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_ItemDefinition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPickup">();
	}
	static class AItemPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemPickup>();
	}
};
static_assert(alignof(AItemPickup) == 0x000008, "Wrong alignment on AItemPickup");
static_assert(sizeof(AItemPickup) == 0x0002B8, "Wrong size on AItemPickup");
static_assert(offsetof(AItemPickup, TouchCapsule) == 0x000290, "Member 'AItemPickup::TouchCapsule' has a wrong offset!");
static_assert(offsetof(AItemPickup, ItemDefinition) == 0x000298, "Member 'AItemPickup::ItemDefinition' has a wrong offset!");
static_assert(offsetof(AItemPickup, Amount) == 0x0002A0, "Member 'AItemPickup::Amount' has a wrong offset!");
static_assert(offsetof(AItemPickup, SkeletalMesh) == 0x0002A8, "Member 'AItemPickup::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AItemPickup, StaticMesh) == 0x0002B0, "Member 'AItemPickup::StaticMesh' has a wrong offset!");

// Class ItemizationCoreRuntime.InventoryCollection
// 0x05B0 (0x0840 - 0x0290)
class AInventoryCollection final : public AInfo
{
public:
	TMulticastInlineDelegate<void(class AInventoryCollection* OwningInventory, EInventoryCollectionLoadState PreviousLoadState, EInventoryCollectionLoadState NewLoadState)> OnInventoryCollectionLoadStateChanged;             // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UInventory*>                     InventoryList;                                     // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UInventory*>         InventoryMap;                                      // 0x02B0(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<struct FGuid, struct FGuid>              ItemInventoryMap;                                  // 0x0300(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UItemInstance*>      ItemInstanceMap;                                   // 0x0350(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UItemComponentStorageManager*           ItemComponentStorageManager;                       // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x468];                                    // 0x03A8(0x0468)(Fixing Size After Last Property [ Dumper-7 ])
	EInventoryCollectionType                      InventoryCollectionType;                           // 0x0810(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_811[0x27];                                     // 0x0811(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	EInventoryCollectionLoadState                 InventoryCollectionLoadState;                      // 0x0838(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_839[0x7];                                      // 0x0839(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOnItemAbilityCooldownUpdated(class UInventory* Inventory, const struct FGuid& ItemEntryID, const struct FItemAbilityCooldownState& CooldownState);
	void DropItem(const struct FGuid& ItemEntryID, const int64 AmountToDrop);
	void Server_DropItem(const struct FGuid& ItemEntryID, const int64 AmountToDrop);
	void Server_SetEquippableItemActive(const struct FGuid& ItemEntryID);
	void Server_SetEquippableItemInactive(const struct FGuid& ItemEntryID);
	void Server_SetItemSlot(const struct FGuid& OwningInventoryID, const struct FGuid& ItemEntryID, const uint16 SlotNumber, const EVkInventoryMoveBehaviour MoveBehaviour);
	void Server_UseItem(const struct FGuid& ItemId, const struct FGuid& AdditionalItemID);
	void SetEquippableItemActive(const struct FGuid& ItemEntryID);
	void SetEquippableItemInactive(const struct FGuid& ItemEntryID);
	void UseItem(const struct FGuid& ItemId, const struct FGuid& AdditionalItemID);

	bool GetAllInventoriesInCollection(TArray<struct FGuid>* OutInventoryIDList) const;
	bool GetAllItemsInInventory(const struct FGuid& TargetInventoryID, TArray<struct FGuid>* OutItemEntryIDList) const;
	TArray<struct FGuid> GetInventoriesWithInventoryDefinition(const class UInventoryDefinition* InventoryDefinition) const;
	const class UInventoryDefinition* GetInventoryDefinition(const struct FGuid& TargetInventoryID) const;
	TArray<struct FGuid> GetInventoryListInPickupPriorityForItemDefinition(const class UItemDefinitionBase* ItemDefinition) const;
	const class FText GetInventoryName(const struct FGuid& TargetInventoryID) const;
	int64 GetItemAmount(const class UItemDefinitionBase* ItemDefinition) const;
	int64 GetItemAmountFromEntry(const struct FGuid& TargetInventoryID, const struct FGuid& ItemEntryID) const;
	int64 GetItemAmountFromInventory(const class UItemDefinitionBase* ItemDefinition, const struct FGuid& TargetInventoryID) const;
	const class UItemDefinitionBase* GetItemDefinition(const struct FGuid& TargetInventoryID, const struct FGuid& ItemEntryID) const;
	int64 GetItemIntAttribute(const struct FGuid& TargetInventoryID, const struct FGuid& ItemEntryID, const TSubclassOf<class UItemAttribute_Int>& Attribute) const;
	int32 GetItemSlotNumber(const struct FGuid& TargetInventoryID, const struct FGuid& ItemEntryID) const;
	bool IsItemEquipped(const struct FGuid& ItemEntryID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryCollection">();
	}
	static class AInventoryCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInventoryCollection>();
	}
};
static_assert(alignof(AInventoryCollection) == 0x000008, "Wrong alignment on AInventoryCollection");
static_assert(sizeof(AInventoryCollection) == 0x000840, "Wrong size on AInventoryCollection");
static_assert(offsetof(AInventoryCollection, OnInventoryCollectionLoadStateChanged) == 0x000290, "Member 'AInventoryCollection::OnInventoryCollectionLoadStateChanged' has a wrong offset!");
static_assert(offsetof(AInventoryCollection, InventoryList) == 0x0002A0, "Member 'AInventoryCollection::InventoryList' has a wrong offset!");
static_assert(offsetof(AInventoryCollection, InventoryMap) == 0x0002B0, "Member 'AInventoryCollection::InventoryMap' has a wrong offset!");
static_assert(offsetof(AInventoryCollection, ItemInventoryMap) == 0x000300, "Member 'AInventoryCollection::ItemInventoryMap' has a wrong offset!");
static_assert(offsetof(AInventoryCollection, ItemInstanceMap) == 0x000350, "Member 'AInventoryCollection::ItemInstanceMap' has a wrong offset!");
static_assert(offsetof(AInventoryCollection, ItemComponentStorageManager) == 0x0003A0, "Member 'AInventoryCollection::ItemComponentStorageManager' has a wrong offset!");
static_assert(offsetof(AInventoryCollection, InventoryCollectionType) == 0x000810, "Member 'AInventoryCollection::InventoryCollectionType' has a wrong offset!");
static_assert(offsetof(AInventoryCollection, InventoryCollectionLoadState) == 0x000838, "Member 'AInventoryCollection::InventoryCollectionLoadState' has a wrong offset!");

// Class ItemizationCoreRuntime.Inventory
// 0x04F8 (0x0598 - 0x00A0)
class UInventory : public UActorComponent
{
public:
	class AInventoryCollection*                   OwningInventoryCollection;                         // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryDefinition*                   InventoryDefinition;                               // 0x00A8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  InventoryID;                                       // 0x00B0(0x0010)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemEntryList                         ItemEntryData;                                     // 0x00C0(0x0308)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint16                                        InventoryTotalSlotsOverride;                       // 0x03C8(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CA[0x6];                                      // 0x03CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         InventoryMaxStackSizeOverride;                     // 0x03D0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint8>                                 InventoryMaxStackSizeOverrideAttributeData;        // 0x03D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x1B0];                                    // 0x03E8(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_InventoryDefinition();
	void OnRep_InventoryID();
	void OnRep_InventoryMaxStackSizeOverride();
	void OnRep_InventoryTotalSlotsOverride();
	void OnRep_ItemData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Inventory">();
	}
	static class UInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventory>();
	}
};
static_assert(alignof(UInventory) == 0x000008, "Wrong alignment on UInventory");
static_assert(sizeof(UInventory) == 0x000598, "Wrong size on UInventory");
static_assert(offsetof(UInventory, OwningInventoryCollection) == 0x0000A0, "Member 'UInventory::OwningInventoryCollection' has a wrong offset!");
static_assert(offsetof(UInventory, InventoryDefinition) == 0x0000A8, "Member 'UInventory::InventoryDefinition' has a wrong offset!");
static_assert(offsetof(UInventory, InventoryID) == 0x0000B0, "Member 'UInventory::InventoryID' has a wrong offset!");
static_assert(offsetof(UInventory, ItemEntryData) == 0x0000C0, "Member 'UInventory::ItemEntryData' has a wrong offset!");
static_assert(offsetof(UInventory, InventoryTotalSlotsOverride) == 0x0003C8, "Member 'UInventory::InventoryTotalSlotsOverride' has a wrong offset!");
static_assert(offsetof(UInventory, InventoryMaxStackSizeOverride) == 0x0003D0, "Member 'UInventory::InventoryMaxStackSizeOverride' has a wrong offset!");
static_assert(offsetof(UInventory, InventoryMaxStackSizeOverrideAttributeData) == 0x0003D8, "Member 'UInventory::InventoryMaxStackSizeOverrideAttributeData' has a wrong offset!");

// Class ItemizationCoreRuntime.EquippableInventory
// 0x0078 (0x0610 - 0x0598)
class UEquippableInventory final : public UInventory
{
public:
	TArray<struct FGuid>                          EquippedItems;                                     // 0x0598(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          PreviouslyEquippedItems;                           // 0x05A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x58];                                     // 0x05B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EquippedItems();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquippableInventory">();
	}
	static class UEquippableInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquippableInventory>();
	}
};
static_assert(alignof(UEquippableInventory) == 0x000008, "Wrong alignment on UEquippableInventory");
static_assert(sizeof(UEquippableInventory) == 0x000610, "Wrong size on UEquippableInventory");
static_assert(offsetof(UEquippableInventory, EquippedItems) == 0x000598, "Member 'UEquippableInventory::EquippedItems' has a wrong offset!");
static_assert(offsetof(UEquippableInventory, PreviouslyEquippedItems) == 0x0005A8, "Member 'UEquippableInventory::PreviouslyEquippedItems' has a wrong offset!");

// Class ItemizationCoreRuntime.EquippableInventoryDefinition
// 0x0038 (0x00B0 - 0x0078)
class UEquippableInventoryDefinition : public UInventoryDefinition
{
public:
	TArray<struct FEquipItemRestriction>          EquipRestrictions;                                 // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEquipItemCondition>            AutoEquipConditions;                               // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UInputAction*>                   SlotBindings;                                      // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowSlotBindings;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquippableInventoryDefinition">();
	}
	static class UEquippableInventoryDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquippableInventoryDefinition>();
	}
};
static_assert(alignof(UEquippableInventoryDefinition) == 0x000008, "Wrong alignment on UEquippableInventoryDefinition");
static_assert(sizeof(UEquippableInventoryDefinition) == 0x0000B0, "Wrong size on UEquippableInventoryDefinition");
static_assert(offsetof(UEquippableInventoryDefinition, EquipRestrictions) == 0x000078, "Member 'UEquippableInventoryDefinition::EquipRestrictions' has a wrong offset!");
static_assert(offsetof(UEquippableInventoryDefinition, AutoEquipConditions) == 0x000088, "Member 'UEquippableInventoryDefinition::AutoEquipConditions' has a wrong offset!");
static_assert(offsetof(UEquippableInventoryDefinition, SlotBindings) == 0x000098, "Member 'UEquippableInventoryDefinition::SlotBindings' has a wrong offset!");
static_assert(offsetof(UEquippableInventoryDefinition, bShowSlotBindings) == 0x0000A8, "Member 'UEquippableInventoryDefinition::bShowSlotBindings' has a wrong offset!");

// Class ItemizationCoreRuntime.EquipmentSlot
// 0x0000 (0x00B0 - 0x00B0)
class UEquipmentSlot final : public UEquippableInventoryDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentSlot">();
	}
	static class UEquipmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentSlot>();
	}
};
static_assert(alignof(UEquipmentSlot) == 0x000008, "Wrong alignment on UEquipmentSlot");
static_assert(sizeof(UEquipmentSlot) == 0x0000B0, "Wrong size on UEquipmentSlot");

// Class ItemizationCoreRuntime.ItemInstance
// 0x0018 (0x0040 - 0x0028)
class UItemInstance : public UObject
{
public:
	struct FGuid                                  ItemEntryID;                                       // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInstance">();
	}
	static class UItemInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInstance>();
	}
};
static_assert(alignof(UItemInstance) == 0x000008, "Wrong alignment on UItemInstance");
static_assert(sizeof(UItemInstance) == 0x000040, "Wrong size on UItemInstance");
static_assert(offsetof(UItemInstance, ItemEntryID) == 0x000028, "Member 'UItemInstance::ItemEntryID' has a wrong offset!");

// Class ItemizationCoreRuntime.EquipmentHotBar
// 0x0000 (0x00B0 - 0x00B0)
class UEquipmentHotBar final : public UEquippableInventoryDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentHotBar">();
	}
	static class UEquipmentHotBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentHotBar>();
	}
};
static_assert(alignof(UEquipmentHotBar) == 0x000008, "Wrong alignment on UEquipmentHotBar");
static_assert(sizeof(UEquipmentHotBar) == 0x0000B0, "Wrong size on UEquipmentHotBar");

// Class ItemizationCoreRuntime.InventoryCheatManager
// 0x0000 (0x0028 - 0x0028)
class UInventoryCheatManager final : public UCheatManagerExtension
{
public:
	void InventoryAddToItem(int32 InventoryIndex, int32 ItemIndex, int64 AmountToAdd);
	void InventoryDropItem(int32 InventoryIndex, int32 ItemIndex, int64 AmountToDrop);
	void InventoryMoveAmountOfItem(int32 SourceInventoryIndex, int32 ItemIndex, int32 TargetInventoryIndex, int64 AmountToMove);
	void InventoryMoveItem(int32 SourceInventoryIndex, int32 ItemIndex, int32 TargetInventoryIndex);
	void InventoryRemoveFromItem(int32 InventoryIndex, int32 ItemIndex, int64 AmountToRemove);
	void InventorySetEquippedItemActive(int32 InventoryIndex, int32 ItemIndex, bool bActive);
	void InventorySetItemSlot(int32 InventoryIndex, int32 ItemIndex, uint16 NewSlotIndex);
	void InventoryUseItem(int32 InventoryIndex, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryCheatManager">();
	}
	static class UInventoryCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryCheatManager>();
	}
};
static_assert(alignof(UInventoryCheatManager) == 0x000008, "Wrong alignment on UInventoryCheatManager");
static_assert(sizeof(UInventoryCheatManager) == 0x000028, "Wrong size on UInventoryCheatManager");

// Class ItemizationCoreRuntime.InventorySetupData
// 0x00A8 (0x00D8 - 0x0030)
class UInventorySetupData final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UEquippableInventoryDefinition>> EquipmentSetups;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UInventoryDefinition>> InventoryDefinitions;                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UItemDefinition>> StartingItems;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputMappingContext>    InputMappingContext;                               // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InventoryUIWidgetClass;                            // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InventoryHUDUIWidgetClass;                         // 0x00A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventorySetupData">();
	}
	static class UInventorySetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventorySetupData>();
	}
};
static_assert(alignof(UInventorySetupData) == 0x000008, "Wrong alignment on UInventorySetupData");
static_assert(sizeof(UInventorySetupData) == 0x0000D8, "Wrong size on UInventorySetupData");
static_assert(offsetof(UInventorySetupData, EquipmentSetups) == 0x000030, "Member 'UInventorySetupData::EquipmentSetups' has a wrong offset!");
static_assert(offsetof(UInventorySetupData, InventoryDefinitions) == 0x000040, "Member 'UInventorySetupData::InventoryDefinitions' has a wrong offset!");
static_assert(offsetof(UInventorySetupData, StartingItems) == 0x000050, "Member 'UInventorySetupData::StartingItems' has a wrong offset!");
static_assert(offsetof(UInventorySetupData, InputMappingContext) == 0x000060, "Member 'UInventorySetupData::InputMappingContext' has a wrong offset!");
static_assert(offsetof(UInventorySetupData, InventoryUIWidgetClass) == 0x000080, "Member 'UInventorySetupData::InventoryUIWidgetClass' has a wrong offset!");
static_assert(offsetof(UInventorySetupData, InventoryHUDUIWidgetClass) == 0x0000A0, "Member 'UInventorySetupData::InventoryHUDUIWidgetClass' has a wrong offset!");
static_assert(offsetof(UInventorySetupData, DisplayName) == 0x0000C0, "Member 'UInventorySetupData::DisplayName' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemDefinitionBase
// 0x00B0 (0x00E0 - 0x0030)
class UItemDefinitionBase : public UMcpItemDefinitionBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemDescription;                                   // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemShortDescription;                              // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FItemComponentContainer                ComponentContainer;                                // 0x0080(0x0010)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x50];                                      // 0x0090(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetDisplayName() const;
	const class UItemComponentBase* GetItemComponentByClass(const TSubclassOf<class UItemComponentBase> ItemComponentClass) const;
	class FText GetItemDescription() const;
	class FText GetItemShortDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDefinitionBase">();
	}
	static class UItemDefinitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDefinitionBase>();
	}
};
static_assert(alignof(UItemDefinitionBase) == 0x000008, "Wrong alignment on UItemDefinitionBase");
static_assert(sizeof(UItemDefinitionBase) == 0x0000E0, "Wrong size on UItemDefinitionBase");
static_assert(offsetof(UItemDefinitionBase, ItemName) == 0x000038, "Member 'UItemDefinitionBase::ItemName' has a wrong offset!");
static_assert(offsetof(UItemDefinitionBase, ItemDescription) == 0x000050, "Member 'UItemDefinitionBase::ItemDescription' has a wrong offset!");
static_assert(offsetof(UItemDefinitionBase, ItemShortDescription) == 0x000068, "Member 'UItemDefinitionBase::ItemShortDescription' has a wrong offset!");
static_assert(offsetof(UItemDefinitionBase, ComponentContainer) == 0x000080, "Member 'UItemDefinitionBase::ComponentContainer' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemDefinition
// 0x00B0 (0x0190 - 0x00E0)
class UItemDefinition final : public UItemDefinitionBase
{
public:
	uint8                                         Pad_E0[0xA8];                                      // 0x00E0(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ModifiedComponentIdx;                              // 0x0188(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDefinition">();
	}
	static class UItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDefinition>();
	}
};
static_assert(alignof(UItemDefinition) == 0x000008, "Wrong alignment on UItemDefinition");
static_assert(sizeof(UItemDefinition) == 0x000190, "Wrong size on UItemDefinition");
static_assert(offsetof(UItemDefinition, ModifiedComponentIdx) == 0x000188, "Member 'UItemDefinition::ModifiedComponentIdx' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAbilityConfigurationAsset
// 0x0008 (0x0038 - 0x0030)
class UItemAbilityConfigurationAsset final : public UPrimaryDataAsset
{
public:
	TSubclassOf<class UGameplayAbility>           GameplayAbilityClass;                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Construct(class UGameplayAbility* Ability) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAbilityConfigurationAsset">();
	}
	static class UItemAbilityConfigurationAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAbilityConfigurationAsset>();
	}
};
static_assert(alignof(UItemAbilityConfigurationAsset) == 0x000008, "Wrong alignment on UItemAbilityConfigurationAsset");
static_assert(sizeof(UItemAbilityConfigurationAsset) == 0x000038, "Wrong size on UItemAbilityConfigurationAsset");
static_assert(offsetof(UItemAbilityConfigurationAsset, GameplayAbilityClass) == 0x000030, "Member 'UItemAbilityConfigurationAsset::GameplayAbilityClass' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAbilityCost
// 0x0000 (0x0028 - 0x0028)
class UItemAbilityCost : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAbilityCost">();
	}
	static class UItemAbilityCost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAbilityCost>();
	}
};
static_assert(alignof(UItemAbilityCost) == 0x000008, "Wrong alignment on UItemAbilityCost");
static_assert(sizeof(UItemAbilityCost) == 0x000028, "Wrong size on UItemAbilityCost");

// Class ItemizationCoreRuntime.ItemAbilityCostItem
// 0x0028 (0x0050 - 0x0028)
class UItemAbilityCostItem final : public UItemAbilityCost
{
public:
	TSoftObjectPtr<class UItemDefinitionBase>     ItemDefinition;                                    // 0x0028(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumConsumed;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAbilityCostItem">();
	}
	static class UItemAbilityCostItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAbilityCostItem>();
	}
};
static_assert(alignof(UItemAbilityCostItem) == 0x000008, "Wrong alignment on UItemAbilityCostItem");
static_assert(sizeof(UItemAbilityCostItem) == 0x000050, "Wrong size on UItemAbilityCostItem");
static_assert(offsetof(UItemAbilityCostItem, ItemDefinition) == 0x000028, "Member 'UItemAbilityCostItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(UItemAbilityCostItem, NumConsumed) == 0x000048, "Member 'UItemAbilityCostItem::NumConsumed' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAbilityCostAttribute
// 0x0018 (0x0040 - 0x0028)
class UItemAbilityCostAttribute final : public UItemAbilityCost
{
public:
	TSubclassOf<class UItemAttribute_Int>         Attribute;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MinValue;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Change;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAbilityCostAttribute">();
	}
	static class UItemAbilityCostAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAbilityCostAttribute>();
	}
};
static_assert(alignof(UItemAbilityCostAttribute) == 0x000008, "Wrong alignment on UItemAbilityCostAttribute");
static_assert(sizeof(UItemAbilityCostAttribute) == 0x000040, "Wrong size on UItemAbilityCostAttribute");
static_assert(offsetof(UItemAbilityCostAttribute, Attribute) == 0x000028, "Member 'UItemAbilityCostAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(UItemAbilityCostAttribute, MinValue) == 0x000030, "Member 'UItemAbilityCostAttribute::MinValue' has a wrong offset!");
static_assert(offsetof(UItemAbilityCostAttribute, Change) == 0x000038, "Member 'UItemAbilityCostAttribute::Change' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemizationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemizationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString DescribeInventoryID(const struct FGuid& InventoryID);
	static class FString DescribeItemEntryID(const struct FGuid& ItemEntryID);
	static TArray<TSubclassOf<class UItemAttribute>> GetItemDataAttributeList(const struct FItemAggregatedData& ItemData);
	static bool GetItemDataBoolAttributeValue(const struct FItemAggregatedData& ItemData, const TSubclassOf<class UItemAttribute_Bool> AttributeClass);
	static double GetItemDataDecimalAttributeValue(const struct FItemAggregatedData& ItemData, const TSubclassOf<class UItemAttribute_Decimal> AttributeClass);
	static const class UItemDefinitionBase* GetItemDataDefinition(const struct FItemAggregatedData& ItemData);
	static int64 GetItemDataIntAttributeValue(const struct FItemAggregatedData& ItemData, const TSubclassOf<class UItemAttribute_Int> AttributeClass);
	static struct FGuid GetItemDataItemEntryID(const struct FItemAggregatedData& ItemData);
	static int32 GetItemDataSlot(const struct FItemAggregatedData& ItemData);
	static class FString GetItemDataStringAttributeValue(const struct FItemAggregatedData& ItemData, const TSubclassOf<class UItemAttribute_String> AttributeClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemizationFunctionLibrary">();
	}
	static class UItemizationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemizationFunctionLibrary>();
	}
};
static_assert(alignof(UItemizationFunctionLibrary) == 0x000008, "Wrong alignment on UItemizationFunctionLibrary");
static_assert(sizeof(UItemizationFunctionLibrary) == 0x000028, "Wrong size on UItemizationFunctionLibrary");

// Class ItemizationCoreRuntime.ItemAbilityCooldown
// 0x0008 (0x0030 - 0x0028)
class UItemAbilityCooldown : public UObject
{
public:
	bool                                          bApplyOnStart;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAbilityCooldown">();
	}
	static class UItemAbilityCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAbilityCooldown>();
	}
};
static_assert(alignof(UItemAbilityCooldown) == 0x000008, "Wrong alignment on UItemAbilityCooldown");
static_assert(sizeof(UItemAbilityCooldown) == 0x000030, "Wrong size on UItemAbilityCooldown");
static_assert(offsetof(UItemAbilityCooldown, bApplyOnStart) == 0x000028, "Member 'UItemAbilityCooldown::bApplyOnStart' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAbilityCooldownTime
// 0x0008 (0x0038 - 0x0030)
class UItemAbilityCooldownTime final : public UItemAbilityCooldown
{
public:
	float                                         CooldownTime;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAbilityCooldownTime">();
	}
	static class UItemAbilityCooldownTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAbilityCooldownTime>();
	}
};
static_assert(alignof(UItemAbilityCooldownTime) == 0x000008, "Wrong alignment on UItemAbilityCooldownTime");
static_assert(sizeof(UItemAbilityCooldownTime) == 0x000038, "Wrong size on UItemAbilityCooldownTime");
static_assert(offsetof(UItemAbilityCooldownTime, CooldownTime) == 0x000030, "Member 'UItemAbilityCooldownTime::CooldownTime' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAbilityCooldownVelocityBased
// 0x0010 (0x0040 - 0x0030)
class UItemAbilityCooldownVelocityBased final : public UItemAbilityCooldown
{
public:
	float                                         CooldownTimeIfStationary;                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTimeScaleFactorIfMoving;                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CooldownTimeIsResetToZeroWhenMoving;               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAbilityCooldownVelocityBased">();
	}
	static class UItemAbilityCooldownVelocityBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAbilityCooldownVelocityBased>();
	}
};
static_assert(alignof(UItemAbilityCooldownVelocityBased) == 0x000008, "Wrong alignment on UItemAbilityCooldownVelocityBased");
static_assert(sizeof(UItemAbilityCooldownVelocityBased) == 0x000040, "Wrong size on UItemAbilityCooldownVelocityBased");
static_assert(offsetof(UItemAbilityCooldownVelocityBased, CooldownTimeIfStationary) == 0x000030, "Member 'UItemAbilityCooldownVelocityBased::CooldownTimeIfStationary' has a wrong offset!");
static_assert(offsetof(UItemAbilityCooldownVelocityBased, CooldownTimeScaleFactorIfMoving) == 0x000034, "Member 'UItemAbilityCooldownVelocityBased::CooldownTimeScaleFactorIfMoving' has a wrong offset!");
static_assert(offsetof(UItemAbilityCooldownVelocityBased, CooldownTimeIsResetToZeroWhenMoving) == 0x000038, "Member 'UItemAbilityCooldownVelocityBased::CooldownTimeIsResetToZeroWhenMoving' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttachment
// 0x0018 (0x02A8 - 0x0290)
class AItemAttachment final : public AActor
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemAttachmentDefinition*              AttachmentData;                                    // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttachment">();
	}
	static class AItemAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemAttachment>();
	}
};
static_assert(alignof(AItemAttachment) == 0x000008, "Wrong alignment on AItemAttachment");
static_assert(sizeof(AItemAttachment) == 0x0002A8, "Wrong size on AItemAttachment");
static_assert(offsetof(AItemAttachment, Mesh) == 0x000290, "Member 'AItemAttachment::Mesh' has a wrong offset!");
static_assert(offsetof(AItemAttachment, AttachmentData) == 0x000298, "Member 'AItemAttachment::AttachmentData' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttribute
// 0x0048 (0x0070 - 0x0028)
class UItemAttribute : public UObject
{
public:
	class FText                                   AttributeName;                                     // 0x0028(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   AttributeDescription;                              // 0x0040(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<uint8>                                 DefaultValueAsData;                                // 0x0058(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	EItemAttributeType                            AttributeType;                                     // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsesCustomSerializer;                             // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetAttributeDescription() const;
	class FText GetAttributeName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute">();
	}
	static class UItemAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute>();
	}
};
static_assert(alignof(UItemAttribute) == 0x000008, "Wrong alignment on UItemAttribute");
static_assert(sizeof(UItemAttribute) == 0x000070, "Wrong size on UItemAttribute");
static_assert(offsetof(UItemAttribute, AttributeName) == 0x000028, "Member 'UItemAttribute::AttributeName' has a wrong offset!");
static_assert(offsetof(UItemAttribute, AttributeDescription) == 0x000040, "Member 'UItemAttribute::AttributeDescription' has a wrong offset!");
static_assert(offsetof(UItemAttribute, DefaultValueAsData) == 0x000058, "Member 'UItemAttribute::DefaultValueAsData' has a wrong offset!");
static_assert(offsetof(UItemAttribute, AttributeType) == 0x000068, "Member 'UItemAttribute::AttributeType' has a wrong offset!");
static_assert(offsetof(UItemAttribute, bUsesCustomSerializer) == 0x000069, "Member 'UItemAttribute::bUsesCustomSerializer' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttribute_Int
// 0x0010 (0x0080 - 0x0070)
class UItemAttribute_Int : public UItemAttribute
{
public:
	int64                                         DefaultValue;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttributeCombineLogic_Math                   CombineLogic;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_Int">();
	}
	static class UItemAttribute_Int* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_Int>();
	}
};
static_assert(alignof(UItemAttribute_Int) == 0x000008, "Wrong alignment on UItemAttribute_Int");
static_assert(sizeof(UItemAttribute_Int) == 0x000080, "Wrong size on UItemAttribute_Int");
static_assert(offsetof(UItemAttribute_Int, DefaultValue) == 0x000070, "Member 'UItemAttribute_Int::DefaultValue' has a wrong offset!");
static_assert(offsetof(UItemAttribute_Int, CombineLogic) == 0x000078, "Member 'UItemAttribute_Int::CombineLogic' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttribute_Decimal
// 0x0010 (0x0080 - 0x0070)
class UItemAttribute_Decimal : public UItemAttribute
{
public:
	double                                        DefaultValue;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttributeCombineLogic_Math                   CombineLogic;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_Decimal">();
	}
	static class UItemAttribute_Decimal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_Decimal>();
	}
};
static_assert(alignof(UItemAttribute_Decimal) == 0x000008, "Wrong alignment on UItemAttribute_Decimal");
static_assert(sizeof(UItemAttribute_Decimal) == 0x000080, "Wrong size on UItemAttribute_Decimal");
static_assert(offsetof(UItemAttribute_Decimal, DefaultValue) == 0x000070, "Member 'UItemAttribute_Decimal::DefaultValue' has a wrong offset!");
static_assert(offsetof(UItemAttribute_Decimal, CombineLogic) == 0x000078, "Member 'UItemAttribute_Decimal::CombineLogic' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttribute_Bool
// 0x0008 (0x0078 - 0x0070)
class UItemAttribute_Bool : public UItemAttribute
{
public:
	bool                                          DefaultValue;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_Bool">();
	}
	static class UItemAttribute_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_Bool>();
	}
};
static_assert(alignof(UItemAttribute_Bool) == 0x000008, "Wrong alignment on UItemAttribute_Bool");
static_assert(sizeof(UItemAttribute_Bool) == 0x000078, "Wrong size on UItemAttribute_Bool");
static_assert(offsetof(UItemAttribute_Bool, DefaultValue) == 0x000070, "Member 'UItemAttribute_Bool::DefaultValue' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttribute_String
// 0x0010 (0x0080 - 0x0070)
class UItemAttribute_String : public UItemAttribute
{
public:
	class FString                                 DefaultValue;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_String">();
	}
	static class UItemAttribute_String* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_String>();
	}
};
static_assert(alignof(UItemAttribute_String) == 0x000008, "Wrong alignment on UItemAttribute_String");
static_assert(sizeof(UItemAttribute_String) == 0x000080, "Wrong size on UItemAttribute_String");
static_assert(offsetof(UItemAttribute_String, DefaultValue) == 0x000070, "Member 'UItemAttribute_String::DefaultValue' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttribute_Int_Test
// 0x0000 (0x0080 - 0x0080)
class UItemAttribute_Int_Test final : public UItemAttribute_Int
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_Int_Test">();
	}
	static class UItemAttribute_Int_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_Int_Test>();
	}
};
static_assert(alignof(UItemAttribute_Int_Test) == 0x000008, "Wrong alignment on UItemAttribute_Int_Test");
static_assert(sizeof(UItemAttribute_Int_Test) == 0x000080, "Wrong size on UItemAttribute_Int_Test");

// Class ItemizationCoreRuntime.ItemAttribute_Decimal_Test
// 0x0000 (0x0080 - 0x0080)
class UItemAttribute_Decimal_Test final : public UItemAttribute_Decimal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_Decimal_Test">();
	}
	static class UItemAttribute_Decimal_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_Decimal_Test>();
	}
};
static_assert(alignof(UItemAttribute_Decimal_Test) == 0x000008, "Wrong alignment on UItemAttribute_Decimal_Test");
static_assert(sizeof(UItemAttribute_Decimal_Test) == 0x000080, "Wrong size on UItemAttribute_Decimal_Test");

// Class ItemizationCoreRuntime.ItemAttribute_Bool_Test
// 0x0000 (0x0078 - 0x0078)
class UItemAttribute_Bool_Test final : public UItemAttribute_Bool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_Bool_Test">();
	}
	static class UItemAttribute_Bool_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_Bool_Test>();
	}
};
static_assert(alignof(UItemAttribute_Bool_Test) == 0x000008, "Wrong alignment on UItemAttribute_Bool_Test");
static_assert(sizeof(UItemAttribute_Bool_Test) == 0x000078, "Wrong size on UItemAttribute_Bool_Test");

// Class ItemizationCoreRuntime.ItemAttribute_String_Test
// 0x0000 (0x0080 - 0x0080)
class UItemAttribute_String_Test final : public UItemAttribute_String
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_String_Test">();
	}
	static class UItemAttribute_String_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_String_Test>();
	}
};
static_assert(alignof(UItemAttribute_String_Test) == 0x000008, "Wrong alignment on UItemAttribute_String_Test");
static_assert(sizeof(UItemAttribute_String_Test) == 0x000080, "Wrong size on UItemAttribute_String_Test");

// Class ItemizationCoreRuntime.ItemAttributeValueBase
// 0x0018 (0x0040 - 0x0028)
class UItemAttributeValueBase : public UObject
{
public:
	struct FGuid                                  QueriedItemEntryID;                                // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AInventoryCollection>    QueriedInventoryCollection;                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttributeValueBase">();
	}
	static class UItemAttributeValueBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttributeValueBase>();
	}
};
static_assert(alignof(UItemAttributeValueBase) == 0x000008, "Wrong alignment on UItemAttributeValueBase");
static_assert(sizeof(UItemAttributeValueBase) == 0x000040, "Wrong size on UItemAttributeValueBase");
static_assert(offsetof(UItemAttributeValueBase, QueriedItemEntryID) == 0x000028, "Member 'UItemAttributeValueBase::QueriedItemEntryID' has a wrong offset!");
static_assert(offsetof(UItemAttributeValueBase, QueriedInventoryCollection) == 0x000038, "Member 'UItemAttributeValueBase::QueriedInventoryCollection' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttributeValue_Int
// 0x0000 (0x0040 - 0x0040)
class UItemAttributeValue_Int : public UItemAttributeValueBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttributeValue_Int">();
	}
	static class UItemAttributeValue_Int* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttributeValue_Int>();
	}
};
static_assert(alignof(UItemAttributeValue_Int) == 0x000008, "Wrong alignment on UItemAttributeValue_Int");
static_assert(sizeof(UItemAttributeValue_Int) == 0x000040, "Wrong size on UItemAttributeValue_Int");

// Class ItemizationCoreRuntime.ItemAttributeValue_Decimal
// 0x0000 (0x0040 - 0x0040)
class UItemAttributeValue_Decimal : public UItemAttributeValueBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttributeValue_Decimal">();
	}
	static class UItemAttributeValue_Decimal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttributeValue_Decimal>();
	}
};
static_assert(alignof(UItemAttributeValue_Decimal) == 0x000008, "Wrong alignment on UItemAttributeValue_Decimal");
static_assert(sizeof(UItemAttributeValue_Decimal) == 0x000040, "Wrong size on UItemAttributeValue_Decimal");

// Class ItemizationCoreRuntime.ItemAttributeValue_Bool
// 0x0000 (0x0040 - 0x0040)
class UItemAttributeValue_Bool : public UItemAttributeValueBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttributeValue_Bool">();
	}
	static class UItemAttributeValue_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttributeValue_Bool>();
	}
};
static_assert(alignof(UItemAttributeValue_Bool) == 0x000008, "Wrong alignment on UItemAttributeValue_Bool");
static_assert(sizeof(UItemAttributeValue_Bool) == 0x000040, "Wrong size on UItemAttributeValue_Bool");

// Class ItemizationCoreRuntime.ItemAttributeValue_String
// 0x0000 (0x0040 - 0x0040)
class UItemAttributeValue_String : public UItemAttributeValueBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttributeValue_String">();
	}
	static class UItemAttributeValue_String* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttributeValue_String>();
	}
};
static_assert(alignof(UItemAttributeValue_String) == 0x000008, "Wrong alignment on UItemAttributeValue_String");
static_assert(sizeof(UItemAttributeValue_String) == 0x000040, "Wrong size on UItemAttributeValue_String");

// Class ItemizationCoreRuntime.ItemComponentStorageManager
// 0x00A0 (0x00C8 - 0x0028)
class UItemComponentStorageManager final : public UObject
{
public:
	TMap<class UClass*, struct FItemEntryStorageMap> ClassIndividualStorageMap;                         // 0x0028(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UClass*, class UItemComponentSharedLocalStorage*> ClassSharedStorageMap;                             // 0x0078(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentStorageManager">();
	}
	static class UItemComponentStorageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentStorageManager>();
	}
};
static_assert(alignof(UItemComponentStorageManager) == 0x000008, "Wrong alignment on UItemComponentStorageManager");
static_assert(sizeof(UItemComponentStorageManager) == 0x0000C8, "Wrong size on UItemComponentStorageManager");
static_assert(offsetof(UItemComponentStorageManager, ClassIndividualStorageMap) == 0x000028, "Member 'UItemComponentStorageManager::ClassIndividualStorageMap' has a wrong offset!");
static_assert(offsetof(UItemComponentStorageManager, ClassSharedStorageMap) == 0x000078, "Member 'UItemComponentStorageManager::ClassSharedStorageMap' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponentLocalStorage
// 0x0010 (0x0038 - 0x0028)
class UItemComponentLocalStorage : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentLocalStorage">();
	}
	static class UItemComponentLocalStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentLocalStorage>();
	}
};
static_assert(alignof(UItemComponentLocalStorage) == 0x000008, "Wrong alignment on UItemComponentLocalStorage");
static_assert(sizeof(UItemComponentLocalStorage) == 0x000038, "Wrong size on UItemComponentLocalStorage");

// Class ItemizationCoreRuntime.ItemComponentSharedLocalStorage
// 0x0000 (0x0028 - 0x0028)
class UItemComponentSharedLocalStorage : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentSharedLocalStorage">();
	}
	static class UItemComponentSharedLocalStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentSharedLocalStorage>();
	}
};
static_assert(alignof(UItemComponentSharedLocalStorage) == 0x000008, "Wrong alignment on UItemComponentSharedLocalStorage");
static_assert(sizeof(UItemComponentSharedLocalStorage) == 0x000028, "Wrong size on UItemComponentSharedLocalStorage");

// Class ItemizationCoreRuntime.ItemComponent_Ability
// 0x0010 (0x0038 - 0x0028)
class UItemComponent_Ability final : public UItemComponentBase
{
public:
	TArray<struct FItemAbilityBinding>            AbilityList;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponent_Ability">();
	}
	static class UItemComponent_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponent_Ability>();
	}
};
static_assert(alignof(UItemComponent_Ability) == 0x000008, "Wrong alignment on UItemComponent_Ability");
static_assert(sizeof(UItemComponent_Ability) == 0x000038, "Wrong size on UItemComponent_Ability");
static_assert(offsetof(UItemComponent_Ability, AbilityList) == 0x000028, "Member 'UItemComponent_Ability::AbilityList' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponentStorage_Ability
// 0x0028 (0x0060 - 0x0038)
class UItemComponentStorage_Ability final : public UItemComponentLocalStorage
{
public:
	TArray<bool>                                  AbilityIsAvailableList;                            // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UItemComponent_Ability*                 SourceData;                                        // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentStorage_Ability">();
	}
	static class UItemComponentStorage_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentStorage_Ability>();
	}
};
static_assert(alignof(UItemComponentStorage_Ability) == 0x000008, "Wrong alignment on UItemComponentStorage_Ability");
static_assert(sizeof(UItemComponentStorage_Ability) == 0x000060, "Wrong size on UItemComponentStorage_Ability");
static_assert(offsetof(UItemComponentStorage_Ability, AbilityIsAvailableList) == 0x000038, "Member 'UItemComponentStorage_Ability::AbilityIsAvailableList' has a wrong offset!");
static_assert(offsetof(UItemComponentStorage_Ability, SourceData) == 0x000048, "Member 'UItemComponentStorage_Ability::SourceData' has a wrong offset!");
static_assert(offsetof(UItemComponentStorage_Ability, AbilitySystemComponent) == 0x000050, "Member 'UItemComponentStorage_Ability::AbilitySystemComponent' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponentStorage_AbilityShared
// 0x0050 (0x0078 - 0x0028)
class UItemComponentStorage_AbilityShared final : public UItemComponentSharedLocalStorage
{
public:
	TMap<uint32, struct FItemAbilityRuntimeData>  RefCountedAbilityRuntimeData;                      // 0x0028(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentStorage_AbilityShared">();
	}
	static class UItemComponentStorage_AbilityShared* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentStorage_AbilityShared>();
	}
};
static_assert(alignof(UItemComponentStorage_AbilityShared) == 0x000008, "Wrong alignment on UItemComponentStorage_AbilityShared");
static_assert(sizeof(UItemComponentStorage_AbilityShared) == 0x000078, "Wrong size on UItemComponentStorage_AbilityShared");
static_assert(offsetof(UItemComponentStorage_AbilityShared, RefCountedAbilityRuntimeData) == 0x000028, "Member 'UItemComponentStorage_AbilityShared::RefCountedAbilityRuntimeData' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttachmentDefinition
// 0x0008 (0x0030 - 0x0028)
class UItemAttachmentDefinition : public UObject
{
public:
	EItemStateFilter                              AttachmentVisibility;                              // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttachmentDefinition">();
	}
	static class UItemAttachmentDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttachmentDefinition>();
	}
};
static_assert(alignof(UItemAttachmentDefinition) == 0x000008, "Wrong alignment on UItemAttachmentDefinition");
static_assert(sizeof(UItemAttachmentDefinition) == 0x000030, "Wrong size on UItemAttachmentDefinition");
static_assert(offsetof(UItemAttachmentDefinition, AttachmentVisibility) == 0x000028, "Member 'UItemAttachmentDefinition::AttachmentVisibility' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemMeshAttachmentDefinition
// 0x0050 (0x0080 - 0x0030)
class UItemMeshAttachmentDefinition : public UItemAttachmentDefinition
{
public:
	class FName                                   AttachToSocketName;                                // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetLocation;                                    // 0x0038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OffsetRotation;                                    // 0x0050(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MeshScale;                                         // 0x0068(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemMeshAttachmentDefinition">();
	}
	static class UItemMeshAttachmentDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemMeshAttachmentDefinition>();
	}
};
static_assert(alignof(UItemMeshAttachmentDefinition) == 0x000008, "Wrong alignment on UItemMeshAttachmentDefinition");
static_assert(sizeof(UItemMeshAttachmentDefinition) == 0x000080, "Wrong size on UItemMeshAttachmentDefinition");
static_assert(offsetof(UItemMeshAttachmentDefinition, AttachToSocketName) == 0x000030, "Member 'UItemMeshAttachmentDefinition::AttachToSocketName' has a wrong offset!");
static_assert(offsetof(UItemMeshAttachmentDefinition, OffsetLocation) == 0x000038, "Member 'UItemMeshAttachmentDefinition::OffsetLocation' has a wrong offset!");
static_assert(offsetof(UItemMeshAttachmentDefinition, OffsetRotation) == 0x000050, "Member 'UItemMeshAttachmentDefinition::OffsetRotation' has a wrong offset!");
static_assert(offsetof(UItemMeshAttachmentDefinition, MeshScale) == 0x000068, "Member 'UItemMeshAttachmentDefinition::MeshScale' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemInputAction
// 0x0000 (0x0080 - 0x0080)
class UItemInputAction final : public UInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInputAction">();
	}
	static class UItemInputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInputAction>();
	}
};
static_assert(alignof(UItemInputAction) == 0x000008, "Wrong alignment on UItemInputAction");
static_assert(sizeof(UItemInputAction) == 0x000080, "Wrong size on UItemInputAction");

// Class ItemizationCoreRuntime.ItemStaticMeshAttachmentDefinition
// 0x0020 (0x00A0 - 0x0080)
class UItemStaticMeshAttachmentDefinition final : public UItemMeshAttachmentDefinition
{
public:
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x0080(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStaticMeshAttachmentDefinition">();
	}
	static class UItemStaticMeshAttachmentDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemStaticMeshAttachmentDefinition>();
	}
};
static_assert(alignof(UItemStaticMeshAttachmentDefinition) == 0x000008, "Wrong alignment on UItemStaticMeshAttachmentDefinition");
static_assert(sizeof(UItemStaticMeshAttachmentDefinition) == 0x0000A0, "Wrong size on UItemStaticMeshAttachmentDefinition");
static_assert(offsetof(UItemStaticMeshAttachmentDefinition, Mesh) == 0x000080, "Member 'UItemStaticMeshAttachmentDefinition::Mesh' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemSkeletalMeshAttachmentDefinition
// 0x0040 (0x00C0 - 0x0080)
class UItemSkeletalMeshAttachmentDefinition final : public UItemMeshAttachmentDefinition
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0080(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           Animation;                                         // 0x00A0(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSkeletalMeshAttachmentDefinition">();
	}
	static class UItemSkeletalMeshAttachmentDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSkeletalMeshAttachmentDefinition>();
	}
};
static_assert(alignof(UItemSkeletalMeshAttachmentDefinition) == 0x000008, "Wrong alignment on UItemSkeletalMeshAttachmentDefinition");
static_assert(sizeof(UItemSkeletalMeshAttachmentDefinition) == 0x0000C0, "Wrong size on UItemSkeletalMeshAttachmentDefinition");
static_assert(offsetof(UItemSkeletalMeshAttachmentDefinition, Mesh) == 0x000080, "Member 'UItemSkeletalMeshAttachmentDefinition::Mesh' has a wrong offset!");
static_assert(offsetof(UItemSkeletalMeshAttachmentDefinition, Animation) == 0x0000A0, "Member 'UItemSkeletalMeshAttachmentDefinition::Animation' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponent_Attach
// 0x0010 (0x0038 - 0x0028)
class UItemComponent_Attach final : public UItemComponentBase
{
public:
	TArray<class UItemAttachmentDefinition*>      Attachments;                                       // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponent_Attach">();
	}
	static class UItemComponent_Attach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponent_Attach>();
	}
};
static_assert(alignof(UItemComponent_Attach) == 0x000008, "Wrong alignment on UItemComponent_Attach");
static_assert(sizeof(UItemComponent_Attach) == 0x000038, "Wrong size on UItemComponent_Attach");
static_assert(offsetof(UItemComponent_Attach, Attachments) == 0x000028, "Member 'UItemComponent_Attach::Attachments' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponentStorage_Attach
// 0x0020 (0x0058 - 0x0038)
class UItemComponentStorage_Attach final : public UItemComponentLocalStorage
{
public:
	TArray<TWeakObjectPtr<class AItemAttachment>> ActorAttachments;                                  // 0x0038(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerTransformUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentStorage_Attach">();
	}
	static class UItemComponentStorage_Attach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentStorage_Attach>();
	}
};
static_assert(alignof(UItemComponentStorage_Attach) == 0x000008, "Wrong alignment on UItemComponentStorage_Attach");
static_assert(sizeof(UItemComponentStorage_Attach) == 0x000058, "Wrong size on UItemComponentStorage_Attach");
static_assert(offsetof(UItemComponentStorage_Attach, ActorAttachments) == 0x000038, "Member 'UItemComponentStorage_Attach::ActorAttachments' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemizationPersistenceManagerBase
// 0x0000 (0x0028 - 0x0028)
class UItemizationPersistenceManagerBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemizationPersistenceManagerBase">();
	}
	static class UItemizationPersistenceManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemizationPersistenceManagerBase>();
	}
};
static_assert(alignof(UItemizationPersistenceManagerBase) == 0x000008, "Wrong alignment on UItemizationPersistenceManagerBase");
static_assert(sizeof(UItemizationPersistenceManagerBase) == 0x000028, "Wrong size on UItemizationPersistenceManagerBase");

// Class ItemizationCoreRuntime.ItemAttribute_WasLoadedFromSave
// 0x0000 (0x0078 - 0x0078)
class UItemAttribute_WasLoadedFromSave final : public UItemAttribute_Bool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_WasLoadedFromSave">();
	}
	static class UItemAttribute_WasLoadedFromSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_WasLoadedFromSave>();
	}
};
static_assert(alignof(UItemAttribute_WasLoadedFromSave) == 0x000008, "Wrong alignment on UItemAttribute_WasLoadedFromSave");
static_assert(sizeof(UItemAttribute_WasLoadedFromSave) == 0x000078, "Wrong size on UItemAttribute_WasLoadedFromSave");

// Class ItemizationCoreRuntime.ItemComponent_Core
// 0x0020 (0x0048 - 0x0028)
class UItemComponent_Core final : public UItemComponentBase
{
public:
	class UItemType*                              ItemType;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemRarity*                            ItemRarity;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVerseGameplayTagContainer             ItemTags;                                          // 0x0038(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	class UItemRarity* GetItemRarity() const;
	class UItemType* GetItemType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponent_Core">();
	}
	static class UItemComponent_Core* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponent_Core>();
	}
};
static_assert(alignof(UItemComponent_Core) == 0x000008, "Wrong alignment on UItemComponent_Core");
static_assert(sizeof(UItemComponent_Core) == 0x000048, "Wrong size on UItemComponent_Core");
static_assert(offsetof(UItemComponent_Core, ItemType) == 0x000028, "Member 'UItemComponent_Core::ItemType' has a wrong offset!");
static_assert(offsetof(UItemComponent_Core, ItemRarity) == 0x000030, "Member 'UItemComponent_Core::ItemRarity' has a wrong offset!");
static_assert(offsetof(UItemComponent_Core, ItemTags) == 0x000038, "Member 'UItemComponent_Core::ItemTags' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponent_DisplayUI
// 0x0068 (0x0090 - 0x0028)
class UItemComponent_DisplayUI final : public UItemComponentBase
{
public:
	TSoftObjectPtr<class UTexture2D>              ItemIcon;                                          // 0x0028(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              SmallItemIcon;                                     // 0x0048(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UMaterialInterface>      ItemMaterial;                                      // 0x0068(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialTextureParameter;                          // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EItemIconDisplayTextType                      IconDisplayTextType;                               // 0x008C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TSoftObjectPtr<class UTexture2D> GetItemIcon() const;
	EItemIconDisplayTextType GetItemIconDisplayTextType() const;
	const TSoftObjectPtr<class UMaterialInterface> GetItemMaterial() const;
	const class FName GetMaterialTextureParameter() const;
	const TSoftObjectPtr<class UTexture2D> GetSmallItemIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponent_DisplayUI">();
	}
	static class UItemComponent_DisplayUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponent_DisplayUI>();
	}
};
static_assert(alignof(UItemComponent_DisplayUI) == 0x000008, "Wrong alignment on UItemComponent_DisplayUI");
static_assert(sizeof(UItemComponent_DisplayUI) == 0x000090, "Wrong size on UItemComponent_DisplayUI");
static_assert(offsetof(UItemComponent_DisplayUI, ItemIcon) == 0x000028, "Member 'UItemComponent_DisplayUI::ItemIcon' has a wrong offset!");
static_assert(offsetof(UItemComponent_DisplayUI, SmallItemIcon) == 0x000048, "Member 'UItemComponent_DisplayUI::SmallItemIcon' has a wrong offset!");
static_assert(offsetof(UItemComponent_DisplayUI, ItemMaterial) == 0x000068, "Member 'UItemComponent_DisplayUI::ItemMaterial' has a wrong offset!");
static_assert(offsetof(UItemComponent_DisplayUI, MaterialTextureParameter) == 0x000088, "Member 'UItemComponent_DisplayUI::MaterialTextureParameter' has a wrong offset!");
static_assert(offsetof(UItemComponent_DisplayUI, IconDisplayTextType) == 0x00008C, "Member 'UItemComponent_DisplayUI::IconDisplayTextType' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemOwnerPoseAsset
// 0x0008 (0x0038 - 0x0030)
class UItemOwnerPoseAsset final : public UPrimaryDataAsset
{
public:
	class UProxyTable*                            ProxyTable;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemOwnerPoseAsset">();
	}
	static class UItemOwnerPoseAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemOwnerPoseAsset>();
	}
};
static_assert(alignof(UItemOwnerPoseAsset) == 0x000008, "Wrong alignment on UItemOwnerPoseAsset");
static_assert(sizeof(UItemOwnerPoseAsset) == 0x000038, "Wrong size on UItemOwnerPoseAsset");
static_assert(offsetof(UItemOwnerPoseAsset, ProxyTable) == 0x000030, "Member 'UItemOwnerPoseAsset::ProxyTable' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponent_OwnerPose
// 0x0018 (0x0040 - 0x0028)
class UItemComponent_OwnerPose final : public UItemComponentBase
{
public:
	EItemStateFilter                              ApplyPoseState;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemOwnerPoseAsset*                    PoseAsset;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosePriority;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponent_OwnerPose">();
	}
	static class UItemComponent_OwnerPose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponent_OwnerPose>();
	}
};
static_assert(alignof(UItemComponent_OwnerPose) == 0x000008, "Wrong alignment on UItemComponent_OwnerPose");
static_assert(sizeof(UItemComponent_OwnerPose) == 0x000040, "Wrong size on UItemComponent_OwnerPose");
static_assert(offsetof(UItemComponent_OwnerPose, ApplyPoseState) == 0x000028, "Member 'UItemComponent_OwnerPose::ApplyPoseState' has a wrong offset!");
static_assert(offsetof(UItemComponent_OwnerPose, PoseAsset) == 0x000030, "Member 'UItemComponent_OwnerPose::PoseAsset' has a wrong offset!");
static_assert(offsetof(UItemComponent_OwnerPose, PosePriority) == 0x000038, "Member 'UItemComponent_OwnerPose::PosePriority' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponentStorage_OwnerPose
// 0x0008 (0x0040 - 0x0038)
class UItemComponentStorage_OwnerPose final : public UItemComponentLocalStorage
{
public:
	bool                                          bHasAppliedProceduralLayer;                        // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentStorage_OwnerPose">();
	}
	static class UItemComponentStorage_OwnerPose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentStorage_OwnerPose>();
	}
};
static_assert(alignof(UItemComponentStorage_OwnerPose) == 0x000008, "Wrong alignment on UItemComponentStorage_OwnerPose");
static_assert(sizeof(UItemComponentStorage_OwnerPose) == 0x000040, "Wrong size on UItemComponentStorage_OwnerPose");
static_assert(offsetof(UItemComponentStorage_OwnerPose, bHasAppliedProceduralLayer) == 0x000038, "Member 'UItemComponentStorage_OwnerPose::bHasAppliedProceduralLayer' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemComponentStorage_OwnerPoseShared
// 0x0010 (0x0038 - 0x0028)
class UItemComponentStorage_OwnerPoseShared final : public UItemComponentSharedLocalStorage
{
public:
	TArray<class UItemComponent_OwnerPose*>       ActiveProceduralLayers;                            // 0x0028(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentStorage_OwnerPoseShared">();
	}
	static class UItemComponentStorage_OwnerPoseShared* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentStorage_OwnerPoseShared>();
	}
};
static_assert(alignof(UItemComponentStorage_OwnerPoseShared) == 0x000008, "Wrong alignment on UItemComponentStorage_OwnerPoseShared");
static_assert(sizeof(UItemComponentStorage_OwnerPoseShared) == 0x000038, "Wrong size on UItemComponentStorage_OwnerPoseShared");
static_assert(offsetof(UItemComponentStorage_OwnerPoseShared, ActiveProceduralLayers) == 0x000028, "Member 'UItemComponentStorage_OwnerPoseShared::ActiveProceduralLayers' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttribute_StackSize
// 0x0000 (0x0080 - 0x0080)
class UItemAttribute_StackSize final : public UItemAttribute_Int
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_StackSize">();
	}
	static class UItemAttribute_StackSize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_StackSize>();
	}
};
static_assert(alignof(UItemAttribute_StackSize) == 0x000008, "Wrong alignment on UItemAttribute_StackSize");
static_assert(sizeof(UItemAttribute_StackSize) == 0x000080, "Wrong size on UItemAttribute_StackSize");

// Class ItemizationCoreRuntime.ItemAttribute_MaxStackSize
// 0x0000 (0x0080 - 0x0080)
class UItemAttribute_MaxStackSize final : public UItemAttribute_Int
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_MaxStackSize">();
	}
	static class UItemAttribute_MaxStackSize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_MaxStackSize>();
	}
};
static_assert(alignof(UItemAttribute_MaxStackSize) == 0x000008, "Wrong alignment on UItemAttribute_MaxStackSize");
static_assert(sizeof(UItemAttribute_MaxStackSize) == 0x000080, "Wrong size on UItemAttribute_MaxStackSize");

// Class ItemizationCoreRuntime.ItemComponent_Stackable
// 0x0010 (0x0038 - 0x0028)
class UItemComponent_Stackable final : public UItemComponentBase
{
public:
	int64                                         MaxStackSize;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AllowMultipleStacks;                               // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DestroyEmptyStacks;                                // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponent_Stackable">();
	}
	static class UItemComponent_Stackable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponent_Stackable>();
	}
};
static_assert(alignof(UItemComponent_Stackable) == 0x000008, "Wrong alignment on UItemComponent_Stackable");
static_assert(sizeof(UItemComponent_Stackable) == 0x000038, "Wrong size on UItemComponent_Stackable");
static_assert(offsetof(UItemComponent_Stackable, MaxStackSize) == 0x000028, "Member 'UItemComponent_Stackable::MaxStackSize' has a wrong offset!");
static_assert(offsetof(UItemComponent_Stackable, AllowMultipleStacks) == 0x000030, "Member 'UItemComponent_Stackable::AllowMultipleStacks' has a wrong offset!");
static_assert(offsetof(UItemComponent_Stackable, DestroyEmptyStacks) == 0x000031, "Member 'UItemComponent_Stackable::DestroyEmptyStacks' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemInputMappingContext
// 0x0000 (0x0058 - 0x0058)
class UItemInputMappingContext final : public UInputMappingContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInputMappingContext">();
	}
	static class UItemInputMappingContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInputMappingContext>();
	}
};
static_assert(alignof(UItemInputMappingContext) == 0x000008, "Wrong alignment on UItemInputMappingContext");
static_assert(sizeof(UItemInputMappingContext) == 0x000058, "Wrong size on UItemInputMappingContext");

// Class ItemizationCoreRuntime.ItemizationPickupFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemizationPickupFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class AItemPickup* DropItemFromInventoryAsPickup(class AInventoryCollection* Collection, const struct FGuid& InventoryID, const struct FGuid& ItemEntryID, int64 AmountToDrop);
	static void SetDefaultItemPickupClass(TSubclassOf<class AItemPickup> ItemPickupClass);
	static void SetDefaultItemPickupMesh(class UStaticMesh* Mesh);
	static class AItemPickup* SpawnItemPickupInWorld(class UObject* WorldContextObject, const class UItemDefinitionBase* ItemDefinition, const struct FVector& InPosition, const int64 Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemizationPickupFunctionLibrary">();
	}
	static class UItemizationPickupFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemizationPickupFunctionLibrary>();
	}
};
static_assert(alignof(UItemizationPickupFunctionLibrary) == 0x000008, "Wrong alignment on UItemizationPickupFunctionLibrary");
static_assert(sizeof(UItemizationPickupFunctionLibrary) == 0x000028, "Wrong size on UItemizationPickupFunctionLibrary");

// Class ItemizationCoreRuntime.ItemRarity
// 0x0058 (0x0088 - 0x0030)
class UItemRarity final : public UDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FLinearColor                           Color;                                             // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Tier;                                              // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVerseGameplayTagContainer             Tags;                                              // 0x0078(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	const struct FLinearColor GetColor() const;
	const class FText GetDescription() const;
	const class FText GetName() const;
	float GetTier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRarity">();
	}
	static class UItemRarity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRarity>();
	}
};
static_assert(alignof(UItemRarity) == 0x000008, "Wrong alignment on UItemRarity");
static_assert(sizeof(UItemRarity) == 0x000088, "Wrong size on UItemRarity");
static_assert(offsetof(UItemRarity, Name_0) == 0x000030, "Member 'UItemRarity::Name_0' has a wrong offset!");
static_assert(offsetof(UItemRarity, Description) == 0x000048, "Member 'UItemRarity::Description' has a wrong offset!");
static_assert(offsetof(UItemRarity, Color) == 0x000060, "Member 'UItemRarity::Color' has a wrong offset!");
static_assert(offsetof(UItemRarity, Tier) == 0x000070, "Member 'UItemRarity::Tier' has a wrong offset!");
static_assert(offsetof(UItemRarity, Tags) == 0x000078, "Member 'UItemRarity::Tags' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemAttribute_Rarity
// 0x0000 (0x0080 - 0x0080)
class UItemAttribute_Rarity final : public UItemAttribute_Int
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAttribute_Rarity">();
	}
	static class UItemAttribute_Rarity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAttribute_Rarity>();
	}
};
static_assert(alignof(UItemAttribute_Rarity) == 0x000008, "Wrong alignment on UItemAttribute_Rarity");
static_assert(sizeof(UItemAttribute_Rarity) == 0x000080, "Wrong size on UItemAttribute_Rarity");

// Class ItemizationCoreRuntime.ItemRarityTable
// 0x0040 (0x0070 - 0x0030)
class UItemRarityTable final : public UDataAsset
{
public:
	class FText                                   RarityTableName;                                   // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   RarityTableDescription;                            // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FVkRarityEntry>                 RarityList;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRarityTable">();
	}
	static class UItemRarityTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRarityTable>();
	}
};
static_assert(alignof(UItemRarityTable) == 0x000008, "Wrong alignment on UItemRarityTable");
static_assert(sizeof(UItemRarityTable) == 0x000070, "Wrong size on UItemRarityTable");
static_assert(offsetof(UItemRarityTable, RarityTableName) == 0x000030, "Member 'UItemRarityTable::RarityTableName' has a wrong offset!");
static_assert(offsetof(UItemRarityTable, RarityTableDescription) == 0x000048, "Member 'UItemRarityTable::RarityTableDescription' has a wrong offset!");
static_assert(offsetof(UItemRarityTable, RarityList) == 0x000060, "Member 'UItemRarityTable::RarityList' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemRequirements
// 0x00B0 (0x00E0 - 0x0030)
class UItemRequirements final : public UDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSet<class UItemType*>                        ItemTypes;                                         // 0x0060(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FItemTagContainer                      TagContainer;                                      // 0x00B0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRequirements">();
	}
	static class UItemRequirements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRequirements>();
	}
};
static_assert(alignof(UItemRequirements) == 0x000008, "Wrong alignment on UItemRequirements");
static_assert(sizeof(UItemRequirements) == 0x0000E0, "Wrong size on UItemRequirements");
static_assert(offsetof(UItemRequirements, Name_0) == 0x000030, "Member 'UItemRequirements::Name_0' has a wrong offset!");
static_assert(offsetof(UItemRequirements, Description) == 0x000048, "Member 'UItemRequirements::Description' has a wrong offset!");
static_assert(offsetof(UItemRequirements, ItemTypes) == 0x000060, "Member 'UItemRequirements::ItemTypes' has a wrong offset!");
static_assert(offsetof(UItemRequirements, TagContainer) == 0x0000B0, "Member 'UItemRequirements::TagContainer' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemType
// 0x0048 (0x0078 - 0x0030)
class UItemType final : public UDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UItemType*                              ParentType;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVerseGameplayTagContainer             Tags;                                              // 0x0068(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	const class FText GetDescription() const;
	const class FText GetName() const;
	const class UItemType* GetParentType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemType">();
	}
	static class UItemType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemType>();
	}
};
static_assert(alignof(UItemType) == 0x000008, "Wrong alignment on UItemType");
static_assert(sizeof(UItemType) == 0x000078, "Wrong size on UItemType");
static_assert(offsetof(UItemType, Name_0) == 0x000030, "Member 'UItemType::Name_0' has a wrong offset!");
static_assert(offsetof(UItemType, Description) == 0x000048, "Member 'UItemType::Description' has a wrong offset!");
static_assert(offsetof(UItemType, ParentType) == 0x000060, "Member 'UItemType::ParentType' has a wrong offset!");
static_assert(offsetof(UItemType, Tags) == 0x000068, "Member 'UItemType::Tags' has a wrong offset!");

// Class ItemizationCoreRuntime.ItemVariant
// 0x0038 (0x0118 - 0x00E0)
class UItemVariant final : public UItemDefinitionBase
{
public:
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemDefinition*                        Original;                                          // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOverriddenRecord>              CachedOverriddenList;                              // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         ModifiedComponentIdx;                              // 0x0110(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVariant">();
	}
	static class UItemVariant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemVariant>();
	}
};
static_assert(alignof(UItemVariant) == 0x000008, "Wrong alignment on UItemVariant");
static_assert(sizeof(UItemVariant) == 0x000118, "Wrong size on UItemVariant");
static_assert(offsetof(UItemVariant, Original) == 0x0000F8, "Member 'UItemVariant::Original' has a wrong offset!");
static_assert(offsetof(UItemVariant, CachedOverriddenList) == 0x000100, "Member 'UItemVariant::CachedOverriddenList' has a wrong offset!");
static_assert(offsetof(UItemVariant, ModifiedComponentIdx) == 0x000110, "Member 'UItemVariant::ModifiedComponentIdx' has a wrong offset!");

// Class ItemizationCoreRuntime.InventoryComponent
// 0x0048 (0x00E8 - 0x00A0)
class UInventoryComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class UInventoryComponent* InventoryComponent)> OnInventoryComponentDestroyed;                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInventorySetupData>     InventorySetupData;                                // 0x00B0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AInventoryCollection>    InventoryCollection;                               // 0x00D0(0x0008)(Net, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  PersistenceID;                                     // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddItem(class UItemDefinitionBase* ItemDefinition, int64 Amount);
	void AddOrResetInventory(class UInventoryDefinition* NewInventoryDefinition);
	void DropItem(const struct FGuid& ItemEntryID);
	void SetEquippableItemActive(const struct FGuid& ItemEntryID, bool bActive);
	void UseItem(const struct FGuid& ItemId, const struct FGuid& AdditionalItemID);

	class AInventoryCollection* GetInventoryCollection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x0000E8, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, OnInventoryComponentDestroyed) == 0x0000A0, "Member 'UInventoryComponent::OnInventoryComponentDestroyed' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, InventorySetupData) == 0x0000B0, "Member 'UInventoryComponent::InventorySetupData' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, InventoryCollection) == 0x0000D0, "Member 'UInventoryComponent::InventoryCollection' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, PersistenceID) == 0x0000D8, "Member 'UInventoryComponent::PersistenceID' has a wrong offset!");

}

