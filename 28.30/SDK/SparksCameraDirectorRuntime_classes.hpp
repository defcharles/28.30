#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SparksCameraDirectorRuntime

#include "Basic.hpp"

#include "SparksCameraDirectorRuntime_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_classes.hpp"
#include "LevelSequence_classes.hpp"


namespace SDK
{

// Class SparksCameraDirectorRuntime.SparksCameraShotPool
// 0x0098 (0x00C8 - 0x0030)
class USparksCameraShotPool final : public UDataAsset
{
public:
	TArray<struct FSparksCameraShot>              Shots;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreShotTags;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PoolTags;                                          // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSparksCameraFilter                    PoolFilter;                                        // 0x0068(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCameraShotPool">();
	}
	static class USparksCameraShotPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCameraShotPool>();
	}
};
static_assert(alignof(USparksCameraShotPool) == 0x000008, "Wrong alignment on USparksCameraShotPool");
static_assert(sizeof(USparksCameraShotPool) == 0x0000C8, "Wrong size on USparksCameraShotPool");
static_assert(offsetof(USparksCameraShotPool, Shots) == 0x000030, "Member 'USparksCameraShotPool::Shots' has a wrong offset!");
static_assert(offsetof(USparksCameraShotPool, bIgnoreShotTags) == 0x000040, "Member 'USparksCameraShotPool::bIgnoreShotTags' has a wrong offset!");
static_assert(offsetof(USparksCameraShotPool, PoolTags) == 0x000048, "Member 'USparksCameraShotPool::PoolTags' has a wrong offset!");
static_assert(offsetof(USparksCameraShotPool, PoolFilter) == 0x000068, "Member 'USparksCameraShotPool::PoolFilter' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksCameraDebugWidget
// 0x0000 (0x02C0 - 0x02C0)
class USparksCameraDebugWidget final : public UUserWidget
{
public:
	void ClearAll();
	void ClearCurrent();
	void LogToScreen(const class FString& Data, ESparksCameraLogType Type);
	void SetEventRouter(class UGameplayEventRouterComponent* EventRouter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCameraDebugWidget">();
	}
	static class USparksCameraDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCameraDebugWidget>();
	}
};
static_assert(alignof(USparksCameraDebugWidget) == 0x000008, "Wrong alignment on USparksCameraDebugWidget");
static_assert(sizeof(USparksCameraDebugWidget) == 0x0002C0, "Wrong size on USparksCameraDebugWidget");

// Class SparksCameraDirectorRuntime.SparksCameraDirectorComponent
// 0x01E0 (0x0280 - 0x00A0)
class alignas(0x10) USparksCameraDirectorComponent final : public UActorComponent
{
public:
	class USparksCameraDirectorConfig*            MainConfig;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USparksCameraDirectorConfig*            QAConfig;                                          // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USparksCameraDirectorConfig*            PerfConfig;                                        // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USparksCameraDirectorConfig*>    CustomConfig;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class USparksCameraDirectorConfig*            Config;                                            // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinShotTimeSeconds;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSparksCameraDirectorSequence>  Sequences;                                         // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class USparksPerformanceMap*                  PerformanceMap;                                    // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USparksCameraDebugWidget*               DebugWidget;                                       // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  IntermissionTags;                                  // 0x0100(0x0020)(Protected, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    SequenceActor;                                     // 0x0120(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USparksLevelSequencePlayer*             SequencePlayer;                                    // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCamerasAreActive;                                 // 0x0130(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCamerasAreLocked;                                 // 0x0131(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USparksCameraPluginDataProvider> DataProvider;                                      // 0x0134(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugTargetIndex;                                  // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentSequenceIndex;                              // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentSequenceEntryIndex;                         // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasActiveDynamicEvent;                            // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSparksCommonDynamicCameraDirectorEvent DynamicEvent;                                      // 0x0150(0x0038)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x18];                                     // 0x0188(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSparksCameraDirectorSequenceEntry     CurrentPlayingEntry;                               // 0x01A0(0x0080)(Protected, NativeAccessSpecifierProtected)
	struct FSparksCameraDirectorSequence          IntermissionSequence;                              // 0x0220(0x0028)(Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentIntermissionSequenceEntryIndex;             // 0x0248(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  LastKnownIntermissionTags;                         // 0x0250(0x0020)(Protected, NativeAccessSpecifierProtected)
	bool                                          bForceCameraViewTargetEnabled;                     // 0x0270(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EvalStartIndex;                                    // 0x0274(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EvalEndIndex;                                      // 0x0278(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateCameraControl(bool bActive);
	void DebugLockSpecificCameraShot(const struct FSparksCameraShot& Shot, bool bLockToFirstFrame, class AActor* Target);
	bool FindCurrentShot(int32* SequenceIndex, int32* EntryIndex);
	void HandleDirectorDynamicEvent(const struct FSparksCommonDynamicCameraDirectorEvent& Payload);
	void HandleForceIntermissionEvent(const struct FSparksCommonForceIntermissionCameraDirectorEvent& Payload);
	void HandleIntermissionTagsEvent(const struct FSparksCommonIntermissionCameraDirectorEvent& Payload);
	void InitDynamicCameras();
	void InsertPerformanceMap(class USparksPerformanceMap* Map);
	void InsertSequence(const struct FSparksCameraDirectorSequence& Sequence);
	void LogToScreen(const class FString& Data, ESparksCameraLogType Type, float TimeSeconds);
	void OnShotFinished();
	void PlayNextShot();
	void PlaySequenceEntry(const struct FSparksCameraDirectorSequenceEntry& Entry, float MsOffset, bool bIntermission, class AActor* ForceTarget);
	float PlayShot(const struct FSparksCameraDirectorSequenceEntry& Entry);
	void ReplaceWithNonCloseupShot(const struct FSparksCameraDirectorSequenceEntry& OldEntry);
	void Reset(bool bForceShotChange);
	void StartIntermissionCameras(float ForceLengthMS, bool bForceReloadNewSequence, bool bForceShotChange);

	bool GetCameraActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCameraDirectorComponent">();
	}
	static class USparksCameraDirectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCameraDirectorComponent>();
	}
};
static_assert(alignof(USparksCameraDirectorComponent) == 0x000010, "Wrong alignment on USparksCameraDirectorComponent");
static_assert(sizeof(USparksCameraDirectorComponent) == 0x000280, "Wrong size on USparksCameraDirectorComponent");
static_assert(offsetof(USparksCameraDirectorComponent, MainConfig) == 0x0000A0, "Member 'USparksCameraDirectorComponent::MainConfig' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, QAConfig) == 0x0000A8, "Member 'USparksCameraDirectorComponent::QAConfig' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, PerfConfig) == 0x0000B0, "Member 'USparksCameraDirectorComponent::PerfConfig' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, CustomConfig) == 0x0000B8, "Member 'USparksCameraDirectorComponent::CustomConfig' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, Config) == 0x0000C8, "Member 'USparksCameraDirectorComponent::Config' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, MinShotTimeSeconds) == 0x0000D8, "Member 'USparksCameraDirectorComponent::MinShotTimeSeconds' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, Sequences) == 0x0000E0, "Member 'USparksCameraDirectorComponent::Sequences' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, PerformanceMap) == 0x0000F0, "Member 'USparksCameraDirectorComponent::PerformanceMap' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, DebugWidget) == 0x0000F8, "Member 'USparksCameraDirectorComponent::DebugWidget' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, IntermissionTags) == 0x000100, "Member 'USparksCameraDirectorComponent::IntermissionTags' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, SequenceActor) == 0x000120, "Member 'USparksCameraDirectorComponent::SequenceActor' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, SequencePlayer) == 0x000128, "Member 'USparksCameraDirectorComponent::SequencePlayer' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, bCamerasAreActive) == 0x000130, "Member 'USparksCameraDirectorComponent::bCamerasAreActive' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, bCamerasAreLocked) == 0x000131, "Member 'USparksCameraDirectorComponent::bCamerasAreLocked' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, DataProvider) == 0x000134, "Member 'USparksCameraDirectorComponent::DataProvider' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, DebugTargetIndex) == 0x00013C, "Member 'USparksCameraDirectorComponent::DebugTargetIndex' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, CurrentSequenceIndex) == 0x000140, "Member 'USparksCameraDirectorComponent::CurrentSequenceIndex' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, CurrentSequenceEntryIndex) == 0x000144, "Member 'USparksCameraDirectorComponent::CurrentSequenceEntryIndex' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, bHasActiveDynamicEvent) == 0x000148, "Member 'USparksCameraDirectorComponent::bHasActiveDynamicEvent' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, DynamicEvent) == 0x000150, "Member 'USparksCameraDirectorComponent::DynamicEvent' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, CurrentPlayingEntry) == 0x0001A0, "Member 'USparksCameraDirectorComponent::CurrentPlayingEntry' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, IntermissionSequence) == 0x000220, "Member 'USparksCameraDirectorComponent::IntermissionSequence' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, CurrentIntermissionSequenceEntryIndex) == 0x000248, "Member 'USparksCameraDirectorComponent::CurrentIntermissionSequenceEntryIndex' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, LastKnownIntermissionTags) == 0x000250, "Member 'USparksCameraDirectorComponent::LastKnownIntermissionTags' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, bForceCameraViewTargetEnabled) == 0x000270, "Member 'USparksCameraDirectorComponent::bForceCameraViewTargetEnabled' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, EvalStartIndex) == 0x000274, "Member 'USparksCameraDirectorComponent::EvalStartIndex' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorComponent, EvalEndIndex) == 0x000278, "Member 'USparksCameraDirectorComponent::EvalEndIndex' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksCameraDirectorConfig
// 0x0148 (0x0178 - 0x0030)
class USparksCameraDirectorConfig final : public UDataAsset
{
public:
	float                                         MaxIntermissionShotTimeSeconds;                    // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGeneratedShotTimeSeconds;                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenSameShotSeconds;                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRetriesToFindShot;                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSparksCameraSectionWrapper            DefaultSequenceGenerator;                          // 0x0040(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class USparksCameraDirectorSequenceGenerator* RuntimeDefaultSequenceGenerator;                   // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSparksCameraSectionWrapper>    SequenceGenerators;                                // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class USparksCameraDirectorSequenceGenerator*> RuntimeSequenceGenerators;                         // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USparksCameraPluginDataProvider> DataProvider;                                      // 0x0110(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USparksCameraDebugWidget>   DebugWidgetClass;                                  // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class ULevelSequence*, struct FSparksCameraShotUses> ShotTimestamps;                                    // 0x0120(0x0050)(Protected, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USparksCameraDirectorSequenceGenerator* FindBestGenerator(const struct FSparksPerformanceMapSection& Section);
	bool GenerateEntry(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutEntry);
	bool GenerateSequence(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequence* OutSequence);
	void Init();
	void MarkShotTime(class ULevelSequence* Shot, float AtTimestamp);
	void ResetCache();
	bool ShouldUseShot(class ULevelSequence* Shot, float AtTimestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCameraDirectorConfig">();
	}
	static class USparksCameraDirectorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCameraDirectorConfig>();
	}
};
static_assert(alignof(USparksCameraDirectorConfig) == 0x000008, "Wrong alignment on USparksCameraDirectorConfig");
static_assert(sizeof(USparksCameraDirectorConfig) == 0x000178, "Wrong size on USparksCameraDirectorConfig");
static_assert(offsetof(USparksCameraDirectorConfig, MaxIntermissionShotTimeSeconds) == 0x000030, "Member 'USparksCameraDirectorConfig::MaxIntermissionShotTimeSeconds' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, MaxGeneratedShotTimeSeconds) == 0x000034, "Member 'USparksCameraDirectorConfig::MaxGeneratedShotTimeSeconds' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, MinTimeBetweenSameShotSeconds) == 0x000038, "Member 'USparksCameraDirectorConfig::MinTimeBetweenSameShotSeconds' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, MaxRetriesToFindShot) == 0x00003C, "Member 'USparksCameraDirectorConfig::MaxRetriesToFindShot' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, DefaultSequenceGenerator) == 0x000040, "Member 'USparksCameraDirectorConfig::DefaultSequenceGenerator' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, RuntimeDefaultSequenceGenerator) == 0x0000E8, "Member 'USparksCameraDirectorConfig::RuntimeDefaultSequenceGenerator' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, SequenceGenerators) == 0x0000F0, "Member 'USparksCameraDirectorConfig::SequenceGenerators' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, RuntimeSequenceGenerators) == 0x000100, "Member 'USparksCameraDirectorConfig::RuntimeSequenceGenerators' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, DataProvider) == 0x000110, "Member 'USparksCameraDirectorConfig::DataProvider' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, DebugWidgetClass) == 0x000118, "Member 'USparksCameraDirectorConfig::DebugWidgetClass' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, ShotTimestamps) == 0x000120, "Member 'USparksCameraDirectorConfig::ShotTimestamps' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorConfig, bInitialized) == 0x000170, "Member 'USparksCameraDirectorConfig::bInitialized' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksCameraPluginDataProvider
// 0x0010 (0x00B0 - 0x00A0)
class USparksCameraPluginDataProvider : public UActorComponent
{
public:
	TArray<struct FSparksCameraShot>              StaticShots;                                       // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	TArray<class AActor*> GetAllTargets();
	float GetCurrentMSTimeInCameraEvent();
	class AActor* GetMatchingCameraTarget(const struct FGameplayTagContainer& Tags, float ShotTimeMS, bool bPreferLocal);
	class AActor* GetTargetForCloseup(float ShotTimeMS, struct FGameplayTagContainer* TagsOut, bool bPreferLocal);
	bool GetTargetRelevantTags(class AActor* Target, struct FSparksCameraFilter* TagsOut);
	bool GetValidTimestamp(float DesiredTimestampMS, float* OutTimestampMSHigh, float* OutTimestampMSLow);

	bool GetStaticShot(int32 Index_0, struct FSparksCameraShot* OutShot) const;
	int32 GetStaticShotCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCameraPluginDataProvider">();
	}
	static class USparksCameraPluginDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCameraPluginDataProvider>();
	}
};
static_assert(alignof(USparksCameraPluginDataProvider) == 0x000008, "Wrong alignment on USparksCameraPluginDataProvider");
static_assert(sizeof(USparksCameraPluginDataProvider) == 0x0000B0, "Wrong size on USparksCameraPluginDataProvider");
static_assert(offsetof(USparksCameraPluginDataProvider, StaticShots) == 0x0000A0, "Member 'USparksCameraPluginDataProvider::StaticShots' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksCameraShotSelectRuleBase
// 0x0028 (0x0050 - 0x0028)
class USparksCameraShotSelectRuleBase : public UObject
{
public:
	bool                                          bIsInitialized;                                    // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USparksCameraShotPool*                  Pool;                                              // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 ShotIndexes;                                       // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         Index_0;                                           // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChooseShot(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutShot);
	bool Init(class USparksCameraShotPool* InPool);
	bool Reset();

	int32 GetShotCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCameraShotSelectRuleBase">();
	}
	static class USparksCameraShotSelectRuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCameraShotSelectRuleBase>();
	}
};
static_assert(alignof(USparksCameraShotSelectRuleBase) == 0x000008, "Wrong alignment on USparksCameraShotSelectRuleBase");
static_assert(sizeof(USparksCameraShotSelectRuleBase) == 0x000050, "Wrong size on USparksCameraShotSelectRuleBase");
static_assert(offsetof(USparksCameraShotSelectRuleBase, bIsInitialized) == 0x000028, "Member 'USparksCameraShotSelectRuleBase::bIsInitialized' has a wrong offset!");
static_assert(offsetof(USparksCameraShotSelectRuleBase, Pool) == 0x000030, "Member 'USparksCameraShotSelectRuleBase::Pool' has a wrong offset!");
static_assert(offsetof(USparksCameraShotSelectRuleBase, ShotIndexes) == 0x000038, "Member 'USparksCameraShotSelectRuleBase::ShotIndexes' has a wrong offset!");
static_assert(offsetof(USparksCameraShotSelectRuleBase, Index_0) == 0x000048, "Member 'USparksCameraShotSelectRuleBase::Index_0' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksCameraPoolSelectRuleBase
// 0x00E8 (0x0110 - 0x0028)
class USparksCameraPoolSelectRuleBase : public UObject
{
public:
	bool                                          bIsInitialized;                                    // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSparksCameraSectionWrapper            Wrapper;                                           // 0x0030(0x00A8)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 PoolIndexes;                                       // 0x00D8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class USparksCameraShotSelectRuleBase*> PoolRules;                                         // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class USparksCameraShotSelectRuleBase*        IntroPoolRule;                                     // 0x00F8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USparksCameraShotSelectRuleBase*        ExitPoolRule;                                      // 0x0100(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Index_0;                                           // 0x0108(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChooseExitShot(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutShot);
	bool ChooseIntroShot(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutShot);
	bool ChooseShot(const struct FSparksPerformanceMapSection& Section, struct FSparksCameraDirectorSequenceEntry* OutShot);
	bool Init(const struct FSparksCameraSectionWrapper& Section);
	bool Reset();

	int32 GetPoolCount() const;
	int32 GetShotCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCameraPoolSelectRuleBase">();
	}
	static class USparksCameraPoolSelectRuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCameraPoolSelectRuleBase>();
	}
};
static_assert(alignof(USparksCameraPoolSelectRuleBase) == 0x000008, "Wrong alignment on USparksCameraPoolSelectRuleBase");
static_assert(sizeof(USparksCameraPoolSelectRuleBase) == 0x000110, "Wrong size on USparksCameraPoolSelectRuleBase");
static_assert(offsetof(USparksCameraPoolSelectRuleBase, bIsInitialized) == 0x000028, "Member 'USparksCameraPoolSelectRuleBase::bIsInitialized' has a wrong offset!");
static_assert(offsetof(USparksCameraPoolSelectRuleBase, Wrapper) == 0x000030, "Member 'USparksCameraPoolSelectRuleBase::Wrapper' has a wrong offset!");
static_assert(offsetof(USparksCameraPoolSelectRuleBase, PoolIndexes) == 0x0000D8, "Member 'USparksCameraPoolSelectRuleBase::PoolIndexes' has a wrong offset!");
static_assert(offsetof(USparksCameraPoolSelectRuleBase, PoolRules) == 0x0000E8, "Member 'USparksCameraPoolSelectRuleBase::PoolRules' has a wrong offset!");
static_assert(offsetof(USparksCameraPoolSelectRuleBase, IntroPoolRule) == 0x0000F8, "Member 'USparksCameraPoolSelectRuleBase::IntroPoolRule' has a wrong offset!");
static_assert(offsetof(USparksCameraPoolSelectRuleBase, ExitPoolRule) == 0x000100, "Member 'USparksCameraPoolSelectRuleBase::ExitPoolRule' has a wrong offset!");
static_assert(offsetof(USparksCameraPoolSelectRuleBase, Index_0) == 0x000108, "Member 'USparksCameraPoolSelectRuleBase::Index_0' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksShotSelectRuleRandomized
// 0x0000 (0x0050 - 0x0050)
class USparksShotSelectRuleRandomized final : public USparksCameraShotSelectRuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksShotSelectRuleRandomized">();
	}
	static class USparksShotSelectRuleRandomized* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksShotSelectRuleRandomized>();
	}
};
static_assert(alignof(USparksShotSelectRuleRandomized) == 0x000008, "Wrong alignment on USparksShotSelectRuleRandomized");
static_assert(sizeof(USparksShotSelectRuleRandomized) == 0x000050, "Wrong size on USparksShotSelectRuleRandomized");

// Class SparksCameraDirectorRuntime.SparksShotSelectRuleSequential
// 0x0000 (0x0050 - 0x0050)
class USparksShotSelectRuleSequential final : public USparksCameraShotSelectRuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksShotSelectRuleSequential">();
	}
	static class USparksShotSelectRuleSequential* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksShotSelectRuleSequential>();
	}
};
static_assert(alignof(USparksShotSelectRuleSequential) == 0x000008, "Wrong alignment on USparksShotSelectRuleSequential");
static_assert(sizeof(USparksShotSelectRuleSequential) == 0x000050, "Wrong size on USparksShotSelectRuleSequential");

// Class SparksCameraDirectorRuntime.SparksShotSelectRuleScored
// 0x0000 (0x0050 - 0x0050)
class USparksShotSelectRuleScored final : public USparksCameraShotSelectRuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksShotSelectRuleScored">();
	}
	static class USparksShotSelectRuleScored* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksShotSelectRuleScored>();
	}
};
static_assert(alignof(USparksShotSelectRuleScored) == 0x000008, "Wrong alignment on USparksShotSelectRuleScored");
static_assert(sizeof(USparksShotSelectRuleScored) == 0x000050, "Wrong size on USparksShotSelectRuleScored");

// Class SparksCameraDirectorRuntime.SparksPoolSelectRuleRandomized
// 0x0000 (0x0110 - 0x0110)
class USparksPoolSelectRuleRandomized final : public USparksCameraPoolSelectRuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksPoolSelectRuleRandomized">();
	}
	static class USparksPoolSelectRuleRandomized* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksPoolSelectRuleRandomized>();
	}
};
static_assert(alignof(USparksPoolSelectRuleRandomized) == 0x000008, "Wrong alignment on USparksPoolSelectRuleRandomized");
static_assert(sizeof(USparksPoolSelectRuleRandomized) == 0x000110, "Wrong size on USparksPoolSelectRuleRandomized");

// Class SparksCameraDirectorRuntime.SparksPoolSelectRuleSequential
// 0x0000 (0x0110 - 0x0110)
class USparksPoolSelectRuleSequential final : public USparksCameraPoolSelectRuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksPoolSelectRuleSequential">();
	}
	static class USparksPoolSelectRuleSequential* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksPoolSelectRuleSequential>();
	}
};
static_assert(alignof(USparksPoolSelectRuleSequential) == 0x000008, "Wrong alignment on USparksPoolSelectRuleSequential");
static_assert(sizeof(USparksPoolSelectRuleSequential) == 0x000110, "Wrong size on USparksPoolSelectRuleSequential");

// Class SparksCameraDirectorRuntime.SparksPoolSelectRuleScored
// 0x0000 (0x0110 - 0x0110)
class USparksPoolSelectRuleScored final : public USparksCameraPoolSelectRuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksPoolSelectRuleScored">();
	}
	static class USparksPoolSelectRuleScored* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksPoolSelectRuleScored>();
	}
};
static_assert(alignof(USparksPoolSelectRuleScored) == 0x000008, "Wrong alignment on USparksPoolSelectRuleScored");
static_assert(sizeof(USparksPoolSelectRuleScored) == 0x000110, "Wrong size on USparksPoolSelectRuleScored");

// Class SparksCameraDirectorRuntime.SparksCameraDirectorSequenceGenerator
// 0x00C0 (0x00E8 - 0x0028)
class USparksCameraDirectorSequenceGenerator final : public UObject
{
public:
	bool                                          bIsInitialized;                                    // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSparksCameraSectionWrapper            SectionData;                                       // 0x0030(0x00A8)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USparksCameraPoolSelectRuleBase*        SelectionRule;                                     // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USparksCameraDirectorConfig*            CameraConfig;                                      // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ESparksSectionGeneratorResult GenerateEntry(const struct FSparksPerformanceMapSection& Section, class USparksCameraPluginDataProvider* DataProvider, struct FSparksCameraDirectorSequenceEntry* OutEntry);
	ESparksSectionGeneratorResult GenerateExitEntry(const struct FSparksPerformanceMapSection& Section, class USparksCameraPluginDataProvider* DataProvider, struct FSparksCameraDirectorSequenceEntry* OutEntry);
	ESparksSectionGeneratorResult GenerateIntroEntry(const struct FSparksPerformanceMapSection& Section, class USparksCameraPluginDataProvider* DataProvider, struct FSparksCameraDirectorSequenceEntry* OutEntry);
	ESparksSectionGeneratorResult GenerateSequence(const struct FSparksPerformanceMapSection& Section, class USparksCameraPluginDataProvider* DataProvider, struct FSparksCameraDirectorSequence* OutSequence);
	const struct FSparksCameraFilter GetFilter();
	bool Init(const struct FSparksCameraSectionWrapper& InPool, class USparksCameraDirectorConfig* Config);
	bool Reset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCameraDirectorSequenceGenerator">();
	}
	static class USparksCameraDirectorSequenceGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCameraDirectorSequenceGenerator>();
	}
};
static_assert(alignof(USparksCameraDirectorSequenceGenerator) == 0x000008, "Wrong alignment on USparksCameraDirectorSequenceGenerator");
static_assert(sizeof(USparksCameraDirectorSequenceGenerator) == 0x0000E8, "Wrong size on USparksCameraDirectorSequenceGenerator");
static_assert(offsetof(USparksCameraDirectorSequenceGenerator, bIsInitialized) == 0x000028, "Member 'USparksCameraDirectorSequenceGenerator::bIsInitialized' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorSequenceGenerator, SectionData) == 0x000030, "Member 'USparksCameraDirectorSequenceGenerator::SectionData' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorSequenceGenerator, SelectionRule) == 0x0000D8, "Member 'USparksCameraDirectorSequenceGenerator::SelectionRule' has a wrong offset!");
static_assert(offsetof(USparksCameraDirectorSequenceGenerator, CameraConfig) == 0x0000E0, "Member 'USparksCameraDirectorSequenceGenerator::CameraConfig' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksCamera_BPFL
// 0x0000 (0x0028 - 0x0028)
class USparksCamera_BPFL final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayTag GetSubTagForMidiEventName(const class FString& EventString);
	static struct FGameplayTag GetTagForMidiEventName(const class FString& EventString);
	static float ScoreTagContainers(const struct FGameplayTagContainer& Tags1, const struct FGameplayTagContainer& Tags2);
	static ESparksFilterResult ScoreTagsAgainstFilter(const struct FSparksCameraFilter& Filter, const struct FGameplayTagContainer& TagsToMatch, float* OutScore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksCamera_BPFL">();
	}
	static class USparksCamera_BPFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksCamera_BPFL>();
	}
};
static_assert(alignof(USparksCamera_BPFL) == 0x000008, "Wrong alignment on USparksCamera_BPFL");
static_assert(sizeof(USparksCamera_BPFL) == 0x000028, "Wrong size on USparksCamera_BPFL");

// Class SparksCameraDirectorRuntime.SparksDefaultLevelSequenceInstanceData
// 0x0080 (0x0120 - 0x00A0)
class USparksDefaultLevelSequenceInstanceData final : public UDefaultLevelSequenceInstanceData
{
public:
	class USkeletalMeshComponent*                 MeshToAttachTo;                                    // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x78];                                      // 0x00A8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksDefaultLevelSequenceInstanceData">();
	}
	static class USparksDefaultLevelSequenceInstanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksDefaultLevelSequenceInstanceData>();
	}
};
static_assert(alignof(USparksDefaultLevelSequenceInstanceData) == 0x000010, "Wrong alignment on USparksDefaultLevelSequenceInstanceData");
static_assert(sizeof(USparksDefaultLevelSequenceInstanceData) == 0x000120, "Wrong size on USparksDefaultLevelSequenceInstanceData");
static_assert(offsetof(USparksDefaultLevelSequenceInstanceData, MeshToAttachTo) == 0x0000A0, "Member 'USparksDefaultLevelSequenceInstanceData::MeshToAttachTo' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksLevelSequenceActor
// 0x0000 (0x0330 - 0x0330)
class ASparksLevelSequenceActor final : public ALevelSequenceActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksLevelSequenceActor">();
	}
	static class ASparksLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASparksLevelSequenceActor>();
	}
};
static_assert(alignof(ASparksLevelSequenceActor) == 0x000008, "Wrong alignment on ASparksLevelSequenceActor");
static_assert(sizeof(ASparksLevelSequenceActor) == 0x000330, "Wrong size on ASparksLevelSequenceActor");

// Class SparksCameraDirectorRuntime.SparksLevelSequencePlayer
// 0x0020 (0x0628 - 0x0608)
class USparksLevelSequencePlayer final : public ULevelSequencePlayer
{
public:
	class ACineCameraActor*                       SpawnedCamera;                                     // 0x0608(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedLookAtTraget;                               // 0x0618(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USparksLevelSequencePlayer* SparksCreateLevelSequencePlayer(class UObject* WorldContextObject, class ULevelSequence* LevelSequence, const struct FMovieSceneSequencePlaybackSettings& Settings, class ASparksLevelSequenceActor** OutActor, class USkeletalMeshComponent* TargetActor, const struct FSparksCameraShot& Shot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksLevelSequencePlayer">();
	}
	static class USparksLevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksLevelSequencePlayer>();
	}
};
static_assert(alignof(USparksLevelSequencePlayer) == 0x000008, "Wrong alignment on USparksLevelSequencePlayer");
static_assert(sizeof(USparksLevelSequencePlayer) == 0x000628, "Wrong size on USparksLevelSequencePlayer");
static_assert(offsetof(USparksLevelSequencePlayer, SpawnedCamera) == 0x000608, "Member 'USparksLevelSequencePlayer::SpawnedCamera' has a wrong offset!");
static_assert(offsetof(USparksLevelSequencePlayer, TargetMesh) == 0x000610, "Member 'USparksLevelSequencePlayer::TargetMesh' has a wrong offset!");
static_assert(offsetof(USparksLevelSequencePlayer, SpawnedLookAtTraget) == 0x000618, "Member 'USparksLevelSequencePlayer::SpawnedLookAtTraget' has a wrong offset!");

// Class SparksCameraDirectorRuntime.SparksPerformanceMap
// 0x0010 (0x0038 - 0x0028)
class USparksPerformanceMap final : public UObject
{
public:
	TArray<struct FSparksPerformanceMapSection>   Timeline;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void AddSection(float StartMS, const struct FGameplayTag& PrimaryTag, const struct FGameplayTagContainer& SecondaryTags);
	void FixupSectionTimeLengths();
	int32 InsertTimeline(class USparksPerformanceMap* Map, int32* OutFirstIndex, int32* OutLastIndex, bool bOverwrite);

	int32 GetNextSectionIndexAtTime(float TimeMS) const;
	int32 GetSectionIndexAtTime(float TimeMS) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SparksPerformanceMap">();
	}
	static class USparksPerformanceMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<USparksPerformanceMap>();
	}
};
static_assert(alignof(USparksPerformanceMap) == 0x000008, "Wrong alignment on USparksPerformanceMap");
static_assert(sizeof(USparksPerformanceMap) == 0x000038, "Wrong size on USparksPerformanceMap");
static_assert(offsetof(USparksPerformanceMap, Timeline) == 0x000028, "Member 'USparksPerformanceMap::Timeline' has a wrong offset!");

}

