#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: IrwinRuntime

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "IrwinRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"


namespace SDK
{

// Class IrwinRuntime.FortAIFaunaAnimInstance
// 0x0180 (0x0720 - 0x05A0)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAIFaunaAnimInstance : public UFortAIAnimInstance
{
public:
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AverageSpeed;                                      // 0x05A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageSpeedTimeFrame;                             // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasValidAimTarget;                                // 0x05A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimTime;                                           // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTargetLocation;                                 // 0x05B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurfaceSwimming;                                // 0x05C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGround;                                 // 0x05C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTornado;                                      // 0x05CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CB[0x1];                                      // 0x05CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlpha;                                       // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToPlayerForLookAt;                      // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTooFarFromPlayerTimeOut;                     // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLookAtDuringMontage;                       // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableHeadTrackingCurveName;                      // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRidingAnimationData                   RidingAnimationData;                               // 0x05E0(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSlopeSliding;                                   // 0x05F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeSlidingPitch;                                 // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeSlidingRoll;                                  // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RidingMovePlayRate;                                // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustGotPlayer;                                    // 0x0604(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBoosting;                                       // 0x0605(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurningInPlace;                                 // 0x0606(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_607[0x1];                                      // 0x0607(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceRotationSpeed;                          // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAngleDelta;                             // 0x060C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingBackwards;                                // 0x0610(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_611[0x3];                                      // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RiderReferentialYaw;                               // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostPlayRate;                                     // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnInPlaceAngleDeltaPositive;                  // 0x061C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayLandAdditive;                                 // 0x061D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61E[0x2];                                      // 0x061E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackwardVelocity;                                  // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayStopBackwards;                          // 0x0624(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwimmingYaw;                                       // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardsPlayRate;                                 // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyRoll;                                          // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngleStored;                                   // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasTurningRight;                                  // 0x0638(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERidingFootPhase                              FootPhase;                                         // 0x0639(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_FeetInAir;                            // 0x063A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_FrontFeetPlanted;                     // 0x063B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_BackFeetPlanted;                      // 0x063C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_LeftBackFeetForward;                  // 0x063D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_RightBackFeetForward;                 // 0x063E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_LeftPlantedRightPass;                 // 0x063F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFootPhase_RightPlantedLeftPass;                 // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x7];                                      // 0x0641(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SlipstreamTags;                                    // 0x0648(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsInSlipstream;                                   // 0x0668(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_669[0x7];                                      // 0x0669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SkydivingTags;                                     // 0x0670(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bMovementMode_Skydiving;                           // 0x0690(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_691[0x7];                                      // 0x0691(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SkytubingTags;                                     // 0x0698(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bGameplay_Status_Skytubing;                        // 0x06B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAbducted;                                       // 0x06B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BA[0x6];                                      // 0x06BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TractorBeamTags;                                   // 0x06C0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x06E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x06E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E2[0x2];                                      // 0x06E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JustGotPlayerInitialDelaySec;                      // 0x06E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x1C];                                     // 0x06E8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallAsleepAnimDuration;                            // 0x0704(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WakeUpAnimDuration;                                // 0x0708(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallAsleepToSleepingCrossfade;                     // 0x070C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WakeUpToIdleCrossfade;                             // 0x0710(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         StateTransition_FallAsleepToSleeping : 1;          // 0x0714(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_SleepingToWakeUp : 1;              // 0x0714(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_WakeUpToIdle : 1;                  // 0x0714(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_IdleToFallAsleep : 1;              // 0x0714(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_715[0x3];                                      // 0x0715(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateLookAtAlpha(bool bForceDisableLookAt, float DeltaSeconds);
	void FinishFootPhaseStopUpdate();
	void UpdateBackwardsPlayRate();
	void UpdateBackwardVelocity();
	void UpdateBodyRoll();
	void UpdateBoostPlayRate();
	void UpdateFootPhaseStop();
	void UpdatePlayLandAdditive();
	void UpdateRidingMovePlayRate();
	void UpdateSwimmingYaw();
	void UpdateTurnAngleStored();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance">();
	}
	static class UFortAIFaunaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAIFaunaAnimInstance) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance");
static_assert(sizeof(UFortAIFaunaAnimInstance) == 0x000720, "Wrong size on UFortAIFaunaAnimInstance");
static_assert(offsetof(UFortAIFaunaAnimInstance, AverageSpeed) == 0x0005A0, "Member 'UFortAIFaunaAnimInstance::AverageSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AverageSpeedTimeFrame) == 0x0005A4, "Member 'UFortAIFaunaAnimInstance::AverageSpeedTimeFrame' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bHasValidAimTarget) == 0x0005A8, "Member 'UFortAIFaunaAnimInstance::bHasValidAimTarget' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AimTime) == 0x0005AC, "Member 'UFortAIFaunaAnimInstance::AimTime' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AimTargetLocation) == 0x0005B0, "Member 'UFortAIFaunaAnimInstance::AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsSurfaceSwimming) == 0x0005C8, "Member 'UFortAIFaunaAnimInstance::bIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsMovingOnGround) == 0x0005C9, "Member 'UFortAIFaunaAnimInstance::bIsMovingOnGround' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsInTornado) == 0x0005CA, "Member 'UFortAIFaunaAnimInstance::bIsInTornado' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, LookAtAlpha) == 0x0005CC, "Member 'UFortAIFaunaAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, MaxDistanceToPlayerForLookAt) == 0x0005D0, "Member 'UFortAIFaunaAnimInstance::MaxDistanceToPlayerForLookAt' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, LookAtTooFarFromPlayerTimeOut) == 0x0005D4, "Member 'UFortAIFaunaAnimInstance::LookAtTooFarFromPlayerTimeOut' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bDisableLookAtDuringMontage) == 0x0005D8, "Member 'UFortAIFaunaAnimInstance::bDisableLookAtDuringMontage' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, DisableHeadTrackingCurveName) == 0x0005DC, "Member 'UFortAIFaunaAnimInstance::DisableHeadTrackingCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, RidingAnimationData) == 0x0005E0, "Member 'UFortAIFaunaAnimInstance::RidingAnimationData' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsSlopeSliding) == 0x0005F4, "Member 'UFortAIFaunaAnimInstance::bIsSlopeSliding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, SlopeSlidingPitch) == 0x0005F8, "Member 'UFortAIFaunaAnimInstance::SlopeSlidingPitch' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, SlopeSlidingRoll) == 0x0005FC, "Member 'UFortAIFaunaAnimInstance::SlopeSlidingRoll' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, RidingMovePlayRate) == 0x000600, "Member 'UFortAIFaunaAnimInstance::RidingMovePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bJustGotPlayer) == 0x000604, "Member 'UFortAIFaunaAnimInstance::bJustGotPlayer' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsBoosting) == 0x000605, "Member 'UFortAIFaunaAnimInstance::bIsBoosting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsTurningInPlace) == 0x000606, "Member 'UFortAIFaunaAnimInstance::bIsTurningInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, TurnInPlaceRotationSpeed) == 0x000608, "Member 'UFortAIFaunaAnimInstance::TurnInPlaceRotationSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, TurnInPlaceAngleDelta) == 0x00060C, "Member 'UFortAIFaunaAnimInstance::TurnInPlaceAngleDelta' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsMovingBackwards) == 0x000610, "Member 'UFortAIFaunaAnimInstance::bIsMovingBackwards' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, RiderReferentialYaw) == 0x000614, "Member 'UFortAIFaunaAnimInstance::RiderReferentialYaw' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, BoostPlayRate) == 0x000618, "Member 'UFortAIFaunaAnimInstance::BoostPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsTurnInPlaceAngleDeltaPositive) == 0x00061C, "Member 'UFortAIFaunaAnimInstance::bIsTurnInPlaceAngleDeltaPositive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bPlayLandAdditive) == 0x00061D, "Member 'UFortAIFaunaAnimInstance::bPlayLandAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, BackwardVelocity) == 0x000620, "Member 'UFortAIFaunaAnimInstance::BackwardVelocity' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bShouldPlayStopBackwards) == 0x000624, "Member 'UFortAIFaunaAnimInstance::bShouldPlayStopBackwards' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, SwimmingYaw) == 0x000628, "Member 'UFortAIFaunaAnimInstance::SwimmingYaw' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, BackwardsPlayRate) == 0x00062C, "Member 'UFortAIFaunaAnimInstance::BackwardsPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, BodyRoll) == 0x000630, "Member 'UFortAIFaunaAnimInstance::BodyRoll' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, TurnAngleStored) == 0x000634, "Member 'UFortAIFaunaAnimInstance::TurnAngleStored' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bWasTurningRight) == 0x000638, "Member 'UFortAIFaunaAnimInstance::bWasTurningRight' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, FootPhase) == 0x000639, "Member 'UFortAIFaunaAnimInstance::FootPhase' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsFootPhase_FeetInAir) == 0x00063A, "Member 'UFortAIFaunaAnimInstance::bIsFootPhase_FeetInAir' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsFootPhase_FrontFeetPlanted) == 0x00063B, "Member 'UFortAIFaunaAnimInstance::bIsFootPhase_FrontFeetPlanted' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsFootPhase_BackFeetPlanted) == 0x00063C, "Member 'UFortAIFaunaAnimInstance::bIsFootPhase_BackFeetPlanted' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsFootPhase_LeftBackFeetForward) == 0x00063D, "Member 'UFortAIFaunaAnimInstance::bIsFootPhase_LeftBackFeetForward' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsFootPhase_RightBackFeetForward) == 0x00063E, "Member 'UFortAIFaunaAnimInstance::bIsFootPhase_RightBackFeetForward' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsFootPhase_LeftPlantedRightPass) == 0x00063F, "Member 'UFortAIFaunaAnimInstance::bIsFootPhase_LeftPlantedRightPass' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsFootPhase_RightPlantedLeftPass) == 0x000640, "Member 'UFortAIFaunaAnimInstance::bIsFootPhase_RightPlantedLeftPass' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, SlipstreamTags) == 0x000648, "Member 'UFortAIFaunaAnimInstance::SlipstreamTags' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsInSlipstream) == 0x000668, "Member 'UFortAIFaunaAnimInstance::bIsInSlipstream' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, SkydivingTags) == 0x000670, "Member 'UFortAIFaunaAnimInstance::SkydivingTags' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bMovementMode_Skydiving) == 0x000690, "Member 'UFortAIFaunaAnimInstance::bMovementMode_Skydiving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, SkytubingTags) == 0x000698, "Member 'UFortAIFaunaAnimInstance::SkytubingTags' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bGameplay_Status_Skytubing) == 0x0006B8, "Member 'UFortAIFaunaAnimInstance::bGameplay_Status_Skytubing' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsAbducted) == 0x0006B9, "Member 'UFortAIFaunaAnimInstance::bIsAbducted' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, TractorBeamTags) == 0x0006C0, "Member 'UFortAIFaunaAnimInstance::TractorBeamTags' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsInTractorBeam) == 0x0006E0, "Member 'UFortAIFaunaAnimInstance::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsFloating) == 0x0006E1, "Member 'UFortAIFaunaAnimInstance::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, JustGotPlayerInitialDelaySec) == 0x0006E4, "Member 'UFortAIFaunaAnimInstance::JustGotPlayerInitialDelaySec' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, FallAsleepAnimDuration) == 0x000704, "Member 'UFortAIFaunaAnimInstance::FallAsleepAnimDuration' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, WakeUpAnimDuration) == 0x000708, "Member 'UFortAIFaunaAnimInstance::WakeUpAnimDuration' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, FallAsleepToSleepingCrossfade) == 0x00070C, "Member 'UFortAIFaunaAnimInstance::FallAsleepToSleepingCrossfade' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, WakeUpToIdleCrossfade) == 0x000710, "Member 'UFortAIFaunaAnimInstance::WakeUpToIdleCrossfade' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Grandma
// 0x00C0 (0x07E0 - 0x0720)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAIFaunaAnimInstance_Grandma : public UFortAIFaunaAnimInstance
{
public:
	class AFortAIPawn*                            AIPawn;                                            // 0x0718(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshScale;                                         // 0x0720(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayFullBodyInPlace;                        // 0x0724(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_725[0x3];                                      // 0x0725(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkAlpha;                                        // 0x0728(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunPlayRate;                                   // 0x072C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x0730(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSniffAdditive;                              // 0x0734(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAlertAdditive;                              // 0x0735(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleStartTurn;                                    // 0x0736(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtAdditiveTurnAlpha;                          // 0x0737(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0738(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_739[0x3];                                      // 0x0739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x073C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0740(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x0744(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_745[0x3];                                      // 0x0745(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceModulatedSpeed;                         // 0x0748(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedFullBodyInPlace;                           // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCurveValueFullBodyInPlace;                      // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlphaInterpRate;             // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SniffAdditiveFrequenceySeconds;                    // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlertAdditiveFrequenceySeconds;                    // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnIDScale;                                       // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShouldPlayFullBodyInPlaceCurveName;                // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlinkAlphaCurveName;                               // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleStartTurnInterruptibleThreshold;               // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAdditiveTurnAlphaThreshold;                  // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceModulatedSpeedFactor;                   // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGroundORIsSurfaceSwimming;              // 0x0794(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_DefaultJump_ToJumpApex;                 // 0x0795(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Idle;                          // 0x0796(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Moving;                        // 0x0797(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnIdle;                        // 0x0798(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_Moving;                      // 0x0799(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnMoving;                      // 0x079A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x079B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_Idle;                            // 0x079C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpLand_Idle;                          // 0x079D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpLand_Moving;                        // 0x079E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpStart_JumpApex;                     // 0x079F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Moving;                            // 0x07A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Idle;                              // 0x07A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimIdle_SwimLoco;                      // 0x07A2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimLoco_SwimIdle;                      // 0x07A3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimIdle;                      // 0x07A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimLoco;                      // 0x07A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRule_NegativeTurnAngle;                       // 0x07A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A7[0x1];                                      // 0x07A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterruptibleMaxCheck;                             // 0x07A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedStopTransition;                               // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleMoveTransition;                           // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMovingTurnIdleTransition;                     // 0x07B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMin;                                    // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMinWhileRiding;                         // 0x07BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMinWhileAcceleratingAndRiding;          // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeFromEndThreshold;                         // 0x07C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleStartTurnThreshold;                       // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedFallMovingThreshold;                          // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D0[0x8];                                      // 0x07D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateBlinkAlpha();
	float CalculateLocomotionPoseAlpha();
	float CalculateMeshScale();
	float CalculateWalkRunPlayRate();
	bool DetermineEnableAlertAdditive();
	bool DetermineEnableSniffAdditive();
	bool DetermineIdleStartTurn();
	bool DetermineShouldPlayFullBodyInPlace();
	void UpdateBlinkAlpha();
	void UpdateEnableAlertAdditive();
	void UpdateEnableSniffAdditive();
	void UpdateIdleStartTurn();
	void UpdateLocomotionPoseAlpha();
	void UpdateMeshScale();
	void UpdateMovingRates();
	void UpdateShouldPlayFullBodyInPlace();
	void UpdateStateVariables(const bool bAccelerating);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Grandma">();
	}
	static class UFortAIFaunaAnimInstance_Grandma* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Grandma>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAIFaunaAnimInstance_Grandma) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Grandma");
static_assert(sizeof(UFortAIFaunaAnimInstance_Grandma) == 0x0007E0, "Wrong size on UFortAIFaunaAnimInstance_Grandma");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, AIPawn) == 0x000718, "Member 'UFortAIFaunaAnimInstance_Grandma::AIPawn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MeshScale) == 0x000720, "Member 'UFortAIFaunaAnimInstance_Grandma::MeshScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bShouldPlayFullBodyInPlace) == 0x000724, "Member 'UFortAIFaunaAnimInstance_Grandma::bShouldPlayFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, BlinkAlpha) == 0x000728, "Member 'UFortAIFaunaAnimInstance_Grandma::BlinkAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, WalkRunPlayRate) == 0x00072C, "Member 'UFortAIFaunaAnimInstance_Grandma::WalkRunPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LocomotionPoseAdditiveAlpha) == 0x000730, "Member 'UFortAIFaunaAnimInstance_Grandma::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bEnableSniffAdditive) == 0x000734, "Member 'UFortAIFaunaAnimInstance_Grandma::bEnableSniffAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bEnableAlertAdditive) == 0x000735, "Member 'UFortAIFaunaAnimInstance_Grandma::bEnableAlertAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIdleStartTurn) == 0x000736, "Member 'UFortAIFaunaAnimInstance_Grandma::bIdleStartTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bLookAtAdditiveTurnAlpha) == 0x000737, "Member 'UFortAIFaunaAnimInstance_Grandma::bLookAtAdditiveTurnAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIsIdleShuffleTurn) == 0x000738, "Member 'UFortAIFaunaAnimInstance_Grandma::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleBodyBend) == 0x00073C, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRate) == 0x000740, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIdleShuffleTurnDirection) == 0x000744, "Member 'UFortAIFaunaAnimInstance_Grandma::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, TurnInPlaceModulatedSpeed) == 0x000748, "Member 'UFortAIFaunaAnimInstance_Grandma::TurnInPlaceModulatedSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MaxSpeedFullBodyInPlace) == 0x00074C, "Member 'UFortAIFaunaAnimInstance_Grandma::MaxSpeedFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MinCurveValueFullBodyInPlace) == 0x000750, "Member 'UFortAIFaunaAnimInstance_Grandma::MinCurveValueFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LocomotionPoseAdditiveAlphaInterpRate) == 0x000754, "Member 'UFortAIFaunaAnimInstance_Grandma::LocomotionPoseAdditiveAlphaInterpRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SniffAdditiveFrequenceySeconds) == 0x000758, "Member 'UFortAIFaunaAnimInstance_Grandma::SniffAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, AlertAdditiveFrequenceySeconds) == 0x00075C, "Member 'UFortAIFaunaAnimInstance_Grandma::AlertAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, PawnIDScale) == 0x000760, "Member 'UFortAIFaunaAnimInstance_Grandma::PawnIDScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, ShouldPlayFullBodyInPlaceCurveName) == 0x000764, "Member 'UFortAIFaunaAnimInstance_Grandma::ShouldPlayFullBodyInPlaceCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, BlinkAlphaCurveName) == 0x000768, "Member 'UFortAIFaunaAnimInstance_Grandma::BlinkAlphaCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleStartTurnInterruptibleThreshold) == 0x00076C, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleStartTurnInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleBodyBendMultiplier) == 0x000770, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleTurnThreshold) == 0x000774, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleTurnDirectionThreshold) == 0x000778, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LookAtAdditiveTurnAlphaThreshold) == 0x00077C, "Member 'UFortAIFaunaAnimInstance_Grandma::LookAtAdditiveTurnAlphaThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateInRangeA) == 0x000780, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateInRangeB) == 0x000784, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateOutRangeA) == 0x000788, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateOutRangeB) == 0x00078C, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, TurnInPlaceModulatedSpeedFactor) == 0x000790, "Member 'UFortAIFaunaAnimInstance_Grandma::TurnInPlaceModulatedSpeedFactor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIsMovingOnGroundORIsSurfaceSwimming) == 0x000794, "Member 'UFortAIFaunaAnimInstance_Grandma::bIsMovingOnGroundORIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_DefaultJump_ToJumpApex) == 0x000795, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_DefaultJump_ToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnIdle_Idle) == 0x000796, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnIdle_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnIdle_Moving) == 0x000797, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnIdle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_TurnIdle) == 0x000798, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnMoving_Moving) == 0x000799, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnMoving_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_TurnMoving) == 0x00079A, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_TurnMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Idle_Moving) == 0x00079B, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_Idle) == 0x00079C, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpLand_Idle) == 0x00079D, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpLand_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpLand_Moving) == 0x00079E, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpLand_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpStart_JumpApex) == 0x00079F, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpStart_JumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Fall_Moving) == 0x0007A0, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Fall_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Fall_Idle) == 0x0007A1, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Fall_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimIdle_SwimLoco) == 0x0007A2, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimIdle_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimLoco_SwimIdle) == 0x0007A3, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimLoco_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimTurn_SwimIdle) == 0x0007A4, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimTurn_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimTurn_SwimLoco) == 0x0007A5, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimTurn_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bAnimRule_NegativeTurnAngle) == 0x0007A6, "Member 'UFortAIFaunaAnimInstance_Grandma::bAnimRule_NegativeTurnAngle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, InterruptibleMaxCheck) == 0x0007A8, "Member 'UFortAIFaunaAnimInstance_Grandma::InterruptibleMaxCheck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedStopTransition) == 0x0007AC, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedStopTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedIdleMoveTransition) == 0x0007B0, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedIdleMoveTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedMovingTurnIdleTransition) == 0x0007B4, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedMovingTurnIdleTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedToMoveMin) == 0x0007B8, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedToMoveMin' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedToMoveMinWhileRiding) == 0x0007BC, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedToMoveMinWhileRiding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedToMoveMinWhileAcceleratingAndRiding) == 0x0007C0, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedToMoveMinWhileAcceleratingAndRiding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, StateTimeFromEndThreshold) == 0x0007C4, "Member 'UFortAIFaunaAnimInstance_Grandma::StateTimeFromEndThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedIdleStartTurnThreshold) == 0x0007C8, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedIdleStartTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedFallMovingThreshold) == 0x0007CC, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedFallMovingThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Grandma_Hitchhiker
// 0x0000 (0x07E0 - 0x07E0)
class UFortAIFaunaAnimInstance_Grandma_Hitchhiker final : public UFortAIFaunaAnimInstance_Grandma
{
public:
	bool                                          bIsHitchhiked;                                     // 0x07D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrandmaSprinting;                               // 0x07D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DA[0x2];                                      // 0x07DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintCheckSpeed;                                  // 0x07DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Grandma_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Grandma_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Grandma_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Grandma_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker) == 0x0007E0, "Wrong size on UFortAIFaunaAnimInstance_Grandma_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsHitchhiked) == 0x0007D8, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsHitchhiked' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsGrandmaSprinting) == 0x0007D9, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsGrandmaSprinting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, SprintCheckSpeed) == 0x0007DC, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::SprintCheckSpeed' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Burt
// 0x00A0 (0x07C0 - 0x0720)
class UFortAIFaunaAnimInstance_Burt : public UFortAIFaunaAnimInstance
{
public:
	float                                         MovingPlayRate;                                    // 0x0718(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x071C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadTiltUpAdditive;                         // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAngleIsNegative;                              // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_722[0x2];                                      // 0x0722(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableLocomotionAdditiveCurveName;                // 0x0724(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InterruptibleCurveName;                            // 0x0728(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x072C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72D[0x3];                                      // 0x072D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x0730(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0734(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x0738(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0739(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToApex;                          // 0x073A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToMoving;                        // 0x073B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionMovingToIdle;                        // 0x073C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLandToIdle;                          // 0x073D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLandToJumpStart;                     // 0x073E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpStartToApex;                     // 0x073F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionApexToFall;                          // 0x0740(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToLand;                          // 0x0741(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToIdle;                      // 0x0742(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToIdle;                // 0x0743(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToMoving;              // 0x0744(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToMoving;                    // 0x0745(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToMoving;                        // 0x0746(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToIdle;                          // 0x0747(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SpeedThreshold;                     // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SlowSpeedDivisor;                   // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_FastSpeedDivisor;                   // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MinClamp;                           // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MaxClamp;                           // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_InterpSpeed;                        // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha_InterpSpeed;           // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier;   // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableHeadTiltUpAdditive_ModOperand;               // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_LargeThreshold;            // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_TurnAngleThreshold;        // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_MovingThreshold;                             // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_IdleThreshold;                               // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle_LargeThreshold;                          // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_RidingMovingThreshold;                       // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_RidingIdleThreshold;                         // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x0794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedSlowRidingMovePlayRate;                    // 0x07A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedSlowDivisorRidingMovePlayRate;                // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapRangeClamped_Ranges                RidingMovePlayRate_Ranges;                         // 0x07AC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Burt">();
	}
	static class UFortAIFaunaAnimInstance_Burt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Burt>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Burt) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Burt");
static_assert(sizeof(UFortAIFaunaAnimInstance_Burt) == 0x0007C0, "Wrong size on UFortAIFaunaAnimInstance_Burt");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate) == 0x000718, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, LocomotionPoseAdditiveAlpha) == 0x00071C, "Member 'UFortAIFaunaAnimInstance_Burt::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bEnableHeadTiltUpAdditive) == 0x000720, "Member 'UFortAIFaunaAnimInstance_Burt::bEnableHeadTiltUpAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bTurnAngleIsNegative) == 0x000721, "Member 'UFortAIFaunaAnimInstance_Burt::bTurnAngleIsNegative' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, DisableLocomotionAdditiveCurveName) == 0x000724, "Member 'UFortAIFaunaAnimInstance_Burt::DisableLocomotionAdditiveCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveName) == 0x000728, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIsIdleShuffleTurn) == 0x00072C, "Member 'UFortAIFaunaAnimInstance_Burt::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleBodyBend) == 0x000730, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRate) == 0x000734, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIdleShuffleTurnDirection) == 0x000738, "Member 'UFortAIFaunaAnimInstance_Burt::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIsMoving) == 0x000739, "Member 'UFortAIFaunaAnimInstance_Burt::bIsMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleToApex) == 0x00073A, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleToApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleToMoving) == 0x00073B, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionMovingToIdle) == 0x00073C, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionMovingToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLandToIdle) == 0x00073D, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLandToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLandToJumpStart) == 0x00073E, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLandToJumpStart' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionJumpStartToApex) == 0x00073F, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionJumpStartToApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionApexToFall) == 0x000740, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionApexToFall' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToLand) == 0x000741, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleTurnToIdle) == 0x000742, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLocomotionTurnToIdle) == 0x000743, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLocomotionTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLocomotionTurnToMoving) == 0x000744, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLocomotionTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleTurnToMoving) == 0x000745, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToMoving) == 0x000746, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToIdle) == 0x000747, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_SpeedThreshold) == 0x000748, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_SlowSpeedDivisor) == 0x00074C, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_SlowSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_FastSpeedDivisor) == 0x000750, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_FastSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_MinClamp) == 0x000754, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_MinClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_MaxClamp) == 0x000758, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_MaxClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_InterpSpeed) == 0x00075C, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, LocomotionPoseAdditiveAlpha_InterpSpeed) == 0x000760, "Member 'UFortAIFaunaAnimInstance_Burt::LocomotionPoseAdditiveAlpha_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier) == 0x000764, "Member 'UFortAIFaunaAnimInstance_Burt::EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, EnableHeadTiltUpAdditive_ModOperand) == 0x000768, "Member 'UFortAIFaunaAnimInstance_Burt::EnableHeadTiltUpAdditive_ModOperand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveValue_LargeThreshold) == 0x00076C, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveValue_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveValue_TurnAngleThreshold) == 0x000770, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveValue_TurnAngleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_MovingThreshold) == 0x000774, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_MovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_IdleThreshold) == 0x000778, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_IdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, TurnAngle_LargeThreshold) == 0x00077C, "Member 'UFortAIFaunaAnimInstance_Burt::TurnAngle_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_RidingMovingThreshold) == 0x000780, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_RidingMovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_RidingIdleThreshold) == 0x000784, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_RidingIdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleBodyBendMultiplier) == 0x000788, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleTurnThreshold) == 0x00078C, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleTurnDirectionThreshold) == 0x000790, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateInRangeA) == 0x000794, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateInRangeB) == 0x000798, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateOutRangeA) == 0x00079C, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateOutRangeB) == 0x0007A0, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MinSpeedSlowRidingMovePlayRate) == 0x0007A4, "Member 'UFortAIFaunaAnimInstance_Burt::MinSpeedSlowRidingMovePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, SpeedSlowDivisorRidingMovePlayRate) == 0x0007A8, "Member 'UFortAIFaunaAnimInstance_Burt::SpeedSlowDivisorRidingMovePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, RidingMovePlayRate_Ranges) == 0x0007AC, "Member 'UFortAIFaunaAnimInstance_Burt::RidingMovePlayRate_Ranges' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Burt_Hitchhiker
// 0x0010 (0x07D0 - 0x07C0)
class UFortAIFaunaAnimInstance_Burt_Hitchhiker final : public UFortAIFaunaAnimInstance_Burt
{
public:
	bool                                          IsFloating;                                        // 0x07C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInTractorBeam;                                   // 0x07C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHitchhiked;                                      // 0x07C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C3[0xD];                                      // 0x07C3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Burt_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Burt_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Burt_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Burt_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Burt_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Burt_Hitchhiker) == 0x0007D0, "Wrong size on UFortAIFaunaAnimInstance_Burt_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsFloating) == 0x0007C0, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsInTractorBeam) == 0x0007C1, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsHitchhiked) == 0x0007C2, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsHitchhiked' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Crow
// 0x0030 (0x0750 - 0x0720)
class UFortAIFaunaAnimInstance_Crow final : public UFortAIFaunaAnimInstance
{
public:
	float                                         WingFlapPlayRate;                                  // 0x0718(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDescending;                                     // 0x071C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGliding;                                        // 0x071D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlying;                                         // 0x071E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlyingSlow;                                     // 0x071F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLanding;                                        // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WingFlapPlayRateInRangeA;                          // 0x0724(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateInRangeB;                          // 0x0728(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateOutRangeA;                         // 0x072C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateOutRangeB;                         // 0x0730(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZVelocityDescendingThreshold;                      // 0x0734(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingSpeedThreshold;                             // 0x0738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingSpeedThreshold;                              // 0x073C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingSlowSpeedThreshold;                          // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingSpeedThreshold;                             // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Crow">();
	}
	static class UFortAIFaunaAnimInstance_Crow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Crow>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Crow) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Crow");
static_assert(sizeof(UFortAIFaunaAnimInstance_Crow) == 0x000750, "Wrong size on UFortAIFaunaAnimInstance_Crow");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRate) == 0x000718, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsDescending) == 0x00071C, "Member 'UFortAIFaunaAnimInstance_Crow::bIsDescending' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsGliding) == 0x00071D, "Member 'UFortAIFaunaAnimInstance_Crow::bIsGliding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsFlying) == 0x00071E, "Member 'UFortAIFaunaAnimInstance_Crow::bIsFlying' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsFlyingSlow) == 0x00071F, "Member 'UFortAIFaunaAnimInstance_Crow::bIsFlyingSlow' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsLanding) == 0x000720, "Member 'UFortAIFaunaAnimInstance_Crow::bIsLanding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateInRangeA) == 0x000724, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateInRangeB) == 0x000728, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateOutRangeA) == 0x00072C, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateOutRangeB) == 0x000730, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, ZVelocityDescendingThreshold) == 0x000734, "Member 'UFortAIFaunaAnimInstance_Crow::ZVelocityDescendingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, GlidingSpeedThreshold) == 0x000738, "Member 'UFortAIFaunaAnimInstance_Crow::GlidingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, FlyingSpeedThreshold) == 0x00073C, "Member 'UFortAIFaunaAnimInstance_Crow::FlyingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, FlyingSlowSpeedThreshold) == 0x000740, "Member 'UFortAIFaunaAnimInstance_Crow::FlyingSlowSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, LandingSpeedThreshold) == 0x000744, "Member 'UFortAIFaunaAnimInstance_Crow::LandingSpeedThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Nug
// 0x0090 (0x07B0 - 0x0720)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAIFaunaAnimInstance_Nug : public UFortAIFaunaAnimInstance
{
public:
	bool                                          bIsBeingHeld;                                      // 0x0718(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingThrown;                                    // 0x0719(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71A[0x2];                                      // 0x071A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerBodyMaskAlpha;                                // 0x071C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExitJump;                                   // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingPlayRate;                                    // 0x0724(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLean;                                       // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_729[0x3];                                      // 0x0729(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanDirection;                                     // 0x072C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAngleIsNegative;                              // 0x0730(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_731[0x3];                                      // 0x0731(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InterruptibleCurveName;                            // 0x0734(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0738(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_739[0x3];                                      // 0x0739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x073C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0740(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x0744(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToIdleTurn;                      // 0x0745(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToLocomotionTurn;                // 0x0746(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToMoving;                        // 0x0747(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToJumpApex;                      // 0x0748(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionMovingToIdle;                        // 0x0749(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpStartToJumpApex;                 // 0x074A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpApexToJumpLoop;                  // 0x074B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToIdle;                // 0x074C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToMoving;              // 0x074D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToMoving;                    // 0x074E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToIdle;                      // 0x074F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpLoopToJumpLand;                  // 0x0750(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIsBeingHeldToChickenChuck;           // 0x0751(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_752[0x2];                                      // 0x0752(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShouldExitJump_SpeedThreshold;                     // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SpeedThreshold;                     // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SlowSpeedDivisor;                   // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_FastSpeedDivisor;                   // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_InterpSpeed;                        // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MinClamp;                           // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MaxClamp;                           // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanDirection_SpeedThreshold;                      // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShouldLean_SpeedThreshold;                         // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_LargeThreshold;            // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_MovingThreshold;                             // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_IdleThreshold;                               // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTurnTransition_SpeedThreshold;                 // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionTurnTransition_SpeedThreshold;           // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Nug">();
	}
	static class UFortAIFaunaAnimInstance_Nug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Nug>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAIFaunaAnimInstance_Nug) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Nug");
static_assert(sizeof(UFortAIFaunaAnimInstance_Nug) == 0x0007B0, "Wrong size on UFortAIFaunaAnimInstance_Nug");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsBeingHeld) == 0x000718, "Member 'UFortAIFaunaAnimInstance_Nug::bIsBeingHeld' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsBeingThrown) == 0x000719, "Member 'UFortAIFaunaAnimInstance_Nug::bIsBeingThrown' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LowerBodyMaskAlpha) == 0x00071C, "Member 'UFortAIFaunaAnimInstance_Nug::LowerBodyMaskAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bShouldExitJump) == 0x000720, "Member 'UFortAIFaunaAnimInstance_Nug::bShouldExitJump' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate) == 0x000724, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bShouldLean) == 0x000728, "Member 'UFortAIFaunaAnimInstance_Nug::bShouldLean' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LeanDirection) == 0x00072C, "Member 'UFortAIFaunaAnimInstance_Nug::LeanDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bTurnAngleIsNegative) == 0x000730, "Member 'UFortAIFaunaAnimInstance_Nug::bTurnAngleIsNegative' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, InterruptibleCurveName) == 0x000734, "Member 'UFortAIFaunaAnimInstance_Nug::InterruptibleCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsIdleShuffleTurn) == 0x000738, "Member 'UFortAIFaunaAnimInstance_Nug::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleBodyBend) == 0x00073C, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRate) == 0x000740, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIdleShuffleTurnDirection) == 0x000744, "Member 'UFortAIFaunaAnimInstance_Nug::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToIdleTurn) == 0x000745, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToIdleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToLocomotionTurn) == 0x000746, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToLocomotionTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToMoving) == 0x000747, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToJumpApex) == 0x000748, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionMovingToIdle) == 0x000749, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionMovingToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpStartToJumpApex) == 0x00074A, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpStartToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpApexToJumpLoop) == 0x00074B, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpApexToJumpLoop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionLocomotionTurnToIdle) == 0x00074C, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionLocomotionTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionLocomotionTurnToMoving) == 0x00074D, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionLocomotionTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleTurnToMoving) == 0x00074E, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleTurnToIdle) == 0x00074F, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpLoopToJumpLand) == 0x000750, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpLoopToJumpLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIsBeingHeldToChickenChuck) == 0x000751, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIsBeingHeldToChickenChuck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, ShouldExitJump_SpeedThreshold) == 0x000754, "Member 'UFortAIFaunaAnimInstance_Nug::ShouldExitJump_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_SpeedThreshold) == 0x000758, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_SlowSpeedDivisor) == 0x00075C, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_SlowSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_FastSpeedDivisor) == 0x000760, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_FastSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_InterpSpeed) == 0x000764, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_MinClamp) == 0x000768, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_MinClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_MaxClamp) == 0x00076C, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_MaxClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LeanDirection_SpeedThreshold) == 0x000770, "Member 'UFortAIFaunaAnimInstance_Nug::LeanDirection_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, ShouldLean_SpeedThreshold) == 0x000774, "Member 'UFortAIFaunaAnimInstance_Nug::ShouldLean_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, InterruptibleCurveValue_LargeThreshold) == 0x000778, "Member 'UFortAIFaunaAnimInstance_Nug::InterruptibleCurveValue_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, Speed_MovingThreshold) == 0x00077C, "Member 'UFortAIFaunaAnimInstance_Nug::Speed_MovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, Speed_IdleThreshold) == 0x000780, "Member 'UFortAIFaunaAnimInstance_Nug::Speed_IdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleTurnTransition_SpeedThreshold) == 0x000784, "Member 'UFortAIFaunaAnimInstance_Nug::IdleTurnTransition_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LocomotionTurnTransition_SpeedThreshold) == 0x000788, "Member 'UFortAIFaunaAnimInstance_Nug::LocomotionTurnTransition_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleBodyBendMultiplier) == 0x00078C, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleTurnThreshold) == 0x000790, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleTurnDirectionThreshold) == 0x000794, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateInRangeA) == 0x000798, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateInRangeB) == 0x00079C, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateOutRangeA) == 0x0007A0, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateOutRangeB) == 0x0007A4, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateOutRangeB' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Nug_Hitchhiker
// 0x0000 (0x07B0 - 0x07B0)
class UFortAIFaunaAnimInstance_Nug_Hitchhiker final : public UFortAIFaunaAnimInstance_Nug
{
public:
	bool                                          bIsSwimming;                                       // 0x07A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHitchhiked;                                     // 0x07A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7AA[0x6];                                      // 0x07AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Nug_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Nug_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Nug_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Nug_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Nug_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Nug_Hitchhiker) == 0x0007B0, "Wrong size on UFortAIFaunaAnimInstance_Nug_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsSwimming) == 0x0007A8, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsHitchhiked) == 0x0007A9, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsHitchhiked' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Robert
// 0x01B0 (0x08D0 - 0x0720)
class UFortAIFaunaAnimInstance_Robert final : public UFortAIFaunaAnimInstance
{
public:
	uint8                                         Pad_718[0x8];                                      // 0x0718(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            AIPawn;                                            // 0x0720(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleStartTurn;                                    // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadTiltDownAdditive;                       // 0x0729(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFullBodyInPlace;                                // 0x072A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72B[0x1];                                      // 0x072B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x072C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0730(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_731[0x3];                                      // 0x0731(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x0734(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0738(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x073C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtAdditiveTurnAlpha;                          // 0x073D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnDirection;                                    // 0x073E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73F[0x1];                                      // 0x073F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PawnIDScale;                                       // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadTiltDownAdditiveFrequenceySeconds;             // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceFullBodyTransition;                           // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlphaInterpRate;             // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleStartTurnInterruptibleThreshold;               // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlphaThreshold;                              // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMovingThreshold;                              // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDirectionThreshold;                            // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintStopThreshold;                               // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkStopThreshold;                                 // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardStopThreshold;                             // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveInterruptibleThreshold;                    // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleThreshold;                            // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningRightThreshold;                             // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftFootStopThreshold;                             // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipInterpSpeed_Fast;                               // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipInterpSpeed_Slow;                               // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveHipAlphaTargeting_Constant;                // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardLocomotionThreshold;                       // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionThreshold;                               // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnSpeedThreshold;                                // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPlayRate_Fixed;                          // 0x0794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostJumpingThreshold;                             // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostStartPosition_Jumping;                        // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostStartPosition_NotJumping;                     // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyTurnSwimInRangeA;                      // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyTurnSwimInRangeB;                      // 0x07A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyTurnSwimOutRangeA;                     // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyTurnSwimOutRangeB;                     // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyTurnNotSwimInRangeA;                   // 0x07B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyTurnNotSwimInRangeB;                   // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyTurnNotSwimOutRangeA;                  // 0x07BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyTurnNotSwimOutRangeB;                  // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyTurnInterpSpeed_Accel;                         // 0x07C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyTurnInterpSpeed_NotAccel;                      // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleAdditiveBodyTurnTarget_NotAccel;               // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLeanAlphaTargeting_Targeting;              // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLeanAlphaTargeting_NonTargeting;           // 0x07D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLeanAlphaInterpSpeed;                      // 0x07D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveHipStopAlphaTargeting_PlayerTargeting;     // 0x07DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipInterpSpeed_PlayerTargeting;                    // 0x07E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveHipStopAlphaTargeting_NotPlayerTargeting;  // 0x07E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipInterpSpeed_NotPlayerTargeting;                 // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionSecondaryInRangeA;                       // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionSecondaryInRangeB;                       // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionSecondaryOutRangeA;                      // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionSecondaryOutRangeB;                      // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimCameraRotationSecondaryInRangeA;               // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimCameraRotationSecondaryInRangeB;               // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimCameraRotationSecondaryOutRangeA;              // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimCameraRotationSecondaryOutRangeB;              // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimRaptorRotationSecondaryInRangeA;               // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimRaptorRotationSecondaryInRangeB;               // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimRaptorRotationSecondaryOutRangeA;              // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimRaptorRotationSecondaryOutRangeB;              // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0824(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x0828(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x082C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x0830(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x0834(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x0838(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_Idle;                            // 0x0839(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Swimming_Fall;                          // 0x083A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Land_Idle;                              // 0x083B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Idle;                              // 0x083C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Moving;                            // 0x083D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimIdle_SwimLoco;                      // 0x083E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsTurnInPlace;                          // 0x083F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsSprintStop;                           // 0x0840(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsStopBackwards;                        // 0x0841(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsLocomotion;                           // 0x0842(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsFinishedTurnInPlace;                  // 0x0843(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsInterruptible;                        // 0x0844(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsIdleTurnRight;                        // 0x0845(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsLeftFootStop;                         // 0x0846(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsTurningRight;                         // 0x0847(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsAdditiveInterruptible;                // 0x0848(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsBackwardLocomotion;                   // 0x0849(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsJumpIdleLand;                         // 0x084A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsIdleTurnToIdleTurn;                   // 0x084B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_BoostJumpToBoostLand;                   // 0x084C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsJumpToBoostJump;                      // 0x084D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsJumpToJumpLand;                       // 0x084E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_BoostFallLoopToBoostLand;               // 0x084F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsLocomotionToIdle;                     // 0x0850(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsExitLocomotionToIdle;                 // 0x0851(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsLocomotionHoldToSecondary;            // 0x0852(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsLocomotionSecondaryToHold;            // 0x0853(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsJumpAdditive;                         // 0x0854(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsLandAdditiveToJump;                   // 0x0855(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsAllowSlopeSlide;                      // 0x0856(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_IsToJumpState;                          // 0x0857(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRidden;                                         // 0x0858(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStop;                                           // 0x0859(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWalkStop;                                       // 0x085A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85B[0x1];                                      // 0x085B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditiveHipAlpha;                                  // 0x085C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveBodyAlpha;                                 // 0x0860(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiderAimYaw;                                       // 0x0864(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSlopePitch;                                  // 0x0868(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerTargeting;                                // 0x086C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86D[0x3];                                      // 0x086D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditiveHipAlphaTargeting;                         // 0x0870(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipInterpSpeed;                                    // 0x0874(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleAdditiveBodyTurnTarget;                        // 0x0878(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyTurnAlpha;                                     // 0x087C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyTurnInterpSpeed;                               // 0x0880(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPlayRate;                                // 0x0884(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLeanAlpha;                                 // 0x0888(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLeanAlphaTargeting;                        // 0x088C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostStartPosition;                                // 0x0890(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveHipStopAlpha;                              // 0x0894(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveHipStopAlphaTargeting;                     // 0x0898(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowBoost;                                     // 0x089C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSlopeWarpHack;                                  // 0x089D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89E[0x2];                                      // 0x089E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionHeadSecondary;                           // 0x08A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionTailSecondary;                           // 0x08A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimCameraRotationSecondary;                       // 0x08A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimRaptorRotationSecondary;                       // 0x08AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimTurnYaw;                                       // 0x08B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimHeadYaw;                                       // 0x08B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRule_NegativeTurnAngle;                       // 0x08B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAccelerating2D;                                 // 0x08B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BA[0x2];                                      // 0x08BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterruptibleMaxCheck;                             // 0x08BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedStopTransition;                               // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleMoveTransition;                           // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMin;                                    // 0x08C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeFromEndThreshold;                         // 0x08CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float CalculateLocomotionPoseAdditiveAlpha();
	bool DetermineEnableHeadTiltDownAdditive();
	bool DetermineIdleStartTurn();
	bool DetermineIsFullBodyInPlace();
	void UpdateEnableHeadTiltDownAdditive();
	void UpdateIdleStartTurn();
	void UpdateIsFullBodyInPlace();
	void UpdateLocomotionPoseAdditiveAlpha();
	void UpdateStateVariables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Robert">();
	}
	static class UFortAIFaunaAnimInstance_Robert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Robert>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Robert) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Robert");
static_assert(sizeof(UFortAIFaunaAnimInstance_Robert) == 0x0008D0, "Wrong size on UFortAIFaunaAnimInstance_Robert");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AIPawn) == 0x000720, "Member 'UFortAIFaunaAnimInstance_Robert::AIPawn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIdleStartTurn) == 0x000728, "Member 'UFortAIFaunaAnimInstance_Robert::bIdleStartTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bEnableHeadTiltDownAdditive) == 0x000729, "Member 'UFortAIFaunaAnimInstance_Robert::bEnableHeadTiltDownAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsFullBodyInPlace) == 0x00072A, "Member 'UFortAIFaunaAnimInstance_Robert::bIsFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPoseAdditiveAlpha) == 0x00072C, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsIdleShuffleTurn) == 0x000730, "Member 'UFortAIFaunaAnimInstance_Robert::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleBodyBend) == 0x000734, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRate) == 0x000738, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIdleShuffleTurnDirection) == 0x00073C, "Member 'UFortAIFaunaAnimInstance_Robert::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bLookAtAdditiveTurnAlpha) == 0x00073D, "Member 'UFortAIFaunaAnimInstance_Robert::bLookAtAdditiveTurnAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bTurnDirection) == 0x00073E, "Member 'UFortAIFaunaAnimInstance_Robert::bTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, PawnIDScale) == 0x000740, "Member 'UFortAIFaunaAnimInstance_Robert::PawnIDScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HeadTiltDownAdditiveFrequenceySeconds) == 0x000744, "Member 'UFortAIFaunaAnimInstance_Robert::HeadTiltDownAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, ForceFullBodyTransition) == 0x000748, "Member 'UFortAIFaunaAnimInstance_Robert::ForceFullBodyTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPoseAdditiveAlphaInterpRate) == 0x00074C, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPoseAdditiveAlphaInterpRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleStartTurnInterruptibleThreshold) == 0x000750, "Member 'UFortAIFaunaAnimInstance_Robert::IdleStartTurnInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LookAtAlphaThreshold) == 0x000754, "Member 'UFortAIFaunaAnimInstance_Robert::LookAtAlphaThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedMovingThreshold) == 0x000758, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedMovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, TurnDirectionThreshold) == 0x00075C, "Member 'UFortAIFaunaAnimInstance_Robert::TurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SprintStopThreshold) == 0x000760, "Member 'UFortAIFaunaAnimInstance_Robert::SprintStopThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, WalkStopThreshold) == 0x000764, "Member 'UFortAIFaunaAnimInstance_Robert::WalkStopThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BackwardStopThreshold) == 0x000768, "Member 'UFortAIFaunaAnimInstance_Robert::BackwardStopThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveInterruptibleThreshold) == 0x00076C, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, InterruptibleThreshold) == 0x000770, "Member 'UFortAIFaunaAnimInstance_Robert::InterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, TurningRightThreshold) == 0x000774, "Member 'UFortAIFaunaAnimInstance_Robert::TurningRightThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LeftFootStopThreshold) == 0x000778, "Member 'UFortAIFaunaAnimInstance_Robert::LeftFootStopThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HipInterpSpeed_Fast) == 0x00077C, "Member 'UFortAIFaunaAnimInstance_Robert::HipInterpSpeed_Fast' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HipInterpSpeed_Slow) == 0x000780, "Member 'UFortAIFaunaAnimInstance_Robert::HipInterpSpeed_Slow' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveHipAlphaTargeting_Constant) == 0x000784, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveHipAlphaTargeting_Constant' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BackwardLocomotionThreshold) == 0x000788, "Member 'UFortAIFaunaAnimInstance_Robert::BackwardLocomotionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionThreshold) == 0x00078C, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, PawnSpeedThreshold) == 0x000790, "Member 'UFortAIFaunaAnimInstance_Robert::PawnSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPlayRate_Fixed) == 0x000794, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPlayRate_Fixed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BoostJumpingThreshold) == 0x000798, "Member 'UFortAIFaunaAnimInstance_Robert::BoostJumpingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BoostStartPosition_Jumping) == 0x00079C, "Member 'UFortAIFaunaAnimInstance_Robert::BoostStartPosition_Jumping' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BoostStartPosition_NotJumping) == 0x0007A0, "Member 'UFortAIFaunaAnimInstance_Robert::BoostStartPosition_NotJumping' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyTurnSwimInRangeA) == 0x0007A4, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyTurnSwimInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyTurnSwimInRangeB) == 0x0007A8, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyTurnSwimInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyTurnSwimOutRangeA) == 0x0007AC, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyTurnSwimOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyTurnSwimOutRangeB) == 0x0007B0, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyTurnSwimOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyTurnNotSwimInRangeA) == 0x0007B4, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyTurnNotSwimInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyTurnNotSwimInRangeB) == 0x0007B8, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyTurnNotSwimInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyTurnNotSwimOutRangeA) == 0x0007BC, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyTurnNotSwimOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyTurnNotSwimOutRangeB) == 0x0007C0, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyTurnNotSwimOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BodyTurnInterpSpeed_Accel) == 0x0007C4, "Member 'UFortAIFaunaAnimInstance_Robert::BodyTurnInterpSpeed_Accel' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BodyTurnInterpSpeed_NotAccel) == 0x0007C8, "Member 'UFortAIFaunaAnimInstance_Robert::BodyTurnInterpSpeed_NotAccel' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleAdditiveBodyTurnTarget_NotAccel) == 0x0007CC, "Member 'UFortAIFaunaAnimInstance_Robert::IdleAdditiveBodyTurnTarget_NotAccel' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveLeanAlphaTargeting_Targeting) == 0x0007D0, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveLeanAlphaTargeting_Targeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveLeanAlphaTargeting_NonTargeting) == 0x0007D4, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveLeanAlphaTargeting_NonTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveLeanAlphaInterpSpeed) == 0x0007D8, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveLeanAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveHipStopAlphaTargeting_PlayerTargeting) == 0x0007DC, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveHipStopAlphaTargeting_PlayerTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HipInterpSpeed_PlayerTargeting) == 0x0007E0, "Member 'UFortAIFaunaAnimInstance_Robert::HipInterpSpeed_PlayerTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveHipStopAlphaTargeting_NotPlayerTargeting) == 0x0007E4, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveHipStopAlphaTargeting_NotPlayerTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HipInterpSpeed_NotPlayerTargeting) == 0x0007E8, "Member 'UFortAIFaunaAnimInstance_Robert::HipInterpSpeed_NotPlayerTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionSecondaryInRangeA) == 0x0007EC, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionSecondaryInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionSecondaryInRangeB) == 0x0007F0, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionSecondaryInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionSecondaryOutRangeA) == 0x0007F4, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionSecondaryOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionSecondaryOutRangeB) == 0x0007F8, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionSecondaryOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimCameraRotationSecondaryInRangeA) == 0x0007FC, "Member 'UFortAIFaunaAnimInstance_Robert::SwimCameraRotationSecondaryInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimCameraRotationSecondaryInRangeB) == 0x000800, "Member 'UFortAIFaunaAnimInstance_Robert::SwimCameraRotationSecondaryInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimCameraRotationSecondaryOutRangeA) == 0x000804, "Member 'UFortAIFaunaAnimInstance_Robert::SwimCameraRotationSecondaryOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimCameraRotationSecondaryOutRangeB) == 0x000808, "Member 'UFortAIFaunaAnimInstance_Robert::SwimCameraRotationSecondaryOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimRaptorRotationSecondaryInRangeA) == 0x00080C, "Member 'UFortAIFaunaAnimInstance_Robert::SwimRaptorRotationSecondaryInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimRaptorRotationSecondaryInRangeB) == 0x000810, "Member 'UFortAIFaunaAnimInstance_Robert::SwimRaptorRotationSecondaryInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimRaptorRotationSecondaryOutRangeA) == 0x000814, "Member 'UFortAIFaunaAnimInstance_Robert::SwimRaptorRotationSecondaryOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimRaptorRotationSecondaryOutRangeB) == 0x000818, "Member 'UFortAIFaunaAnimInstance_Robert::SwimRaptorRotationSecondaryOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleBodyBendMultiplier) == 0x00081C, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleTurnThreshold) == 0x000820, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleTurnDirectionThreshold) == 0x000824, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateInRangeA) == 0x000828, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateInRangeB) == 0x00082C, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateOutRangeA) == 0x000830, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateOutRangeB) == 0x000834, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Idle_Moving) == 0x000838, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Moving_Idle) == 0x000839, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Moving_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Swimming_Fall) == 0x00083A, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Swimming_Fall' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Land_Idle) == 0x00083B, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Land_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Fall_Idle) == 0x00083C, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Fall_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Fall_Moving) == 0x00083D, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Fall_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimIdle_SwimLoco) == 0x00083E, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimIdle_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsTurnInPlace) == 0x00083F, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsTurnInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsSprintStop) == 0x000840, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsSprintStop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsStopBackwards) == 0x000841, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsStopBackwards' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsLocomotion) == 0x000842, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsLocomotion' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsFinishedTurnInPlace) == 0x000843, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsFinishedTurnInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsInterruptible) == 0x000844, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsInterruptible' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsIdleTurnRight) == 0x000845, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsIdleTurnRight' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsLeftFootStop) == 0x000846, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsLeftFootStop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsTurningRight) == 0x000847, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsTurningRight' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsAdditiveInterruptible) == 0x000848, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsAdditiveInterruptible' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsBackwardLocomotion) == 0x000849, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsBackwardLocomotion' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsJumpIdleLand) == 0x00084A, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsJumpIdleLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsIdleTurnToIdleTurn) == 0x00084B, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsIdleTurnToIdleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_BoostJumpToBoostLand) == 0x00084C, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_BoostJumpToBoostLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsJumpToBoostJump) == 0x00084D, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsJumpToBoostJump' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsJumpToJumpLand) == 0x00084E, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsJumpToJumpLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_BoostFallLoopToBoostLand) == 0x00084F, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_BoostFallLoopToBoostLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsLocomotionToIdle) == 0x000850, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsLocomotionToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsExitLocomotionToIdle) == 0x000851, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsExitLocomotionToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsLocomotionHoldToSecondary) == 0x000852, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsLocomotionHoldToSecondary' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsLocomotionSecondaryToHold) == 0x000853, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsLocomotionSecondaryToHold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsJumpAdditive) == 0x000854, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsJumpAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsLandAdditiveToJump) == 0x000855, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsLandAdditiveToJump' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsAllowSlopeSlide) == 0x000856, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsAllowSlopeSlide' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_IsToJumpState) == 0x000857, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_IsToJumpState' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsRidden) == 0x000858, "Member 'UFortAIFaunaAnimInstance_Robert::bIsRidden' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsStop) == 0x000859, "Member 'UFortAIFaunaAnimInstance_Robert::bIsStop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsWalkStop) == 0x00085A, "Member 'UFortAIFaunaAnimInstance_Robert::bIsWalkStop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveHipAlpha) == 0x00085C, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveHipAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveBodyAlpha) == 0x000860, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveBodyAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, RiderAimYaw) == 0x000864, "Member 'UFortAIFaunaAnimInstance_Robert::RiderAimYaw' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, PlayerSlopePitch) == 0x000868, "Member 'UFortAIFaunaAnimInstance_Robert::PlayerSlopePitch' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsPlayerTargeting) == 0x00086C, "Member 'UFortAIFaunaAnimInstance_Robert::bIsPlayerTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveHipAlphaTargeting) == 0x000870, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveHipAlphaTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HipInterpSpeed) == 0x000874, "Member 'UFortAIFaunaAnimInstance_Robert::HipInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleAdditiveBodyTurnTarget) == 0x000878, "Member 'UFortAIFaunaAnimInstance_Robert::IdleAdditiveBodyTurnTarget' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BodyTurnAlpha) == 0x00087C, "Member 'UFortAIFaunaAnimInstance_Robert::BodyTurnAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BodyTurnInterpSpeed) == 0x000880, "Member 'UFortAIFaunaAnimInstance_Robert::BodyTurnInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPlayRate) == 0x000884, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveLeanAlpha) == 0x000888, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveLeanAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveLeanAlphaTargeting) == 0x00088C, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveLeanAlphaTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, BoostStartPosition) == 0x000890, "Member 'UFortAIFaunaAnimInstance_Robert::BoostStartPosition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveHipStopAlpha) == 0x000894, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveHipStopAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AdditiveHipStopAlphaTargeting) == 0x000898, "Member 'UFortAIFaunaAnimInstance_Robert::AdditiveHipStopAlphaTargeting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsAllowBoost) == 0x00089C, "Member 'UFortAIFaunaAnimInstance_Robert::bIsAllowBoost' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsSlopeWarpHack) == 0x00089D, "Member 'UFortAIFaunaAnimInstance_Robert::bIsSlopeWarpHack' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionHeadSecondary) == 0x0008A0, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionHeadSecondary' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionTailSecondary) == 0x0008A4, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionTailSecondary' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimCameraRotationSecondary) == 0x0008A8, "Member 'UFortAIFaunaAnimInstance_Robert::SwimCameraRotationSecondary' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimRaptorRotationSecondary) == 0x0008AC, "Member 'UFortAIFaunaAnimInstance_Robert::SwimRaptorRotationSecondary' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimTurnYaw) == 0x0008B0, "Member 'UFortAIFaunaAnimInstance_Robert::SwimTurnYaw' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SwimHeadYaw) == 0x0008B4, "Member 'UFortAIFaunaAnimInstance_Robert::SwimHeadYaw' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bAnimRule_NegativeTurnAngle) == 0x0008B8, "Member 'UFortAIFaunaAnimInstance_Robert::bAnimRule_NegativeTurnAngle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsAccelerating2D) == 0x0008B9, "Member 'UFortAIFaunaAnimInstance_Robert::bIsAccelerating2D' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, InterruptibleMaxCheck) == 0x0008BC, "Member 'UFortAIFaunaAnimInstance_Robert::InterruptibleMaxCheck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedStopTransition) == 0x0008C0, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedStopTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedIdleMoveTransition) == 0x0008C4, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedIdleMoveTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedToMoveMin) == 0x0008C8, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedToMoveMin' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, StateTimeFromEndThreshold) == 0x0008CC, "Member 'UFortAIFaunaAnimInstance_Robert::StateTimeFromEndThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Smackie
// 0x0030 (0x0750 - 0x0720)
class UFortAIFaunaAnimInstance_Smackie final : public UFortAIFaunaAnimInstance
{
public:
	bool                                          bIsIdleShuffleTurn;                                // 0x0718(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_719[0x3];                                      // 0x0719(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x071C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0720(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x0724(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToHop;                           // 0x0725(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionHopToIdle;                           // 0x0726(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToIdle;                          // 0x0727(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToHop;                           // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_729[0x3];                                      // 0x0729(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedThreshold;                                    // 0x072C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x0730(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x0734(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x073C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74C[0x4];                                      // 0x074C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Smackie">();
	}
	static class UFortAIFaunaAnimInstance_Smackie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Smackie>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Smackie) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Smackie");
static_assert(sizeof(UFortAIFaunaAnimInstance_Smackie) == 0x000750, "Wrong size on UFortAIFaunaAnimInstance_Smackie");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bIsIdleShuffleTurn) == 0x000718, "Member 'UFortAIFaunaAnimInstance_Smackie::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleBodyBend) == 0x00071C, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRate) == 0x000720, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bIdleShuffleTurnDirection) == 0x000724, "Member 'UFortAIFaunaAnimInstance_Smackie::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionIdleToHop) == 0x000725, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionIdleToHop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionHopToIdle) == 0x000726, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionHopToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionFallToIdle) == 0x000727, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionFallToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionFallToHop) == 0x000728, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionFallToHop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, SpeedThreshold) == 0x00072C, "Member 'UFortAIFaunaAnimInstance_Smackie::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleBodyBendMultiplier) == 0x000730, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleTurnThreshold) == 0x000734, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleTurnDirectionThreshold) == 0x000738, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateInRangeA) == 0x00073C, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateInRangeB) == 0x000740, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateOutRangeA) == 0x000744, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateOutRangeB) == 0x000748, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateOutRangeB' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaLayerAnimInstance
// 0x0000 (0x0470 - 0x0470)
class UFortAIFaunaLayerAnimInstance final : public UFortBaseLayerAnimInstance
{
public:
	class UAnimInstance*                          MainAnimBP;                                        // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaLayerAnimInstance">();
	}
	static class UFortAIFaunaLayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaLayerAnimInstance>();
	}
};
static_assert(alignof(UFortAIFaunaLayerAnimInstance) == 0x000010, "Wrong alignment on UFortAIFaunaLayerAnimInstance");
static_assert(sizeof(UFortAIFaunaLayerAnimInstance) == 0x000470, "Wrong size on UFortAIFaunaLayerAnimInstance");
static_assert(offsetof(UFortAIFaunaLayerAnimInstance, MainAnimBP) == 0x000468, "Member 'UFortAIFaunaLayerAnimInstance::MainAnimBP' has a wrong offset!");

}

