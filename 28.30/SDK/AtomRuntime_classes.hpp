#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AtomRuntime

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AtomRuntime_structs.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class AtomRuntime.AtomPrimitiveComponent
// 0x0030 (0x05F0 - 0x05C0)
class UAtomPrimitiveComponent final : public UStaticMeshComponent
{
public:
	class UAtomPrimitive*                         AtomPrimitive;                                     // 0x05C0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RenderStyle;                                       // 0x05C8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FallbackRenderStyle;                               // 0x05D8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCombinedMeshes;                                // 0x05E8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E9[0x7];                                      // 0x05E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomPrimitiveComponent">();
	}
	static class UAtomPrimitiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomPrimitiveComponent>();
	}
};
static_assert(alignof(UAtomPrimitiveComponent) == 0x000010, "Wrong alignment on UAtomPrimitiveComponent");
static_assert(sizeof(UAtomPrimitiveComponent) == 0x0005F0, "Wrong size on UAtomPrimitiveComponent");
static_assert(offsetof(UAtomPrimitiveComponent, AtomPrimitive) == 0x0005C0, "Member 'UAtomPrimitiveComponent::AtomPrimitive' has a wrong offset!");
static_assert(offsetof(UAtomPrimitiveComponent, RenderStyle) == 0x0005C8, "Member 'UAtomPrimitiveComponent::RenderStyle' has a wrong offset!");
static_assert(offsetof(UAtomPrimitiveComponent, FallbackRenderStyle) == 0x0005D8, "Member 'UAtomPrimitiveComponent::FallbackRenderStyle' has a wrong offset!");
static_assert(offsetof(UAtomPrimitiveComponent, bUseCombinedMeshes) == 0x0005E8, "Member 'UAtomPrimitiveComponent::bUseCombinedMeshes' has a wrong offset!");

// Class AtomRuntime.AtomAssetImportData
// 0x0000 (0x0028 - 0x0028)
class UAtomAssetImportData final : public UAssetImportData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomAssetImportData">();
	}
	static class UAtomAssetImportData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomAssetImportData>();
	}
};
static_assert(alignof(UAtomAssetImportData) == 0x000008, "Wrong alignment on UAtomAssetImportData");
static_assert(sizeof(UAtomAssetImportData) == 0x000028, "Wrong size on UAtomAssetImportData");

// Class AtomRuntime.AtomModelMergedMeshImportData
// 0x0000 (0x0028 - 0x0028)
class UAtomModelMergedMeshImportData final : public UAssetImportData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomModelMergedMeshImportData">();
	}
	static class UAtomModelMergedMeshImportData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomModelMergedMeshImportData>();
	}
};
static_assert(alignof(UAtomModelMergedMeshImportData) == 0x000008, "Wrong alignment on UAtomModelMergedMeshImportData");
static_assert(sizeof(UAtomModelMergedMeshImportData) == 0x000028, "Wrong size on UAtomModelMergedMeshImportData");

// Class AtomRuntime.AtomPartsCollectionBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAtomPartsCollectionBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddPartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartInstanceInfo& PartInstance);
	static class FString Conv_ModelPartGuidToString(const struct FAtomModelPartGuid& InModelPartGuid);
	static struct FAtomModelPartGuid Conv_StringToModelPartGuid(const class FString& InString);
	static struct FAtomModelPartColorInfo CreateColorInfoFromColorId(int32 ColorId);
	static struct FAtomModelPartsCollection FilterGroup(class UAtomModel* Model, const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& GroupName, const class FString& NewPartsCollectionName);
	static struct FAtomModelPartsCollection FilterNonTransparent(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& NewPartsCollectionName);
	static struct FAtomModelPartsCollection FilterSelectionSet(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& SelectionSetName, const class FString& NewPartsCollectionName);
	static struct FAtomModelPartsCollection FilterTransparent(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& NewPartsCollectionName);
	static class FString GetName(const struct FAtomModelPartsCollection& PartsCollection);
	static const TArray<struct FAtomModelPartInstanceInfo> GetParts(const struct FAtomModelPartsCollection& PartsCollection);
	static TArray<struct FAtomCommonPartAndTransform> GetPrimitiveCommonParts(class UAtomPrimitive* Primitive, double Scale);
	static struct FAtomModelPartsCollection InitializeCommonParts(struct FAtomModelPartsCollection& PartsCollection, const class UAtomModel* Model, float Scale, bool bRemoveConnectedParts, bool bRemoveAllKnobs, bool bRemoveAllTubes, bool bRemoveAllPins);
	static void RemovePartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartGuid& PartInstanceId);
	static void ReplacePartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartInstanceInfo& SourcePartInstance, const struct FAtomModelPartGuid& TargetPartInstanceId);
	static void SetName(struct FAtomModelPartsCollection* PartsCollection, const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomPartsCollectionBlueprintLibrary">();
	}
	static class UAtomPartsCollectionBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomPartsCollectionBlueprintLibrary>();
	}
};
static_assert(alignof(UAtomPartsCollectionBlueprintLibrary) == 0x000008, "Wrong alignment on UAtomPartsCollectionBlueprintLibrary");
static_assert(sizeof(UAtomPartsCollectionBlueprintLibrary) == 0x000028, "Wrong size on UAtomPartsCollectionBlueprintLibrary");

// Class AtomRuntime.AtomModelGeometryCollectionImportData
// 0x0000 (0x0028 - 0x0028)
class UAtomModelGeometryCollectionImportData final : public UAssetImportData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomModelGeometryCollectionImportData">();
	}
	static class UAtomModelGeometryCollectionImportData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomModelGeometryCollectionImportData>();
	}
};
static_assert(alignof(UAtomModelGeometryCollectionImportData) == 0x000008, "Wrong alignment on UAtomModelGeometryCollectionImportData");
static_assert(sizeof(UAtomModelGeometryCollectionImportData) == 0x000028, "Wrong size on UAtomModelGeometryCollectionImportData");

// Class AtomRuntime.AtomCommonPartModelAssetUserData
// 0x0010 (0x0038 - 0x0028)
class UAtomCommonPartModelAssetUserData final : public UAssetUserData
{
public:
	struct FAtomCommonPartAssetDescription        AssetDescription;                                  // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomCommonPartModelAssetUserData">();
	}
	static class UAtomCommonPartModelAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomCommonPartModelAssetUserData>();
	}
};
static_assert(alignof(UAtomCommonPartModelAssetUserData) == 0x000008, "Wrong alignment on UAtomCommonPartModelAssetUserData");
static_assert(sizeof(UAtomCommonPartModelAssetUserData) == 0x000038, "Wrong size on UAtomCommonPartModelAssetUserData");
static_assert(offsetof(UAtomCommonPartModelAssetUserData, AssetDescription) == 0x000028, "Member 'UAtomCommonPartModelAssetUserData::AssetDescription' has a wrong offset!");

// Class AtomRuntime.AtomDatabaseSubsystemBase
// 0x0000 (0x0030 - 0x0030)
class UAtomDatabaseSubsystemBase final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomDatabaseSubsystemBase">();
	}
	static class UAtomDatabaseSubsystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomDatabaseSubsystemBase>();
	}
};
static_assert(alignof(UAtomDatabaseSubsystemBase) == 0x000008, "Wrong alignment on UAtomDatabaseSubsystemBase");
static_assert(sizeof(UAtomDatabaseSubsystemBase) == 0x000030, "Wrong size on UAtomDatabaseSubsystemBase");

// Class AtomRuntime.AtomModelActor
// 0x0018 (0x02A8 - 0x0290)
class AAtomModelActor final : public AActor
{
public:
	class UAtomModel*                             AtomModel;                                         // 0x0290(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrimitiveStyleName;                                // 0x0298(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomModelActor">();
	}
	static class AAtomModelActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtomModelActor>();
	}
};
static_assert(alignof(AAtomModelActor) == 0x000008, "Wrong alignment on AAtomModelActor");
static_assert(sizeof(AAtomModelActor) == 0x0002A8, "Wrong size on AAtomModelActor");
static_assert(offsetof(AAtomModelActor, AtomModel) == 0x000290, "Member 'AAtomModelActor::AtomModel' has a wrong offset!");
static_assert(offsetof(AAtomModelActor, PrimitiveStyleName) == 0x000298, "Member 'AAtomModelActor::PrimitiveStyleName' has a wrong offset!");

// Class AtomRuntime.AtomModelAssetUserData
// 0x0080 (0x00A8 - 0x0028)
class UAtomModelAssetUserData final : public UAssetUserData
{
public:
	struct FSerializedConnectivityObjects         AtomModelConnections;                              // 0x0028(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAtomCommonPartInstancesCache          CommonPartCache;                                   // 0x0048(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           Tags;                                              // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomModelAssetUserData">();
	}
	static class UAtomModelAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomModelAssetUserData>();
	}
};
static_assert(alignof(UAtomModelAssetUserData) == 0x000008, "Wrong alignment on UAtomModelAssetUserData");
static_assert(sizeof(UAtomModelAssetUserData) == 0x0000A8, "Wrong size on UAtomModelAssetUserData");
static_assert(offsetof(UAtomModelAssetUserData, AtomModelConnections) == 0x000028, "Member 'UAtomModelAssetUserData::AtomModelConnections' has a wrong offset!");
static_assert(offsetof(UAtomModelAssetUserData, CommonPartCache) == 0x000048, "Member 'UAtomModelAssetUserData::CommonPartCache' has a wrong offset!");
static_assert(offsetof(UAtomModelAssetUserData, Tags) == 0x000098, "Member 'UAtomModelAssetUserData::Tags' has a wrong offset!");

// Class AtomRuntime.AtomPrimitiveBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAtomPrimitiveBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetDefaultPrimitiveScale();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomPrimitiveBlueprintLibrary">();
	}
	static class UAtomPrimitiveBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomPrimitiveBlueprintLibrary>();
	}
};
static_assert(alignof(UAtomPrimitiveBlueprintLibrary) == 0x000008, "Wrong alignment on UAtomPrimitiveBlueprintLibrary");
static_assert(sizeof(UAtomPrimitiveBlueprintLibrary) == 0x000028, "Wrong size on UAtomPrimitiveBlueprintLibrary");

// Class AtomRuntime.AtomPrimitiveGeometry
// 0x02C0 (0x02E8 - 0x0028)
class UAtomPrimitiveGeometry final : public UObject
{
public:
	uint8                                         Pad_28[0x2C0];                                     // 0x0028(0x02C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAtomPrimitiveGeometry* CreateAtomGeometryFromCommonPart(const class FString& ExportStyleName, EAtomCommonPartType CommonPartType, int32 LODIndex, const class FString& CommonPartsMeshPath);
	static class UAtomPrimitiveGeometry* CreateEmptyAtomGeometry();
	static int32 GetNumberOfCommonPartLODs(const class FString& ExportStyleName, EAtomCommonPartType CommonPartType, const class FString& CommonPartsMeshPath);

	class UAtomPrimitiveGeometry* Append(const class UAtomPrimitiveGeometry* GeometryToAppend, const struct FTransform3f& Transform);
	class UAtomPrimitiveGeometry* AppendAndWeld(const class UAtomPrimitiveGeometry* GeometryToAppend, const struct FTransform3f& Transform);
	void AttachVerticesToBoneIndex(int32 BoneIndex);
	void AttachVerticesToNamedBone(const class FString& BoneName);
	class UAtomPrimitiveGeometry* BakeScale(float Scale);
	class UAtomPrimitiveGeometry* BakeTransform(const struct FTransform3f& Transform);
	class UAtomPrimitiveGeometry* BakeTransforms(const TArray<struct FTransform3f>& Transforms);
	class UAtomPrimitiveGeometry* SetMaterialName(const class FString& Name_0, int32 PolygonGroupIndex);
	class UAtomPrimitiveGeometry* SetTiledUVs(float TileSize);
	class UAtomPrimitiveGeometry* SetVertexColor(const struct FColor& Color);

	class UAtomPrimitiveGeometry* DuplicateGeometry() const;
	int32 GetBoneIndexForName(const class FString& BoneName) const;
	TArray<class FString> GetMaterialNames() const;
	TArray<class UAtomPrimitiveGeometry*> SplitByPolygonGroup() const;
	class UStaticMesh* ToSimplifiedStaticMesh(float Scale, class UObject* Outer_0, const class FString& Name_0, bool bFastBuild) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomPrimitiveGeometry">();
	}
	static class UAtomPrimitiveGeometry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomPrimitiveGeometry>();
	}
};
static_assert(alignof(UAtomPrimitiveGeometry) == 0x000008, "Wrong alignment on UAtomPrimitiveGeometry");
static_assert(sizeof(UAtomPrimitiveGeometry) == 0x0002E8, "Wrong size on UAtomPrimitiveGeometry");

// Class AtomRuntime.AtomPrimitiveGeometryContainer
// 0x00D0 (0x00F8 - 0x0028)
class UAtomPrimitiveGeometryContainer final : public UObject
{
public:
	TSoftObjectPtr<class UStaticMesh>             SourceMesh;                                        // 0x0028(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExportStyleName;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, int32>                    GeometryCount;                                     // 0x0058(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FAtomPrimitiveGeometryAndTransform> GetCapsGeometry();
	TArray<struct FAtomPrimitiveGeometryAndTransform> GetDetailsGeometry();
	class UAtomPrimitiveGeometry* GetGeometry(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity);
	class UAtomPrimitiveGeometry* GetGeometryWithMaterialNames(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity, const class FString& ShellMaterial, const class FString& UndersideMaterial);
	TArray<struct FAtomPrimitiveGeometryAndTransform> GetPartsGeometry();
	TArray<struct FAtomPrimitiveGeometryAndTransform> GetScaledCapsGeometry(float Scale);
	TArray<struct FAtomPrimitiveGeometryAndTransform> GetScaledDetailsGeometry(float Scale);
	class UAtomPrimitiveGeometry* GetScaledGeometry(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity, float Scale);
	struct FAtomPrimitiveGeometryAndTransform GetScaledShellGeometry(float Scale);
	struct FAtomPrimitiveGeometryAndTransform GetShellGeometry();

	TArray<struct FTransform> GetDefaultBoneTransforms(float Scale) const;
	class FString GetExportStyleName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomPrimitiveGeometryContainer">();
	}
	static class UAtomPrimitiveGeometryContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomPrimitiveGeometryContainer>();
	}
};
static_assert(alignof(UAtomPrimitiveGeometryContainer) == 0x000008, "Wrong alignment on UAtomPrimitiveGeometryContainer");
static_assert(sizeof(UAtomPrimitiveGeometryContainer) == 0x0000F8, "Wrong size on UAtomPrimitiveGeometryContainer");
static_assert(offsetof(UAtomPrimitiveGeometryContainer, SourceMesh) == 0x000028, "Member 'UAtomPrimitiveGeometryContainer::SourceMesh' has a wrong offset!");
static_assert(offsetof(UAtomPrimitiveGeometryContainer, ExportStyleName) == 0x000048, "Member 'UAtomPrimitiveGeometryContainer::ExportStyleName' has a wrong offset!");
static_assert(offsetof(UAtomPrimitiveGeometryContainer, GeometryCount) == 0x000058, "Member 'UAtomPrimitiveGeometryContainer::GeometryCount' has a wrong offset!");

// Class AtomRuntime.AtomRuntimeBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAtomRuntimeBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TMap<int32, struct FAtomColorInfo> GetAllColorInfo();
	static int32 GetBitPackForColor(const struct FColor& Color);
	static int32 GetBitPackForColorId(int32 AtomColorId);
	static void GetCommonPartAssetDescriptionFromStaticMesh(class UStaticMesh* StaticMesh, struct FAtomCommonPartAssetDescription* OutDescription, EGetCommonPartDescriptionResult* OutIsValid);
	static EAtomCommonPartCategory GetCommonPartCategoryFromType(EAtomCommonPartType CommonPartType);
	static void GetCommonPartDescriptionFromType(EAtomCommonPartType CommonPartType, struct FAtomCommonPartDescription* OutDescription);
	static struct FAtomColorInfo GetInfoForColorId(int32 ColorId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomRuntimeBlueprintLibrary">();
	}
	static class UAtomRuntimeBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomRuntimeBlueprintLibrary>();
	}
};
static_assert(alignof(UAtomRuntimeBlueprintLibrary) == 0x000008, "Wrong alignment on UAtomRuntimeBlueprintLibrary");
static_assert(sizeof(UAtomRuntimeBlueprintLibrary) == 0x000028, "Wrong size on UAtomRuntimeBlueprintLibrary");

// Class AtomRuntime.AtomRuntimeSettings
// 0x0030 (0x0060 - 0x0030)
class UAtomRuntimeSettings final : public UDeveloperSettings
{
public:
	float                                         PrimitiveGlobalScale;                              // 0x0030(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              ColorDataTableOverride;                            // 0x0038(0x0020)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWorldConnectivity;                          // 0x0058(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCookContent;                                      // 0x0059(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class UDataTable* GetColorDataTable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomRuntimeSettings">();
	}
	static class UAtomRuntimeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomRuntimeSettings>();
	}
};
static_assert(alignof(UAtomRuntimeSettings) == 0x000008, "Wrong alignment on UAtomRuntimeSettings");
static_assert(sizeof(UAtomRuntimeSettings) == 0x000060, "Wrong size on UAtomRuntimeSettings");
static_assert(offsetof(UAtomRuntimeSettings, PrimitiveGlobalScale) == 0x000030, "Member 'UAtomRuntimeSettings::PrimitiveGlobalScale' has a wrong offset!");
static_assert(offsetof(UAtomRuntimeSettings, ColorDataTableOverride) == 0x000038, "Member 'UAtomRuntimeSettings::ColorDataTableOverride' has a wrong offset!");
static_assert(offsetof(UAtomRuntimeSettings, bEnableWorldConnectivity) == 0x000058, "Member 'UAtomRuntimeSettings::bEnableWorldConnectivity' has a wrong offset!");
static_assert(offsetof(UAtomRuntimeSettings, bCookContent) == 0x000059, "Member 'UAtomRuntimeSettings::bCookContent' has a wrong offset!");

// Class AtomRuntime.WorldConnectivitySubsystem
// 0x0150 (0x0180 - 0x0030)
class UWorldConnectivitySubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x150];                                     // 0x0030(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisconnectAllObjectConnections(const struct FWorldConnectivityHandle& Object);
	void DisconnectObjects(const struct FWorldConnectivityHandle& ObjectA, const struct FWorldConnectivityHandle& ObjectB);
	class UAtomModelAssetUserData* GetAtomModelAssetUserData(class UObject* Object);
	struct FPlanarFieldInfo GetClosestFieldToPoint(const struct FWorldConnectivityHandle& Handle, const struct FVector& WorldLocation, EConnectionFieldGender Type, bool* bSuccess);
	TArray<struct FWorldConnectivityHandle> GetConnectedObjects(const struct FWorldConnectivityHandle& Object);
	TArray<struct FWorldConnectivityHandle> GetConnectedObjectsRecursively(const struct FWorldConnectivityHandle& Object);
	struct FVector GetOverlapPenetrationDepth(class AStaticMeshActor* Actor1, class AStaticMeshActor* Actor2, const struct FVector& Offset);
	struct FVector GetPlanarFieldCenter(const struct FPlanarFieldInfo& Field);
	TArray<struct FPlanarFieldInfo> GetPlanarFields(const struct FWorldConnectivityHandle& Handle, EConnectionFieldGender Type);
	void RegisterConnectivityActor(const class AActor* Actor, const class UAtomModel* Model);
	void RegisterCustomConnectivityActor(const class AActor* Actor, const struct FSerializedConnectivityObjects& ConnectivityObject);
	void RegisterModelActor(const class AActor* Actor, const struct FSerializedConnectivityObjects& Connections);
	TArray<struct FConnectivityQueryResult> RunPlanarConnectivityQuery(const class AActor* AtomModelActorToPlace, const class AActor* AtomModelActorToConnect, const struct FVector& QueryStartLocation, const struct FVector& QueryEndLocation, ECollisionChannel QueryCollisionChannel, int32 QueryRadius);
	bool TryConnectObjectAtLocation(const struct FWorldConnectivityHandle& ObjectToConnect, const struct FTransform& DesiredObjectTransform, const TArray<struct FWorldConnectivityHandle>& ConnectionCandidates, bool PerformConnection);
	void UnregisterConnectivityActor(const class AActor* Actor);

	class AActor* GetActor(const struct FWorldConnectivityHandle& Handle) const;
	struct FWorldConnectivityHandle GetConnectivityHandle(const class AActor* Actor) const;
	TArray<struct FWorldConnectivityHandle> GetConnectivityHandles(const class AActor* Actor) const;
	const struct FTransform GetTransform(const struct FWorldConnectivityHandle& Handle) const;
	double PlanarGridStepSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldConnectivitySubsystem">();
	}
	static class UWorldConnectivitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldConnectivitySubsystem>();
	}
};
static_assert(alignof(UWorldConnectivitySubsystem) == 0x000008, "Wrong alignment on UWorldConnectivitySubsystem");
static_assert(sizeof(UWorldConnectivitySubsystem) == 0x000180, "Wrong size on UWorldConnectivitySubsystem");

// Class AtomRuntime.WorldConnectivityBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorldConnectivityBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* GetActor(class UObject* WorldContext, const struct FWorldConnectivityHandle& Handle);
	static struct FVector GetFieldCenter(class UObject* WorldContext, const struct FPlanarFieldInfo& Field);
	static struct FTransform GetTransform(class UObject* WorldContext, const struct FWorldConnectivityHandle& Handle);
	static bool IsValid(const struct FWorldConnectivityHandle& Handle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldConnectivityBlueprintLibrary">();
	}
	static class UWorldConnectivityBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldConnectivityBlueprintLibrary>();
	}
};
static_assert(alignof(UWorldConnectivityBlueprintLibrary) == 0x000008, "Wrong alignment on UWorldConnectivityBlueprintLibrary");
static_assert(sizeof(UWorldConnectivityBlueprintLibrary) == 0x000028, "Wrong size on UWorldConnectivityBlueprintLibrary");

// Class AtomRuntime.AtomModel
// 0x0230 (0x0258 - 0x0028)
class UAtomModel final : public UObject
{
public:
	struct FAtomModelAssetSettings                Settings;                                          // 0x0028(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelPrimitive>            Primitives;                                        // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtomHingedElement>             Elements;                                          // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelSelectionSet>         SelectionSets;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAtomModelConfigurationGroup>   Groups;                                            // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<EAtomCommonPartType, TSoftObjectPtr<class UStaticMesh>> CommonPartOverrides;                               // 0x00A0(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         CommonPartOptimization;                            // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSerializedConnectivityObjects         SerializedConnectivityObjects;                     // 0x00F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftObjectPtr<class UTexture>> TextureNameToAsset;                                // 0x0118(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x50];                                     // 0x0168(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAtomSourceModel                       SourceModel;                                       // 0x01B8(0x00A0)(NativeAccessSpecifierPrivate)

public:
	class FString GetChildIdentifier(int32 InChildIdx);
	void GetPrimitivesForChildArray(int32 InChildIdx, TArray<struct FAtomModelPrimitiveInstance>* OutPrimitives);

	TArray<TSoftObjectPtr<class UStaticMesh>> GetGeneratedMergedMeshes() const;
	class FString GetModelName() const;
	class FString GetModelPath() const;
	struct FAtomModelPartsCollection GetPartsCollection() const;
	class UTexture* GetTextureForDecorationTextureName(const class FString& TextureName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomModel">();
	}
	static class UAtomModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomModel>();
	}
};
static_assert(alignof(UAtomModel) == 0x000008, "Wrong alignment on UAtomModel");
static_assert(sizeof(UAtomModel) == 0x000258, "Wrong size on UAtomModel");
static_assert(offsetof(UAtomModel, Settings) == 0x000028, "Member 'UAtomModel::Settings' has a wrong offset!");
static_assert(offsetof(UAtomModel, Primitives) == 0x000060, "Member 'UAtomModel::Primitives' has a wrong offset!");
static_assert(offsetof(UAtomModel, Elements) == 0x000070, "Member 'UAtomModel::Elements' has a wrong offset!");
static_assert(offsetof(UAtomModel, SelectionSets) == 0x000080, "Member 'UAtomModel::SelectionSets' has a wrong offset!");
static_assert(offsetof(UAtomModel, Groups) == 0x000090, "Member 'UAtomModel::Groups' has a wrong offset!");
static_assert(offsetof(UAtomModel, CommonPartOverrides) == 0x0000A0, "Member 'UAtomModel::CommonPartOverrides' has a wrong offset!");
static_assert(offsetof(UAtomModel, CommonPartOptimization) == 0x0000F0, "Member 'UAtomModel::CommonPartOptimization' has a wrong offset!");
static_assert(offsetof(UAtomModel, SerializedConnectivityObjects) == 0x0000F8, "Member 'UAtomModel::SerializedConnectivityObjects' has a wrong offset!");
static_assert(offsetof(UAtomModel, TextureNameToAsset) == 0x000118, "Member 'UAtomModel::TextureNameToAsset' has a wrong offset!");
static_assert(offsetof(UAtomModel, SourceModel) == 0x0001B8, "Member 'UAtomModel::SourceModel' has a wrong offset!");

// Class AtomRuntime.AtomModelComponent
// 0x00A0 (0x02C0 - 0x0220)
class UAtomModelComponent final : public USceneComponent
{
public:
	class UAtomModel*                             AtomModel;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtomModelInstanceType                        InstanceType;                                      // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RenderStyle;                                       // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FallbackRenderStyle;                               // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCombinedMeshes;                                // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseColorPayload;                                  // 0x0251(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateRigidElements;                              // 0x0252(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableConnectivity;                               // 0x0253(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectionSetFilter;                                // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CommonPartOptimization;                            // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                RigidElementComponents;                            // 0x0260(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, struct FModelPrimitiveEntry> ComponentToPrimitive;                              // 0x0270(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomModelComponent">();
	}
	static class UAtomModelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomModelComponent>();
	}
};
static_assert(alignof(UAtomModelComponent) == 0x000010, "Wrong alignment on UAtomModelComponent");
static_assert(sizeof(UAtomModelComponent) == 0x0002C0, "Wrong size on UAtomModelComponent");
static_assert(offsetof(UAtomModelComponent, AtomModel) == 0x000220, "Member 'UAtomModelComponent::AtomModel' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, InstanceType) == 0x000228, "Member 'UAtomModelComponent::InstanceType' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, RenderStyle) == 0x000230, "Member 'UAtomModelComponent::RenderStyle' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, FallbackRenderStyle) == 0x000240, "Member 'UAtomModelComponent::FallbackRenderStyle' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, bUseCombinedMeshes) == 0x000250, "Member 'UAtomModelComponent::bUseCombinedMeshes' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, bUseColorPayload) == 0x000251, "Member 'UAtomModelComponent::bUseColorPayload' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, bCreateRigidElements) == 0x000252, "Member 'UAtomModelComponent::bCreateRigidElements' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, bEnableConnectivity) == 0x000253, "Member 'UAtomModelComponent::bEnableConnectivity' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, SelectionSetFilter) == 0x000254, "Member 'UAtomModelComponent::SelectionSetFilter' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, CommonPartOptimization) == 0x000258, "Member 'UAtomModelComponent::CommonPartOptimization' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, RigidElementComponents) == 0x000260, "Member 'UAtomModelComponent::RigidElementComponents' has a wrong offset!");
static_assert(offsetof(UAtomModelComponent, ComponentToPrimitive) == 0x000270, "Member 'UAtomModelComponent::ComponentToPrimitive' has a wrong offset!");

// Class AtomRuntime.AtomModelProcessor
// 0x0030 (0x0058 - 0x0028)
class UAtomModelProcessor final : public UObject
{
public:
	bool                                          bEnableRebuildProgress;                            // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DialogDelay;                                       // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumProgressSteps;                                  // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ProgressMessage;                                   // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IncrementProgress(int32 NumSteps, const class FString& Message);
	class FString OnGetProcessModelTargetAssetPath(class UAtomModel* Model, const struct FAtomModelPartsCollection& AtomModelPartsCollection);
	class FString OnGetProcessPrimitiveTargetAssetPath(class UAtomModel* Model, class UAtomPrimitive* Primitive, const struct FAtomModelPartsCollection& AtomModelPartsCollection, const struct FAtomOnProcessPrimitiveSettings& Settings);
	class FString OnGetTargetAssetPath(class UAtomModel* Model, class UAtomPrimitive* Primitive, const struct FAtomModelPartsCollection& AtomModelPartsCollection);
	struct FAtomProcessorResult OnProcessModel(class UAtomModel* Model, const struct FAtomModelPartsCollection& AtomModelPartsCollection, const TArray<TSoftObjectPtr<class UObject>>& ExistingObjects);
	struct FAtomProcessorResult OnProcessPrimitive(class UAtomModel* DummyModel, class UAtomPrimitive* Primitive, const struct FAtomModelPartsCollection& AtomModelPartsCollection, const struct FAtomOnProcessPrimitiveSettings& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomModelProcessor">();
	}
	static class UAtomModelProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomModelProcessor>();
	}
};
static_assert(alignof(UAtomModelProcessor) == 0x000008, "Wrong alignment on UAtomModelProcessor");
static_assert(sizeof(UAtomModelProcessor) == 0x000058, "Wrong size on UAtomModelProcessor");
static_assert(offsetof(UAtomModelProcessor, bEnableRebuildProgress) == 0x000028, "Member 'UAtomModelProcessor::bEnableRebuildProgress' has a wrong offset!");
static_assert(offsetof(UAtomModelProcessor, DialogDelay) == 0x00002C, "Member 'UAtomModelProcessor::DialogDelay' has a wrong offset!");
static_assert(offsetof(UAtomModelProcessor, NumProgressSteps) == 0x000030, "Member 'UAtomModelProcessor::NumProgressSteps' has a wrong offset!");
static_assert(offsetof(UAtomModelProcessor, ProgressMessage) == 0x000038, "Member 'UAtomModelProcessor::ProgressMessage' has a wrong offset!");

// Class AtomRuntime.AtomProcessorBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAtomProcessorBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FAtomProcessorResult AppendAtomProcessorResult(const struct FAtomProcessorResult& Result, const struct FAtomProcessorResult& ResultToAppend);
	static const class UAtomModelProcessor* GetModelProcessor(const struct FAtomModelProcessorInstance& ProcessorInstance);
	static const class UClass* GetProcessorClass(const struct FAtomModelProcessorInstance& ProcessorInstance);
	static bool IsValid(const struct FAtomModelProcessorInstance& ProcessorInstance);
	static void SetModelProcessor(struct FAtomModelProcessorInstance& ProcessorInstance, class UAtomModelProcessor* ModelProcessor, bool bUseCustomSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomProcessorBlueprintLibrary">();
	}
	static class UAtomProcessorBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomProcessorBlueprintLibrary>();
	}
};
static_assert(alignof(UAtomProcessorBlueprintLibrary) == 0x000008, "Wrong alignment on UAtomProcessorBlueprintLibrary");
static_assert(sizeof(UAtomProcessorBlueprintLibrary) == 0x000028, "Wrong size on UAtomProcessorBlueprintLibrary");

// Class AtomRuntime.AtomPrimitive
// 0x01C8 (0x01F0 - 0x0028)
class UAtomPrimitive final : public UObject
{
public:
	int32                                         PartId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PartRevision;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DesignName;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlex;                                           // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVariant;                                        // 0x0045(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DecorationSurfaceNames;                            // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         NumberOfColorSurfaces;                             // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtomPlatform                                 AtomPlatform;                                      // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AtomMainGroupId;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AtomSubMainGroupId;                                // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAtomCommonPartType, struct FAtomPrimitiveCommonPart> PrimitiveCommonParts;                              // 0x0068(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, struct FAtomPrimitiveCommonPart> CommonParts;                                       // 0x00B8(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bOverrideConnectionFields;                         // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoxSphereBounds                       Bounds;                                            // 0x0110(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       UnscaledBounds;                                    // 0x0148(0x0038)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UAtomPrimitiveGeometryContainer*> GeometryContainers;                                // 0x0180(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FConnectionFieldContainer              ConnectionFields;                                  // 0x0190(0x0030)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FConnectionFieldContainer              ConnectionFieldsOverride;                          // 0x01C0(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class FName GetMainGroupName(int32 MainGroupId);
	static class FName GetSubMainGroupName(int32 SubMainGroupId);

	class UAtomPrimitiveGeometryContainer* GetGeometryContainerForExportStyle(const class FString& ExportStyleName, const class FString& FallbackExportStyleName) const;
	bool IsFlexElement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomPrimitive">();
	}
	static class UAtomPrimitive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomPrimitive>();
	}
};
static_assert(alignof(UAtomPrimitive) == 0x000008, "Wrong alignment on UAtomPrimitive");
static_assert(sizeof(UAtomPrimitive) == 0x0001F0, "Wrong size on UAtomPrimitive");
static_assert(offsetof(UAtomPrimitive, PartId) == 0x000028, "Member 'UAtomPrimitive::PartId' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, PartRevision) == 0x000030, "Member 'UAtomPrimitive::PartRevision' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, DesignName) == 0x000040, "Member 'UAtomPrimitive::DesignName' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, bIsFlex) == 0x000044, "Member 'UAtomPrimitive::bIsFlex' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, bIsVariant) == 0x000045, "Member 'UAtomPrimitive::bIsVariant' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, DecorationSurfaceNames) == 0x000048, "Member 'UAtomPrimitive::DecorationSurfaceNames' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, NumberOfColorSurfaces) == 0x000058, "Member 'UAtomPrimitive::NumberOfColorSurfaces' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, AtomPlatform) == 0x00005C, "Member 'UAtomPrimitive::AtomPlatform' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, AtomMainGroupId) == 0x000060, "Member 'UAtomPrimitive::AtomMainGroupId' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, AtomSubMainGroupId) == 0x000064, "Member 'UAtomPrimitive::AtomSubMainGroupId' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, PrimitiveCommonParts) == 0x000068, "Member 'UAtomPrimitive::PrimitiveCommonParts' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, CommonParts) == 0x0000B8, "Member 'UAtomPrimitive::CommonParts' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, bOverrideConnectionFields) == 0x000108, "Member 'UAtomPrimitive::bOverrideConnectionFields' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, Bounds) == 0x000110, "Member 'UAtomPrimitive::Bounds' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, UnscaledBounds) == 0x000148, "Member 'UAtomPrimitive::UnscaledBounds' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, GeometryContainers) == 0x000180, "Member 'UAtomPrimitive::GeometryContainers' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, ConnectionFields) == 0x000190, "Member 'UAtomPrimitive::ConnectionFields' has a wrong offset!");
static_assert(offsetof(UAtomPrimitive, ConnectionFieldsOverride) == 0x0001C0, "Member 'UAtomPrimitive::ConnectionFieldsOverride' has a wrong offset!");

}

