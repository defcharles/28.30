#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CraftingRuntime

#include "Basic.hpp"

#include "CraftingRuntime_classes.hpp"
#include "CraftingRuntime_parameters.hpp"


namespace SDK
{

// Function CraftingRuntime.CraftingObjectBGA.HandleInteractionRangeBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACraftingObjectBGA::HandleInteractionRangeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleInteractionRangeBeginOverlap");

	Params::CraftingObjectBGA_HandleInteractionRangeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingObjectBGA.HandleInteractionRangeEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACraftingObjectBGA::HandleInteractionRangeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleInteractionRangeEndOverlap");

	Params::CraftingObjectBGA_HandleInteractionRangeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingCheatManager.StartSelfCrafting
// (Final, BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// class FName                             FormulaName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingCheatManager::StartSelfCrafting(class FName FormulaName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartSelfCrafting");

	Params::CraftingCheatManager_StartSelfCrafting Parms{};

	Parms.FormulaName = FormulaName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingCheatManager.ToggleFreeCrafting
// (Final, Exec, Native, Public)

void UCraftingCheatManager::ToggleFreeCrafting()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleFreeCrafting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CraftingRuntime.CraftingObjectComponent.HandlePickupCraftingItemPickedUp
// (Final, Native, Private, HasDefaults)
// Parameters:
// class AFortPickup*                      Pickup                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPawn*                        InteractingPawn                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFortWorldItemDefinition*         WorldItemDefinition                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PickupLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingObjectComponent::HandlePickupCraftingItemPickedUp(class AFortPickup* Pickup, class AFortPawn* InteractingPawn, const class UFortWorldItemDefinition* WorldItemDefinition, const struct FVector& PickupLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandlePickupCraftingItemPickedUp");

	Params::CraftingObjectComponent_HandlePickupCraftingItemPickedUp Parms{};

	Parms.Pickup = Pickup;
	Parms.InteractingPawn = InteractingPawn;
	Parms.WorldItemDefinition = WorldItemDefinition;
	Parms.PickupLocation = std::move(PickupLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingObjectComponent.OnRep_CraftingObjectRepStateData
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FCraftingObjectRepStateData>OldValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCraftingObjectComponent::OnRep_CraftingObjectRepStateData(const TArray<struct FCraftingObjectRepStateData>& OldValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_CraftingObjectRepStateData");

	Params::CraftingObjectComponent_OnRep_CraftingObjectRepStateData Parms{};

	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ClientNotifyCraftingFailed
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            FailedReason                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ClientNotifyCraftingFailed(class AActor* CraftingObject, const struct FGameplayTagContainer& FailedReason, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientNotifyCraftingFailed");

	Params::FortControllerComponent_CraftingNetworkEvents_ClientNotifyCraftingFailed Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.FailedReason = std::move(FailedReason);
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ClientNotifyCraftingSuccess
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FormulaRowName                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FFortItemEntry>           ConsumedIngredients                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ClientNotifyCraftingSuccess(class AActor* CraftingObject, const class FName& FormulaRowName, const TArray<struct FFortItemEntry>& ConsumedIngredients, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientNotifyCraftingSuccess");

	Params::FortControllerComponent_CraftingNetworkEvents_ClientNotifyCraftingSuccess Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.FormulaRowName = FormulaRowName;
	Parms.ConsumedIngredients = std::move(ConsumedIngredients);
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.NotifyCraftingSuccess
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FormulaRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FFortItemEntry>           ConsumedIngredients                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::NotifyCraftingSuccess(class AActor* CraftingObject, const class FName& FormulaRowName, const TArray<struct FFortItemEntry>& ConsumedIngredients, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NotifyCraftingSuccess");

	Params::FortControllerComponent_CraftingNetworkEvents_NotifyCraftingSuccess Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.FormulaRowName = FormulaRowName;
	Parms.ConsumedIngredients = std::move(ConsumedIngredients);
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ServerCancelCrafting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ServerCancelCrafting(class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerCancelCrafting");

	Params::FortControllerComponent_CraftingNetworkEvents_ServerCancelCrafting Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ServerClaimCraftingResults
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ServerClaimCraftingResults(class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerClaimCraftingResults");

	Params::FortControllerComponent_CraftingNetworkEvents_ServerClaimCraftingResults Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ServerEjectItems
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ServerEjectItems(class AActor* CraftingObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerEjectItems");

	Params::FortControllerComponent_CraftingNetworkEvents_ServerEjectItems Parms{};

	Parms.CraftingObject = CraftingObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ServerPauseCrafting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDecayPausedTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ServerPauseCrafting(class AActor* CraftingObject, bool bDecayPausedTime, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerPauseCrafting");

	Params::FortControllerComponent_CraftingNetworkEvents_ServerPauseCrafting Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.bDecayPausedTime = bDecayPausedTime;
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ServerPickupItemAndStartCrafting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPickup*                      Pickup                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaName                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ServerPickupItemAndStartCrafting(class AActor* CraftingObject, class AFortPickup* Pickup, const class FName& CraftingFormulaName, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerPickupItemAndStartCrafting");

	Params::FortControllerComponent_CraftingNetworkEvents_ServerPickupItemAndStartCrafting Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Pickup = Pickup;
	Parms.CraftingFormulaName = CraftingFormulaName;
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ServerReportCraftingSuccess
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ServerReportCraftingSuccess(class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerReportCraftingSuccess");

	Params::FortControllerComponent_CraftingNetworkEvents_ServerReportCraftingSuccess Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ServerResumeCrafting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ServerResumeCrafting(class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerResumeCrafting");

	Params::FortControllerComponent_CraftingNetworkEvents_ServerResumeCrafting Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortControllerComponent_CraftingNetworkEvents.ServerStartCrafting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaName                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumberToCraft                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CraftingNetworkEvents::ServerStartCrafting(class AActor* CraftingObject, const class FName& CraftingFormulaName, const int32 NumberToCraft, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerStartCrafting");

	Params::FortControllerComponent_CraftingNetworkEvents_ServerStartCrafting Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.CraftingFormulaName = CraftingFormulaName;
	Parms.NumberToCraft = NumberToCraft;
	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortGameStateComponent_Crafting.OnPlaylistDataReady
// (RequiredAPI, Native, Protected, HasOutParams)
// Parameters:
// class AFortGameStateAthena*             GameState                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFortPlaylist*                    Playlist                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            PlaylistContextTags                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFortGameStateComponent_Crafting::OnPlaylistDataReady(class AFortGameStateAthena* GameState, const class UFortPlaylist* Playlist, const struct FGameplayTagContainer& PlaylistContextTags)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlaylistDataReady");

	Params::FortGameStateComponent_Crafting_OnPlaylistDataReady Parms{};

	Parms.GameState = GameState;
	Parms.Playlist = Playlist;
	Parms.PlaylistContextTags = std::move(PlaylistContextTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortGameStateComponent_Crafting.OnRep_CraftingResultsList
// (Final, Native, Protected)

void UFortGameStateComponent_Crafting::OnRep_CraftingResultsList()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_CraftingResultsList");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CraftingRuntime.FortContextualTutorial_CraftingComplete.OnCraftingSuccess
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCraftingObjectSuccessEvent      Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFortContextualTutorial_CraftingComplete::OnCraftingSuccess(const struct FCraftingObjectSuccessEvent& Event)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCraftingSuccess");

	Params::FortContextualTutorial_CraftingComplete_OnCraftingSuccess Parms{};

	Parms.Event = std::move(Event);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortContextualTutorial_CraftingReady.HandleFormulaCraftableChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             FormulaRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCraftable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortContextualTutorial_CraftingReady::HandleFormulaCraftableChanged(const class FName& FormulaRowName, bool bIsCraftable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleFormulaCraftableChanged");

	Params::FortContextualTutorial_CraftingReady_HandleFormulaCraftableChanged Parms{};

	Parms.FormulaRowName = FormulaRowName;
	Parms.bIsCraftable = bIsCraftable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortContextualTutorial_CraftingTabOpen.HandleFormulaCraftableChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             FormulaRowName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCraftable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortContextualTutorial_CraftingTabOpen::HandleFormulaCraftableChanged(const class FName& FormulaRowName, bool bIsCraftable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleFormulaCraftableChanged");

	Params::FortContextualTutorial_CraftingTabOpen_HandleFormulaCraftableChanged Parms{};

	Parms.FormulaRowName = FormulaRowName;
	Parms.bIsCraftable = bIsCraftable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.FortContextualTutorial_CraftingTabOpen.HandleInventoryTabChanged
// (Final, Native, Private)
// Parameters:
// class FName                             InventoryTabNameId                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortContextualTutorial_CraftingTabOpen::HandleInventoryTabChanged(const class FName InventoryTabNameId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleInventoryTabChanged");

	Params::FortContextualTutorial_CraftingTabOpen_HandleInventoryTabChanged Parms{};

	Parms.InventoryTabNameId = InventoryTabNameId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.CancelAllCrafting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::CancelAllCrafting(class AActor* CraftingObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CancelAllCrafting");

	Params::CraftingLibrary_CancelAllCrafting Parms{};

	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.CancelCrafting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::CancelCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CancelCrafting");

	Params::CraftingLibrary_CancelCrafting Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.CanCraftFormula
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaRow                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCraftingIngredientQueryState>OutIngredientStates                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   NumberToCraft                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingLibrary::CanCraftFormula(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, const class FName CraftingFormulaRow, TArray<struct FCraftingIngredientQueryState>* OutIngredientStates, const int32 NumberToCraft)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CanCraftFormula");

	Params::CraftingLibrary_CanCraftFormula Parms{};

	Parms.FortPC = FortPC;
	Parms.CraftingObject = CraftingObject;
	Parms.CraftingFormulaRow = CraftingFormulaRow;
	Parms.NumberToCraft = NumberToCraft;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutIngredientStates != nullptr)
		*OutIngredientStates = std::move(Parms.OutIngredientStates);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.CanCraftFormulaWithAdditionalItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaRow                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FItemAndCount>            AdditionalItems                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FCraftingIngredientQueryState>OutIngredientStates                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   NumberToCraft                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingLibrary::CanCraftFormulaWithAdditionalItems(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, const class FName CraftingFormulaRow, const TArray<struct FItemAndCount>& AdditionalItems, TArray<struct FCraftingIngredientQueryState>* OutIngredientStates, const int32 NumberToCraft)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CanCraftFormulaWithAdditionalItems");

	Params::CraftingLibrary_CanCraftFormulaWithAdditionalItems Parms{};

	Parms.FortPC = FortPC;
	Parms.CraftingObject = CraftingObject;
	Parms.CraftingFormulaRow = CraftingFormulaRow;
	Parms.AdditionalItems = std::move(AdditionalItems);
	Parms.NumberToCraft = NumberToCraft;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutIngredientStates != nullptr)
		*OutIngredientStates = std::move(Parms.OutIngredientStates);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.ClaimCraftingResults
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::ClaimCraftingResults(class AFortPlayerController* Instigator, class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClaimCraftingResults");

	Params::CraftingLibrary_ClaimCraftingResults Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.EjectItems
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::EjectItems(class AFortPlayerController* Instigator, class AActor* CraftingObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EjectItems");

	Params::CraftingLibrary_EjectItems Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.GetAllCraftableFormulas
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutFormulas                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCraftingLibrary::GetAllCraftableFormulas(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class FName>* OutFormulas)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllCraftableFormulas");

	Params::CraftingLibrary_GetAllCraftableFormulas Parms{};

	Parms.FortPC = FortPC;
	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutFormulas != nullptr)
		*OutFormulas = std::move(Parms.OutFormulas);
}


// Function CraftingRuntime.CraftingLibrary.GetAllCraftingFormulas
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutFormulas                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCraftingLibrary::GetAllCraftingFormulas(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class FName>* OutFormulas)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllCraftingFormulas");

	Params::CraftingLibrary_GetAllCraftingFormulas Parms{};

	Parms.FortPC = FortPC;
	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutFormulas != nullptr)
		*OutFormulas = std::move(Parms.OutFormulas);
}


// Function CraftingRuntime.CraftingLibrary.GetAllValidIngredients
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTagContainer>    OutIngredients                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCraftingLibrary::GetAllValidIngredients(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<struct FGameplayTagContainer>* OutIngredients)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllValidIngredients");

	Params::CraftingLibrary_GetAllValidIngredients Parms{};

	Parms.FortPC = FortPC;
	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutIngredients != nullptr)
		*OutIngredients = std::move(Parms.OutIngredients);
}


// Function CraftingRuntime.CraftingLibrary.GetCraftedResults_TempItems
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFortWorldItem*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UFortWorldItem*> UCraftingLibrary::GetCraftedResults_TempItems(class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftedResults_TempItems");

	Params::CraftingLibrary_GetCraftedResults_TempItems Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingFormulaIngredientRequirements
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaRow                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCraftingIngredientRequirement>OutIngredientRequirements                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingLibrary::GetCraftingFormulaIngredientRequirements(class UObject* WorldContextObject, const class FName& CraftingFormulaRow, TArray<struct FCraftingIngredientRequirement>* OutIngredientRequirements)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingFormulaIngredientRequirements");

	Params::CraftingLibrary_GetCraftingFormulaIngredientRequirements Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CraftingFormulaRow = CraftingFormulaRow;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutIngredientRequirements != nullptr)
		*OutIngredientRequirements = std::move(Parms.OutIngredientRequirements);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingFormulaNameBeingCrafted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCraftingLibrary::GetCraftingFormulaNameBeingCrafted(class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingFormulaNameBeingCrafted");

	Params::CraftingLibrary_GetCraftingFormulaNameBeingCrafted Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingIngredients_TempItems
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFortWorldItem*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UFortWorldItem*> UCraftingLibrary::GetCraftingIngredients_TempItems(class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingIngredients_TempItems");

	Params::CraftingLibrary_GetCraftingIngredients_TempItems Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingObjectComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCraftingObjectComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCraftingObjectComponent* UCraftingLibrary::GetCraftingObjectComponent(const class AActor* CraftingObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingObjectComponent");

	Params::CraftingLibrary_GetCraftingObjectComponent Parms{};

	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingObjectCraftingState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECraftingObjectState                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECraftingObjectState UCraftingLibrary::GetCraftingObjectCraftingState(class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingObjectCraftingState");

	Params::CraftingLibrary_GetCraftingObjectCraftingState Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingObjectCurrentCraftingStateEndTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCraftingLibrary::GetCraftingObjectCurrentCraftingStateEndTime(const class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingObjectCurrentCraftingStateEndTime");

	Params::CraftingLibrary_GetCraftingObjectCurrentCraftingStateEndTime Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingObjectCurrentCraftingStateStartTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCraftingLibrary::GetCraftingObjectCurrentCraftingStateStartTime(const class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingObjectCurrentCraftingStateStartTime");

	Params::CraftingLibrary_GetCraftingObjectCurrentCraftingStateStartTime Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingObjectCurrentCraftingStateTimeLeft
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCraftingLibrary::GetCraftingObjectCurrentCraftingStateTimeLeft(const class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingObjectCurrentCraftingStateTimeLeft");

	Params::CraftingLibrary_GetCraftingObjectCurrentCraftingStateTimeLeft Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingObjectPausedTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCraftingLibrary::GetCraftingObjectPausedTime(const class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingObjectPausedTime");

	Params::CraftingLibrary_GetCraftingObjectPausedTime Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingObjectTags
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UCraftingLibrary::GetCraftingObjectTags(const class AActor* CraftingObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingObjectTags");

	Params::CraftingLibrary_GetCraftingObjectTags Parms{};

	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetCraftingResultsForRowName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaRow                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FItemAndCount>            OutResults                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   NumToCraft                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::GetCraftingResultsForRowName(const class UObject* WorldContextObject, const class FName& CraftingFormulaRow, TArray<struct FItemAndCount>* OutResults, int32 NumToCraft)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCraftingResultsForRowName");

	Params::CraftingLibrary_GetCraftingResultsForRowName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CraftingFormulaRow = CraftingFormulaRow;
	Parms.NumToCraft = NumToCraft;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutResults != nullptr)
		*OutResults = std::move(Parms.OutResults);
}


// Function CraftingRuntime.CraftingLibrary.GetIngredientsInCraftingObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFortWorldItem*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UFortWorldItem*> UCraftingLibrary::GetIngredientsInCraftingObject(class AActor* CraftingObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetIngredientsInCraftingObject");

	Params::CraftingLibrary_GetIngredientsInCraftingObject Parms{};

	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetKnownCraftingFormulas
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutFormulas                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCraftingLibrary::GetKnownCraftingFormulas(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class FName>* OutFormulas)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetKnownCraftingFormulas");

	Params::CraftingLibrary_GetKnownCraftingFormulas Parms{};

	Parms.FortPC = FortPC;
	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutFormulas != nullptr)
		*OutFormulas = std::move(Parms.OutFormulas);
}


// Function CraftingRuntime.CraftingLibrary.GetLastCraftedItemFormulaName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCraftingLibrary::GetLastCraftedItemFormulaName(class AActor* CraftingObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLastCraftedItemFormulaName");

	Params::CraftingLibrary_GetLastCraftedItemFormulaName Parms{};

	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetTimeToCraftRecipe
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaName                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCraftingLibrary::GetTimeToCraftRecipe(const class AActor* CraftingObject, const class FName& CraftingFormulaName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTimeToCraftRecipe");

	Params::CraftingLibrary_GetTimeToCraftRecipe Parms{};

	Parms.CraftingObject = CraftingObject;
	Parms.CraftingFormulaName = CraftingFormulaName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.GetUIDataForCraftingIngredientTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            IngredientTags                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UFortItemDefinition>>OutItemDefs                                            (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UObject>>   OutIcons                                               (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UCraftingLibrary::GetUIDataForCraftingIngredientTags(class UObject* WorldContextObject, const struct FGameplayTagContainer& IngredientTags, TArray<TSoftObjectPtr<class UFortItemDefinition>>* OutItemDefs, TArray<TSoftObjectPtr<class UObject>>* OutIcons)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetUIDataForCraftingIngredientTags");

	Params::CraftingLibrary_GetUIDataForCraftingIngredientTags Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IngredientTags = std::move(IngredientTags);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutItemDefs != nullptr)
		*OutItemDefs = std::move(Parms.OutItemDefs);

	if (OutIcons != nullptr)
		*OutIcons = std::move(Parms.OutIcons);
}


// Function CraftingRuntime.CraftingLibrary.GetValidIngredientsInInventory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFortWorldItem*>           OutIngredients                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCraftingLibrary::GetValidIngredientsInInventory(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class UFortWorldItem*>* OutIngredients)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetValidIngredientsInInventory");

	Params::CraftingLibrary_GetValidIngredientsInInventory Parms{};

	Parms.FortPC = FortPC;
	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutIngredients != nullptr)
		*OutIngredients = std::move(Parms.OutIngredients);
}


// Function CraftingRuntime.CraftingLibrary.GiveItemToCraftingObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFortItemEntry                   ItemEntryToGrant                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCraftingLibrary::GiveItemToCraftingObject(class AFortPlayerController* Instigator, class AActor* CraftingObject, const struct FFortItemEntry& ItemEntryToGrant)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GiveItemToCraftingObject");

	Params::CraftingLibrary_GiveItemToCraftingObject Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;
	Parms.ItemEntryToGrant = std::move(ItemEntryToGrant);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.IsFreeCraftingEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingLibrary::IsFreeCraftingEnabled(const class AActor* CraftingObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsFreeCraftingEnabled");

	Params::CraftingLibrary_IsFreeCraftingEnabled Parms{};

	Parms.CraftingObject = CraftingObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.IsValidIngredient
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFortItemDefinition*              ItemDef                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingLibrary::IsValidIngredient(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, const class UFortItemDefinition* ItemDef)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValidIngredient");

	Params::CraftingLibrary_IsValidIngredient Parms{};

	Parms.FortPC = FortPC;
	Parms.CraftingObject = CraftingObject;
	Parms.ItemDef = ItemDef;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CraftingRuntime.CraftingLibrary.PauseCrafting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDecayPausedTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::PauseCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject, bool bDecayPausedTime, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PauseCrafting");

	Params::CraftingLibrary_PauseCrafting Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;
	Parms.bDecayPausedTime = bDecayPausedTime;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.PickupItemAndStartCrafting
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPickup*                      Pickup                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaName                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::PickupItemAndStartCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject, class AFortPickup* Pickup, const class FName& CraftingFormulaName, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PickupItemAndStartCrafting");

	Params::CraftingLibrary_PickupItemAndStartCrafting Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;
	Parms.Pickup = Pickup;
	Parms.CraftingFormulaName = CraftingFormulaName;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.ReportCraftingSuccess
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::ReportCraftingSuccess(class AFortPlayerController* Instigator, class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReportCraftingSuccess");

	Params::CraftingLibrary_ReportCraftingSuccess Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.ResumeCrafting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::ResumeCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ResumeCrafting");

	Params::CraftingLibrary_ResumeCrafting Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function CraftingRuntime.CraftingLibrary.StartCrafting
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CraftingObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CraftingFormulaName                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumberToCraft                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingMultiKey                Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCraftingLibrary::StartCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject, const class FName& CraftingFormulaName, const int32 NumberToCraft, const struct FCraftingMultiKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StartCrafting");

	Params::CraftingLibrary_StartCrafting Parms{};

	Parms.Instigator = Instigator;
	Parms.CraftingObject = CraftingObject;
	Parms.CraftingFormulaName = CraftingFormulaName;
	Parms.NumberToCraft = NumberToCraft;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}

}

