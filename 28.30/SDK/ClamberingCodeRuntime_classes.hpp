#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ClamberingCodeRuntime

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "ContextualTraversalRuntime_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "ClamberingCodeRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class ClamberingCodeRuntime.FortMovementMode_ExtClambering
// 0x0068 (0x01E0 - 0x0178)
class UFortMovementMode_ExtClambering : public UFortMovementMode_ExtLogicTraversalBase
{
public:
	TSubclassOf<class UFortCameraMode>            LedgeLaunchCameraMode;                             // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            WindowClamberCameraMode;                           // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ClamberingTag;                                     // 0x0188(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ClamberingStartedTag;                              // 0x01A8(0x0004)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ClamberingFinishedTag;                             // 0x01B0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UCameraShakeBase*                       CameraShake;                                       // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LedgeLaunchSyncPointInterpSpeed;                   // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LedgeLaunchPlayerCollideBounceSpeed;               // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_GetAnimationMontageInformation(const struct FClamberMontageInput& Context, class UAnimMontage** AnimMontage, class FName* StartSectionName, class FName* MontageMiddleSectionName);

	struct FVector BP_GetClamberLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementMode_ExtClambering">();
	}
	static class UFortMovementMode_ExtClambering* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementMode_ExtClambering>();
	}
};
static_assert(alignof(UFortMovementMode_ExtClambering) == 0x000008, "Wrong alignment on UFortMovementMode_ExtClambering");
static_assert(sizeof(UFortMovementMode_ExtClambering) == 0x0001E0, "Wrong size on UFortMovementMode_ExtClambering");
static_assert(offsetof(UFortMovementMode_ExtClambering, LedgeLaunchCameraMode) == 0x000178, "Member 'UFortMovementMode_ExtClambering::LedgeLaunchCameraMode' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtClambering, WindowClamberCameraMode) == 0x000180, "Member 'UFortMovementMode_ExtClambering::WindowClamberCameraMode' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtClambering, ClamberingTag) == 0x000188, "Member 'UFortMovementMode_ExtClambering::ClamberingTag' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtClambering, ClamberingStartedTag) == 0x0001A8, "Member 'UFortMovementMode_ExtClambering::ClamberingStartedTag' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtClambering, ClamberingFinishedTag) == 0x0001B0, "Member 'UFortMovementMode_ExtClambering::ClamberingFinishedTag' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtClambering, CameraShake) == 0x0001D0, "Member 'UFortMovementMode_ExtClambering::CameraShake' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtClambering, LedgeLaunchSyncPointInterpSpeed) == 0x0001D8, "Member 'UFortMovementMode_ExtClambering::LedgeLaunchSyncPointInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementMode_ExtClambering, LedgeLaunchPlayerCollideBounceSpeed) == 0x0001DC, "Member 'UFortMovementMode_ExtClambering::LedgeLaunchPlayerCollideBounceSpeed' has a wrong offset!");

// Class ClamberingCodeRuntime.InstancedLedgeActor
// 0x0058 (0x02F0 - 0x0298)
class AInstancedLedgeActor final : public AFortClientOnlyActor
{
public:
	class UInstancedStaticMeshComponent*          InstancedStaticMeshComponent;                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x50];                                     // 0x02A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnAddInstance(const struct FTransform& LedgeTransform, int32 InstanceIndex);
	void BP_OnRemoveInstance(const struct FTransform& LedgeTransform, int32 InstanceIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InstancedLedgeActor">();
	}
	static class AInstancedLedgeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInstancedLedgeActor>();
	}
};
static_assert(alignof(AInstancedLedgeActor) == 0x000008, "Wrong alignment on AInstancedLedgeActor");
static_assert(sizeof(AInstancedLedgeActor) == 0x0002F0, "Wrong size on AInstancedLedgeActor");
static_assert(offsetof(AInstancedLedgeActor, InstancedStaticMeshComponent) == 0x000298, "Member 'AInstancedLedgeActor::InstancedStaticMeshComponent' has a wrong offset!");

// Class ClamberingCodeRuntime.LedgeLaunchWorldSubsystem
// 0x0170 (0x01A0 - 0x0030)
class ULedgeLaunchWorldSubsystem final : public UBuildingWallSubsystem
{
public:
	TSoftObjectPtr<class UPBWLedgeConfigurationData> ConfigurationData;                                 // 0x0030(0x0020)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   InstancedLedgeActorClass;                          // 0x0050(0x0020)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPBWLedgeConfigurationData*             CachedConfigurationData;                           // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInstancedLedgeActor*                   InstancedLedgeActor;                               // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UClass*, struct FLedgeLaunchConfigEntry> CachedLedgeLaunchMap;                              // 0x0080(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0xD0];                                      // 0x00D0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWallDied(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LedgeLaunchWorldSubsystem">();
	}
	static class ULedgeLaunchWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULedgeLaunchWorldSubsystem>();
	}
};
static_assert(alignof(ULedgeLaunchWorldSubsystem) == 0x000008, "Wrong alignment on ULedgeLaunchWorldSubsystem");
static_assert(sizeof(ULedgeLaunchWorldSubsystem) == 0x0001A0, "Wrong size on ULedgeLaunchWorldSubsystem");
static_assert(offsetof(ULedgeLaunchWorldSubsystem, ConfigurationData) == 0x000030, "Member 'ULedgeLaunchWorldSubsystem::ConfigurationData' has a wrong offset!");
static_assert(offsetof(ULedgeLaunchWorldSubsystem, InstancedLedgeActorClass) == 0x000050, "Member 'ULedgeLaunchWorldSubsystem::InstancedLedgeActorClass' has a wrong offset!");
static_assert(offsetof(ULedgeLaunchWorldSubsystem, CachedConfigurationData) == 0x000070, "Member 'ULedgeLaunchWorldSubsystem::CachedConfigurationData' has a wrong offset!");
static_assert(offsetof(ULedgeLaunchWorldSubsystem, InstancedLedgeActor) == 0x000078, "Member 'ULedgeLaunchWorldSubsystem::InstancedLedgeActor' has a wrong offset!");
static_assert(offsetof(ULedgeLaunchWorldSubsystem, CachedLedgeLaunchMap) == 0x000080, "Member 'ULedgeLaunchWorldSubsystem::CachedLedgeLaunchMap' has a wrong offset!");

// Class ClamberingCodeRuntime.PBWLedgeConfigurationData
// 0x0190 (0x01C0 - 0x0030)
class UPBWLedgeConfigurationData final : public UDataAsset
{
public:
	TMap<EPlayerBuiltWallType, TSoftClassPtr<class UClass>> MetalWalls;                                        // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EPlayerBuiltWallType, TSoftClassPtr<class UClass>> StoneWalls;                                        // 0x0080(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EPlayerBuiltWallType, TSoftClassPtr<class UClass>> WoodWalls;                                         // 0x00D0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EPlayerBuiltWallType, struct FLedgeLaunchConfigEntry> Transforms;                                        // 0x0120(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EPlayerBuiltWallMaterialType, struct FLedgeLaunchTransformConfigEntry> PerMaterialTransforms;                             // 0x0170(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PBWLedgeConfigurationData">();
	}
	static class UPBWLedgeConfigurationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPBWLedgeConfigurationData>();
	}
};
static_assert(alignof(UPBWLedgeConfigurationData) == 0x000008, "Wrong alignment on UPBWLedgeConfigurationData");
static_assert(sizeof(UPBWLedgeConfigurationData) == 0x0001C0, "Wrong size on UPBWLedgeConfigurationData");
static_assert(offsetof(UPBWLedgeConfigurationData, MetalWalls) == 0x000030, "Member 'UPBWLedgeConfigurationData::MetalWalls' has a wrong offset!");
static_assert(offsetof(UPBWLedgeConfigurationData, StoneWalls) == 0x000080, "Member 'UPBWLedgeConfigurationData::StoneWalls' has a wrong offset!");
static_assert(offsetof(UPBWLedgeConfigurationData, WoodWalls) == 0x0000D0, "Member 'UPBWLedgeConfigurationData::WoodWalls' has a wrong offset!");
static_assert(offsetof(UPBWLedgeConfigurationData, Transforms) == 0x000120, "Member 'UPBWLedgeConfigurationData::Transforms' has a wrong offset!");
static_assert(offsetof(UPBWLedgeConfigurationData, PerMaterialTransforms) == 0x000170, "Member 'UPBWLedgeConfigurationData::PerMaterialTransforms' has a wrong offset!");

// Class ClamberingCodeRuntime.ClamberingAnalytics
// 0x0000 (0x0028 - 0x0028)
class UClamberingAnalytics final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClamberingAnalytics">();
	}
	static class UClamberingAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClamberingAnalytics>();
	}
};
static_assert(alignof(UClamberingAnalytics) == 0x000008, "Wrong alignment on UClamberingAnalytics");
static_assert(sizeof(UClamberingAnalytics) == 0x000028, "Wrong size on UClamberingAnalytics");

// Class ClamberingCodeRuntime.ClamberingComponent
// 0x0E20 (0x0EC8 - 0x00A8)
class UClamberingComponent final : public UFortPawnOverrideComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EClamberingState                              LocalClamberingState;                              // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EClamberingState                              ReplicatedClamberingState;                         // 0x00B1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClamberingTargetingData               LockedTargetingData;                               // 0x00B8(0x00E0)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FReplicatedClamberingTargetingData_SimClient ReplicatedTargetingData;                           // 0x0198(0x0038)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x8];                                      // 0x01D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ClamberingEnabled;                                 // 0x01D8(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ClamberIndicatorEnabled;                           // 0x0200(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ClamberStartMaxFallingDamageFraction;              // 0x0230(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bPerformTargetingWhileWalking;                     // 0x0258(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPerformTargetingWhileSwimming;                    // 0x0259(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A[0x6];                                      // 0x025A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ServerFailDelay;                                   // 0x0260(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ServerValidatePlayerMaxDistance;                   // 0x0288(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FClamberingInputConfig                 InputConfig;                                       // 0x02B0(0x0350)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FClamberingTargetingConfig_Ledge       TargetingConfig_Ledge;                             // 0x0600(0x04D8)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FClamberingInputConfig_CachedValues    InputConfigCachedValues;                           // 0x0AD8(0x005C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FClamberingTargetingConfig_Ledge_CachedContextualValues TargetingConfig_Ledge_CachedContextualValues;      // 0x0B34(0x0080)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB4[0x4];                                      // 0x0BB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClamberingMovementConfig_Ledge        MoveConfig_Ledge;                                  // 0x0BB8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ClamberSyncTargetLedgeOffset;                      // 0x0C08(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ClamberingMaxAnalyticsEvents;                      // 0x0C30(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SynchedActionFailDelay;                            // 0x0C58(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortMovementMode_ExtClambering> MovementModeExtension;                             // 0x0C80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SynchedActionMMETag;                               // 0x0C88(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LedgeLaunchSyncPointName;                          // 0x0C8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        LastTeleportTime;                                  // 0x0C90(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTutorialModeEnabled;                              // 0x0C98(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C99[0x7];                                      // 0x0C99(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClamberingTargetingData               LocalTargetingData;                                // 0x0CA0(0x00E0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FClamberingTargetingData               ParallelTargetingData;                             // 0x0D80(0x00E0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         QueuedInputTimer;                                  // 0x0E60(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InputEnabledTimer;                                 // 0x0E64(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bJumpInputPressed;                                 // 0x0E68(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E69[0x3];                                      // 0x0E69(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpHeldInAirTime;                                 // 0x0E6C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E70[0x50];                                     // 0x0E70(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Tag_DisableClambering;                             // 0x0EC0(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC4[0x4];                                      // 0x0EC4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_HandleClamberingStateChanged(const EClamberingState OldClamberingState, const EClamberingState NewClamberingState);
	void BP_HandleSynchedActionStarted(const struct FSynchedActionInfo& SynchedActionInfo);
	void BP_OnMMEStarted();
	void DrawDebugHUD(class AHUD* HUD, class UCanvas* Canvas);
	void HandleClamberingTargetInActivationRange();
	void HandleClamberingTargetOutOfActivationRange();
	void HandleOwnerASCInitialized(class UFortAbilitySystemComponent* AbilitySystemComponent, class AFortPlayerPawn* AffectedPawn);
	void HandleOwnerASCInvalidated();
	void HandleOwnerDBNO();
	void HandleOwnerDied(class AFortPawn* DeadPawn);
	void HandleOwnerJumpInput(bool bPressed);
	void HandleOwnerMovementModeChanged(class ACharacter* Character, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode);
	void HandleOwnerTeleported(class AFortPawn* TeleportedOwner);
	void HandleTargetActorDestroyed(class AActor* Actor);
	void HandleTargetActorHealthChanged();
	void HandleTargetingDataInvalid();
	void HandleTargetingDataValid(const struct FClamberingTargetingData& TargetingData);
	void NetMulticast_ClamberingLedgeFailed(EClamberingFailedReason FailedReason, EClamberingState FailedState);
	void OnMutatorUpdated();
	void OnPlayerStatePawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn);
	void OnRep_ReplicatedClamberingState();
	void OnRep_ReplicatedLastTeleportTime();
	void OnRep_ReplicatedTargetingData();
	void RegisterMutatorUpdatedDelegate(class APawn* AffectedPawn);
	void ServerStartClambering(const struct FReplicatedClamberingTargetingData& InReplicatedTargetingData, const double ClientLastTeleportTime);
	void SetTutorialModeEnabled(bool bEnabled);
	void UnregisterMutatorUpdatedDelegate();

	void BP_CanStartClambering(bool* bCanStartClambering) const;
	void BP_CanStartTargeting(bool* bCanStartTargeting) const;
	void BP_IsValidTargetActor(const class AActor* TargetActor, bool* bIsValidTargetActor) const;
	void BP_TutorialModeDisabled() const;
	void BP_TutorialModeEnabled() const;
	bool IsAutoClamberingEnabled() const;
	bool IsClamberingEnabled() const;
	bool IsTutorialModeEnabled() const;
	bool ShouldShowClamberIndicator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClamberingComponent">();
	}
	static class UClamberingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClamberingComponent>();
	}
};
static_assert(alignof(UClamberingComponent) == 0x000008, "Wrong alignment on UClamberingComponent");
static_assert(sizeof(UClamberingComponent) == 0x000EC8, "Wrong size on UClamberingComponent");
static_assert(offsetof(UClamberingComponent, LocalClamberingState) == 0x0000B0, "Member 'UClamberingComponent::LocalClamberingState' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ReplicatedClamberingState) == 0x0000B1, "Member 'UClamberingComponent::ReplicatedClamberingState' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, LockedTargetingData) == 0x0000B8, "Member 'UClamberingComponent::LockedTargetingData' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ReplicatedTargetingData) == 0x000198, "Member 'UClamberingComponent::ReplicatedTargetingData' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberingEnabled) == 0x0001D8, "Member 'UClamberingComponent::ClamberingEnabled' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberIndicatorEnabled) == 0x000200, "Member 'UClamberingComponent::ClamberIndicatorEnabled' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberStartMaxFallingDamageFraction) == 0x000230, "Member 'UClamberingComponent::ClamberStartMaxFallingDamageFraction' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, bPerformTargetingWhileWalking) == 0x000258, "Member 'UClamberingComponent::bPerformTargetingWhileWalking' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, bPerformTargetingWhileSwimming) == 0x000259, "Member 'UClamberingComponent::bPerformTargetingWhileSwimming' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ServerFailDelay) == 0x000260, "Member 'UClamberingComponent::ServerFailDelay' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ServerValidatePlayerMaxDistance) == 0x000288, "Member 'UClamberingComponent::ServerValidatePlayerMaxDistance' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, InputConfig) == 0x0002B0, "Member 'UClamberingComponent::InputConfig' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, TargetingConfig_Ledge) == 0x000600, "Member 'UClamberingComponent::TargetingConfig_Ledge' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, InputConfigCachedValues) == 0x000AD8, "Member 'UClamberingComponent::InputConfigCachedValues' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, TargetingConfig_Ledge_CachedContextualValues) == 0x000B34, "Member 'UClamberingComponent::TargetingConfig_Ledge_CachedContextualValues' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, MoveConfig_Ledge) == 0x000BB8, "Member 'UClamberingComponent::MoveConfig_Ledge' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberSyncTargetLedgeOffset) == 0x000C08, "Member 'UClamberingComponent::ClamberSyncTargetLedgeOffset' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberingMaxAnalyticsEvents) == 0x000C30, "Member 'UClamberingComponent::ClamberingMaxAnalyticsEvents' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, SynchedActionFailDelay) == 0x000C58, "Member 'UClamberingComponent::SynchedActionFailDelay' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, MovementModeExtension) == 0x000C80, "Member 'UClamberingComponent::MovementModeExtension' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, SynchedActionMMETag) == 0x000C88, "Member 'UClamberingComponent::SynchedActionMMETag' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, LedgeLaunchSyncPointName) == 0x000C8C, "Member 'UClamberingComponent::LedgeLaunchSyncPointName' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, LastTeleportTime) == 0x000C90, "Member 'UClamberingComponent::LastTeleportTime' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, bTutorialModeEnabled) == 0x000C98, "Member 'UClamberingComponent::bTutorialModeEnabled' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, LocalTargetingData) == 0x000CA0, "Member 'UClamberingComponent::LocalTargetingData' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ParallelTargetingData) == 0x000D80, "Member 'UClamberingComponent::ParallelTargetingData' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, QueuedInputTimer) == 0x000E60, "Member 'UClamberingComponent::QueuedInputTimer' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, InputEnabledTimer) == 0x000E64, "Member 'UClamberingComponent::InputEnabledTimer' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, bJumpInputPressed) == 0x000E68, "Member 'UClamberingComponent::bJumpInputPressed' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, JumpHeldInAirTime) == 0x000E6C, "Member 'UClamberingComponent::JumpHeldInAirTime' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, Tag_DisableClambering) == 0x000EC0, "Member 'UClamberingComponent::Tag_DisableClambering' has a wrong offset!");

// Class ClamberingCodeRuntime.ClamberingLibrary
// 0x0000 (0x0028 - 0x0028)
class UClamberingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool PerformClamberingTargeting(const class ACharacter* Character, struct FClamberingTargetingData* OutTargetingData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClamberingLibrary">();
	}
	static class UClamberingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClamberingLibrary>();
	}
};
static_assert(alignof(UClamberingLibrary) == 0x000008, "Wrong alignment on UClamberingLibrary");
static_assert(sizeof(UClamberingLibrary) == 0x000028, "Wrong size on UClamberingLibrary");

// Class ClamberingCodeRuntime.FortAthenaMutator_LedgeLaunch
// 0x0178 (0x04B0 - 0x0338)
class alignas(0x10) AFortAthenaMutator_LedgeLaunch final : public AFortAthenaMutator
{
public:
	uint8                                         Pad_338[0x158];                                    // 0x0338(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ABuildingWall>>   CurrentWalls;                                      // 0x0490(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bShouldSpawnLedge;                                 // 0x04A0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A1[0xF];                                      // 0x04A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bShouldSpawnLedge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaMutator_LedgeLaunch">();
	}
	static class AFortAthenaMutator_LedgeLaunch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaMutator_LedgeLaunch>();
	}
};
static_assert(alignof(AFortAthenaMutator_LedgeLaunch) == 0x000010, "Wrong alignment on AFortAthenaMutator_LedgeLaunch");
static_assert(sizeof(AFortAthenaMutator_LedgeLaunch) == 0x0004B0, "Wrong size on AFortAthenaMutator_LedgeLaunch");
static_assert(offsetof(AFortAthenaMutator_LedgeLaunch, CurrentWalls) == 0x000490, "Member 'AFortAthenaMutator_LedgeLaunch::CurrentWalls' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_LedgeLaunch, bShouldSpawnLedge) == 0x0004A0, "Member 'AFortAthenaMutator_LedgeLaunch::bShouldSpawnLedge' has a wrong offset!");

}

