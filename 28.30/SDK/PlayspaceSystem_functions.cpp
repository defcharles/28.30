#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PlayspaceSystem

#include "Basic.hpp"

#include "PlayspaceSystem_classes.hpp"
#include "PlayspaceSystem_parameters.hpp"


namespace SDK
{

// Function PlayspaceSystem.OverlapComponent.OnBeginActorOverlap
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOverlapComponent::OnBeginActorOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnBeginActorOverlap");

	Params::OverlapComponent_OnBeginActorOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.OverlapComponent.OnEndActorOverlap
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlapComponent::OnEndActorOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnEndActorOverlap");

	Params::OverlapComponent_OnEndActorOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.PlayspaceControllerComponent_PlayerSpawning.ClientReplicatedSpawnInfo
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FReplicatedSpawnInfo             InReplicatedSpawnInfo                                  (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayspaceControllerComponent_PlayerSpawning::ClientReplicatedSpawnInfo(const struct FReplicatedSpawnInfo& InReplicatedSpawnInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientReplicatedSpawnInfo");

	Params::PlayspaceControllerComponent_PlayerSpawning_ClientReplicatedSpawnInfo Parms{};

	Parms.InReplicatedSpawnInfo = std::move(InReplicatedSpawnInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.PlayspaceControllerComponent_PlayerSpawning.OnRep_ReplicatedSpawnInfo
// (Final, Native, Private)

void UPlayspaceControllerComponent_PlayerSpawning::OnRep_ReplicatedSpawnInfo()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedSpawnInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.PlayspaceControllerComponent_PlayerSpawning.ServerMarkReadyForSpawning
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UPlayspaceControllerComponent_PlayerSpawning::ServerMarkReadyForSpawning()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMarkReadyForSpawning");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.PlayspaceControllerComponent_PlayerSpawning.GetSpawnInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FReplicatedSpawnInfo       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FReplicatedSpawnInfo UPlayspaceControllerComponent_PlayerSpawning::GetSpawnInfo() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSpawnInfo");

	Params::PlayspaceControllerComponent_PlayerSpawning_GetSpawnInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PlayspaceSystem.GameplayVolume.InitializeBoundsComponent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UOverlapComponent*                NewBoundsComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayVolume::InitializeBoundsComponent(class UOverlapComponent* NewBoundsComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitializeBoundsComponent");

	Params::GameplayVolume_InitializeBoundsComponent Parms{};

	Parms.NewBoundsComponent = NewBoundsComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.GameplayVolume.OnOverlappedPawnControllerChanged
// (Native, Protected)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OldController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayVolume::OnOverlappedPawnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnOverlappedPawnControllerChanged");

	Params::GameplayVolume_OnOverlappedPawnControllerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.OldController = OldController;
	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.GameplayVolume.OnRep_Playspace
// (Final, Native, Protected)

void AGameplayVolume::OnRep_Playspace()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Playspace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.GameplayVolume.UpdateSize
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          NewScale                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayVolume::UpdateSize(const struct FVector& NewScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateSize");

	Params::GameplayVolume_UpdateSize Parms{};

	Parms.NewScale = std::move(NewScale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.GameplayVolume.GetPlayspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayspace*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayspace* AGameplayVolume::GetPlayspace() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayspace");

	Params::GameplayVolume_GetPlayspace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PlayspaceSystem.Playspace.OnRep_bIsInitialized
// (Final, RequiredAPI, Native, Protected)

void APlayspace::OnRep_bIsInitialized()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bIsInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.Playspace.OnRep_bMatchHasEnded
// (Final, RequiredAPI, Native, Protected)

void APlayspace::OnRep_bMatchHasEnded()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bMatchHasEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.Playspace.OnRep_BoundGameplayVolume
// (Final, Native, Protected)

void APlayspace::OnRep_BoundGameplayVolume()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_BoundGameplayVolume");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.Playspace.OnRep_MatchStartTime
// (RequiredAPI, Native, Protected)

void APlayspace::OnRep_MatchStartTime()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_MatchStartTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.Playspace.OnRep_PlayspaceUsers
// (Final, RequiredAPI, Native, Protected)

void APlayspace::OnRep_PlayspaceUsers()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_PlayspaceUsers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.PlayspaceComponent_PlayerManager.OnPlayerPawnSet
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayspaceComponent_PlayerManager::OnPlayerPawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlayerPawnSet");

	Params::PlayspaceComponent_PlayerManager_OnPlayerPawnSet Parms{};

	Parms.Player = Player;
	Parms.NewPawn = NewPawn;
	Parms.OldPawn = OldPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.PlayspaceLibrary.DestroyPlayspace
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayspace*                       PlayspaceToDestroy                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayspaceLibrary::DestroyPlayspace(class APlayspace* PlayspaceToDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DestroyPlayspace");

	Params::PlayspaceLibrary_DestroyPlayspace Parms{};

	Parms.PlayspaceToDestroy = PlayspaceToDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.PlayspaceLibrary.GetPlayspaceForActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayspace*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayspace* UPlayspaceLibrary::GetPlayspaceForActor(const class UObject* WorldContextObject, class AActor* InActor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayspaceForActor");

	Params::PlayspaceLibrary_GetPlayspaceForActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InActor = InActor;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PlayspaceSystem.PlayspaceLogic.OnRep_bMatchHasEnded
// (Final, Native, Private)

void APlayspaceLogic::OnRep_bMatchHasEnded()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bMatchHasEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.PlayspaceLogic.OnRep_MatchStartTime
// (Native, Protected)

void APlayspaceLogic::OnRep_MatchStartTime()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_MatchStartTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.PlayspaceManagerComponent.OnPlayerBeginOverlapGameplayVolume
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameplayVolume*                  Volume                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayspaceManagerComponent::OnPlayerBeginOverlapGameplayVolume(class APlayerState* PlayerState, class AGameplayVolume* Volume)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlayerBeginOverlapGameplayVolume");

	Params::PlayspaceManagerComponent_OnPlayerBeginOverlapGameplayVolume Parms{};

	Parms.PlayerState = PlayerState;
	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.PlayspaceManagerComponent.OnPlayerEndOverlapGameplayVolume
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameplayVolume*                  Volume                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayspaceManagerComponent::OnPlayerEndOverlapGameplayVolume(class APlayerState* PlayerState, class AGameplayVolume* Volume)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPlayerEndOverlapGameplayVolume");

	Params::PlayspaceManagerComponent_OnPlayerEndOverlapGameplayVolume Parms{};

	Parms.PlayerState = PlayerState;
	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PlayspaceSystem.PlayspaceManagerComponent.OnRep_RootPlayspace
// (Final, Native, Private)

void UPlayspaceManagerComponent::OnRep_RootPlayspace()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_RootPlayspace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PlayspaceSystem.PlayspaceManagerComponent.ProcessOverlapEvents
// (Final, Native, Private)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayspaceManagerComponent::ProcessOverlapEvents(float DeltaTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ProcessOverlapEvents");

	Params::PlayspaceManagerComponent_ProcessOverlapEvents Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

