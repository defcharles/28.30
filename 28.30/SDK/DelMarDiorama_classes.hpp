#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DelMarDiorama

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DelMarDiorama_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CinematicCamera_classes.hpp"
#include "ModularGameplay_classes.hpp"
#include "FortniteGame_classes.hpp"
#include "DelMarCore_structs.hpp"


namespace SDK
{

// Class DelMarDiorama.DelMarCockpitActor
// 0x0010 (0x02A0 - 0x0290)
class ADelMarCockpitActor final : public AActor
{
public:
	class USkeletalMeshComponent*                 CockpitMeshComponent;                              // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADelMarVehicle*                         BoundVehicle;                                      // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnBoundVehicleChanged(const class ADelMarVehicle* NewVehicle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCockpitActor">();
	}
	static class ADelMarCockpitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarCockpitActor>();
	}
};
static_assert(alignof(ADelMarCockpitActor) == 0x000008, "Wrong alignment on ADelMarCockpitActor");
static_assert(sizeof(ADelMarCockpitActor) == 0x0002A0, "Wrong size on ADelMarCockpitActor");
static_assert(offsetof(ADelMarCockpitActor, CockpitMeshComponent) == 0x000290, "Member 'ADelMarCockpitActor::CockpitMeshComponent' has a wrong offset!");
static_assert(offsetof(ADelMarCockpitActor, BoundVehicle) == 0x000298, "Member 'ADelMarCockpitActor::BoundVehicle' has a wrong offset!");

// Class DelMarDiorama.DelMarDioramaActor
// 0x0158 (0x03E8 - 0x0290)
class ADelMarDioramaActor final : public AActor
{
public:
	class USkeletalMeshComponent*                 VehicleInteriorMeshComponent;                      // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FDelMarDriverSequenceDataList> CustomSequenceListTable;                           // 0x0298(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ADelMarDriverMannequin>     DriverMannequinClass;                              // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALevelSequenceActor>        LevelSequenceActorClass;                           // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADelMarDriverCameraActor>   CineCameraClass;                                   // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADelMarCockpitActor>        CockpitClass;                                      // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarDioramaConfigData*               ConfigData;                                        // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DefaultCameraOffset;                               // 0x0328(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               DefaultCameraRotation;                             // 0x0340(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    SequenceActor;                                     // 0x0358(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADelMarDriverCameraActor*               CameraActor;                                       // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADelMarDriverMannequin*                 DriverMannequin;                                   // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADelMarCockpitActor*                    CockpitActor;                                      // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           BoundPlayer;                                       // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarDriverSequenceData*              LastPlayedSequenceData;                            // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UDelMarDriverSequenceDataTable*>   BoundSequencesTables;                              // 0x0388(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x4];                                      // 0x03D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultCameraSocketIndex;                          // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSequenceFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDioramaActor">();
	}
	static class ADelMarDioramaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarDioramaActor>();
	}
};
static_assert(alignof(ADelMarDioramaActor) == 0x000008, "Wrong alignment on ADelMarDioramaActor");
static_assert(sizeof(ADelMarDioramaActor) == 0x0003E8, "Wrong size on ADelMarDioramaActor");
static_assert(offsetof(ADelMarDioramaActor, VehicleInteriorMeshComponent) == 0x000290, "Member 'ADelMarDioramaActor::VehicleInteriorMeshComponent' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, CustomSequenceListTable) == 0x000298, "Member 'ADelMarDioramaActor::CustomSequenceListTable' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, DriverMannequinClass) == 0x000300, "Member 'ADelMarDioramaActor::DriverMannequinClass' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, LevelSequenceActorClass) == 0x000308, "Member 'ADelMarDioramaActor::LevelSequenceActorClass' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, CineCameraClass) == 0x000310, "Member 'ADelMarDioramaActor::CineCameraClass' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, CockpitClass) == 0x000318, "Member 'ADelMarDioramaActor::CockpitClass' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, ConfigData) == 0x000320, "Member 'ADelMarDioramaActor::ConfigData' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, DefaultCameraOffset) == 0x000328, "Member 'ADelMarDioramaActor::DefaultCameraOffset' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, DefaultCameraRotation) == 0x000340, "Member 'ADelMarDioramaActor::DefaultCameraRotation' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, SequenceActor) == 0x000358, "Member 'ADelMarDioramaActor::SequenceActor' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, CameraActor) == 0x000360, "Member 'ADelMarDioramaActor::CameraActor' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, DriverMannequin) == 0x000368, "Member 'ADelMarDioramaActor::DriverMannequin' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, CockpitActor) == 0x000370, "Member 'ADelMarDioramaActor::CockpitActor' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, BoundPlayer) == 0x000378, "Member 'ADelMarDioramaActor::BoundPlayer' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, LastPlayedSequenceData) == 0x000380, "Member 'ADelMarDioramaActor::LastPlayedSequenceData' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, BoundSequencesTables) == 0x000388, "Member 'ADelMarDioramaActor::BoundSequencesTables' has a wrong offset!");
static_assert(offsetof(ADelMarDioramaActor, DefaultCameraSocketIndex) == 0x0003DC, "Member 'ADelMarDioramaActor::DefaultCameraSocketIndex' has a wrong offset!");

// Class DelMarDiorama.DelMarDioramaConfigData
// 0x0028 (0x0058 - 0x0030)
class UDelMarDioramaConfigData final : public UDataAsset
{
public:
	class FName                                   CameraActorTag;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DriverMannequinTag;                                // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CockpitActorTag;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CockpitCameraCutSockets;                           // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   CockpitCameraIdleSocket;                           // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDioramaConfigData">();
	}
	static class UDelMarDioramaConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDioramaConfigData>();
	}
};
static_assert(alignof(UDelMarDioramaConfigData) == 0x000008, "Wrong alignment on UDelMarDioramaConfigData");
static_assert(sizeof(UDelMarDioramaConfigData) == 0x000058, "Wrong size on UDelMarDioramaConfigData");
static_assert(offsetof(UDelMarDioramaConfigData, CameraActorTag) == 0x000030, "Member 'UDelMarDioramaConfigData::CameraActorTag' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaConfigData, DriverMannequinTag) == 0x000034, "Member 'UDelMarDioramaConfigData::DriverMannequinTag' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaConfigData, CockpitActorTag) == 0x000038, "Member 'UDelMarDioramaConfigData::CockpitActorTag' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaConfigData, CockpitCameraCutSockets) == 0x000040, "Member 'UDelMarDioramaConfigData::CockpitCameraCutSockets' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaConfigData, CockpitCameraIdleSocket) == 0x000050, "Member 'UDelMarDioramaConfigData::CockpitCameraIdleSocket' has a wrong offset!");

// Class DelMarDiorama.DelMarDriverCameraActor
// 0x0010 (0x0A20 - 0x0A10)
class ADelMarDriverCameraActor final : public ACineCameraActor
{
public:
	class USceneCaptureComponent2D*               CaptureComponent;                                  // 0x0A10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A18[0x8];                                      // 0x0A18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverCameraActor">();
	}
	static class ADelMarDriverCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarDriverCameraActor>();
	}
};
static_assert(alignof(ADelMarDriverCameraActor) == 0x000010, "Wrong alignment on ADelMarDriverCameraActor");
static_assert(sizeof(ADelMarDriverCameraActor) == 0x000A20, "Wrong size on ADelMarDriverCameraActor");
static_assert(offsetof(ADelMarDriverCameraActor, CaptureComponent) == 0x000A10, "Member 'ADelMarDriverCameraActor::CaptureComponent' has a wrong offset!");

// Class DelMarDiorama.DelMarDriverCheatManager
// 0x0000 (0x0028 - 0x0028)
class UDelMarDriverCheatManager final : public UChildCheatManager
{
public:
	void DelMarDioramaOpenChannel(bool bOpened);
	void DelMarDioramaSetDriverReaction(const class FString& ReactionTag);
	void DelMarDioramaSetEnabled(bool bEnabled);
	void DelMarDioramaSetLightingChannel(bool bMainChannel);
	void DelMarDioramaSetLocation(float X, float Y, float Z);
	void DelMarDioramaSetVisibleInSceneCaptureOnly(bool bOnly);
	void DelMarIntercomBroadcastEmote(const class FString& EmoteTag);
	void DelMarIntercomPlayInteraction(const class FString& InteractionTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverCheatManager">();
	}
	static class UDelMarDriverCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDriverCheatManager>();
	}
};
static_assert(alignof(UDelMarDriverCheatManager) == 0x000008, "Wrong alignment on UDelMarDriverCheatManager");
static_assert(sizeof(UDelMarDriverCheatManager) == 0x000028, "Wrong size on UDelMarDriverCheatManager");

// Class DelMarDiorama.DelMarDriverSequenceData
// 0x0010 (0x0040 - 0x0030)
class UDelMarDriverSequenceData final : public UDataAsset
{
public:
	class ULevelSequence*                         Sequence;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriorityLevel;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerReactiveWidget;                            // 0x003D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraCut;                                        // 0x003E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverSequenceData">();
	}
	static class UDelMarDriverSequenceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDriverSequenceData>();
	}
};
static_assert(alignof(UDelMarDriverSequenceData) == 0x000008, "Wrong alignment on UDelMarDriverSequenceData");
static_assert(sizeof(UDelMarDriverSequenceData) == 0x000040, "Wrong size on UDelMarDriverSequenceData");
static_assert(offsetof(UDelMarDriverSequenceData, Sequence) == 0x000030, "Member 'UDelMarDriverSequenceData::Sequence' has a wrong offset!");
static_assert(offsetof(UDelMarDriverSequenceData, PriorityLevel) == 0x000038, "Member 'UDelMarDriverSequenceData::PriorityLevel' has a wrong offset!");
static_assert(offsetof(UDelMarDriverSequenceData, bLoop) == 0x00003C, "Member 'UDelMarDriverSequenceData::bLoop' has a wrong offset!");
static_assert(offsetof(UDelMarDriverSequenceData, bTriggerReactiveWidget) == 0x00003D, "Member 'UDelMarDriverSequenceData::bTriggerReactiveWidget' has a wrong offset!");
static_assert(offsetof(UDelMarDriverSequenceData, bCameraCut) == 0x00003E, "Member 'UDelMarDriverSequenceData::bCameraCut' has a wrong offset!");

// Class DelMarDiorama.DelMarDriverSequenceDataTable
// 0x0050 (0x0080 - 0x0030)
class UDelMarDriverSequenceDataTable final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FDelMarDriverSequenceDataList> SequenceListTable;                                 // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverSequenceDataTable">();
	}
	static class UDelMarDriverSequenceDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDriverSequenceDataTable>();
	}
};
static_assert(alignof(UDelMarDriverSequenceDataTable) == 0x000008, "Wrong alignment on UDelMarDriverSequenceDataTable");
static_assert(sizeof(UDelMarDriverSequenceDataTable) == 0x000080, "Wrong size on UDelMarDriverSequenceDataTable");
static_assert(offsetof(UDelMarDriverSequenceDataTable, SequenceListTable) == 0x000030, "Member 'UDelMarDriverSequenceDataTable::SequenceListTable' has a wrong offset!");

// Class DelMarDiorama.DelMarIntercomEvent
// 0x0018 (0x0040 - 0x0028)
class UDelMarIntercomEvent : public UObject
{
public:
	class AFortPlayerState*                       OwningPlayerState;                                 // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADelMarVehicle*                         OwningVehicle;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarIntercomComponent*               IntercomComponent;                                 // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarIntercomEvent">();
	}
	static class UDelMarIntercomEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarIntercomEvent>();
	}
};
static_assert(alignof(UDelMarIntercomEvent) == 0x000008, "Wrong alignment on UDelMarIntercomEvent");
static_assert(sizeof(UDelMarIntercomEvent) == 0x000040, "Wrong size on UDelMarIntercomEvent");
static_assert(offsetof(UDelMarIntercomEvent, OwningPlayerState) == 0x000028, "Member 'UDelMarIntercomEvent::OwningPlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomEvent, OwningVehicle) == 0x000030, "Member 'UDelMarIntercomEvent::OwningVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomEvent, IntercomComponent) == 0x000038, "Member 'UDelMarIntercomEvent::IntercomComponent' has a wrong offset!");

// Class DelMarDiorama.DelMarIntercomEvent_TurboPassing
// 0x0010 (0x0050 - 0x0040)
class UDelMarIntercomEvent_TurboPassing final : public UDelMarIntercomEvent
{
public:
	TWeakObjectPtr<class AFortPlayerState>        PlayerAhead;                                       // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarPlayerRaceDataComponent*         RaceData;                                          // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarIntercomEvent_TurboPassing">();
	}
	static class UDelMarIntercomEvent_TurboPassing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarIntercomEvent_TurboPassing>();
	}
};
static_assert(alignof(UDelMarIntercomEvent_TurboPassing) == 0x000008, "Wrong alignment on UDelMarIntercomEvent_TurboPassing");
static_assert(sizeof(UDelMarIntercomEvent_TurboPassing) == 0x000050, "Wrong size on UDelMarIntercomEvent_TurboPassing");
static_assert(offsetof(UDelMarIntercomEvent_TurboPassing, PlayerAhead) == 0x000040, "Member 'UDelMarIntercomEvent_TurboPassing::PlayerAhead' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomEvent_TurboPassing, RaceData) == 0x000048, "Member 'UDelMarIntercomEvent_TurboPassing::RaceData' has a wrong offset!");

// Class DelMarDiorama.DelMarDriverAnimInstance
// 0x0020 (0x0480 - 0x0460)
#pragma pack(push, 0x1)
class alignas(0x10) UDelMarDriverAnimInstance : public UFortBaseAnimInstance
{
public:
	class ADelMarVehicle*                         BoundVehicle;                                      // 0x0458(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrifting;                                         // 0x0460(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTurboing;                                         // 0x0461(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_462[0x2];                                      // 0x0462(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SteeringAngle;                                     // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlipAngle;                                         // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StableSpeed;                                       // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrivingSpeedThreshold;                             // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsDrivingSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverAnimInstance">();
	}
	static class UDelMarDriverAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDriverAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDelMarDriverAnimInstance) == 0x000010, "Wrong alignment on UDelMarDriverAnimInstance");
static_assert(sizeof(UDelMarDriverAnimInstance) == 0x000480, "Wrong size on UDelMarDriverAnimInstance");
static_assert(offsetof(UDelMarDriverAnimInstance, BoundVehicle) == 0x000458, "Member 'UDelMarDriverAnimInstance::BoundVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarDriverAnimInstance, bDrifting) == 0x000460, "Member 'UDelMarDriverAnimInstance::bDrifting' has a wrong offset!");
static_assert(offsetof(UDelMarDriverAnimInstance, bTurboing) == 0x000461, "Member 'UDelMarDriverAnimInstance::bTurboing' has a wrong offset!");
static_assert(offsetof(UDelMarDriverAnimInstance, SteeringAngle) == 0x000464, "Member 'UDelMarDriverAnimInstance::SteeringAngle' has a wrong offset!");
static_assert(offsetof(UDelMarDriverAnimInstance, SlipAngle) == 0x000468, "Member 'UDelMarDriverAnimInstance::SlipAngle' has a wrong offset!");
static_assert(offsetof(UDelMarDriverAnimInstance, StableSpeed) == 0x00046C, "Member 'UDelMarDriverAnimInstance::StableSpeed' has a wrong offset!");
static_assert(offsetof(UDelMarDriverAnimInstance, DrivingSpeedThreshold) == 0x000470, "Member 'UDelMarDriverAnimInstance::DrivingSpeedThreshold' has a wrong offset!");

// Class DelMarDiorama.DelMarCockpitAnimInstance
// 0x0010 (0x0490 - 0x0480)
class UDelMarCockpitAnimInstance final : public UDelMarDriverAnimInstance
{
public:
	float                                         DefaultCameraShakeIntensity;                       // 0x0478(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultTerrainAccMultiplier;                       // 0x047C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultTerrainMaxForwardSpeedPercentage;           // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeIntensity;                              // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarCockpitAnimInstance">();
	}
	static class UDelMarCockpitAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarCockpitAnimInstance>();
	}
};
static_assert(alignof(UDelMarCockpitAnimInstance) == 0x000010, "Wrong alignment on UDelMarCockpitAnimInstance");
static_assert(sizeof(UDelMarCockpitAnimInstance) == 0x000490, "Wrong size on UDelMarCockpitAnimInstance");
static_assert(offsetof(UDelMarCockpitAnimInstance, DefaultCameraShakeIntensity) == 0x000478, "Member 'UDelMarCockpitAnimInstance::DefaultCameraShakeIntensity' has a wrong offset!");
static_assert(offsetof(UDelMarCockpitAnimInstance, DefaultTerrainAccMultiplier) == 0x00047C, "Member 'UDelMarCockpitAnimInstance::DefaultTerrainAccMultiplier' has a wrong offset!");
static_assert(offsetof(UDelMarCockpitAnimInstance, DefaultTerrainMaxForwardSpeedPercentage) == 0x000480, "Member 'UDelMarCockpitAnimInstance::DefaultTerrainMaxForwardSpeedPercentage' has a wrong offset!");
static_assert(offsetof(UDelMarCockpitAnimInstance, CameraShakeIntensity) == 0x000484, "Member 'UDelMarCockpitAnimInstance::CameraShakeIntensity' has a wrong offset!");

// Class DelMarDiorama.DelMarDioramaControllerComponent
// 0x0130 (0x01D0 - 0x00A0)
class UDelMarDioramaControllerComponent final : public UControllerComponent
{
public:
	struct FVector                                DioramaOffset;                                     // 0x00A0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADelMarDioramaActor>        DioramaClass;                                      // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDelMarDriverSequenceDataTable*         CustomizedSequencesTable;                          // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DioramaInitialTransform;                           // 0x00D0(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDelMarDriverChannel>       MainChannelClass;                                  // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarDriverChannel*                   MainChannel;                                       // 0x0138(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDelMarDriverChannelBase>   PostRaceChannelClass;                              // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDelMarDriverChannelBase*>       PostRaceChannels;                                  // 0x0148(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class APlayerState*                           CachedOwningPlayerState;                           // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           ViewTargetPlayer;                                  // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarVehicle>          ViewTargetVehicle;                                 // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class APlayerState*, class ADelMarDioramaActor*> PlayerDioramaTable;                                // 0x0170(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         NumPostRaceChannel;                                // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0xC];                                      // 0x01C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleViewTargetChanged(class AFortPlayerController* PC, class AActor* Old, class AActor* NewViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDioramaControllerComponent">();
	}
	static class UDelMarDioramaControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDioramaControllerComponent>();
	}
};
static_assert(alignof(UDelMarDioramaControllerComponent) == 0x000010, "Wrong alignment on UDelMarDioramaControllerComponent");
static_assert(sizeof(UDelMarDioramaControllerComponent) == 0x0001D0, "Wrong size on UDelMarDioramaControllerComponent");
static_assert(offsetof(UDelMarDioramaControllerComponent, DioramaOffset) == 0x0000A0, "Member 'UDelMarDioramaControllerComponent::DioramaOffset' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, DioramaClass) == 0x0000B8, "Member 'UDelMarDioramaControllerComponent::DioramaClass' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, CustomizedSequencesTable) == 0x0000C0, "Member 'UDelMarDioramaControllerComponent::CustomizedSequencesTable' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, DioramaInitialTransform) == 0x0000D0, "Member 'UDelMarDioramaControllerComponent::DioramaInitialTransform' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, MainChannelClass) == 0x000130, "Member 'UDelMarDioramaControllerComponent::MainChannelClass' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, MainChannel) == 0x000138, "Member 'UDelMarDioramaControllerComponent::MainChannel' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, PostRaceChannelClass) == 0x000140, "Member 'UDelMarDioramaControllerComponent::PostRaceChannelClass' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, PostRaceChannels) == 0x000148, "Member 'UDelMarDioramaControllerComponent::PostRaceChannels' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, CachedOwningPlayerState) == 0x000158, "Member 'UDelMarDioramaControllerComponent::CachedOwningPlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, ViewTargetPlayer) == 0x000160, "Member 'UDelMarDioramaControllerComponent::ViewTargetPlayer' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, ViewTargetVehicle) == 0x000168, "Member 'UDelMarDioramaControllerComponent::ViewTargetVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, PlayerDioramaTable) == 0x000170, "Member 'UDelMarDioramaControllerComponent::PlayerDioramaTable' has a wrong offset!");
static_assert(offsetof(UDelMarDioramaControllerComponent, NumPostRaceChannel) == 0x0001C0, "Member 'UDelMarDioramaControllerComponent::NumPostRaceChannel' has a wrong offset!");

// Class DelMarDiorama.DelMarDriverChannelBase
// 0x0060 (0x0088 - 0x0028)
class UDelMarDriverChannelBase : public UObject
{
public:
	class UTextureRenderTarget2D*                 ViewRenderTarget;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              RenderTargetDim;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelMarDriverSequenceDataTable*         SequencesTable;                                    // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           ViewPlayer;                                        // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADelMarDioramaActor*                    ViewDiorama;                                       // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMovieSceneSequencePlayer*              SequencePlayer;                                    // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleSequenceFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverChannelBase">();
	}
	static class UDelMarDriverChannelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDriverChannelBase>();
	}
};
static_assert(alignof(UDelMarDriverChannelBase) == 0x000008, "Wrong alignment on UDelMarDriverChannelBase");
static_assert(sizeof(UDelMarDriverChannelBase) == 0x000088, "Wrong size on UDelMarDriverChannelBase");
static_assert(offsetof(UDelMarDriverChannelBase, ViewRenderTarget) == 0x000028, "Member 'UDelMarDriverChannelBase::ViewRenderTarget' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannelBase, RenderTargetDim) == 0x000030, "Member 'UDelMarDriverChannelBase::RenderTargetDim' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannelBase, SequencesTable) == 0x000068, "Member 'UDelMarDriverChannelBase::SequencesTable' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannelBase, ViewPlayer) == 0x000070, "Member 'UDelMarDriverChannelBase::ViewPlayer' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannelBase, ViewDiorama) == 0x000078, "Member 'UDelMarDriverChannelBase::ViewDiorama' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannelBase, SequencePlayer) == 0x000080, "Member 'UDelMarDriverChannelBase::SequencePlayer' has a wrong offset!");

// Class DelMarDiorama.DelMarDriverChannel
// 0x00D8 (0x0160 - 0x0088)
class UDelMarDriverChannel final : public UDelMarDriverChannelBase
{
public:
	class ADelMarVehicle*                         ViewVehicle;                                       // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   QueueReactions;                                    // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FDelMarDriverSequenceDataList> SequenceListTableInstance;                         // 0x00A0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, float>              ReactionCoolDownTimeStamp;                         // 0x00F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         LandingForceThreshold;                             // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowDownImpactSpeedThreshold;                      // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitWallImpactThreshold;                            // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitWallImpactHardThreshold;                        // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DraftBonusPercentageThreshold;                     // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartlineBoostPercentageEarnedThreshold;           // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDraftStateChanged(EDelmarDraftingState DraftState);
	void HandleDriftBoostActivated(float PercentageMaxBoostGained);
	void HandleHazardSpeedLost();
	void HandleSpeedChanged(float NewSpeed);
	void HandleStartlineBoostActivated(float PercentageSpeedEarned);
	void HandleTurboActivated();
	void HandleVehicleDemolished(const struct FGameplayTag& CausedByTag);
	void HandleVehicleHitWall(float ImpactMagnitude, const struct FVector& WorldLocation, float ForwardRotationDegrees);
	void HandleVehicleLanded(float LandingForce, bool bLandedKickflip);
	void HandleVehicleSpawned(bool bFirstCar, bool bPrevCarDemolished);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverChannel">();
	}
	static class UDelMarDriverChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarDriverChannel>();
	}
};
static_assert(alignof(UDelMarDriverChannel) == 0x000008, "Wrong alignment on UDelMarDriverChannel");
static_assert(sizeof(UDelMarDriverChannel) == 0x000160, "Wrong size on UDelMarDriverChannel");
static_assert(offsetof(UDelMarDriverChannel, ViewVehicle) == 0x000088, "Member 'UDelMarDriverChannel::ViewVehicle' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, QueueReactions) == 0x000090, "Member 'UDelMarDriverChannel::QueueReactions' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, SequenceListTableInstance) == 0x0000A0, "Member 'UDelMarDriverChannel::SequenceListTableInstance' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, ReactionCoolDownTimeStamp) == 0x0000F0, "Member 'UDelMarDriverChannel::ReactionCoolDownTimeStamp' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, LandingForceThreshold) == 0x000140, "Member 'UDelMarDriverChannel::LandingForceThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, SlowDownImpactSpeedThreshold) == 0x000144, "Member 'UDelMarDriverChannel::SlowDownImpactSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, HitWallImpactThreshold) == 0x000148, "Member 'UDelMarDriverChannel::HitWallImpactThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, HitWallImpactHardThreshold) == 0x00014C, "Member 'UDelMarDriverChannel::HitWallImpactHardThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, DraftBonusPercentageThreshold) == 0x000150, "Member 'UDelMarDriverChannel::DraftBonusPercentageThreshold' has a wrong offset!");
static_assert(offsetof(UDelMarDriverChannel, StartlineBoostPercentageEarnedThreshold) == 0x000154, "Member 'UDelMarDriverChannel::StartlineBoostPercentageEarnedThreshold' has a wrong offset!");

// Class DelMarDiorama.DelMarDriverMannequin
// 0x0000 (0x0630 - 0x0630)
class ADelMarDriverMannequin final : public AFortPlayerMannequin
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarDriverMannequin">();
	}
	static class ADelMarDriverMannequin* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelMarDriverMannequin>();
	}
};
static_assert(alignof(ADelMarDriverMannequin) == 0x000008, "Wrong alignment on ADelMarDriverMannequin");
static_assert(sizeof(ADelMarDriverMannequin) == 0x000630, "Wrong size on ADelMarDriverMannequin");

// Class DelMarDiorama.DelMarIntercomComponent
// 0x00C0 (0x0160 - 0x00A0)
class UDelMarIntercomComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDelMarDriverChannel>       GuestChannelClass;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarDriverChannel*                   GuestChannel;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPlayerPawn>         ViewPlayerPawn;                                    // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADelMarDioramaActor>     MainChannelDiorama;                                // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           ViewPlayerState;                                   // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDelMarDioramaControllerComponent*      DioramaControllerComponent;                        // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UDelMarIntercomEvent>> ServerEventClasses;                                // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UDelMarIntercomEvent*>           ServerEvents;                                      // 0x00F8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FDelMarInteractionTagData> InteractionTagTable;                               // 0x0108(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         EmoteBroadcastMaxDistanceSq;                       // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientReceiveEmote(const struct FGameplayTag& EmoteTag, class APlayerState* Instigator);
	void ClientReceiveInteraction(const struct FGameplayTag& InteractionTag, const class APlayerState* Instigator, const class APlayerState* Receiver);
	void HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget);
	void ServerReceiveEmote(const struct FGameplayTag& EmoteTag);
	void ServerReceiveInteraction(const struct FGameplayTag& EmoteTag, const class APlayerState* Receiver);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelMarIntercomComponent">();
	}
	static class UDelMarIntercomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelMarIntercomComponent>();
	}
};
static_assert(alignof(UDelMarIntercomComponent) == 0x000008, "Wrong alignment on UDelMarIntercomComponent");
static_assert(sizeof(UDelMarIntercomComponent) == 0x000160, "Wrong size on UDelMarIntercomComponent");
static_assert(offsetof(UDelMarIntercomComponent, GuestChannelClass) == 0x0000B8, "Member 'UDelMarIntercomComponent::GuestChannelClass' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, GuestChannel) == 0x0000C0, "Member 'UDelMarIntercomComponent::GuestChannel' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, ViewPlayerPawn) == 0x0000C8, "Member 'UDelMarIntercomComponent::ViewPlayerPawn' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, MainChannelDiorama) == 0x0000D0, "Member 'UDelMarIntercomComponent::MainChannelDiorama' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, ViewPlayerState) == 0x0000D8, "Member 'UDelMarIntercomComponent::ViewPlayerState' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, DioramaControllerComponent) == 0x0000E0, "Member 'UDelMarIntercomComponent::DioramaControllerComponent' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, ServerEventClasses) == 0x0000E8, "Member 'UDelMarIntercomComponent::ServerEventClasses' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, ServerEvents) == 0x0000F8, "Member 'UDelMarIntercomComponent::ServerEvents' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, InteractionTagTable) == 0x000108, "Member 'UDelMarIntercomComponent::InteractionTagTable' has a wrong offset!");
static_assert(offsetof(UDelMarIntercomComponent, EmoteBroadcastMaxDistanceSq) == 0x000158, "Member 'UDelMarIntercomComponent::EmoteBroadcastMaxDistanceSq' has a wrong offset!");

}

