#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FMJamPlayspaceRuntime

#include "Basic.hpp"

#include "FMJamPlayspaceRuntime_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "SparksMusicPlayspaceRuntime_classes.hpp"
#include "FMJamCoreRuntime_structs.hpp"
#include "FMCoreRuntime_structs.hpp"
#include "GameplayEventRouter_structs.hpp"
#include "PlayspaceSystem_classes.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class FMJamPlayspaceRuntime.JamAnalytics
// 0x00A0 (0x0148 - 0x00A8)
class UJamAnalytics final : public UFortControllerComponent
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         MinLoopLength;                                     // 0x00E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         LoopStartTime;                                     // 0x0110(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoopLength;                                        // 0x0114(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LoopShortName;                                     // 0x0118(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoopType;                                          // 0x0120(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LoopID;                                            // 0x0130(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJamPlayspace*                          JamPlayspace;                                      // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamAnalytics">();
	}
	static class UJamAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJamAnalytics>();
	}
};
static_assert(alignof(UJamAnalytics) == 0x000008, "Wrong alignment on UJamAnalytics");
static_assert(sizeof(UJamAnalytics) == 0x000148, "Wrong size on UJamAnalytics");
static_assert(offsetof(UJamAnalytics, MinLoopLength) == 0x0000E8, "Member 'UJamAnalytics::MinLoopLength' has a wrong offset!");
static_assert(offsetof(UJamAnalytics, LoopStartTime) == 0x000110, "Member 'UJamAnalytics::LoopStartTime' has a wrong offset!");
static_assert(offsetof(UJamAnalytics, LoopLength) == 0x000114, "Member 'UJamAnalytics::LoopLength' has a wrong offset!");
static_assert(offsetof(UJamAnalytics, LoopShortName) == 0x000118, "Member 'UJamAnalytics::LoopShortName' has a wrong offset!");
static_assert(offsetof(UJamAnalytics, LoopType) == 0x000120, "Member 'UJamAnalytics::LoopType' has a wrong offset!");
static_assert(offsetof(UJamAnalytics, LoopID) == 0x000130, "Member 'UJamAnalytics::LoopID' has a wrong offset!");
static_assert(offsetof(UJamAnalytics, JamPlayspace) == 0x000140, "Member 'UJamAnalytics::JamPlayspace' has a wrong offset!");

// Class FMJamPlayspaceRuntime.JamMidiEventDriver
// 0x0020 (0x0048 - 0x0028)
class UJamMidiEventDriver final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UJamMusicSlot>           WeakOwningMusicSlotPtr;                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParsedMidiEventData*                   ParsedMidiEventData;                               // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamMidiEventDriver">();
	}
	static class UJamMidiEventDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJamMidiEventDriver>();
	}
};
static_assert(alignof(UJamMidiEventDriver) == 0x000008, "Wrong alignment on UJamMidiEventDriver");
static_assert(sizeof(UJamMidiEventDriver) == 0x000048, "Wrong size on UJamMidiEventDriver");
static_assert(offsetof(UJamMidiEventDriver, WeakOwningMusicSlotPtr) == 0x000030, "Member 'UJamMidiEventDriver::WeakOwningMusicSlotPtr' has a wrong offset!");
static_assert(offsetof(UJamMidiEventDriver, ParsedMidiEventData) == 0x000038, "Member 'UJamMidiEventDriver::ParsedMidiEventData' has a wrong offset!");

// Class FMJamPlayspaceRuntime.JamPlayspace
// 0x0068 (0x07F8 - 0x0790)
class AJamPlayspace final : public ASparksMusicPlayspace
{
public:
	uint8                                         Pad_790[0x18];                                     // 0x0790(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UJamPlayspaceComponent_MusicManager*    MusicManager;                                      // 0x07A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B0[0x18];                                     // 0x07B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UJamPlayspaceComponent_LipSyncAssetManager* LipSyncManager;                                    // 0x07C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJamPlayspaceComponent_ReactiveFX*      ReactiveFXComponent;                               // 0x07D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D8[0x20];                                     // 0x07D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginShutdownJam();
	void ConvertPlayerToAutoJammer(const class APlayerState* PlayerState);
	class UAudioComponent* GetJamAudioSource();
	void PlayLoop(class APlayerState* PlayerState, const class FName SongShortName, const EFMJamLoopType LoopType, const bool bForceAudioState, const bool bIsAutoJammer);
	void StopAllLoopsForLoopType(const EFMJamLoopType LoopType);
	void StopAutoJammersForPlayer(const class APlayerState* PlayerState);
	void StopLoopByInstanceId(const int32 LoopInstanceId);
	void StopLoopForPlayer(const class APlayerState* PlayerState, const bool bStopAutoJammers);

	int32 CountActiveLoops(const bool bCountAutoJammers) const;
	bool DoAnyOtherJammersHaveGameplayTag(const class APlayerState* LocalPlayerState, const struct FGameplayTag& GlobalControlsTag) const;
	void GetAllowGlobalControlAccess(bool* OutAllowGlobalControlAccess, struct FGameplayTagContainer* OutRestrictionReason) const;
	TArray<class APlayerState*> GetJammers() const;
	class UJamMusicSlot* GetMusicSlotForPlayer(const class APlayerState* PlayerState) const;
	TArray<class UJamMusicSlot*> GetMusicSlots() const;
	TArray<class UJamMusicSlot*> GetMusicSlotsForLoopType(const EFMJamLoopType LoopType) const;
	TArray<class UJamMusicSlot*> GetMusicSlotsInUse() const;
	TArray<class UJamMusicSlot*> GetMusicSlotsSortedByLoopType() const;
	bool IsJamFull(const bool bCountAutoJammers) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamPlayspace">();
	}
	static class AJamPlayspace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJamPlayspace>();
	}
};
static_assert(alignof(AJamPlayspace) == 0x000008, "Wrong alignment on AJamPlayspace");
static_assert(sizeof(AJamPlayspace) == 0x0007F8, "Wrong size on AJamPlayspace");
static_assert(offsetof(AJamPlayspace, MusicManager) == 0x0007A8, "Member 'AJamPlayspace::MusicManager' has a wrong offset!");
static_assert(offsetof(AJamPlayspace, LipSyncManager) == 0x0007C8, "Member 'AJamPlayspace::LipSyncManager' has a wrong offset!");
static_assert(offsetof(AJamPlayspace, ReactiveFXComponent) == 0x0007D0, "Member 'AJamPlayspace::ReactiveFXComponent' has a wrong offset!");

// Class FMJamPlayspaceRuntime.JamPlayspaceComponent_LipSyncAssetManager
// 0x0028 (0x00D8 - 0x00B0)
class UJamPlayspaceComponent_LipSyncAssetManager final : public UPlayspaceComponent_LipSyncAssetManager
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamPlayspaceComponent_LipSyncAssetManager">();
	}
	static class UJamPlayspaceComponent_LipSyncAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJamPlayspaceComponent_LipSyncAssetManager>();
	}
};
static_assert(alignof(UJamPlayspaceComponent_LipSyncAssetManager) == 0x000008, "Wrong alignment on UJamPlayspaceComponent_LipSyncAssetManager");
static_assert(sizeof(UJamPlayspaceComponent_LipSyncAssetManager) == 0x0000D8, "Wrong size on UJamPlayspaceComponent_LipSyncAssetManager");

// Class FMJamPlayspaceRuntime.JamMusicSlot
// 0x0098 (0x00C0 - 0x0028)
class UJamMusicSlot final : public UObject
{
public:
	TMulticastInlineDelegate<void(struct FJamPlayParams& PlayParams, bool bChangedLoop)> OnLoopStarted;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FJamPlayParams& PlayParams, bool bChangedLoop)> OnLoopStopped;                                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMidiFile*                              CurrentMidiFile;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFusionPatch*                           CurrentFusionPatch;                                // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJamMidiEventDriver*                    MidiEventDriver;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttemptingResolveAndLoad;                         // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x17];                                      // 0x0061(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJamPlayParams                         CurrentPlayParams;                                 // 0x0078(0x0038)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UJamPlayspaceComponent_MusicManager*    JamMusicManager;                                   // 0x00B0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NthSlot;                                           // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCMSCatalogRequestFinished(class UFMJamSongCatalog* Sender, bool bSuccess);
	void OnJamLoadRequestComplete(const struct FJamLoadResult& LoadResult);
	void OnJamResolverComplete(class UJamContentResolver* Sender, const class FString& LinkCode, bool bSuccess, bool bWasAlreadyLoaded);
	void OnRep_CurrentPlayParams(const struct FJamPlayParams& OldPlayParams);
	void OnScanForSongsCompleted(class UFMJamSongCatalog* Sender, const TArray<class UFMJamSong*>& AddedSongs);
	void OnTerminatingLinkCode(class UJamContentResolver* Sender, const class FString& LinkCode);

	const class UCatalogData* GetCurrentCatalogEntry() const;
	EMusicKey GetCurrentKey() const;
	const class UFMJamLoop* GetCurrentLoop() const;
	int32 GetCurrentLoopInstanceId() const;
	EFMJamLoopType GetCurrentLoopType() const;
	EMusicKeyMode GetCurrentMode() const;
	class APlayerState* GetCurrentPlayerState() const;
	const class UFMJamSong* GetCurrentSong() const;
	class FString GetCurrentSongLinkCode() const;
	class FName GetCurrentSongShortName() const;
	int32 GetCurrentTempo() const;
	bool GetIsAutoJammer() const;
	const class USparksJamEmoteItemDefinition* GetItemDef() const;
	class UJamPlayspaceComponent_MusicManager* GetMusicManager() const;
	const struct FJamPlayParams GetPlayParams() const;
	bool IsInUse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamMusicSlot">();
	}
	static class UJamMusicSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJamMusicSlot>();
	}
};
static_assert(alignof(UJamMusicSlot) == 0x000008, "Wrong alignment on UJamMusicSlot");
static_assert(sizeof(UJamMusicSlot) == 0x0000C0, "Wrong size on UJamMusicSlot");
static_assert(offsetof(UJamMusicSlot, OnLoopStarted) == 0x000028, "Member 'UJamMusicSlot::OnLoopStarted' has a wrong offset!");
static_assert(offsetof(UJamMusicSlot, OnLoopStopped) == 0x000038, "Member 'UJamMusicSlot::OnLoopStopped' has a wrong offset!");
static_assert(offsetof(UJamMusicSlot, CurrentMidiFile) == 0x000048, "Member 'UJamMusicSlot::CurrentMidiFile' has a wrong offset!");
static_assert(offsetof(UJamMusicSlot, CurrentFusionPatch) == 0x000050, "Member 'UJamMusicSlot::CurrentFusionPatch' has a wrong offset!");
static_assert(offsetof(UJamMusicSlot, MidiEventDriver) == 0x000058, "Member 'UJamMusicSlot::MidiEventDriver' has a wrong offset!");
static_assert(offsetof(UJamMusicSlot, bAttemptingResolveAndLoad) == 0x000060, "Member 'UJamMusicSlot::bAttemptingResolveAndLoad' has a wrong offset!");
static_assert(offsetof(UJamMusicSlot, CurrentPlayParams) == 0x000078, "Member 'UJamMusicSlot::CurrentPlayParams' has a wrong offset!");
static_assert(offsetof(UJamMusicSlot, JamMusicManager) == 0x0000B0, "Member 'UJamMusicSlot::JamMusicManager' has a wrong offset!");
static_assert(offsetof(UJamMusicSlot, NthSlot) == 0x0000B8, "Member 'UJamMusicSlot::NthSlot' has a wrong offset!");

// Class FMJamPlayspaceRuntime.JamPlayspaceComponent_MusicManager
// 0x00D0 (0x0170 - 0x00A0)
class UJamPlayspaceComponent_MusicManager final : public UPlayspaceComponent
{
public:
	TMulticastInlineDelegate<void(struct FJamPlayParams& PlayParams, bool bChangedLoop)> OnLoopStarted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FJamPlayParams& PlayParams, bool bChangedLoop)> OnLoopStopped;                                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UJamMusicSlot*>                  MusicSlots;                                        // 0x00C0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayEventListenerHandle           KeyChangedEventHandle;                             // 0x00D0(0x001C)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayEventListenerHandle           ModeChangedEventHandle;                            // 0x00EC(0x001C)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayEventListenerHandle           TempoChangedEventHandle;                           // 0x0108(0x001C)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x24];                                     // 0x0124(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalPlayerGainParam;                              // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandardGainParam;                                 // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x20];                                     // 0x0150(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsAllowedToJamInSplitscreen(class APlayerState* PlayerStateToCheck);

	void FireGlobalControlsAnalytics(const class APlayerState* PlayerState);
	void HandleKeyChangedEvent(const struct FSparksPlayspaceEvent_KeyChanged& Payload);
	void HandleModeChangedEvent(const struct FSparksPlayspaceEvent_KeyModeChanged& Payload);
	void HandleOnLoopStarted(const struct FJamPlayParams& PlayParams, bool bChangedLoop);
	void HandleOnLoopStopped(const struct FJamPlayParams& PlayParams, bool bChangedLoop);
	void HandleTempoChangedEvent(const struct FSparksPlayspaceEvent_TempoChanged& Payload);
	void OnLicensedAudioTreatmentChanged();
	void OnPlayspaceUserAdded(struct FPlayspaceUser* AddedUser);
	void OnPlayspaceUserRemoved(struct FPlayspaceUser* RemovedUser);
	void OnRep_MusicSlots(const TArray<class UJamMusicSlot*>& PreviousMusicSlots);
	void UpdateAllMetasounds(const class APlayerState* PlayerToIgnore);

	int32 CountActiveSlots(const bool bCountAutoJammers) const;
	TArray<class APlayerState*> GetAllJammers() const;
	TArray<class UJamMusicSlot*> GetAllMusicSlots() const;
	TArray<class UJamMusicSlot*> GetAutoJammersForPlayer(const class APlayerState* PlayerState) const;
	EMusicKey GetCurrentKey() const;
	float GetCurrentMidiSeconds() const;
	int32 GetCurrentMidiTick() const;
	EMusicKeyMode GetCurrentMode() const;
	int32 GetCurrentTempo() const;
	float GetDesiredGain(const class APlayerState* PlayerState) const;
	const struct FJamEvent_JamLoopStarted GetJamInfoFromSlot(int32 SlotIndex) const;
	class AJamPlayspace* GetJamPlayspace() const;
	class USparksInstrumentAnimations* GetLoadedAnimations() const;
	float GetLocalPlayerGainValue() const;
	class UAudioComponent* GetMetasoundPlayer() const;
	class UJamMusicSlot* GetMusicSlotByLoopInstanceId(const int32 LoopInstanceId) const;
	class UJamMusicSlot* GetMusicSlotForPlayer(const class APlayerState* PlayerState) const;
	int32 GetMusicSlotIndexForLoopInstanceId(const int32 LoopInstanceId) const;
	int32 GetMusicSlotIndexForPlayer(const class APlayerState* PlayerState) const;
	TArray<class UJamMusicSlot*> GetMusicSlotsForLoopType(const EFMJamLoopType LoopType) const;
	TArray<class UJamMusicSlot*> GetMusicSlotsInUse() const;
	float GetStandardGainValue() const;
	int32 SecondsToTick(const float Seconds) const;
	bool ShouldPlayLocalSound(const class APlayerState* PlayerToIgnore) const;
	float TickToSeconds(const int32 Tick) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamPlayspaceComponent_MusicManager">();
	}
	static class UJamPlayspaceComponent_MusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJamPlayspaceComponent_MusicManager>();
	}
};
static_assert(alignof(UJamPlayspaceComponent_MusicManager) == 0x000008, "Wrong alignment on UJamPlayspaceComponent_MusicManager");
static_assert(sizeof(UJamPlayspaceComponent_MusicManager) == 0x000170, "Wrong size on UJamPlayspaceComponent_MusicManager");
static_assert(offsetof(UJamPlayspaceComponent_MusicManager, OnLoopStarted) == 0x0000A0, "Member 'UJamPlayspaceComponent_MusicManager::OnLoopStarted' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_MusicManager, OnLoopStopped) == 0x0000B0, "Member 'UJamPlayspaceComponent_MusicManager::OnLoopStopped' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_MusicManager, MusicSlots) == 0x0000C0, "Member 'UJamPlayspaceComponent_MusicManager::MusicSlots' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_MusicManager, KeyChangedEventHandle) == 0x0000D0, "Member 'UJamPlayspaceComponent_MusicManager::KeyChangedEventHandle' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_MusicManager, ModeChangedEventHandle) == 0x0000EC, "Member 'UJamPlayspaceComponent_MusicManager::ModeChangedEventHandle' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_MusicManager, TempoChangedEventHandle) == 0x000108, "Member 'UJamPlayspaceComponent_MusicManager::TempoChangedEventHandle' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_MusicManager, LocalPlayerGainParam) == 0x000148, "Member 'UJamPlayspaceComponent_MusicManager::LocalPlayerGainParam' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_MusicManager, StandardGainParam) == 0x00014C, "Member 'UJamPlayspaceComponent_MusicManager::StandardGainParam' has a wrong offset!");

// Class FMJamPlayspaceRuntime.JamPlayspaceComponent_ReactiveFX
// 0x0108 (0x01A8 - 0x00A0)
class UJamPlayspaceComponent_ReactiveFX final : public UPlayspaceComponent
{
public:
	struct FJamReactiveFXState                    ReactiveFXState;                                   // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, DuplicateTransient, NativeAccessSpecifierPublic)
	float                                         PeakTamerValueReleaseTimeSec;                      // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FJamLoopReactiveFX>        LoopReactiveFX;                                    // 0x00D0(0x0050)(Edit, Transient, EditConst, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x88];                                     // 0x0120(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddReactiveNiagaraEffect(int32 LoopInstanceId, class UNiagaraComponent* NiagaraComponent);
	void ClearReactiveEffects(bool bStopEffectsImmediately);
	void ClearReactiveEffectsForLoop(int32 LoopInstanceId, bool bStopEffectsImmediately);
	bool HasReactiveEffectsForLoop(int32 LoopInstanceId);
	bool RemoveReactiveNiagaraEffect(int32 LoopInstanceId, class UNiagaraComponent* NiagaraComponent);

	TArray<class UNiagaraComponent*> GetReactiveNiagaraEffects(int32 LoopInstanceId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamPlayspaceComponent_ReactiveFX">();
	}
	static class UJamPlayspaceComponent_ReactiveFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJamPlayspaceComponent_ReactiveFX>();
	}
};
static_assert(alignof(UJamPlayspaceComponent_ReactiveFX) == 0x000008, "Wrong alignment on UJamPlayspaceComponent_ReactiveFX");
static_assert(sizeof(UJamPlayspaceComponent_ReactiveFX) == 0x0001A8, "Wrong size on UJamPlayspaceComponent_ReactiveFX");
static_assert(offsetof(UJamPlayspaceComponent_ReactiveFX, ReactiveFXState) == 0x0000A0, "Member 'UJamPlayspaceComponent_ReactiveFX::ReactiveFXState' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_ReactiveFX, PeakTamerValueReleaseTimeSec) == 0x0000C8, "Member 'UJamPlayspaceComponent_ReactiveFX::PeakTamerValueReleaseTimeSec' has a wrong offset!");
static_assert(offsetof(UJamPlayspaceComponent_ReactiveFX, LoopReactiveFX) == 0x0000D0, "Member 'UJamPlayspaceComponent_ReactiveFX::LoopReactiveFX' has a wrong offset!");

// Class FMJamPlayspaceRuntime.JamPlayspaceVolume
// 0x0000 (0x0330 - 0x0330)
class AJamPlayspaceVolume final : public AGameplayVolume
{
public:
	void BP_UpdateReactiveFX(float JamAmplitude);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamPlayspaceVolume">();
	}
	static class AJamPlayspaceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJamPlayspaceVolume>();
	}
};
static_assert(alignof(AJamPlayspaceVolume) == 0x000008, "Wrong alignment on AJamPlayspaceVolume");
static_assert(sizeof(AJamPlayspaceVolume) == 0x000330, "Wrong size on AJamPlayspaceVolume");

// Class FMJamPlayspaceRuntime.JamQuickplayPlayerSpawningComponent
// 0x0020 (0x00D0 - 0x00B0)
class UJamQuickplayPlayerSpawningComponent final : public UPlayspaceComponent_PlayerSpawning
{
public:
	struct FGameplayTagContainer                  PregameSpawnTags;                                  // 0x00B0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JamQuickplayPlayerSpawningComponent">();
	}
	static class UJamQuickplayPlayerSpawningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJamQuickplayPlayerSpawningComponent>();
	}
};
static_assert(alignof(UJamQuickplayPlayerSpawningComponent) == 0x000008, "Wrong alignment on UJamQuickplayPlayerSpawningComponent");
static_assert(sizeof(UJamQuickplayPlayerSpawningComponent) == 0x0000D0, "Wrong size on UJamQuickplayPlayerSpawningComponent");
static_assert(offsetof(UJamQuickplayPlayerSpawningComponent, PregameSpawnTags) == 0x0000B0, "Member 'UJamQuickplayPlayerSpawningComponent::PregameSpawnTags' has a wrong offset!");

}

